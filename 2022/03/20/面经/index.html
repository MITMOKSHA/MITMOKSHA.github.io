<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mitmoksha.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="面试总要总结吧">
<meta property="og:type" content="article">
<meta property="og:title" content="面经">
<meta property="og:url" content="https://mitmoksha.github.io/2022/03/20/%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="Moksha&#39;s Blog">
<meta property="og:description" content="面试总要总结吧">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-03-20T09:32:17.000Z">
<meta property="article:modified_time" content="2023-06-10T02:00:45.803Z">
<meta property="article:author" content="Pishun Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mitmoksha.github.io/2022/03/20/%E9%9D%A2%E7%BB%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://mitmoksha.github.io/2022/03/20/%E9%9D%A2%E7%BB%8F/","path":"2022/03/20/面经/","title":"面经"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面经 | Moksha's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Moksha's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Moksha's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">自我介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">计网&#x2F;网络编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%BB%84os"><span class="nav-number">3.</span> <span class="nav-text">计组&#x2F;OS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#db"><span class="nav-number">4.</span> <span class="nav-text">DB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cc"><span class="nav-number">6.</span> <span class="nav-text">C&#x2F;C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objective-c"><span class="nav-number">7.</span> <span class="nav-text">Objective-C</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uml%E7%B1%BB%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">UML类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">智力题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="nav-number">10.</span> <span class="nav-text">场景题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E9%97%AE%E7%8E%AF%E8%8A%82"><span class="nav-number">11.</span> <span class="nav-text">反问环节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E9%97%AE%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%AE%98"><span class="nav-number">11.0.1.</span> <span class="nav-text">反问技术面试官</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hr%E9%9D%A2"><span class="nav-number">12.</span> <span class="nav-text">HR面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E9%97%AEhr"><span class="nav-number">12.0.1.</span> <span class="nav-text">反问HR</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pishun Huang</p>
  <div class="site-description" itemprop="description">Opportunities are ready for it, the more to beat action.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/03/20/%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="面经 | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-20 17:32:17" itemprop="dateCreated datePublished" datetime="2022-03-20T17:32:17+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-06-10 10:00:45" itemprop="dateModified" datetime="2023-06-10T10:00:45+08:00">2023-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <!-- # 面经 -->
<blockquote>
<p>面试总要总结吧 <span id="more"></span></p>
</blockquote>
<h2 id="自我介绍">自我介绍</h2>
<ul>
<li>面试官您好，我是，毕业于XXX大学计算机科学与技术专业。</li>
<li>在校期间，我独立完成了项目...，除了本校课程....</li>
<li>在做项目期间遇到问题能谷歌/stackoverflow，查看相关手册，独立思考解决问题，且能够利用一些工具提高开发效率。</li>
<li>我对计算机系统方向感兴趣。</li>
<li>除此之外，喜欢阅读原版技术书籍，文学类书籍，热爱体育运动，热爱与他人交流讨论问题。希望贵公司可以给我一个机会。</li>
</ul>
<h2 id="计网网络编程">计网/网络编程</h2>
<ul>
<li>socket编程
<ul>
<li>服务器端
<ul>
<li>socket。创建<strong>监听描述符</strong></li>
<li>bind。绑定IP地址和端口号，ip地址和端口号可以确定一台计算机上的一个进程</li>
<li>listen。第二个参数为内核监听队列的最大长度，超过这个长度服务器将不受理新的客户连接(backlog真正取min(backlog, /proc/sys/net/core/somaxconn))；<strong>backlog只表示完全连接和半连接的上限</strong></li>
<li>accept。等待客户端建立，建立成功则返回<strong>连接描述符(用于通信)</strong></li>
<li>send/recv</li>
<li>close。主动关闭一方进入FIN_WAIT2</li>
</ul></li>
<li>客户端
<ul>
<li>socket</li>
<li>connect</li>
<li>send/recv</li>
<li>close</li>
</ul></li>
</ul></li>
<li>TCP，UDP的区别
<ul>
<li>TCP是面向连接的、可靠的(确认应答、超时重传、拥塞控制)、有序的(序列号)；UDP是无连接的、不可靠的、无序的</li>
<li>TCP开销比UDP大，TCP头部需要20个字节，UDP头部只需要8个字节</li>
<li>TCP有拥塞控制，UDP没有拥塞控制</li>
<li>TCP通过字节流传输，UDP中每一个包都是单独的</li>
<li>TCP<strong>提供可靠的服务</strong>，适用于可靠性要求高的场景；UDP<strong>传输效率高</strong>，适用于高速传输和实时性要求的场景</li>
<li>TCP仅支持一对一连接</li>
</ul></li>
<li>TCP是如何保证可靠的？
<ul>
<li>确认应答机制</li>
<li>超时重传</li>
<li>序号(一个字节对应一个序号)</li>
</ul></li>
<li>UDP什么不可靠？
<ul>
<li>不保证消息交付：不确认、无超时重传</li>
<li>不保证交付顺序：不设置序列号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不需要拥塞控制：不设置客户端或网路反馈机制</li>
</ul></li>
<li>UDP什么时候会出现丢包的现象
<ul>
<li>UDP报文错误。系统会将错误报文直接丢弃</li>
<li>UDP接收缓冲区不足。接收报文速率过快，UDP报文超过缓冲区或MTU的大小，</li>
<li>防火墙</li>
</ul></li>
<li>epoll，select，poll的区别？
<ul>
<li>select
<ul>
<li>每次调用select，都需要<strong>把fd集合从用户空间拷贝到内核空间</strong>(不论这些文件描述符是否就绪)，fd很多时开销就很大</li>
<li>每次调用select都需<strong>在内核遍历</strong>传递进来的所有fd, 线性扫描，即轮询是否有就绪的文件描述符, 效率低, 查询时间为O(n)</li>
<li>select支持的文件描述符数量太少(默认最大支持1024个，可以通过ulimit -n修改)</li>
<li>fds集合不能<strong>重用</strong></li>
</ul></li>
<li>poll
<ul>
<li>相对于select
<ul>
<li>无最大连接数限制，基于链表存储</li>
</ul></li>
<li>水平触发，报告fd后没有被处理，则下次poll时会再次报告该fd</li>
<li>解决了select第三第四个缺点</li>
</ul></li>
<li>epoll
<ul>
<li>水平触发(LT)和边缘触发(ET)
<ul>
<li>边缘触发若存在就绪的文件描述符只提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。所以ET模式下，read一个fd时，一定要把它的buffer读完，即直到read返回值小于请求值或遇到EAGAIN错误。</li>
<li>采用回调机制(使用<code>epoll_ctl</code>往内核事件表中注册)，即调用read/write处理I/O就绪事件，有信号发生则执行相应的处理函数，激活fd。</li>
<li>若用LT，若系统中有大量无需读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会降低效率</li>
</ul></li>
<li>对比select和poll省略了把fd集合从用户空间拷贝到内核空间(而是通过<strong>直接在内核空间中创建</strong>)，而且从内核空间拷贝到用户空间的fd集合是就绪fd集合(拷贝开销较小)，<strong>时间复杂度是O(1)</strong></li>
</ul></li>
<li>三者对比：
<ul>
<li>表面上看epoll性能远优于poll和select，但在连接数少且都十分活跃的情况下，select/poll性能可能比epoll好。</li>
</ul></li>
</ul></li>
<li>红黑树说一下？
<ul>
<li>特化的平衡二叉树</li>
<li>查找、插入、删除的时间复杂度都是O(logn)</li>
<li>性质
<ul>
<li>节点是红色或者黑色的</li>
<li>根节点是黑色</li>
<li>所有叶子都是黑色</li>
<li>每个红色结点的两个子结点都是黑色(因此路径上不能有两个相邻的红色节点)</li>
<li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点</li>
</ul></li>
</ul></li>
<li>https加密过程？
<ul>
<li>采用对称加密+非对称加密+CA</li>
<li>对称加密："和日常中的钥匙差不多"</li>
<li>非对称加密：简单来说就是有两把钥匙，一把公钥，一把私钥。使用私钥加密的内容用公钥才能解开，同理，使用公钥加密的内容使用私钥才能解开</li>
<li>非对称加密+对称加密
<ol type="1">
<li>某网站拥有用于非对称加密的公钥A和私钥A'</li>
<li>浏览器首先向网站服务器发送请求，服务器发回公钥A给浏览器</li>
<li>浏览器随机生成一个对称加密的密钥X，用公钥A加密后发给服务器</li>
<li>服务器用私钥A'解密并得到密钥X</li>
<li>这样双方都有密钥X了，且其他人都不知道，之后双方所有数据都通过密钥X加密解密即可</li>
</ol></li>
<li>中间人攻击
<ul>
<li>劫持服务器端发送给客户端的公钥，并自己伪造公钥发送给客户端，客户端将密钥X使用中间人的公钥加密(客户端以为是服务器端的公钥)，然后发出去中间人用私钥进行解密获得密钥X，然后中间人再用服务器端的公钥再次加密X，发送给服务器端。此时中间人已经获得了密钥x，可以获取服务器端和客户端的之间通信的信息</li>
</ul></li>
<li>数字证书，<strong>证明浏览器收到的公钥一定是服务器端的公钥</strong>，浏览器进行验证。
<ul>
<li><strong>将公钥放入数字证书中</strong>，由服务器端颁发给客户端</li>
</ul></li>
</ul></li>
<li>HTTP常见请求方法和区别？
<ul>
<li>GET
<ul>
<li>本质上用来请求服务器上的资源，资源通过一组HTTP头部和呈现数据返回给客户端。GET请求中，永远不会包含<strong>呈现数据</strong>。即GET请求只用来向服务器获取资源，而GET请求本身并不应该携带任何呈现数据</li>
<li>应用场景：
<ol type="1">
<li>登录时GET获取服务器数据库用户名和密码进行验证</li>
<li>下载文本、图片、音频时等获取服务器资源</li>
</ol></li>
</ul></li>
<li>POST
<ul>
<li>用于将实体提交到指定的资源。数据被包含在POST请求体中。POST 请求可能会导致新的资源的建立或已有资源的修改。</li>
<li>应用场景
<ol type="1">
<li>提交用户注册信息</li>
<li>提交修改的用户信息</li>
</ol></li>
</ul></li>
<li>HEAD。
<ul>
<li>和GET方法一样，只是不返回报文的主体部分(返回的响应没有具体内容)。用于确定URI的有效性及资源更新的日期时间等</li>
<li>应用场景：
<ol type="1">
<li>向服务器获取某些易过期或丢失的大型文件时，可以用HEAD方法查询是否存在</li>
</ol></li>
</ul></li>
<li>GET和POST的区别<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28586791">见</a>
<ul>
<li>GET用来从服务器中的指定资源请求数据，POST将实体提交到服务器中的指定资源中</li>
<li>GET是幂等的(没有副作用)；POST是不幂等的(不能随意多次执行)</li>
<li>浏览器可以对GET请求的数据缓存；POST请求不能被浏览器缓存(能缓存意味者比如提交一份订单不会向服务器发送请求)</li>
<li>GET可收藏为书签; POST不可收藏为书签(因为是不幂等的，比如点一个书签就下一个单是很恐怖的事)</li>
<li>POST更安全(POST用HTTP请求body携带数据，GET用url携带数据)</li>
</ul></li>
</ul></li>
<li>TCP粘包了解吗？解决方法？UDP为什么不存在粘包？
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/644658">文章</a></li>
<li>通俗的来讲"我客户端调用了两次send，怎么服务器端一个recv就都读出来了？！"</li>
<li>TCP采用Nagle算法，合并相连的小的数据包，再一次性发送，来达到提升网络传输效率的目的。但是接收方并不知道发送包合并数据包，所以就导致接收方不能还原原始的数据包</li>
<li>解决方法：
<ol type="1">
<li>禁用nagle算法，只能解决发送方的问题，粘包还可能因为接收方，而且TCP传输效率降低了</li>
<li>自定协议，将数据报分为封包(为发送的数据增加包头，包头也可以包含校验信息)和解包</li>
</ol></li>
<li>UDP不是面向流的，发送的每个数据包都是独立的</li>
</ul></li>
<li>TCP三次握手？
<ul>
<li>主要是为了确认双方接收能力和发送能力是否正常</li>
<li>序列号x是随机数(考虑到网路安全)</li>
<li>第一次握手<strong>SYN=1</strong>, seq=x(客户端由CLOSED状态变为SYN_SEND), 第二次握手<strong>SYN=1</strong>, ACK=1, seq=y, ack=x+1(服务器端由LISTEN变为SYN_RCVD)，第三次握手ACK=1, seq=x+1, ack=y+1(客户端和服务器端都变为ESTABLISHED)</li>
</ul></li>
<li>为什么TCP握手不是两次？
<ul>
<li>第一次握手确定客户端的发送能力和服务器端的接收能力，第二次握手确认服务器端的发送能力，如果没有第三次握手，不能确定客户端的接收能力是否正常</li>
</ul></li>
<li>TCP四次挥手？
<ul>
<li>第一次挥手发送<strong>FIN=1</strong>，seq=u(客户端由ESTABLISHED变为FIN_WAIT1)，第二次挥手发送ACK=1，seq=v，ack=u+1（服务器端由ESTABLISHED变为CLOSE_WAIT），第三次挥手发送<strong>FIN=1</strong>，seq=w，ack=u+1(服务器端由CLOSED_WAIT变为LAST_ACK)，第四次挥手发送ACK=1，seq=u+1，ack=w+1</li>
</ul></li>
<li>为什么TCP挥手不是三次？
<ul>
<li>服务器端在收到第一次挥手时可以将ACK和FIN一并发送出去，但是服务器并不会立刻关闭socket(<strong>使用close系统调用</strong>)，只有等到服务器把所有的报文发送完了(TCP的半关闭特性，这样服务器还能发送，客户端还能接收)，才能发送FIN报文，因此是四次挥手</li>
</ul></li>
<li>time_wait为什么需要2MSL？
<ol type="1">
<li><strong>确保被动关闭TCP链接的一端能收到第四次挥手的ACK</strong></li>
<li><strong>避免上一次TCP连接的数据包影响到下一次的TCP连接</strong>(若服务端没有收到ACK，会重发第三次挥手的FIN包，此时客户端新建了一个到服务端的TCP连接，并且客户端使用的还是之前的端口号，那么网络延迟到达的FIN包就会被这个新的TCP连接接收到，这不是客户端希望接收到的数据)</li>
</ol></li>
<li>给定一个网址，访问过程是怎么样的？
<ol type="1">
<li>浏览器向DNS服务器请求解析该URL中的域名所定义的IP地址</li>
<li>解析出IP地址后，根据该IP地址和默认端口号80，和服务器建立TCP连接</li>
<li>浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li>
<li>服务器对浏览器请求作出响应，并把对应的HTML文本发送给浏览器</li>
<li>释放TCP连接</li>
<li>浏览器解析该HTML文本并显示内容</li>
</ol></li>
<li>网络层有哪些协议？
<ul>
<li>IP、ARP、ICMP、IGMP</li>
</ul></li>
<li>TCP第二次握手丢包处理？第三次？
<ul>
<li>客户端第一次握手发送的SYN包、以及服务器端第二次握手的发送的SYN、ACK包会发生重传。有重传最大次数的限制</li>
<li>第三次握手丢包，第二次握手SYN、ACK包会重传，如果达到最大次数限制还未收到ACK，那么就是一个半连接的状态</li>
<li>每一次重传RTO(重传超时时间)就会重新计算</li>
</ul></li>
<li>网络I/O五层模型？
<ul>
<li>阻塞I/O。执行I/O线程会被阻塞(比如socket缓冲区无数据但调用read去读)</li>
<li>非阻塞I/O。上述情况执行I/O线程不会被阻塞，返回EAGAIN或EWOULDBLOCK</li>
<li>I/O复用。在单进程/单线程中一次可以检测多个客户端的事件</li>
<li>信号驱动I/O(在多线程中不好处理)。
<ol type="1">
<li>使用linux相关的API(sigaction)，将信号处理程序的注册到服务器上，当读/写事件就绪时调用处理程序(将信号写入管道中)，然后在事件循环中解析该信号</li>
</ol></li>
<li>异步I/O</li>
</ul></li>
<li>close文件描述符后，epoll会不会把它自动从监听集合中删除呢？
<ul>
<li>如果fd的引用计数是1，close之后会自动删除</li>
</ul></li>
<li>广播和多播的区别？
<ul>
<li>广播(客户端绑定本地IP和端口，需要设置一下socket属性)只能用于局域网；多播即可用于局域网也可用于广域网</li>
<li>多播中客户端需要加入多播组才能接收到多播</li>
</ul></li>
<li>I/O多路复用是同步I/O还是异步的？
<ul>
<li>同步</li>
</ul></li>
<li>常见HTTP状态码？
<ul>
<li>1XX信息</li>
<li>2XX成功
<ul>
<li><code>200 OK</code>。成功建立连接</li>
</ul></li>
<li>3XX重定向</li>
<li>4XX客户端错误
<ul>
<li><code>400 Bad Request</code>。请求报文中存在错误</li>
<li><code>403 Forbidden</code>。请求被拒绝，和资源文件的访问权限相关</li>
<li><code>404 Not Found</code>。未找到服务器上的资源</li>
</ul></li>
<li>5XX服务器错误
<ul>
<li><code>500 Internal Server Error</code>。服务器正在执行请求时发生错误</li>
</ul></li>
</ul></li>
<li>TCP首部和UDP首部？
<ul>
<li>TCP首部20个字节，UDP首部8个字节</li>
<li>TCP首部
<ul>
<li>源/目的端口号</li>
<li>序号。用于对字节流进行编号(以字节为单位)</li>
<li>确认号</li>
<li>数据偏移(指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度，以4字节为单位)，标志位，窗口大小(告知接收方，发送窗口的大小)</li>
<li>校验和，紧急指针</li>
</ul></li>
<li>UDP首部
<ul>
<li>源/目的端口号</li>
<li>校验和</li>
<li>报文长度，UDP首部的长度和数据部分的长度之和</li>
</ul></li>
</ul></li>
<li>说一下cookie和session？
<ul>
<li>cookie。因为HTTP是无状态协议，HTTP/1.1引入<code>Cookie</code>来<strong>保存状态信息</strong>
<ul>
<li><strong>cookie是服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，<strong>用于告知服务器两个请求是否来自同一浏览器</strong>，会带来额外的性能开销</li>
<li>用途
<ul>
<li>会话状态管理（如用户登录状态，购物车，游戏分数或其他需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul></li>
</ul></li>
<li>session。存储在服务器端，存储在服务器端的信息更在安全。</li>
<li>使用session维护用户登录状态的过程
<ul>
<li>用户进行登录时，浏览器发出HTTP请求报文，用户提交包含用户名和密码表单</li>
<li>服务器端验证该用户名密码，并返回一个session ID(作为redis的key)，放在响应报文的<strong>Set-Cookie</strong>字段中</li>
<li>客户端在收到响应报文时将该cookie值存入浏览器中</li>
<li>客户端之后对同一个服务器进行请求时会<strong>包含</strong>该cookie值，服务器收到提取session id，然后从redis中取出用户信息，继续处理业务</li>
</ul></li>
</ul></li>
<li>HTTP状态机？
<ul>
<li>解析请求行: <code>GET /index.html HTTP/1.1</code></li>
<li>解析请求头: <code>connection: close</code></li>
<li>解析请求体</li>
<li>解析结束后生成:状态行，响应头，响应体</li>
</ul></li>
<li>客户端拔掉网线会如何？
<ul>
<li>客户端不会重传</li>
<li>解决方法：使用心跳包，双方定期发送，如果一段时间收不到心跳包就直接断开</li>
</ul></li>
<li>客户端主动kill掉进程会如何？
<ul>
<li>客户端会给服务器端发送fin报文</li>
</ul></li>
<li>epoll的底层实现？</li>
<li>time_wait？大量出现的原因？怎么处理？
<ol type="1">
<li>time_wait是主动断开连接的一方，在发送第四次挥手报文的状态</li>
<li>大量http短连接的存在</li>
<li>connection: keep-alive，改变为长连接</li>
</ol></li>
<li>close_wait？大量出现的原因？怎么处理？
<ol type="1">
<li>被动关闭的一方在发送第二次挥手的ack和第三次挥手fin中间间隔的状态(这种状态大量出现会影响服务器的性能，如：fd数量达到服务器的上限)</li>
<li>通常是服务器出现异常后未关闭连接<code>close()</code>, 或者是close_wait的配置时间过长</li>
<li>top查看cpu利用率，netstate查看网络情况(<code>netstat -ap | grep &lt;PID&gt;</code>)</li>
</ol></li>
<li>reuseaddr?
<ul>
<li>设置<code>SO_REUSEADDR</code>选项，可以复用端口，不必等待2MSL时间(<strong>time_wait状态下</strong>两端的端口都不能使用)</li>
</ul></li>
<li>TCP半关闭状态
<ul>
<li>比如被动关闭的一方处于close_wait状态，因为TCP是全双工的连接，主动关闭连接的一方已经关闭，此时TCP连接处于半关闭状态(既能关闭读方向也能关闭写方向，通过伯克利套接字<code>shutdown</code>)</li>
</ul></li>
<li><a target="_blank" rel="noopener" href="https://zhangbinalan.gitbooks.io/protocol/content/tcpde_yong_sai_kong_zhi.html">流量控制和拥塞控制？</a>
<ul>
<li>对比：
<ul>
<li>拥塞控制是一个<strong>全局性</strong>的过程，涉及到所有的主机、路由器等</li>
<li>流量控制指的是<strong>点对点通信</strong>的控制，所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收</li>
</ul></li>
<li>流量控制：<strong>为了避免分组丢失，控制发送者的发送速度</strong>，使得接收者来得及接收。
<ul>
<li>接收窗口(rwnd):接收方根据自己的接收缓存的大小，动态地调整发送方的发送窗口大小</li>
<li>拥塞窗口(cwnd):发送方根据其堆当前网络拥塞估计而确定的窗口值</li>
<li><strong>发送窗口=min{cwnd, rwnd}</strong></li>
</ul></li>
<li>拥塞控制
<ul>
<li>慢启动(cwnd由1(即一个最大报文段长度MSS)开始指数级增加)，拥塞避免(cwnd达到阈值后线性增加)。如果出现网络拥塞，则cwnd又重新变为1，然后阈值设为出现拥塞时cwnd的一半。</li>
<li>快重传(三次冗余ACK(收到接收方发送的三个ACK), 因为接收方每收到一个失序的报文段后就立即发出重复确认)，直接重传对方尚未收到的报文</li>
<li>快恢复。遇到网络拥塞直接将cwnd置为和阈值一样的值</li>
<li>快重传和快恢复属于慢启动和拥塞避免的<strong>改进</strong></li>
</ul></li>
</ul></li>
<li>视频会议为什么用UDP协议呢？
<ul>
<li>不需要可靠性，一些卡顿是可以接收到</li>
<li>UDP的速度是TCP比不了的</li>
</ul></li>
<li>webbench压测工具的原理？
<ul>
<li>fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果</li>
</ul></li>
<li>udp如何实现可靠？
<ul>
<li>参照<a target="_blank" rel="noopener" href="https://www.51cto.com/article/708598.html">QUIC</a></li>
</ul></li>
<li>介绍一下Http1.1和http2</li>
<li>TLS/SSL在哪一个阶段发挥它的作用?</li>
<li>http的队头阻塞?</li>
<li>多线程accept有什么问题？惊群效应？如何解决？</li>
</ul>
<h2 id="计组os">计组/OS</h2>
<ul>
<li>线程切换用到的硬件有什么？
<ul>
<li>寄存器组</li>
<li>程序计数器(PC)</li>
</ul></li>
<li>常见的系统调用有哪些？
<ul>
<li>文件操作
<ul>
<li>creat, read, write, open, close, link, unlink, chmod等</li>
</ul></li>
<li>过程控制
<ul>
<li>fork, wait, exit, exec</li>
</ul></li>
</ul></li>
<li>了解线程池吗？
<ul>
<li>一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。<strong>这避免了在处理短时间任务时创建与销毁线程的代价</strong></li>
<li>半同步半异步模式(采用Reactor模式作为事件处理模式)：分为同步层(用于处理客户逻辑)、队列层、异步层(用于处理I/O事件)三层。同步层的<strong>主线程(异步线程，不会出现阻塞)</strong>处理工作任务并<strong>存入</strong>请求队列，<strong>工作线程(同步线程)</strong>从工作队列<strong>取出</strong>任务执行，取不到任务的工作线程进入挂起状态
<ul>
<li>缺点
<ul>
<li>主线程往请求队列中添加<strong>任务</strong>，或者工作线程从请求队列中取任务都需要对请求队列加锁保护，从而白白耗费cpu时间</li>
<li>如果客户数量较多，工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢，如果通过添加工作线程来解决这一问题，工作线程的切换也将耗费大量CPU时间</li>
</ul></li>
</ul></li>
</ul></li>
<li>进程间通信方式？
<ul>
<li>信号</li>
<li>管道。 半双工通信方式(通常指无名管道PIPE)</li>
<li>消息队列。用一个链表来存储操作系统内核中的消息，并且使用“消息队列标识符”来标识消息队列。</li>
<li>共享内存。共享内存使用mmap，不同进程的虚拟地址映射到同一处物理地址进行通信</li>
<li>套接字</li>
<li>信号量。信号值为0下调用sem_wait()则会<strong>阻塞</strong>直到信号值大于0或者是信号中断处理的调用</li>
</ul></li>
<li>堆和栈有什么区别?
<ul>
<li>申请方式：栈由系统自动分配释放(如函数调用时存放函数的参数值，局部变量的值等)；堆需要程序员自己申请，并指明大小</li>
<li>申请效率：栈由系统自动分配，申请<strong>效率高</strong>；堆内存分配效率比栈低，容易产生内存碎片。</li>
<li>增长方向：栈由高地址向低地址方向增长；堆由低地址向高地址方向增长</li>
<li>堆中空闲空间使用<strong>空闲链表</strong>来管理，动态分配内存时<strong>空闲内存的管理</strong>：首次适配(不需要排序)、最佳适配(空闲分区按<strong>容量</strong>递增次序排序)、下次适配(在首次适配的基础上，每次分配内存时，从上次查找结束的位置开始查找)、最差适配(空闲分区按<strong>容量</strong>递减次序排序)</li>
<li><strong>由进程的虚拟地址空间布局可知，在多线程环境中，共享的变量应该存储在堆上，而不是栈(每个线程都有自己的栈)</strong></li>
</ul></li>
<li>静态库与动态库(共享库)？
<ul>
<li>静态库是在编译时链接到目标程序中，而动态库则是在运行时动态链接到目标程序中。</li>
<li>静态库文件一旦被编译到目标程序中，就不能再进行更新和维护，如果需要更新或修复库文件中的某个bug，就需要重新编译整个程序；而动态库文件可以独立更新和维护，不会影响到目标程序，只需要<strong>替换</strong>动态库文件即可。</li>
<li>动态库并不会链接到目标程序中，而是在程序<strong>运行时</strong>才被载入。不同的应用程序如果调用相同的库，那么<strong>共享内存</strong>(可实现进程间资源的共享)中只需要有<strong>一份实例</strong></li>
<li>静态库浪费空间和资源，包括对程序更新、部署和发布都需要重新编译(因此衍生出了动态库)</li>
</ul></li>
<li>死锁？
<ul>
<li>死锁是指<strong>两个或两个以上</strong>的进程在执行过程中，由于<strong>竞争资源</strong>或者由于彼此通信而造成的一种<strong>阻塞</strong>的现象</li>
</ul></li>
<li>自旋锁和互斥锁？
<ul>
<li>加锁失败的处理
<ul>
<li><strong>互斥锁加锁失败后会进行线程切换</strong></li>
<li>自旋锁(通过CPU提供的CAS(compare and swap), TAS原子操作)加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁</li>
<li>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁(因为线程互斥锁线程<strong>上下文切换</strong>的开销)</li>
</ul></li>
</ul></li>
<li>悲观锁和乐观锁（加场景）？
<ul>
<li>悲观锁，认为多线程同时修改共享资源的概率比较高，因此访问共享资源前总会加锁</li>
<li>乐观锁(无锁编程，并没有加锁)，反之，<strong>会先修改完共享资源后再验证这段时间内是否发生冲突</strong>，如果没有则操作完成，有则放弃本次操作。</li>
<li>乐观锁重试的成本非常高，因此只有在锁成本高且冲突概率低的场景时，才考虑使用乐观锁，如：多人在线文档</li>
</ul></li>
<li>进程和线程？区别？
<ul>
<li>进程是正在执行的程序实实例，执行程序时，内核会将程序代码载入虚拟内存中，并为程序变量分配空间，建立进程数据结构(记录如进程ID、用户ID、组ID以及终止状态等)。进程虚拟地址空间逻辑上划分为，栈区、堆区、数据区(初始化的全局和静态变量、未初始化的全局和静态变量(BSS))、文本区</li>
<li>线程共享同一数据区和堆，每个线程都有属于自己的栈(硬件多线程有自己的PC和寄存器组)，可以通过共享的全局变量进行通信，线程也能利用IPC的方式进行通信，多线程应用能从多处理器硬件的并行处理中得到性能的提升</li>
<li>区别：
<ul>
<li>进程是资源分配的最小单位，线程是<strong>CPU调度</strong>的最小单位(引入线程之后的cpu)</li>
<li><strong>一个线程只能属于一个进程，而一个进程可以有多个线程</strong></li>
<li>进程在执行过程中拥有独立的内存空间，而多个线程共享进程的内存空间</li>
<li>进程上下文切换的开销大，线程切换的开销小</li>
<li><strong>进程间不会相互影响，而线程为了保证同步需要加锁</strong></li>
</ul></li>
</ul></li>
<li>线程间的同步方式？
<ul>
<li>互斥锁、自旋锁、读写锁、条件变量</li>
</ul></li>
<li>僵尸进程和孤儿进程？
<ul>
<li>孤儿进程是指，父进程已经退出了，子进程还在运行，那么这些子进程将被init进程(1号进程，0号进程为idle进程)所收养，并由init进程对它们完成状态收集工作</li>
<li>僵尸进程是指，子进程退出了，但父进程并未调用waitpid/wait收集子进程状态信息，那么子进程的进程描述符仍然在系统中(如果有大量的僵尸进程，因为<strong>系统所能使用的进程号是有限的</strong>，就可能因为没有进程号而导致创建不了新的进程)</li>
</ul></li>
<li>死锁及避免？
<ul>
<li>死锁预防，破坏四个必要条件之一：
<ul>
<li>请求并保持，互斥条件，不可剥夺，循环等待</li>
<li>破坏
<ul>
<li>请求并保持：一次性申请在整个运行过程中需要的全部资源</li>
<li>互斥条件：无锁编程</li>
<li>循环等待：按顺序申请资源</li>
<li><strong>不可剥夺</strong>：如果某一个进程进一步的请求资源被拒绝，则释放该进程的资源</li>
</ul></li>
</ul></li>
<li>死锁避免，银行家算法</li>
</ul></li>
<li>如何检验死锁？
<ul>
<li>死锁的检测算法通过检测有向图是否存在环来实现，从一个结点出发进行DFS，如果存在环，则出现死锁</li>
</ul></li>
<li>什么是mmap？
<ul>
<li>是一种内存映射文件的方法，将一个文件映射到虚拟地址空间，实现这样的映射关系后，进程就可以采用指针的方式读写这一段内存，对文件的操作不再需要用read、write等系统调用。</li>
<li>mmap由操作系统负责管理</li>
</ul></li>
<li>条件变量和信号量的区别？
<ul>
<li>条件变量可以一次唤醒<strong>所有</strong>等待者(通过pthread_cond_broadcast唤醒所有阻塞的线程, pthread_cond_signal保证至少唤醒一条，效率较高)；而信号量不行</li>
<li>信号量可以指明有效资源的数量(是有值的)，而条件变量没有</li>
<li>信号量使用忙等待；条件变量使用阻塞等待</li>
</ul></li>
<li>CAS
<ul>
<li><code>compare and swap</code>(传入三个参数)，通过检查内存位置中的值是否等于旧值，若未发生变化，则将新值更新到内存位置中。需要搭配Volatile使用(使编译器不再优化对该变量的ld和st)</li>
</ul></li>
<li>内存管理的方式？
<ul>
<li>页式管理</li>
<li>段式管理</li>
<li>段页式管理</li>
</ul></li>
<li>字节对齐的好处？
<ul>
<li>字节对齐能够更好地对指令进行译码，同时避免访问一个数据多次访存(比如获取一个8bit数据，主存宽度为8，<strong>如果字节不对齐，取数据需要访问两次存储器</strong>)</li>
</ul></li>
<li>为什么<code>pthread_create</code>第三个传入的参数为成员函数必须得是静态的？
<ul>
<li>执行的函数返回值必须为<code>(void*)</code></li>
<li>例子 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">()</span></span>;   <span class="comment">// 必须返回的是指针</span></span><br><span class="line"><span class="type">pthread_t</span> p1;</span><br><span class="line"><span class="built_in">pthread_ctate</span>(&amp;p1, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);  <span class="comment">// 线程执行函数func</span></span><br></pre></td></tr></table></figure></li>
<li>首先在C++的类中，<strong>普通成员函数</strong>不能作为pthread_create的线程函数，如果要作为pthread_create中的线程函数，必须是<strong>static</strong> !</li>
<li>普通成员函数的参数会隐式存在一个默认的底层const的this参数，这就和pthread_create的第四个参数(参数列表)不匹配，编译器会报错。因为传入的是静态成员函数，若想使用成员变量，传入一个this指针即可(因为静态成员函数没有this指针)</li>
</ul></li>
<li>进程挂起态和阻塞态的区别？
<ul>
<li>挂起是主动的(这里指的操作系统主动不活跃的进程或线程挂起)；阻塞是被动的(程序员可以进行IO操作)</li>
</ul></li>
<li>中断和异常的区别？
<ul>
<li>中断一般由外部引起(如外部设备的中断)；异常一般由内部引起<strong>一般会重新执行处于异常的指令</strong>(如缺页异常)</li>
<li>中断会进行中断优先级的比较；异常没有</li>
</ul></li>
<li>虚拟内存的优势？
<ul>
<li><strong>程序的保护和共享</strong>(每个进程有自己的虚拟地址空间，进程间通过共享内存通信)</li>
<li><strong>内存管理的便利</strong>，引入页式管理后，可以减少外部碎片</li>
<li>使得一个<strong>进程</strong>所占用的<strong>物理空间</strong>超过主存的空间(有一部分在磁盘的交换区)</li>
<li><strong>可以管理每个页的访问权限</strong>(进程虚拟地址空间内核数据的部分是和物理地址空间一一映射的，不需要进行VA到PA的转换)</li>
</ul></li>
<li>为什么要引入Cache？
<ul>
<li><strong>充分利用局部性</strong>(局部性原理：时间局部性和空间局部性)</li>
<li>CPU和主存的速度相差三个数量级，指令和数据都需要到主存中去取(太慢)</li>
</ul></li>
<li>说一下进程的状态？
<ul>
<li>xv6中：使用、未使用、运行、就绪、阻塞、僵尸</li>
</ul></li>
<li>进程调度算法？
<ul>
<li>周转时间=作业完成时间-作业提交时间，即为等待时间，在就绪队列中排队，在处理机上运行，输入/输出花费的时间总和</li>
<li>先来先服务算法</li>
<li>短进程优先算法</li>
<li>时间片轮转算法</li>
<li>多级反馈队列算法</li>
<li>高响应比优先调度算法，即考虑作业等待时间又考虑作业运行时间</li>
</ul></li>
<li>线程间的同步手段？
<ul>
<li>互斥量(mutex)</li>
<li>读写锁</li>
<li>条件变量</li>
<li>信号量</li>
</ul></li>
<li>协程？
<ul>
<li>用户态线程</li>
<li>轻量(栈比线程小)</li>
<li>在同一个线程的协程是串行执行的</li>
<li>对称协程(go)，非对称协程(libco，同一个线程的子协程不能直接切换，而是要通过主协程)</li>
</ul></li>
</ul>
<h2 id="db">DB</h2>
<ul>
<li>B+树和B树的区别？
<ul>
<li>B树每个节点在内存中占用一个页面</li>
<li>树有多高就需要检索多少次(访问二叉树每个节点就会发生一次I/O)，<strong>索引存在于磁盘中</strong></li>
<li>B树中键不能重复存储</li>
<li>B+树<strong>范围查找</strong>更高效快捷</li>
<li>B+树只有叶子节点存储数据指针(这样内部节点就可存储更多的key，使得B+树相对B树来说更矮)；B树叶子节点和内部节点都存储数据指针，因此节点数量相同，B+的高度比B树更低</li>
</ul></li>
<li>mysql中语句查询的顺序
<ul>
<li>sql查询语句执行顺序
<ul>
<li>SELECT、DISTINCT、FROM、JOIN、ON、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT</li>
</ul></li>
<li>关键字执行顺序
<ul>
<li>FROM、WHERE、GROUP BY、HAVING、SELECT、DISTINCT</li>
</ul></li>
</ul></li>
<li>mysql左连接和内连接？
<ul>
<li>内连接，返回两个表交集的部分</li>
<li>左连接，返回两个表交集的部分以及左表的部分，左表的记录将会全部显示出来，右表记录不足的属性置为NULL</li>
</ul></li>
<li>什么是事务？
<ul>
<li>指数据库中<strong>一组相关的操作</strong>，它们被视为一个单独的工作单元，要么全部执行成功，要么全部回滚。</li>
<li>事务通常用于保证数据库的完整性和一致性</li>
<li>满足ACID特性的一组操作</li>
</ul></li>
<li>数据库的ACID？
<ul>
<li>保证事务的正确可靠：
<ul>
<li>Atomicity(原子性)。事务是为不可分割的最小单元</li>
<li>Consistency(一致性)。DB在事务执行前后都保持一致性状态</li>
<li>Isolation(隔离性)。一个事务再最终提交之前，对其他事务是不可见的</li>
<li>Durability(持久性)。一旦事务提交就会永远保存到数据库中，即使发生系统崩溃，事务执行的结果也不能丢失</li>
</ul></li>
<li>只有满足一致性，事务的执行结果才是正确的。在无并发的情况下，保证原子性就保证了一致性；在有并发的情况下，保证原子性和隔离性才能保证一致性。事务满足持久化是为了应对系统崩溃的情况</li>
</ul></li>
<li>并发一致性的问题(主要原因是破坏了事务的隔离性)
<ul>
<li>丢失修改。一个事务的更新操作被另一个事务的更新操作所替代</li>
<li>脏读。事务T1的修改了一个数据，但并未提交，此时事务T2读取到T1修改后的数据，但此时T1撤销了这次修改，T2所读的就是脏数据</li>
<li>不可重复读。事务T1先读取一次数据，之后事务T2修改数据，事务T1再次读取到数据，此时T1读取到的两次数据的结果不同</li>
<li>幻读。类似于不可重复读，事务T1读取一段范围的数据，事务T2在这个范围内插入了新的数据，事务T1两次读取的数据不一致</li>
</ul></li>
<li>封锁类型
<ul>
<li>读写锁。X锁和S锁，X锁和X锁互斥。对A加了S锁之后可以其他事务能对数据对象A再加S锁
<ul>
<li>互斥锁，又称为写锁，X锁</li>
<li>共享锁，又称为读锁，S锁</li>
</ul></li>
<li>意向锁。存在表级锁和行级锁的情况下，事务想要对表加X锁，需要先检测是否有其他事务对表或者表中的任意一行加了锁，那么就需要对表的每一行都检测一次，非常耗时。<strong>因此引入表锁IX/IS，用来表示一个事务想要在表中的某个数据行上加X锁或者S锁</strong>
<ul>
<li>一个事务在获得某个数据<strong>行</strong>对象的S锁之前，必须要获得<strong>表</strong>的IS锁或更强的锁</li>
<li>一个事务在获得某个数据<strong>行</strong>对象的X锁之前，必须要获得<strong>表</strong>的IX锁</li>
</ul></li>
</ul></li>
<li>封锁协议
<ul>
<li>三级封锁协议
<ul>
<li>一级封锁协议。事务要修改数据时必须加X锁，直到事务结束。解决了丢失修改</li>
<li>二级封锁协议。在一级的基础上，事务要读取数据时必须加S锁，读取完马上释放S锁。解决了脏读</li>
<li>三级封锁协议。在二级的基础上，事务读完数据不释放S锁，直到事务结束。解决了不可重复读</li>
</ul></li>
<li>两段锁协议
<ul>
<li>加锁和解锁分为两个阶段运行</li>
</ul></li>
</ul></li>
<li>隔离级别。<strong>并发控制可以通过封锁实现，但是封锁操作需要用户自己控制，相当复杂，因此DBMS提供了事务的隔离级别</strong>
<ul>
<li>未提交读。事务中的修改，即使没有提交，对其他事务也是可见的</li>
<li>提交读。事务中的修改，只有提交了，其他事务才可见</li>
<li>可重复读。保证同一个事务中多次读取同一数据的结果是一样的</li>
<li>可串行化。强制事务串行执行，多个事务互不干扰，需要加锁实现</li>
</ul></li>
<li>(Multi-Version Concurrency Control, MVCC)，是mysql的InnoDB存储引擎实现隔离级别，实际场景中读操作往往多于写操作，为了避免读写锁引入的不必要的加锁操作。
<ul>
<li>写操作(DELETE、INSERT、UPDATE)更新最新的版本快照，读操作去读旧版本快照，没有互斥关系(类似于copyonwrite)</li>
<li>为了避免脏读和不可重复读，MVCC规定事务进行读取操作时，只能读取已经提交的快照(当然一个事务可以读取自身未提交的快照)</li>
</ul></li>
<li>范式。解决四种异常（冗余数据、修改异常、删除异常、插入异常）
<ul>
<li>1NF。属性不可再分，否则需要再分解</li>
<li>2NF。非主属性完全依赖于主键，否则需要再分解</li>
<li>3NF。非主属性不依赖于其他非主属性，否则需要再分解</li>
</ul></li>
<li>聚簇索引和非聚簇索引？
<ul>
<li>聚簇索引叶子节点存储的是数据；非聚簇索引叶子节点存储的是指向数据的指针</li>
<li>聚簇索引插入和更新插入开销大(因为聚簇索引的数据和索引，存储在同一物理位置上，因此会导致物理位置的变化)，会导致数据的碎片化；非聚簇索引开销小</li>
<li>聚簇索引范围查询和排序操作的性能高；非聚簇索引不如聚簇索引</li>
</ul></li>
<li>存储过程?视图?</li>
</ul>
<h2 id="算法">算法</h2>
<ul>
<li>稳定排序有哪些？不稳定排序有哪些？
<ul>
<li>稳定性：经过排序算法后，原先两个元素的<strong>相对位置</strong>不变，就称它是稳定的</li>
<li>稳定排序：直接插入排序、冒泡排序、归并排序、基数排序</li>
<li>不稳定排序：简单选择排序、希尔排序、快速排序、堆排序</li>
</ul></li>
<li>快速排序的时间复杂度为什么是nlogn?
<ul>
<li>如果分区间的pivot恰好为中点，递归对两个子区间sort复杂度logn，分为n个子区间</li>
</ul></li>
<li>哈希表处理冲突的方法？
<ul>
<li>开放定址法
<ul>
<li>线性探测</li>
<li>平方探测</li>
<li>再散列</li>
</ul></li>
<li>拉链法
<ul>
<li>把所有key一致的元素都存放在同一个链表中</li>
</ul></li>
</ul></li>
<li>二分查找时间复杂度为什么是<code>O(logn)</code>？
<ul>
<li>第一次迭代之后剩余数组长度为<span class="math inline">\(\frac{n}{2}\)</span></li>
<li>第二次迭代之后剩余数组长度为<span class="math inline">\(\frac{n}{2^2}\)</span></li>
<li>第k次迭代之后剩余数组长度为1，即<span class="math inline">\(\frac{n}{2^k}=1\)</span></li>
<li>故时间复杂度为k，即<span class="math inline">\(k=\log_{2}{n}\)</span></li>
</ul></li>
<li>手写堆排序？快速排序？归并排序？</li>
</ul>
<h2 id="cc">C/C++</h2>
<ul>
<li>什么是内联函数？
<ul>
<li>内联函数编译时展开，省去了函数调用的开销(如将实参、局部变量、返回地址等压入栈中, 返回时还要弹栈)</li>
</ul></li>
<li>说一下多态？
<ul>
<li>C++支持两种多态性：编译时多态(通过函数重载，泛型编程实现)，运行时多态(通过虚函数实现。常见通过派生类对象指针或引用, 赋给基类对象指针或引用)。</li>
<li>静态多态是指在编译期间就可以确定函数的地址，而动态多态需要等到运行时才能知道函数的地址</li>
</ul></li>
<li>malloc和new的区别？
<ul>
<li>operator new是<strong>运算符</strong>(其中调用malloc)，malloc是标准库函数</li>
<li>new申请的堆大小由系统自动判断，malloc需要传递申请大小的参数</li>
<li>new返回相应类型的指针，malloc返回void*，需要强制转换</li>
<li>若new<strong>申请不到内存则会抛出异常</strong>，malloc返回NULL</li>
<li>new中会调用malloc <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no inline, required by [replacement.functions]/3</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;1) new(size_t), size = %zu\n&quot;</span>, sz);</span><br><span class="line">    <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">        ++sz; <span class="comment">// avoid std::malloc(0) which may return nullptr on success</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">void</span> *ptr = std::<span class="built_in">malloc</span>(sz))</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> std::bad_alloc&#123;&#125;; <span class="comment">// required by [new.delete.single]/3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>C++为什么构造函数不能是虚函数？
<ul>
<li>因为虚函数的地址是通过虚函数表来查找的，虚函数表由实例化对象中的vptr指向，实例化对象需要构造函数完成初始化，但此时vptr还未初始化</li>
</ul></li>
<li>虚函数表在哪？虚函数指针vptr在哪？
<ul>
<li>虚函数表在只读数据区；vptr一般在对象内存分布的第一个位置，对象的地址就是虚函数指针vptr的地址</li>
</ul></li>
<li>C++纯虚函数？
<ul>
<li>没有函数体，只有声明</li>
<li>函数声明的结尾加上=0，告诉编译器这是纯虚函数</li>
<li>含纯虚函数的类称为抽象类，之所以抽象，因为它无法实例化。</li>
</ul></li>
<li>const限定的变量可以修改吗？怎么修改？
<ul>
<li><code>mutable</code>只能用来修饰类的数据成员，该成员变量可以在<strong>const成员函数</strong>内进行修改</li>
<li>如果是顶层const修饰的变量则不能修改</li>
<li>如果是指针变量，且用底层const修饰，那么该指针指向的值不能修改，但是指针值可以修改</li>
<li><code>const int* const p;  // 靠右的是顶层const，靠左的是底层const</code></li>
</ul></li>
<li>如何用C语言实现面向对象？
<ul>
<li>面向对象三大特性封装、继承、多态，见<a target="_blank" rel="noopener" href="https://schaepher.github.io/2020/03/12/c-oop/">文章</a></li>
<li>封装。可以将结构体的定义在<code>.c</code>文件中，<code>.h</code>中仅作结构体的声明, 这样其他文件就没办法直接访问结构体的具体内容。若想访问成员变量需要提供访问这些变量的方法,如 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">animalGetName</span><span class="params">(Animal this)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>继承。了解过C++内存模型之后很容易能知道，只需要定义"父类"作为"派生类"结构体成员(必须在第一个位置)，这样转换为父类指针时，子类结构体前面部分就是父类结构体了</li>
<li>多态。定义一个结构体作为虚函数表，在基类中增加虚表指针。虚表在构造函数中初始化，在析构函数中销毁。</li>
</ul></li>
<li>用过函数指针吗？
<ul>
<li>本质上是一个指针，指向函数。通常用于函数回调的应用场景</li>
</ul></li>
<li>C++深拷贝和浅拷贝?
<ul>
<li>若没有定义拷贝构造函数，编译器执行的是默认拷贝构造函数(浅拷贝)。如果类成员中有指针成员变量，对指针拷贝后会出现两个指针变量指向同一个内存单元，会出现两次析构，造成内存泄露，此时要采用深拷贝(即自己定义拷贝构造函数, 使拷贝后的对象指针成员有自己的内存空间)</li>
</ul></li>
<li>为什么在继承情况下析构函数要为虚函数？
<ul>
<li>如果不是虚函数则会造成内存泄露，比如多态，delete父类指针后，仅调用父类的析构函数，子类析构函数并未被调用。但如果析构函数是虚函数，则会先调用子类析构函数再调用父类虚构函数(析构函数调用的顺序)</li>
</ul></li>
<li>C语言sizeof和strlen的区别？
<ul>
<li>sizeof是<strong>一元运算符</strong>，以字节为单位，用来求指定变量或变量类型所占内存空间的大小(单位为字节)，其值在<strong>编译时期</strong>就计算好了，因此只能算出静态的大小</li>
<li>strlen是<strong>库函数</strong>，用来求字符串的长度，它回去找字符串结尾的'\0'<strong>结束符</strong>(返回值不包括\0)；如果找不到，返回值会是一个不确定的值</li>
</ul></li>
<li>构造函数的顺序和析构函数的顺序原因？
<ul>
<li>个人感觉是因为对象模型</li>
</ul></li>
<li>空类有哪些函数？空类的大小？
<ul>
<li>有六个:
<ol type="1">
<li>默认构造函数</li>
<li>默认拷贝构造函数</li>
<li>默认拷贝赋值运算符</li>
<li>默认析构函数</li>
<li>取地址运算符</li>
<li>取地址运算符const</li>
</ol></li>
<li>编译器默认分配1 byte空间，编译器是<strong>支持空类实例化对象</strong>的，因此对象必须要被分配内存空间才有意义</li>
</ul></li>
<li>RAII机制？
<ul>
<li>资源获取即初始化，利用C++构造的对象最终会被析构函数销毁的原则，进行资源的释放，避免内存泄露的风险</li>
</ul></li>
<li>四种类型转换
<ul>
<li>const_cast, 消除底层const</li>
<li>static_cast, 只要不含底层const都可以使用，</li>
<li>dynamic_cast, 运行时进行类型转换的安全检查，用于基类和派生类之间的转换</li>
<li>reinterpreter_cast, 进行位模式上的强制转换</li>
</ul></li>
<li>vector在push_back的时候容量满了怎么办？
<ul>
<li>capacity会变为原来的两倍。申请一块新内存，拷贝数据，释放原内存</li>
</ul></li>
<li>vector中resize和reserve的区别？
<ul>
<li>resize是改变容器大小，且创建对象，如果改变之后的大小小于当前容器大小，则erase，否则insert</li>
<li>reserve指定容器预留的空间(改变可用空间的大小)，并未构造对象</li>
</ul></li>
<li>map和unordered_map的区别？
<ul>
<li>map的底层是红黑树，存储的键是有序的。缺点:空间的开销</li>
<li>unordered_map底层是哈希表，存储的键是无序的。缺点：哈希表的建立费时</li>
</ul></li>
<li>C++常用<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/cpp">设计模式</a>？
<ul>
<li>TODO</li>
<li>工厂模式
<ul>
<li>抽象工厂定了用于创建不同产品的接口，具体的工厂类重写该接口实现其相应功能</li>
</ul></li>
<li>单例模式
<ol type="1">
<li>保证一个类只有一个实例(控制某些共享资源的访问权限，如数据库、文件)，因此将其构造函数用private修饰</li>
<li>为该实例提供一个全局访问的节点(使用一个静态成员变量存储指向该实例的指针，再用静态成员函数获取该静态成员变量)</li>
</ol></li>
<li>观察者模式
<ul>
<li>要有一个订阅者列表，添加订阅者和删除订阅者的方法。当事件发生时，遍历订阅者列表通知订阅者(调用其对象的特定通知方法)</li>
</ul></li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>策略模式</li>
<li>原型模式</li>
<li>模板模式</li>
</ul></li>
<li>对象的什么函数不能被声明为虚函数？
<ul>
<li>非成员函数</li>
<li>静态成员函数。该类的所有对象都共享这份代码，<strong>不能被继承</strong>，没有动态绑定的必要性</li>
<li>内联成员函数。内联函数在编译期展开，virtual函数体现的是运行时机制</li>
<li>构造函数(上面有说过)</li>
<li>友元函数。本质上是因为C++不支持友元的继承</li>
</ul></li>
<li>指针和引用的区别？
<ul>
<li>指针是存储地址的<strong>变量</strong>，引用是变量的<strong>别名</strong></li>
<li>引用定义时<strong>必须</strong>初始化，而指针可以不必初始化</li>
<li>指针可以改变指向的存储单元，而<strong>引用初始化之后就不能改变了</strong></li>
<li>指针的自增标识指向下一个地址单元，而引用的自增表示引用变量值的增减</li>
</ul></li>
<li>哪几种情况必须用到初始化列表？
<ul>
<li>const成员变量，不能赋值</li>
<li>引用成员变量，不能赋值</li>
<li>类成员没有默认构造函数的类类型</li>
<li>如果类存在继承关系，派生类必须在其初始化列表中调用直接基类的构造函数</li>
</ul></li>
<li>struct和class的区别？
<ul>
<li>struct类成员默认是public，class是private(作用域限定)</li>
<li>struct默认是public继承，而class是private</li>
</ul></li>
<li>常见C++四大内存分区(const变量的位置取决于编译器)
<ul>
<li>代码区</li>
<li>静态/全局数据区，又分为已初始化/未初始化。const修饰的全局变量</li>
<li>栈区。const修饰的局部变量</li>
<li>堆区</li>
</ul></li>
<li>迭代器失效的情况？解决方案？
<ul>
<li>在迭代时调用erase()、insert()、容器扩容(原来容器的迭代器失效)等</li>
<li>数组型数据容器(如vector、deque等，因为是连续分配的内存，所有元素的迭代器都会失效, 都向前/后移动了一个位置)</li>
<li>链表型数据容器(如list，因为是链式存储，插入和删除不会对其他迭代器造成影响)</li>
<li>树型数据容器(如map、set，删除、插入元素不会对其他元素造成影响，因此只是当前被删除的迭代器失效)</li>
<li>解决方法：
<ul>
<li><strong>erase会返回当前删除的迭代器的下一个迭代器</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里想把大于2的元素都删除</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=q.<span class="built_in">begin</span>();it!=q.<span class="built_in">end</span>();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      it=q.<span class="built_in">erase</span>(it); <span class="comment">// 这里会返回指向下一个元素的迭代器，因此不需要再自加了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>++i和i++是原子操作吗？线程安全？
<ul>
<li>不是，++i先自加再赋值，i++先赋值再自加</li>
<li>如果i是局部变量，那就是线程安全的(每个线程有自己的栈)</li>
</ul></li>
<li>宏和inline的区别
<ul>
<li>宏
<ul>
<li>没有类型检测，不安全，如： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sums(a,b) a+b  <span class="comment">// 这时候调用2*sums(a,b)会被解析为 2*a+b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sums(a,b) (a+b)  <span class="comment">// 这时候调用会被解析为2*(a+b)</span></span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>inline时将函数展开，减少函数调用的开销，编译器会进行安全检查</li>
</ul></li>
<li>C++重写和重载的区别？
<ul>
<li>重写
<ul>
<li>被重写的函数必须是virtual的(C++对象模型虚函数表)</li>
<li>函数名称、参数列表、参数个数、返回值类型都一致</li>
<li>访问修饰符(private等)可以不同</li>
</ul></li>
<li>重载
<ul>
<li><strong>在一个类中</strong>(相同作用域)</li>
<li>函数名称相同</li>
<li>参数个数、参数类型、不同</li>
</ul></li>
</ul></li>
<li>emplace_back vs. push_back？
<ul>
<li>push_back会先创建一个元素然后再将这个元素拷贝/移动到容器的尾部(push_back会优先调用移动构造，如果没有才调用拷贝构造)；而emplace_back直接在容器尾部直接构造，省去了拷贝/移动的过程。</li>
</ul></li>
<li>预处理阶段做的事情
<ul>
<li>使用<code>gcc -E</code>，生成<code>.i</code>文件，将注释删去，将将头文件和宏进行展开和替换</li>
</ul></li>
<li>include防范？
<ul>
<li>为了避免重复声明</li>
</ul></li>
<li>静态成员变量/函数的意义？
<ul>
<li>使用静态成员变量实现<strong>多个对象之间的数据共享</strong>不会破坏隐藏的原则，保证了安全性还可以节省内存</li>
<li>编译器会在编译一个普通成员函数时，隐式地加上一个this指针。静态成员函数中没有this指针，因此只能访问静态成员变量</li>
<li>静态成员变量/函数声明时要加<code>static</code>，定义时不需要，编译器会去找声明</li>
<li><strong>静态成员不能在类内初始化，只能在类外初始化</strong>，<code>类型 类名::变量名 = 值</code></li>
</ul></li>
<li>虚函数和纯虚函数的区别？
<ul>
<li>纯虚函数当前抽象基类的子类必须对该纯虚函数进行覆写；虚函数可以不需要</li>
<li>纯虚函数没有函数体；虚函数有函数体</li>
<li>纯虚函数在声明结尾加上=0 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚函数声明</span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 纯虚函数声明</span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>构造函数和析构函数有返回值吗？
<ul>
<li>它们都没有返回值</li>
</ul></li>
<li>命名空间的作用？
<ul>
<li>处理常见的同名冲突，实际上是由程序设计者命名的内存区域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开</li>
</ul></li>
<li>C++中this指针什么情况下必须要用？
<ul>
<li>重载赋值运算符通常返回<code>*this</code></li>
<li>把自己作为函数实参。</li>
</ul></li>
<li>#define INT 5是什么类型？
<ul>
<li>预处理阶段不会进行类型检查(编译器做的事)，因此它没有类型</li>
</ul></li>
<li>NULL和nullptr的区别 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0  <span class="comment">// C++定义的NULL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)  <span class="comment">// C定义的NULL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在C++中使用<code>nullptr(std::nullptr_t)</code>能隐式转换为其他类型的指针，但C++中不能将<code>void*</code>指针隐式转换为其他类型(反过来是可以的)</li>
<li>避免出现重载时的二义性，比如一个函数的参数为<code>void*</code>，另一个函数的参数为<code>int</code>，这时候编译器就会报错</li>
<li>模板的类型推导会将<code>NULL</code>推导为<code>long int</code></li>
</ul></li>
<li>C++模板类和普通类的区别？
<ul>
<li>普通类都是在头文件中声明，在源文件中是实现；而模板类必须都放在头文件中</li>
<li>模板类和普通类都可以在类体中定义，但模板类在类体外定义要用函数模板</li>
</ul></li>
<li>函数默认参数？
<ul>
<li>在声明时指定，定义时不指定</li>
</ul></li>
<li>典型的移动构造函数和移动复制运算符？
<ul>
<li>移动构造函数(本质上就是浅拷贝)。这里没有深拷贝，只是移动了资源。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Holder</span>(Holder&amp;&amp; other)     <span class="comment">// &lt;-- rvalue reference in input</span></span><br><span class="line">&#123;</span><br><span class="line">  m_data = other.m_data;   <span class="comment">// (1)</span></span><br><span class="line">  m_size = other.m_size;</span><br><span class="line">  <span class="comment">// (2) 将右值引用数据设置为某个有效的状态，防止它在临时对象死亡时被意外删除(调用析构函数)，(浅拷贝的危险性)，右值是将亡值</span></span><br><span class="line">  other.m_data = <span class="literal">nullptr</span>; </span><br><span class="line">  other.m_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>移动赋值运算符 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Holder&amp; <span class="keyword">operator</span>=(Holder&amp;&amp; other)     <span class="comment">// &lt;-- rvalue reference in input  </span></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] m_data;         <span class="comment">// (1) 清理现有资源</span></span><br><span class="line"></span><br><span class="line">  m_data = other.m_data;   <span class="comment">// (2) 传入数据</span></span><br><span class="line">  m_size = other.m_size;</span><br><span class="line"></span><br><span class="line">  other.m_data = <span class="literal">nullptr</span>;  <span class="comment">// (3) 防止临时对象死亡时被意外删除</span></span><br><span class="line">  other.m_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>vector::clear()会释放内存吗？
<ul>
<li>不保证vector的内存被释放，且capacity()的大小并未改变，改变的是size()大小</li>
</ul></li>
<li>new和make_shared初始化智能指针的区别？
<ul>
<li>new会分配两个不连续的内存块(一块分配给new，一块分配给智能指针对象)，而make_shared会分配一段<strong>连续</strong>的内存给这两个内存块。前者会造成碎片化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="comment">// 两者取值是一样的</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/analytics-vidhya/c-shared-ptr-and-how-to-write-your-own-d0d385c118ad">shared_ptr底层实现</a>？
<ul>
<li>引用计数成员变量用指针变量存储(指针对应的智能指针对象共享同一个引用计数)</li>
<li>在析构函数中判断引用计数的值来决定是否要<code>delete</code>成员变量<code>ptr</code>(拷贝过程为浅拷贝)</li>
</ul></li>
<li>unique_ptr和shared_ptr的性能差异？</li>
<li>内存泄漏?
<ul>
<li>内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放</li>
<li>种类
<ul>
<li>堆内存泄漏</li>
<li>资源泄露：比如有限的socket资源</li>
</ul></li>
<li>避免
<ul>
<li>避免在堆上分配</li>
<li>手动释放</li>
<li>使用STL</li>
<li>智能指针</li>
<li>RAII</li>
</ul></li>
</ul></li>
<li>weak_ptr解决shared_ptr循环引用问题
<ul>
<li>必须在程序员能预见会出现循环引用的情况下才能使用</li>
</ul></li>
<li>访问一个NULL会发生什么?
<ul>
<li>段错误</li>
</ul></li>
<li>join()和detach()?
<ul>
<li>join()主线程会<strong>阻塞</strong>等待被调用线程执行结束后，然后主线程回收被调用线程的资源</li>
<li>detach()，主线程继续运行(不被阻塞)，被调用线程驻留在后台运行，<strong>当主线程结束时</strong>，库负责清理与被调用西安城相关的资源</li>
</ul></li>
<li>C++lambda表达式(匿名函数) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 返回类型为int，x,y为传入的参数，若想使用外部变量，要在[]种捕获外部变量</span></span><br><span class="line"><span class="comment">// []不捕获任何外部变量</span></span><br><span class="line"><span class="comment">// [this]显式捕获this指针</span></span><br><span class="line"><span class="comment">// [=]以值的形式捕获所有外部变量</span></span><br><span class="line"><span class="comment">// [&amp;]以引用的形式捕获所有外部变量</span></span><br><span class="line">[&amp;,i](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;<span class="keyword">return</span> i;&#125;  <span class="comment">// [&amp;,i]表示i变量以值的形式捕获，其他外部变量以引用的形式捕获</span></span><br></pre></td></tr></table></figure></li>
<li>C++模板特化
<ul>
<li>匹配顺序：全特化类 &gt; 偏特化类 &gt; 主版本模板类</li>
<li>全特化模板<strong>形参列表</strong>没有参数<code>&lt;&gt;</code>，类名后显式指定所有<strong>模板实参</strong></li>
<li>偏特化模板形参列表有参数但不是全部，类名后指定了部分模板实参，以及模板形参 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">LexicalCast&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="comment">// 主模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LexicalCast&lt;<span class="type">int</span>, T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line">LexicalCast &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>指针为什么在释放之后要置为空？
<ul>
<li>避免出现悬空指针(dangling pointer)的问题，即指针指向的对象被销毁了，指针变量仍然指向这个位置</li>
<li>减少智能指针的引用计数</li>
</ul></li>
<li>std::function内存管理？
<ul>
<li>std::function用内部<strong>可能</strong>使用智能指针来管理，如果可调用对象是一个函数对象或lambda表达式，就是new运算符在堆上动态分配一个函数对象；如果可调用对象是一个函数指针，就直接将其存储在函数指针成员中。</li>
</ul></li>
<li>右值引用的底层实现?</li>
<li>C++内存模型?</li>
</ul>
<h2 id="objective-c">Objective-C</h2>
<ul>
<li>OC当中进行内存管理引用计数有什么缺点</li>
<li>strong和weak指针</li>
<li>怎么用promise发送多个请求</li>
<li>常见的性能优化放啊?</li>
<li>解释一下重绘，怎么避免?</li>
<li>runtime？</li>
<li>OC的类是什么？</li>
<li>IOS中常见的内存泄漏及其解决办法?</li>
<li>NSProxy解决内存泄漏具体怎么做？</li>
<li>NSProxy不是NSObject的子类吗？</li>
<li>mask属性如何实现蒙层的？为什么不推荐这么做？</li>
<li>离屏渲染细说</li>
<li>iOS的持久存储</li>
<li>OC和Swift的重载</li>
<li>如何获取设备信息？</li>
<li>UIKit类要在哪个线程上使用？</li>
<li>下载一个巨大的图片，各个步骤详细说</li>
<li>NSOpertion如何实现线程依赖的</li>
<li>iOS的内存泄漏</li>
<li>autorealeasepool?</li>
<li>OC对象的创建和销毁?</li>
<li>UItableview的reuse原理?</li>
<li>UItableview如果要删除某个cell，你的动画会怎么设计和实现？底层删除逻辑也说说</li>
<li>数据源操作细说?</li>
<li>怎么判定两个cell相同?</li>
<li>reuse队列长度怎么调整？属性名是什么?</li>
<li>cell进入reuse池，然后重新被激活了，计时器逻辑怎么处理?</li>
<li>MVC说一说？</li>
<li>单向数据流怎么说？Model和View如果要实现通信怎么做？</li>
<li>MVVM怎么做的？</li>
<li>UI一般在什么线程更新？</li>
<li>OC的消息转发机制?</li>
<li>优先级反转?</li>
<li>CALayer的三个树，然后渲染树是什么，CALayer是几维坐标?</li>
<li>离屏渲染是什么，怎么避免？</li>
<li>kvo的原理。三种调用方式_property, self.property, kvc的形式，哪些会触发kvo?</li>
<li>weak和assign区别?</li>
<li>自己设计检测性能？</li>
<li>block中局部变量修改这个点，__block关键字？</li>
</ul>
<h2 id="uml类图"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109655171">UML类图</a></h2>
<ul>
<li>泛化关系(空心箭头)(is a)</li>
<li>聚合关系(空心菱形+箭头)(has a)</li>
<li>组合关系(实心菱形+箭头)(contains a)，比聚合更强。A需要知道B的生命周期，A可能需要负责生成和释放B。如人的驱干和手脚的关 系</li>
<li>依赖关系(虚线箭头)(use a)。表示对象A用到了对象B，没有实际的关系。如<code>驾驶员</code>依赖<code>汽车</code>
<ul>
<li>依赖关系具体表现形式为B为A的构造器或方法中的局部变量、方法或构造器的参数、方法的返回值，或者A调用B的静态方法。</li>
</ul></li>
</ul>
<h2 id="智力题">智力题</h2>
<ul>
<li>25匹马，5个跑道，用最少的比赛次数找出前3匹马？</li>
<li>有一个3L量杯和5L量杯，如何量出四升的水？</li>
<li>有两条绳子，质量不均匀，烧断一条绳子的时间是1小时，如何测量15分钟？</li>
<li>有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球？</li>
<li>有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。</li>
<li>一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少。</li>
<li>村子里有红眼病，可以互相看到但不会互相告诉，当发现自己是红眼病之后会自杀，当外人告诉后第三天有人自杀，问村子里有几个人是红眼病</li>
</ul>
<h2 id="场景题">场景题</h2>
<ul>
<li>40亿个数中找一个数是否存在</li>
</ul>
<h2 id="反问环节">反问环节</h2>
<h4 id="反问技术面试官">反问技术面试官</h4>
<ul>
<li>您可以给我一些<strong>学习上的建议吗</strong>？</li>
<li>您已经这么多候选人，您觉得我<strong>相对于这个岗位还有哪些差距需要改善呢</strong>？</li>
<li>您<strong>希望</strong>我们校招应届生身上具有什么特质呢？</li>
<li>请问贵公司所用到的技术栈？</li>
</ul>
<h2 id="hr面">HR面</h2>
<ul>
<li>进入职场之后的规划？
<ul>
<li>贵公司是体系完善。自己<strong>希望能够与公司一起发展</strong>，也希望公司能在未来的培训中给予一定的指导，<strong>我也会努力让自己的目标与公司团队的目标相匹配</strong>。</li>
</ul></li>
<li>未来规划？
<ul>
<li>我准备在技术领域有所作为，短期的职业规划是，如果有幸能够进入贵公司，我会先把我相对于应聘岗位的短板给补齐，<strong>向身边的同事、前辈请教经验</strong>。因为我在学习过程中总是会夹带思考一些问题，也热爱和周围的同学和老师交流问题。</li>
</ul></li>
<li>对工作地点有什么要求？
<ul>
<li>没有要求。如果有机会，我更希望能去总部就职，可能会让我进步的更快</li>
</ul></li>
<li>期望工资？
<ul>
<li>基于我的能力我期望的薪资是</li>
<li>因为我对计算机领域非常感兴趣，只要能够从事到我感兴趣的领域就可以了，所以对工资没有硬性要求。</li>
</ul></li>
<li>如何看待加班？
<ul>
<li>我会调配自己的时间，积极配合，因为所从事的行业领域是我一直以来都热爱的，所以加班过程中我肯定也能收获很多！</li>
<li>我理想中加班是效率比较高的加班，如果是无效没有目的的加班就没必要</li>
</ul></li>
<li>团队遇到分歧怎么办？
<ul>
<li>在分歧中寻找<strong>共识</strong>，<strong>通过共识化解分歧</strong></li>
<li>想想各自的出发点</li>
<li><strong>承认冲突</strong>并找到解决方案</li>
</ul></li>
<li>为什么拒绝之前的offer？
<ul>
<li>交叉行业</li>
<li>技术栈不符</li>
<li>薪资不满意</li>
</ul></li>
<li>自己的三个优势？
<ul>
<li>有计划</li>
<li>学习能力强</li>
<li>抗压能力强</li>
</ul></li>
<li>自己最大的优点和缺点？
<ul>
<li>缺点：公共场合的公开表达</li>
</ul></li>
<li>自己需要改进的地方？</li>
<li>团队中如何分工？</li>
<li>过往中对你帮助很大的事？
<ul>
<li>毕业的旅游</li>
</ul></li>
<li>为什么想加入我们公司？
<ul>
<li>公司的声誉和价值观</li>
<li>官司的文化和氛围</li>
<li>公司的业务和发展前景</li>
<li>公司的培训和职业发展机会</li>
<li>因为我的专业及项目经历与贵司的这个岗位很匹配</li>
</ul></li>
<li>学校生活中遇到的困难？
<ul>
<li>有一些idea没有合适的人可以交流讨论</li>
</ul></li>
<li>反问？
<ul>
<li>请看下面</li>
</ul></li>
</ul>
<h4 id="反问hr">反问HR</h4>
<ul>
<li>公司的公司氛围、团队建设是怎样子的？</li>
<li>这个岗位出差、加班多吗？</li>
<li>新人有培训吗？</li>
<li>公司的晋升机制是什么样子的呢？</li>
<li>公司有餐补、房补、交通补助之类的吗？</li>
<li>当面试官问你的薪资要求时，你可以先问一下公司的薪酬体系</li>
<li>您认为考核这个岗位员工的最重要指标有哪些？</li>
<li>您觉得这个团队的氛围怎么样？</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/" rel="prev" title="leetcode 403. 青蛙过河">
                  <i class="fa fa-chevron-left"></i> leetcode 403. 青蛙过河
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/16/cpp%20Note/" rel="next" title="Advanced Cpp Note">
                  Advanced Cpp Note <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pishun Huang</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>-->

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","//mhchem.github.io/MathJax-mhchem/ mhchem":false,"js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"MITMOKSHA","repo":"MITMOKSHA.github.io","client_id":"1bc801cf709af0ddca6a","client_secret":"10ac0f160a26730afadf94d39d045789894a180a","admin_user":"MITMOKSHA","distraction_free_mode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"06ec8d82be865cdfc7fdb7f86aa614de"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
