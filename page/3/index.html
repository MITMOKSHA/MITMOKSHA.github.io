<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mitmoksha.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Opportunities are ready for it, the more to beat action.">
<meta property="og:type" content="website">
<meta property="og:title" content="Moksha&#39;s Blog">
<meta property="og:url" content="https://mitmoksha.github.io/page/3/index.html">
<meta property="og:site_name" content="Moksha&#39;s Blog">
<meta property="og:description" content="Opportunities are ready for it, the more to beat action.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Pishun Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mitmoksha.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Moksha's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Moksha's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Moksha's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pishun Huang</p>
  <div class="site-description" itemprop="description">Opportunities are ready for it, the more to beat action.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/" class="post-title-link" itemprop="url">leetcode 403. 青蛙过河</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-29 13:16:26" itemprop="dateCreated datePublished" datetime="2021-04-29T13:16:26+08:00">2021-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:15:10" itemprop="dateModified" datetime="2022-05-18T09:15:10+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>给定石子位置的列表stones（升序），青蛙可以跳上石子，但不能跳入水中。<br>如果青蛙一步跳跃了k个单位，那么它接下来跳跃的距离只能为k-1、k或k+1个单位。<br>青蛙只能向前方跳跃。<br><strong>输入</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stones = [0,1,3,5,6,8,12,17]</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">青蛙可以成功过河，按照如下方案跳跃：</span><br><span class="line">跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, </span><br><span class="line">然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure>
<h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><p>思路：本题为二维动态规划，使用动态规划的方法，令<code>dp[i][k]</code>为跳跃k个单位能否到达第i个石子，初始化<code>dp[0][0] = true;</code>，得出状态转移方程<code>dp[i][k] = dp[j][k-1] | dp[j][k] | dp[j][k+1];</code>，其中j为上一次所在石子的编号。</p>
<h3 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;  <span class="comment">// 优化：跳跃距离k必定满足k &lt;= i（可推），此时为青蛙无路可跳</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;  <span class="comment">// 反向枚举</span></span><br><span class="line">                <span class="type">int</span> k = stones[i] - stones[j];  <span class="comment">// 跳跃的距离k，j为上一次所在石子的编号</span></span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;  <span class="comment">// 在第j个石子上至多跳跃j+1的单位</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n^2^)，n为石子的个数，第i个石子后方只有i-1个石子，因此在任意位置，青蛙的上一次跳跃距离至多只有n种，状态总数为 n^2^ </li>
<li><strong>空间复杂度</strong>：O(n^2^)，需要二维动态数组的空间，其中n是石子的数量</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2021/04/28/tcp%20note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/tcp%20note/" class="post-title-link" itemprop="url">TCP/IP Note</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-28 23:00:13" itemprop="dateCreated datePublished" datetime="2021-04-28T23:00:13+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:16:32" itemprop="dateModified" datetime="2022-05-18T09:16:32+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Science-Notes/" itemprop="url" rel="index"><span itemprop="name">Computer Science Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="TCP-x2F-IP详解"><a href="#TCP-x2F-IP详解" class="headerlink" title="TCP&#x2F;IP详解"></a>TCP&#x2F;IP详解</h1><h2 id="一、TCP超时与重传"><a href="#一、TCP超时与重传" class="headerlink" title="一、TCP超时与重传"></a>一、TCP超时与重传</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul>
<li>计时器超时称为重传超时（RTO）</li>
<li>若TCP累计确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文段时，快速重传会推断出现丢包</li>
<li>由下层网络（IP）可能出现丢失重复或失序包，TCP重传其认为已经丢失的包</li>
</ul>
<h3 id="简单的超时与重传举例"><a href="#简单的超时与重传举例" class="headerlink" title="简单的超时与重传举例"></a>简单的超时与重传举例</h3><ul>
<li>二进制指数退避<ul>
<li>每次重传间隔时间加倍</li>
</ul>
</li>
<li>TCP拥有两个阈值来决定如何重传同一个报文段<ul>
<li>R1表示TCP在向IP层传递“消极建议”（如重新评估当前路径）前，愿意尝试重传的次数</li>
<li>R2（大于R1）指示TCP应放弃当前连接的时机</li>
</ul>
</li>
</ul>
<h3 id="设置重传超时"><a href="#设置重传超时" class="headerlink" title="设置重传超时"></a>设置重传超时</h3><ul>
<li>TCP超时和重传的基础根据给定连接的RTT（往返时间）设置RTO<ul>
<li>若TCP先于RTT开始重传，可能会在网络中引入不必要的重复数据</li>
<li>若延迟远大于RTT的间隔发送重传数据，整体网络利用率（及单个连接吞吐量）会随之下降</li>
</ul>
</li>
<li>RTO设置得当是保证TCP性能的关键</li>
<li>当分组失序（或丢失）时，RTT会被过高估算。较大的RTT估计值使得RTO也更大</li>
<li>时间戳选项（TSOPT）使得发送端即使在丢包、延时、失序的情况下也能测量RTT</li>
</ul>
<h3 id="基于计时器的重传"><a href="#基于计时器的重传" class="headerlink" title="基于计时器的重传"></a>基于计时器的重传</h3><ul>
<li>对于TCP来说，计时器需要有效地实现被设置、重新设置或取消的功能</li>
<li>RTO的设置通常大于RTT（两倍或更大）<ul>
<li>因此基于计时器的重传会导致网络利用率的下降</li>
</ul>
</li>
<li>快速重传不需要计时器超时来触发且比超时重传更高效</li>
</ul>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><ul>
<li>快速重传机制基于接收端的反馈信息来引发重传</li>
<li>快速重传是根据收到重复ACK来推断出现丢包并启动重传，而不必等待重传计时器超时</li>
<li>快读重传仅在达到重复阈值后才被触发，而不是一旦收到重复ACK就出发，减少了大量不必要的重传发生</li>
</ul>
<h3 id="带选择确认（SACK）的重传"><a href="#带选择确认（SACK）的重传" class="headerlink" title="带选择确认（SACK）的重传"></a>带选择确认（SACK）的重传</h3><ul>
<li>空缺<ul>
<li>ACK号与接收端缓存中的其他数据之间的间隔</li>
</ul>
</li>
<li>失序数据<ul>
<li>序列号高于空缺的数据</li>
</ul>
</li>
<li>在很多情况下，合理采用SACK信息能更快地实现空缺填补，且能减少不必要的重传</li>
<li>SACK接收端行为<ul>
<li>SACK选项的空间有限，应尽可能确保向TCP发送端提供最新信息，其余的SACK块包含的内容也按照接收的先后依次排序</li>
</ul>
</li>
<li>SACK发送端行为<ul>
<li>SACK发送端记录接收到的累计ACK信息，还需要记录接收到的SACK信息</li>
<li>当SACK发送端执行重传时，通常是由于其收到了SACK或重复SACK（D-SACK）</li>
</ul>
</li>
<li>为提高对ACK丢失的鲁棒性，第一个SACK块中需要包含之前的重复SACK信息</li>
</ul>
<h3 id="伪超时与重传"><a href="#伪超时与重传" class="headerlink" title="伪超时与重传"></a>伪超时与重传</h3><ul>
<li><p>伪重传</p>
<ul>
<li>即使没有出现数据丢失也可能引发的重传</li>
<li>主要原因是伪超时</li>
</ul>
</li>
<li><p>DSACK</p>
<ul>
<li>主要目的是判断何时重传是不必要的</li>
<li>因此发送端至少可以判断是否发生了包失序、ACK丢失、包重复</li>
</ul>
</li>
</ul>
<h3 id="包失序与重复"><a href="#包失序与重复" class="headerlink" title="包失序与重复"></a>包失序与重复</h3><ul>
<li>失序<ul>
<li>IP层不能保证包传输是有序进行的</li>
<li>如果失序发生在正向链路上，TCP可能无法正确识别失序和丢包</li>
</ul>
</li>
<li>重复<ul>
<li>采用DSACK避免</li>
</ul>
</li>
</ul>
<h3 id="重新组包"><a href="#重新组包" class="headerlink" title="重新组包"></a>重新组包</h3><ul>
<li>定义：发送一个更大的报文段来提高性能（不能超过接收端通告的MSS，也不能大于路径MTU）</li>
<li>当TCP超时重传，它并不需要完全重传相同的报文段</li>
<li>解决了重传二义性问题</li>
</ul>
<h2 id="二、TCP数据流与窗口管理"><a href="#二、TCP数据流与窗口管理" class="headerlink" title="二、TCP数据流与窗口管理"></a>二、TCP数据流与窗口管理</h2><h3 id="交互式通信"><a href="#交互式通信" class="headerlink" title="交互式通信"></a>交互式通信</h3><ul>
<li>TCP流量中通常90%或者更多的TCP报文段都包含大批量数据（如Web、文件共享、电子邮件、备份），其余部分则包含交互式数据（如远程登陆、网络游戏），批量数据通常较大，而交互式数据段则会比较小</li>
<li>对于一个ssh连接，客户端对其传输数据加密，意味着用户输入的信息在通过连接传送前已经进行了加密</li>
<li>每一个交互按键通常都会生成一个单独的数据包，每个按键是独立传输的（每次一个字符而非每次一行）</li>
<li>每个输入字符会生成4个TCP数据段：客户端的交互击键输入、服务器对击键的确认、服务器端生成的回显、客户端对该回显的确认<ul>
<li>通常第二段和第三段可以合并，可将对击键的确认与回显一并传送，这种方法称为（捎带延时确认）</li>
</ul>
</li>
</ul>
<h3 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h3><ul>
<li>TCP并不对每个到来的数据包都返回ACK<ul>
<li>利用TCP的累计ACK字段就能实现该功能</li>
</ul>
</li>
<li>捎带传输：<ul>
<li>累计确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传输的数据结合发送</li>
</ul>
</li>
<li>TCP不能任意时长地延迟ACK，否则对方会误认以为数据丢失而出现不必要的重传</li>
<li>RFC指出：TCP实现ACK延迟的时延应小于500ms，实践中时延最大取200ms</li>
</ul>
<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><ul>
<li>当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据），小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送</li>
<li>ACK返回越快，数据传输越快</li>
<li>传输包数目更少而长度更大，但同时传输时延也更长</li>
<li>Nagle算法结合ACK可能会导致某种程度的死锁（这种死锁不是永久的）</li>
<li>要求延时尽量小的应用，建议禁用Nagle算法<ul>
<li>TCP_NODELAY选项可以禁用Nagle算法</li>
</ul>
</li>
</ul>
<h3 id="流量控制与窗口管理"><a href="#流量控制与窗口管理" class="headerlink" title="流量控制与窗口管理"></a>流量控制与窗口管理</h3><ul>
<li>每一个TCP报文段（除了建立之初的包交换）都包含一个有效的序列号字段、一个ACK号或确认字段以及一个窗口大小字段（包含窗口通告信息）</li>
<li>窗口通告：表示发送该窗口信息的通信方为即将到来的新数据预留的存储空间</li>
<li>窗口大小：表明接收端可用缓存空间的大小</li>
<li>滑动窗口<ul>
<li>每个TCP活动连接的两端都维护一个发送窗口结构和接收窗口结构</li>
<li>TCP以字节（而非包）为单位维护其窗口结构</li>
<li>窗口左右边界的运动<ul>
<li>1.关闭<ul>
<li>即窗口左边界右移。当已发送数据得到ACK确认时，窗口会减小</li>
</ul>
</li>
<li>2.打开<ul>
<li>即窗口右边界右移。使得可发送数据量增大。当已确认数据得到处理，接收端可用缓存变大，窗口也随之变大</li>
</ul>
</li>
<li>3.收缩<ul>
<li>即窗口右边界左移</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>零窗口与TCP持续计时器<ul>
<li>零窗口：左右边界相等</li>
<li>当接收端的通告窗口值为0时，可以有效阻止发送端继续发送，直至窗口大小恢复为非零值</li>
<li>当接收端重新获得可用空间时，会给发送端传输一个”窗口更新“告知其可以继续发送数据<ul>
<li>该窗口更新通常不包含数据（纯ACK），不能保证其传输的可靠性，容易丢包，造成死锁的发生（发送方等待收到窗口更新告知其可继续发送，接收方等待接收数据）<ul>
<li>解决方案：发送端会采用一个持续计时器间歇性地查询接收端，看其窗口是否已增长</li>
</ul>
</li>
</ul>
</li>
<li>TCP持续计时器会触发”窗口探测“的传输，强制要求接收端返回ACK（其中包含了窗口大小字段）</li>
<li>窗口探测包含一个字节的数据，采用TCP可靠传输（丢失重传），因此可以避免由窗口更新丢失导致的死锁<ul>
<li>该一个字节的数据能否被接收，取决于接收端的可用缓存空间大小</li>
</ul>
</li>
<li>当TCP持续计时器超时，就会触发窗口探测的发送</li>
<li>窗口探测的响应条件：<ul>
<li>至少为一个MSS</li>
<li>超过总接收缓存的四分之一</li>
</ul>
</li>
<li>可以采用指数时间退避来计算持续计时器的超时</li>
</ul>
</li>
<li>糊涂窗口综合征（SWS）<ul>
<li>基于窗口的流量控制机制，尤其是不使用大小固定的报文段情况（如TCP），可能会出现SWS</li>
<li>当出现该问题时，交换数据段不是全长的而是一些较小的数据段，由于每个报文段中有用数据相对头部信息的比例较小，因此耗费的资源也更多，相应的传输效率也更低</li>
<li>避免SWS问题<ul>
<li>1.对于接收端来说，不应通告小的窗口值</li>
<li>2.对于发送端来说，不应发送小的报文段</li>
<li>为了避免SWS问题，至少满足以下条件之一时才能传输报文段（发送窗口更新）<ul>
<li>（a）全长（发送MSS字节）的报文段可以发送</li>
<li>（b）数据段长度 &gt;&#x3D; 接收端通告过的最大窗口的一半的，可以发送</li>
<li>（c）满足以下任一条件的都可以发送：<ul>
<li>（i）某一ACK不是目前期盼的（即没有未经确认的在传数据）</li>
<li>（ii）该连接禁用Nagle算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>TCP需要避免窗口收缩</li>
<li>优先级：避免窗口收缩 &gt; 避免SWS</li>
</ul>
</li>
<li>大容量缓存与自动调优<ul>
<li>使用较小接收缓存的TCP应用的吞吐性能更差</li>
<li>自动调优<ul>
<li>高效地自动分配缓存大小</li>
<li>窗口值随着接收数据的增多而增大</li>
</ul>
</li>
</ul>
</li>
<li>紧急机制<ul>
<li>紧急指针字段被设置后，发送端生成的每个TCP头部都包含该字段</li>
<li>所有序列号大于紧急指针的数据都经接收端确认</li>
</ul>
</li>
</ul>
<h2 id="三、TCP拥塞控制"><a href="#三、TCP拥塞控制" class="headerlink" title="三、TCP拥塞控制"></a>三、TCP拥塞控制</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><ul>
<li>TCP拥塞控制的难点在于怎样准确地判断何时需要减缓且如何减缓TCP传输，以及何时恢复其原有速度</li>
<li>当网络中大量的发送方和接收方被要求承担超负荷的通信任务时，可以考虑采取(降低发送速率)或者(最终丢弃部分数据)的方法</li>
<li>拥塞<ul>
<li>路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象</li>
</ul>
</li>
</ul>
<h3 id="TCP拥塞检测"><a href="#TCP拥塞检测" class="headerlink" title="TCP拥塞检测"></a>TCP拥塞检测</h3><ul>
<li>针对丢包情况，TCP采取的首要机制是重传<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
</li>
<li>丢包被用作判断拥塞发生与否的值标</li>
<li>在有线网络中，出现在路由器或交换机中的拥塞是造成丢包的主要原因</li>
<li>在无线网络中，传输和接收错误是导致丢包的重要因素</li>
</ul>
<h3 id="减缓TCP发送"><a href="#减缓TCP发送" class="headerlink" title="减缓TCP发送"></a>减缓TCP发送</h3><ul>
<li>TCP头部设置的通知窗口大小字段，是TCP发送方调节发送速率的依据</li>
<li>TCP发送端发送速率 &#x3D; min{接收速率，传输速率}</li>
<li>拥塞窗口（cwnd）<ul>
<li>反映网络传输能力的变量</li>
</ul>
</li>
<li>发送端实际可用窗口W &#x3D; min{cwnd，通知窗口(awnd)}</li>
<li>在外数据值<ul>
<li>已经发出但还未经确认的数据量大小</li>
<li>当TCP不使用选择确认机制时，W的限制作用体现为发送方发送的报文段序列号不能大于ACK号的最大值与W之和</li>
<li>当TCP使用选择确认机制时，W用来限制在外数据值</li>
</ul>
</li>
<li>带宽延迟积（BDP）也称作最佳窗口大小<ul>
<li>若在传输数据值远高于BDP时，会引入不必要的延时</li>
</ul>
</li>
</ul>
<h3 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h3><ul>
<li>TCP通过与接收端交换一个数据包来获得awnd的值</li>
<li>获得cwnd最佳值的唯一方法是以越来越快的速率不断发送数据，直到出现数据包丢失（或网络拥塞）为止</li>
<li>拥塞控制操作是由ACK的接收来驱动或“控制”的</li>
<li>接收到ACK回复表明发送的数据包已被成功接收，因此可以继续发送操作</li>
<li>自同步<ul>
<li>由一个ACK到达（称作ACK时钟）触发一个新数据包传输的关系</li>
</ul>
</li>
<li>在稳定传输状态下，整个系统可“自同步”控制</li>
</ul>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ul>
<li>当一个新的TCP连接建立或检测到由重传超时（RTO）导致的丢包时，需执行慢启动</li>
<li>TCP发送端长时间处于空闲状态也可能调用慢启动算法<ul>
<li>在这种情况下cwnd初始值将被设置为重启窗口（RW），RW &#x3D; min（IW，cwnd）</li>
</ul>
</li>
<li>慢启动的目的<ul>
<li>使TCP在用拥塞避免探寻更多可用宽带之前得到cwnd值，以帮助TCP建立ACK时钟</li>
</ul>
</li>
<li>慢启动算法防止短时间内大量数据注入导致拥塞</li>
<li>TCP以发送一定数目的数据段开始慢启动（在SYN交换之后），称为初始窗口（IW）</li>
<li>SMSS &#x3D; min（接收方MSS，MTU）</li>
<li>慢启动算法会以min（N，SMSS）来增加cwnd值，N是指在未经确认的传输数据中能通过这一”新接收的ACK号大于之前收到的ACK号“确认的字节数</li>
<li>快速ACK模式<ul>
<li>TCP操作只在慢启动阶段完成后才返回ACK</li>
</ul>
</li>
</ul>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul>
<li>在慢启动阶段，cwnd会快速增长，帮助确立一个慢启动阈值，一旦达到阈值，就意味着可能有更多可用的传输资源。如果立即全部占用这些资源，将会使共享路由器队列的其他连接出现严重的丢包和重传情况，从而导致整个网络性能不稳定</li>
<li>一旦确立慢启动阈值，TCP会进入拥塞避免阶段</li>
<li>拥塞避免阶段窗口随时间线性增长，而慢启动阶段呈指数增长<ul>
<li>cwnd1 &#x3D; cwnd0+（1&#x2F;k）*SMSS</li>
</ul>
</li>
</ul>
<h3 id="慢启动和拥塞避免的选择"><a href="#慢启动和拥塞避免的选择" class="headerlink" title="慢启动和拥塞避免的选择"></a>慢启动和拥塞避免的选择</h3><ul>
<li>某个TCP连接总是选择运行慢启动和拥塞避免中的一个，不会出现两者同时运行的情况</li>
<li>当cwnd&lt;ssthresh，使用慢启动算法</li>
<li>当cwnd&gt;ssthresh，使用拥塞避免</li>
<li>当cwnd&#x3D;ssthresh，任何一种算法都可以使用</li>
<li>慢启动阈值ssthresh不是固定的，是随时间改变的</li>
<li>慢启动阈值的主要目的是，在没有丢包发生的情况下，记住上一次”最好的“操作窗口估计值</li>
<li>ssthresh &#x3D; max（在外数据值&#x2F;2，2*SMSS）</li>
<li>如果出现重传情况，慢启动阈值减小至当前窗口大小的一般（但不小于2*SMSS）</li>
</ul>
<h3 id="标准TCP"><a href="#标准TCP" class="headerlink" title="标准TCP"></a>标准TCP</h3><ul>
<li>当接收到一个好的ACK（表明新的数据传输成功）cwnd会相应更新<ul>
<li>cwnd +&#x3D; SMSS 慢启动</li>
<li>cwnd +&#x3D; SMSS*SMSS&#x2F;cwnd 拥塞避免</li>
</ul>
</li>
<li>当收到三次重复ACK（或其他表明需要快速重传的信号）时，会执行以下行为<ul>
<li>1.ssthresh更新为大于等式ssthresh &#x3D; min（在外数据值&#x2F;2，2*SMSS）的值</li>
<li>2.启用快速重传算法，将cwnd设为（ssthresh+3*SMSS）</li>
<li>3.每接收一个重复ACK，cwnd值暂时增加1 SMSS</li>
<li>4.当接收到一个好的ACK，将cwnd重设为ssthresh</li>
</ul>
</li>
</ul>
<h3 id="转发确认（FACK）和速率减半"><a href="#转发确认（FACK）和速率减半" class="headerlink" title="转发确认（FACK）和速率减半"></a>转发确认（FACK）和速率减半</h3><ul>
<li>为避免出现等待空闲而又不违背将拥塞窗口减半的做法，提出了转发确认（FACK）策略</li>
<li>带界定参数的速率减半（RHBP）<ul>
<li>基本操作：在一个RTT时间内，每接收两个重复ACK，TCP发送方可发送一个新的数据包</li>
<li>RHBP中区分了调整间隔（cwnd的修正阶段）和恢复间隔（数据重传阶段）</li>
</ul>
</li>
<li>速率减半是调节发送操作或避免集中发送的方法</li>
</ul>
<h3 id="限制传输"><a href="#限制传输" class="headerlink" title="限制传输"></a>限制传输</h3><ul>
<li>TCP发送方每接收两个连续的重复ACK，就能发送一个新数据包</li>
<li>TCP因此可以避免长时间等待RTO而导致吞吐性能下降</li>
<li>速率减半也是限制传输的一种形式<h3 id="拥塞窗口校验（CWV）"><a href="#拥塞窗口校验（CWV）" class="headerlink" title="拥塞窗口校验（CWV）"></a>拥塞窗口校验（CWV）</h3></li>
<li>在发送长时间暂停的情况下，由ssthresh维护cwnd保存的”记忆”，之后cwnd值会衰减。</li>
<li>需要区分空闲发送端和应用受限发送端</li>
<li>CWV算法原理：当需要发送新数据时，首先看距离上次发送操作是否超过一个RTO，如果超过则<ul>
<li>更新ssthresh值，设为max（ssthresh，（3&#x2F;4）*cwnd）</li>
<li>每经一个空闲RTT时间，cwnd值就减半，但不小于1 SMSS</li>
<li>对应用受限阶段<ul>
<li>已使用的窗口大小为W_used</li>
<li>更新ssthresh的值，设为max（ssthresh，（3&#x2F;4）*cwnd）</li>
<li>cwnd设置为cwnd和W_used的平均值</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2021/04/28/c#%20Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/c#%20Note/" class="post-title-link" itemprop="url">C# Note</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-28 21:20:57" itemprop="dateCreated datePublished" datetime="2021-04-28T21:20:57+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:15:15" itemprop="dateModified" datetime="2022-05-18T09:15:15+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PL/" itemprop="url" rel="index"><span itemprop="name">PL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul>
<li>表达式主体方法<ul>
<li>&#x3D;&gt;操作符引用构成方法主体的表达式，而且没有return语句。表达式的值自动作为返回值；如果表达式不返回值，则方法自动为void方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResult</span>(<span class="params"><span class="built_in">int</span> answer</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>差值表达式<ul>
<li>$符号表明这是个差值字符串，{和}之间的任何表达式都需求值并置换，字符串差值比+操作符高效得多  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>只有<code>float</code>和<code>double</code>除以0得到<code>Infinity</code>（不会出错）</li>
<li><code>int</code>的最大最小值<code>int.MaxValue</code>和<code>int.MinValue</code></li>
<li>隐式类型变量<code>var</code>,作用类似于C++的<code>auto</code></li>
</ul>
<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><ul>
<li>与C++不一致<br>  -<code>if</code>语句中表达式必须是布尔值, 如：<code>if (1)</code> &#x2F;&#x2F; 错误</li>
<li><code>switch</code>语句的控制表达式不能用<code>float</code>和<code>double</code>类型</li>
<li><code>case</code>标签必须是常量表达式，且必须唯一</li>
<li>C#语句的直通规则<ul>
<li>直通，标签之间不能有额外语句（即不加<code>break</code>，不允许拥有语句）</li>
<li>每个<code>case</code>都加上<code>break</code></li>
</ul>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>C#所有方法都必须在类的内部声明</li>
<li>默认参数中如果参数匹配则不会出现歧义</li>
<li>默认参数（可选参数）必须放在后面</li>
<li>具名参数<ul>
<li><code>optMethod(first: 99, third: &quot;Word&quot;);</code>  &#x2F;&#x2F; 传递具名参数（参数名:传递的值），实参可以按任意顺序传递，second参数使用<code>默认值</code></li>
</ul>
</li>
</ul>
<h2 id="结构（结构体）"><a href="#结构（结构体）" class="headerlink" title="结构（结构体）"></a>结构（结构体）</h2><ul>
<li>与C++不一致，结构主体后不加<code>;</code></li>
<li>值类型<ul>
<li>对于简单的、比较小的数据值，复制值的效率等同于或基本等同于复制地址的效率，但较复杂的数据就考虑使用类，这样就可选择只复制数据的地址，从而提高代码的执行效率</li>
</ul>
</li>
<li>不能为结构声明默认构造器（无参构造器），否则无法编译，因为编译器始终会自动生成默认构造器（不同于类）</li>
<li>类的实例字段可在声明时初始化，但结构不允许  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Time</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">private</span> <span class="built_in">int</span> hours = <span class="number">0</span>;  <span class="comment">// 编译时错误</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译器不会自动初始化结构中的字段（与类不一致）</li>
<li>复制结构变量的前提时<code>=</code>操作符右侧的结构变量已完全初始化，否则编译错误</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li>与C++不一致，枚举主体后不加<code>;</code></li>
<li>值类型</li>
<li>声明枚举时字面值默认是int类型，可以选择枚举的基础类型<ul>
<li><code>enum Season : short &#123; Spring, Summer &#125;</code></li>
</ul>
</li>
<li>为枚举的字面值显式指定常量整数值<ul>
<li><code>enum Season &#123; Spring = 1, Summer &#125;</code></li>
</ul>
</li>
<li>编译器自动为它指定比前一个枚举字面值大1的值</li>
<li>多个枚举字面值可以具有相同的基础值<ul>
<li><code>enum Season &#123; Spring, Summer, Fall, Autumn = Fall &#125;</code></li>
</ul>
</li>
<li>每个枚举定义的字面值名称都只有这个枚举类型的作用域，因此要加枚举类型限定，否则编译错误，如：Season.Fall</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li><p>与c++不一致，类主体、结构主体后不加分号</p>
</li>
<li><p>每个字段和方法声明都要重复<code>public</code>或<code>private</code>关键字</p>
</li>
<li><p>省略控制可访问性，默认为<code>private</code></p>
</li>
<li><p>类被拆分到多个文件中之后，要在每个文件中使用<code>partial</code>（分部）关键字定义类的不同部分</p>
</li>
<li><p>如果把方法或字段声明为<code>static</code>，就可使用类名调用方法或访问字段，而不用先创建对象</p>
</li>
<li><p>静态方法只能访问标记为<code>static</code>的其他方法和字段</p>
</li>
<li><p>类外访问类中的<code>static</code>字段要以，类名作为前缀，<code>class.function</code></p>
</li>
<li><p>静态方法也称为类方法</p>
</li>
<li><p>静态字段称为静态字段或静态变量</p>
</li>
<li><p>只有数值类型、字符串类型和枚举类型的字段才能声明为const字段</p>
</li>
<li><p>静态类</p>
<ul>
<li>只能包含静态成员</li>
<li><code>public static class Math</code></li>
</ul>
</li>
<li><p>using语句允许将类引入作用域，以便在访问静态成员时省略类名</p>
<ul>
<li><code>using static System.Math;</code></li>
</ul>
</li>
<li><p>匿名类</p>
<ul>
<li>匿名类就是没有名字的类</li>
<li>不知道类的名称可以使用隐式类型变量来创建正确类型的对象  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAnonymousObject = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">47</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>值类型</p>
<ul>
<li>基元类型</li>
</ul>
</li>
<li><p>引用类型</p>
<ul>
<li><code>string</code>在运行时动态分配内存</li>
<li>声明类变量时，编译器分配一小块内存，其中刚好可以容纳一个地址。以后类实际占用内存块的地址会填充到这里。该地址成为对内存块的引用</li>
<li>实际占用的内存<ul>
<li>使用<code>new</code>关键字创建对象时分配的内存</li>
</ul>
</li>
</ul>
</li>
<li><p>引用类型的变量包含的是引用，引用本身存储在栈上，但该引用指向堆上的对象</p>
</li>
<li><p>类可以提供clone方法来返回自己的新实例，并填充相同数据</p>
  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Circle <span class="title">Clone</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">	    Circle clone = <span class="keyword">new</span> Circle();</span><br><span class="line">	    clone.radius = <span class="keyword">this</span>.radius;</span><br><span class="line">	    <span class="comment">// 返回包含克隆数据的新Circle对象</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果包含任何引用类型的字段，这种引用类型也需要提供Clone方法，否则只是“浅拷贝”，如果提供了Clone方法，能够复制引用的对象，就成为“深拷贝”</p>
  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle(<span class="number">42</span>);</span><br><span class="line">Circle copy = <span class="keyword">new</span> Circle(<span class="number">99</span>);</span><br><span class="line">copy = c;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这时候copy原来的引用被回收了（垃圾回收机制）</p>
</li>
</ul>
</li>
<li><p>空条件操作符（问号加在变量名称之后）</p>
  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(c?.Area());</span><br></pre></td></tr></table></figure>
<ul>
<li>空条件操作符告诉”运行时“在操作符所应用的变量为null的前提下忽略当前语句</li>
</ul>
</li>
<li><p>可空类型</p>
<ul>
<li><code>null</code>本身就是引用，不能把它赋值给值类型</li>
<li>可将变量声明为可空值类型<ul>
<li><code>int? i = null;</code></li>
</ul>
</li>
<li>可将恰当值的表达式直接赋给可空变量<ul>
<li><code>i = j;</code></li>
</ul>
</li>
<li>不可将可空的值赋给普通的值类型变量<ul>
<li><code>j = i;</code></li>
</ul>
</li>
<li>可空类型的两个属性<ul>
<li><code>HasValue</code><ul>
<li>判断可空类型是包含一个值，还是包含null</li>
</ul>
</li>
<li><code>Value</code><ul>
<li>只读的属性</li>
<li>读取变量的值，但不能修改</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>引用传参</p>
<ul>
<li><code>ref</code>参数<ul>
<li>要求实参和形参前都加上<code>ref</code>关键字<ul>
<li><code>DoWork(ref i)</code>;</li>
</ul>
</li>
<li>要求在传参之前必须初始化</li>
</ul>
</li>
<li><code>out</code>参数<ul>
<li>要求实参和形参前都加上<code>out</code>关键字</li>
<li>要求在方法中必须初始化，传参前不要求</li>
</ul>
</li>
</ul>
</li>
<li><p><code>object</code>类型</p>
<ul>
<li><code>object</code>类型的变量能引用任何引用类型的任何对象</li>
</ul>
</li>
<li><p><code>装箱</code></p>
<ul>
<li>将值类型赋给<code>object</code>类型的变量<ul>
<li><code>object o = 42;</code></li>
</ul>
</li>
<li>数据项从栈自动复制到堆的行为</li>
<li>与泛型异曲同工</li>
</ul>
</li>
<li><p><code>拆箱</code></p>
<ul>
<li>将引用了已装箱的值的object引用强制转换成值类型<ul>
<li><code>int a = (int)o;</code></li>
</ul>
</li>
<li>必须强制转换</li>
</ul>
</li>
<li><p>装箱和拆箱会产生较大的开销</p>
<ul>
<li>它们设计不少检查工作，且需要分配额外的堆内存</li>
</ul>
</li>
<li><p>数据的安全转型</p>
<ul>
<li>左操作数为对象，右操作数为类型<ul>
<li>is操作符<ul>
<li>if (o is WrappedInt)</li>
<li>如果is表达式正确，结果为true，反之为false</li>
</ul>
</li>
<li>as操作符<ul>
<li>WrappedInt temp &#x3D; o as WrappedInt;</li>
<li>若转换成功，就返回转换成功的结果，失败则为null</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在c#中使用c指针必须将代码标记为<code>unsafe</code></p>
<ul>
<li><code>unsafe</code>关键字可标记代码块或整个方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">swap</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>命名规范</p>
</li>
<li><p>公共标识符以大写字母开头</p>
</li>
<li><p>非公共标识符（包括局部变量）以小写字母开头</p>
</li>
<li><p>类名以大写字母开头</p>
</li>
<li><p>均采用驼峰命名法</p>
</li>
<li><p><code>TODO:</code>注释通常用于标注以后将进行加工的代码</p>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><code>checked</code>语句是<code>checked</code>关键字开头的代码块<ul>
<li>只有直接在checked块中的整数运算才会检查</li>
<li>溢出则抛出<code>OverflowException</code></li>
<li><code>checked</code>和<code>unchecked</code>关键字只适合整型运算</li>
<li>浮点运算永不抛出异常</li>
</ul>
</li>
<li><code>catch</code>省略名称默认捕获<code>Exception</code><ul>
<li>异常发生后将运行由”运行时“发现的第一个匹配的异常处理程序<code>catch</code>，其他处理程序会被忽略</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/" class="post-title-link" itemprop="url">剑指 Offer 34. 二叉树中和为某一值的路径</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-28 17:59:13" itemprop="dateCreated datePublished" datetime="2021-04-28T17:59:13+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:18:15" itemprop="dateModified" datetime="2022-05-18T09:18:15+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>打印出二叉树中节点值的和为输入整数的所有路径（从根节点一直到叶子节点的路径）<br><strong>输入</strong>：<br>给定如下二叉树，以及目标和 target &#x3D; 22</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><p>由根节点出发，首先想到先序遍历的思路</p>
<h3 id="2-1-回溯"><a href="#2-1-回溯" class="headerlink" title="2.1 回溯"></a>2.1 回溯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">      vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">      <span class="type">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">FindPath</span>(root, target, path, currentSum, ans);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; path, <span class="type">int</span> currentSum, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先序遍历</span></span><br><span class="line">      currentSum += root-&gt;val;  <span class="comment">// 更新当前路径</span></span><br><span class="line">      path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">      <span class="comment">// 如果是叶子节点，并且路径上的节点的和等于输入的值，则打印这条路径</span></span><br><span class="line">      <span class="type">bool</span> isLeaf = root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (currentSum == target &amp;&amp; isLeaf) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若不是叶子节点，则遍历它的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在返回父节点之前，在路径上删除当前节点</span></span><br><span class="line">      path.<span class="built_in">pop_back</span>();  <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，N为二叉树的节点数，需要遍历所有节点</li>
<li><strong>空间复杂度</strong>：O(N)，最差情况下即树退化成链表，path存储所有树节点，使用O(N)额外空间</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/" class="post-title-link" itemprop="url">leetcode 684. 冗余连接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-28 17:57:58" itemprop="dateCreated datePublished" datetime="2021-04-28T17:57:58+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:15:55" itemprop="dateModified" datetime="2022-05-18T09:15:55+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>找出无向图中的冗余连接，即将无向图还原成二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>

<h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><h3 id="2-1-并查集"><a href="#2-1-并查集" class="headerlink" title="2.1 并查集"></a>2.1 并查集</h3><p>思路：通过并查集寻找附加的边，初始时每个节点都属于不同的连通分量，遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量</p>
<ul>
<li>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</li>
<li>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[index]]); </span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      parent[<span class="built_in">Find</span>(parent, x)] = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(klogk)，其中k是图中的节点个数</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="2-2-使用-x3D-x3D-按秩合并-路径压缩-x3D-x3D-的并查集"><a href="#2-2-使用-x3D-x3D-按秩合并-路径压缩-x3D-x3D-的并查集" class="headerlink" title="2.2 使用&#x3D;&#x3D;按秩合并+路径压缩&#x3D;&#x3D;的并查集"></a>2.2 使用&#x3D;&#x3D;按秩合并+路径压缩&#x3D;&#x3D;的并查集</h3><p>优化了空间复杂度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[parent[index]]);  <span class="comment">// 路径压缩，使树的层数更少</span></span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      <span class="type">int</span> i = <span class="built_in">Find</span>(parent, x), j = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">      <span class="comment">// 按秩合并</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">// 如果i的秩大于j的秩</span></span><br><span class="line">        parent[j] = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[i] = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(klogk)</li>
<li>空间复杂度：O(1)</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2021/04/28/mysql%20note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/mysql%20note/" class="post-title-link" itemprop="url">Mysql Note</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-28 17:57:17" itemprop="dateCreated datePublished" datetime="2021-04-28T17:57:17+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:16:07" itemprop="dateModified" datetime="2022-05-18T09:16:07+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PL/" itemprop="url" rel="index"><span itemprop="name">PL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul>
<li>表名是唯一的</li>
<li>表中的数据是按行存储的</li>
<li>行（别名 记录）</li>
<li>主键：一列，其值能够区分表中每个行<ul>
<li>每个行都必须有一个主键值（不允许为NULL）</li>
<li>任意两行都不具有相同的主键值</li>
<li>不更新主键列中的值</li>
<li>不在主键列中使用可能会更改的值</li>
</ul>
</li>
<li>命令用分号；结束</li>
<li>连接到mysql需要以下信息<ul>
<li>主机名：本地服务器为localhost</li>
<li>端口：默认为3036</li>
<li>一个合法的用户名</li>
<li>用户口令（如果需要的话）</li>
</ul>
</li>
<li><code>use&lt;数据库名字&gt;</code>来选择数据库</li>
<li><code>show databases</code>返回可用数据库的一个列表</li>
<li><code>show tables</code>返回该数据库内的可用表的一个列表</li>
<li><code>show columns from &lt;表名&gt;</code> &#x3D; <code>describe &lt;表名&gt;</code>来显示表中的所有列</li>
<li>自动增量：Mysql可以自动地为每个行分配下一个可用的编号，需要create语句</li>
<li><code>show status</code>显示广泛的服务器状态信息</li>
<li><code>show create databases/table</code>分别用来显示创建特定数据库或表的语句</li>
<li><code>show grants</code>显示授予用户的安全权限</li>
<li><code>show errors</code>和<code>show warnings</code>显示服务器错误或警告信息</li>
</ul>
<h2 id="二、SELECT语句"><a href="#二、SELECT语句" class="headerlink" title="二、SELECT语句"></a>二、SELECT语句</h2><ul>
<li><code>SELECT &lt;列名&gt; FROM &lt;表名&gt;</code>在表中检索单个列<blockquote>
<p>SELECT检索多个列，列名用逗号分隔<br>检索所有列，用<code>*</code>通配符</p>
</blockquote>
</li>
<li>sql语句不区分大小写</li>
<li>SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写</li>
<li>处理SQL语句空格会被忽略</li>
<li><code>SELECT DISTINCT ... FROM</code>返回不重复的行（distinct要放在列名前面）</li>
<li>使用完全限定的表名<code>SELECT db.host FROM mysql.db</code></li>
<li><code>FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT</code>是<code>SELECT</code>的子句，其出现次序必须为上述顺序，次序不对将产生错误信息</li>
<li><code>ORDER BY</code>子句取一个或多个列的名字对输出进行排序<blockquote>
<p>默认为asc升序，在列名后加<code>DESC</code>关键字按降序排列，desc关键字只应用到直接位于其前面的列名</p>
</blockquote>
</li>
<li><code>GROUP BY</code>子句，分组允许把数据分为多个逻辑组</li>
<li><code>HAVING</code>和<code>WHERE</code>的区别：<code>HAVING</code>过滤分组，<code>WHERE</code>过滤行</li>
<li><code>WHERE</code>是<code>SELECT</code>的子句（在from子句之后给出）用来指定搜索条件</li>
<li><strong>WHERE子句操作符</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在指定的两个值之间</td>
</tr>
</tbody></table>
<ul>
<li>空值检查(<code>is NULL</code>子句)<code>where...is NULL;</code></li>
<li><code>WHERE</code>子句给出了<code>AND, OR, IN, NOT</code>逻辑操作符来进行逻辑操作</li>
</ul>
<h2 id="三、匹配"><a href="#三、匹配" class="headerlink" title="三、匹配"></a>三、匹配</h2><ul>
<li>通配符本身实际是SQL的<code>WHERE</code>子句中有特殊含义的字符，在搜索子句中使用通配符，必须使用<code>LIKE</code>操作符，<code>LIKE</code>只是Mysql后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较</li>
<li>百分号<code>%</code>通配符匹配任意个数的任意字符，下划线<code>_</code>通配符匹配任意单个字符</li>
<li>使用通配符的技巧<ul>
<li>不要过度使用通配符</li>
<li>把通配符置于搜索模式的开始处搜索起来是最慢的</li>
</ul>
</li>
<li><code>WHERE</code>的子句中<code>REGEXP</code>子句使用正则表达式，在<code>REGEXP</code>关键字后加上<code>BINARY</code>来区分匹配表达式的大小写<br>例：	  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Db, User FROM db </span><br><span class="line">WHERE Db REGEXP BINARY &#x27;.ys&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>匹配正则表达式内具有特殊意义的所有字符都必须以\\的方式转义</li>
</ul>
<p><strong>常用字符类</strong></p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[:alnum:]</td>
<td align="center">任意字母和数字（同[a-zA-Z0-9])</td>
</tr>
<tr>
<td align="center">[:alpha:]</td>
<td align="center">任意字符（同[a-zA-Z]）</td>
</tr>
<tr>
<td align="center">[:blank:]</td>
<td align="center">空格和制表</td>
</tr>
<tr>
<td align="center">[:cntrl:]</td>
<td align="center">ASCII控制字符</td>
</tr>
<tr>
<td align="center">[:digit:]</td>
<td align="center">任意数字</td>
</tr>
<tr>
<td align="center">[:graph:]</td>
<td align="center">与[:print:]相同，但不包括空格</td>
</tr>
<tr>
<td align="center">[:lower:]</td>
<td align="center">任意小写字母</td>
</tr>
<tr>
<td align="center">[:print:]</td>
<td align="center">任意可打印字符</td>
</tr>
<tr>
<td align="center">[:space:]</td>
<td align="center">任意空白字符</td>
</tr>
<tr>
<td align="center">[:upper:]</td>
<td align="center">任意大写字母</td>
</tr>
<tr>
<td align="center">[:xdigit:]</td>
<td align="center">任意十六进制数</td>
</tr>
</tbody></table>
<p><strong>重复元字符</strong></p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>0个或多个匹配</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个匹配（等于{1,}）</td>
</tr>
<tr>
<td>?</td>
<td>0个或1个匹配（等于{0,1}）</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配数目的范围</td>
</tr>
</tbody></table>
<p><strong>定位元字符</strong></p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="center">文本的开始</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">文本的结束</td>
</tr>
<tr>
<td align="center">[[:&lt;:]]</td>
<td align="center">词的开始</td>
</tr>
<tr>
<td align="center">[[:&gt;:]]</td>
<td align="center">词的结束</td>
</tr>
</tbody></table>
<ul>
<li>正则表达式中<code>.</code>表示匹配任意一个字符</li>
<li><code>LIKE</code>与<code>REGEXP</code>的区别，<code>LIKE</code>匹配整个串，<code>REGEXP</code>匹配子串</li>
<li>简单的正则表达式测试，例：<code>SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;</code></li>
<li><code>SELECT</code>语句中，<code>concat()</code>函数用来拼接字段（与列的意思相同），别名用<code>AS</code>关键字赋予，<code>RTrim()</code>函数去掉右边的所有空格<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat(Db, &#x27;(&#x27;, User, &#x27;)&#x27;) AS link</span><br><span class="line">FROM db;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四、相关函数"><a href="#四、相关函数" class="headerlink" title="四、相关函数"></a>四、相关函数</h2><ul>
<li><code>Soundex()</code>函数匹配所有发音类似与Y.Lie的联系名<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE Soundex(cust_contact) = Soundex(&#x27;Y. Lie&#x27;);</span><br></pre></td></tr></table></figure>
<strong>常用数值处理函数</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Abs()</td>
<td align="center">返回一个数的绝对值</td>
</tr>
<tr>
<td align="center">Cos()</td>
<td align="center">返回一个角度的余弦</td>
</tr>
<tr>
<td align="center">Exp()</td>
<td align="center">返回一个数的指数值</td>
</tr>
<tr>
<td align="center">Mod()</td>
<td align="center">返回余数</td>
</tr>
<tr>
<td align="center">Pi()</td>
<td align="center">返回圆周率</td>
</tr>
<tr>
<td align="center">Rand()</td>
<td align="center">返回一个随机数</td>
</tr>
<tr>
<td align="center">Sin()</td>
<td align="center">返回一个角度的正弦</td>
</tr>
<tr>
<td align="center">Sqrt()</td>
<td align="center">返回一个角度的平方根</td>
</tr>
<tr>
<td align="center">Tan()</td>
<td align="center">返回一个角度的正切</td>
</tr>
</tbody></table>
<p><strong>常用时间和日期处理函数</strong></p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AddDate()</td>
<td align="center">增加一个日期（天、周等)</td>
</tr>
<tr>
<td align="center">AddTime()</td>
<td align="center">增加一个时间（时、分等）</td>
</tr>
<tr>
<td align="center">CurDate()</td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center">Date()</td>
<td align="center">返回日期时间的日期部分</td>
</tr>
<tr>
<td align="center">DateDiff()</td>
<td align="center">计算两个日期之差</td>
</tr>
<tr>
<td align="center">Date_add()</td>
<td align="center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td align="center">Date_Format()</td>
<td align="center">返回格式化的日期或时间率</td>
</tr>
<tr>
<td align="center">Day()</td>
<td align="center">返回一个日期的天数部分</td>
</tr>
<tr>
<td align="center">DayOfWeek()</td>
<td align="center">对于一个日期，返回对应的星期</td>
</tr>
<tr>
<td align="center">Hour()</td>
<td align="center">返回一个日期的小时部分</td>
</tr>
<tr>
<td align="center">Minute()</td>
<td align="center">返回一个日期的分钟部分</td>
</tr>
<tr>
<td align="center">Month()</td>
<td align="center">返回一个日期的月份</td>
</tr>
<tr>
<td align="center">Now()</td>
<td align="center">返回当前日期和时间</td>
</tr>
<tr>
<td align="center">Second()</td>
<td align="center">返回一个时间的秒部分</td>
</tr>
<tr>
<td align="center">Time()</td>
<td align="center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="center">Year()</td>
<td align="center">返回一个日期的年份部分</td>
</tr>
</tbody></table>
<ul>
<li>子查询，嵌套<code>SELECT</code>语句<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">					FROM orderitems</span><br><span class="line">					WHERE prod_id = &#x27;TNT2&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="五、联结表"><a href="#五、联结表" class="headerlink" title="五、联结表"></a>五、联结表</h2><ul>
<li><code>WHERE</code>子句在联结表中起配对的作用（用完全限定列名）</li>
<li>没有联结条件的表关系返回的结果为笛卡尔积（检索出的行的数目将是第一个表中的行数乘以第二个表中的行数）</li>
<li>应保证所有联结都有<code>WHERE</code>子句</li>
<li>使用在<code>WHERE</code>子句中使用<code>AND</code>可以联结多个表</li>
<li>等值连接也称为内部联结</li>
<li>尽量使用自联结而不用子查询</li>
<li><strong>联结的方式</strong><br><img src="https://img-blog.csdnimg.cn/20210428125629111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2ODAyNzEz,size_16,color_FFFFFF,t_70#pic_center" alt="联结"></li>
<li>外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系</li>
<li>外键的意义：在于解耦合，定义外键的方法<code>FOREIGN KEY (主键）references &lt;表名&gt;(另一个表的主键）</code></li>
</ul>
<h2 id="六、组合查询"><a href="#六、组合查询" class="headerlink" title="六、组合查询"></a>六、组合查询</h2><ul>
<li>组合查询，必须由两条<code>SELECT</code>语句组成，语句之间用<code>UNION</code>关键字分隔</li>
<li><code>UNION</code>的每个查询必须包含相同的列，表达式或聚集函数</li>
<li>使用<code>UNION</code>时重复的行会被自动取消（默认行为），若想返回所有的匹配行可以用<code>UNION ALL</code></li>
<li>在使用<code>UNION</code>组合查询时，只能使用一次<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后</li>
</ul>
<h2 id="七、全文本搜索"><a href="#七、全文本搜索" class="headerlink" title="七、全文本搜索"></a>七、全文本搜索</h2><ul>
<li>全文本搜索会对结果排序，具有较高优先等级（文本中靠前的等级高）的行先返回，搜索默认不区分大小写</li>
<li>在创建表时跟句子句<code>Fulltext(列名)</code>对它进行索引，函数<code>Match()</code>指定被搜索的列，函数<code>Against()</code>指定要使用的搜索表达式，搭配<code>WHERE</code>子句进行筛选</li>
<li>使用查询扩展<code>Against(&#39;anvils&#39; WITH QUERY EXPANSION)</code>，找出和搜索相关的其他行</li>
</ul>
<h2 id="八、操作数据"><a href="#八、操作数据" class="headerlink" title="八、操作数据"></a>八、操作数据</h2><ul>
<li><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><ul>
<li><code>INSERT INTO &lt;表名&gt; (需要插入值的列名) values (给每个列提供一个值)</code></li>
<li>没有列出的值默认为NULL</li>
<li><code>INSERT INTO</code>搭配<code>SELECT</code>可以从旧表复制数据到新表</li>
</ul>
</li>
<li><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><ul>
<li><code>UPDATE &lt;表名&gt; SET 列=值</code></li>
<li>要更新的表</li>
<li>列名和他们的新值</li>
<li>确定要更新行的过滤条件</li>
</ul>
</li>
<li><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul>
<li><code>DELETE FROM &lt;表名&gt; WHERE 匹配的列</code></li>
<li>删除表中所有行<code>TRUNCATE TABLE</code>语句</li>
</ul>
</li>
<li><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul>
<li><code>CREATE TABLE &lt;表名&gt;(行及相应值)</code></li>
<li>表的主键可以在创建表时用<code>PRIMARY KEY</code>关键字指定，主键值必须唯一，多个主键使用<code>,</code>分割</li>
<li>若仅想在一个表不存在时创建它，应该在表名后给出<code>if not exists</code></li>
<li>指定<code>not null</code>时在插入或更新行时，该列必须有值</li>
<li><code>AUTO_INCREMENT</code>告诉mysql每当增加一行时自动增量</li>
<li>每个表只允许一个<code>AUTO_INCREMENT</code>列</li>
</ul>
</li>
<li><h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><ul>
<li><code>ALTER TABLE &lt;表名&gt; ADD &lt;列&gt; 列的数据类型</code></li>
</ul>
</li>
<li><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><ul>
<li><code>DROP TABLE &lt;表名&gt;</code></li>
</ul>
</li>
<li><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><ul>
<li><code>RENAME TABLE &lt;表名&gt; to &lt;重命名的表名&gt;</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2021/04/28/Lua%20Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/Lua%20Note/" class="post-title-link" itemprop="url">Lua Note</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-28 17:56:31" itemprop="dateCreated datePublished" datetime="2021-04-28T17:56:31+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:15:58" itemprop="dateModified" datetime="2022-05-18T09:15:58+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PL/" itemprop="url" rel="index"><span itemprop="name">PL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h2><ul>
<li><code>lua -i</code>，<code>-i</code>参数用于在运行完其他命令行参数后进入交互模式</li>
<li>不在交互模式下必须把表达式包在函数<code>print</code>的调用中</li>
<li>如果不想输出结果，可以在行末加上一个<code>;</code></li>
</ul>
<h2 id="词法规范"><a href="#词法规范" class="headerlink" title="词法规范"></a>词法规范</h2><ul>
<li><p>标识符由任意字母、数字和下划线组成的字符串（不能以数字开头）</p>
</li>
<li><p><code>_</code>+大写字母（特殊用途）</p>
</li>
<li><p><code>_</code>+小写字母（哑变量）</p>
</li>
<li><p>注释</p>
<ul>
<li>单行注释<code>--</code></li>
<li>多行注释<br>  <code>--[[   多行注释   ]]</code></li>
</ul>
</li>
<li><p>分隔符<code>;</code></p>
<ul>
<li>增加可读性，不是必须的</li>
</ul>
</li>
<li><p>表达式之间的换行不起任何作用</p>
</li>
</ul>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul>
<li>无须声明即可使用</li>
<li>使用未经初始化的全局变量，得到的结果时<code>nil</code></li>
<li><code>nil</code>赋值给全局变量时，Lua会回收该全局变量</li>
</ul>
<h2 id="类型和值"><a href="#类型和值" class="headerlink" title="类型和值"></a>类型和值</h2><ul>
<li><p>Lua语言有8种基本类型</p>
<ul>
<li><p><code>nil</code>（空）</p>
<ul>
<li>nil赋值给全局变量时，则相当于将其删除（Lua会回收）</li>
</ul>
</li>
<li><p><code>boolean</code>（布尔）</p>
<ul>
<li>除false和nil之外的所有值都为真（与C++差异）</li>
<li>not运算符永远返回boolean类型的值<ul>
<li><code>not nil</code>  – true</li>
<li><code>not false</code> – true</li>
</ul>
</li>
</ul>
</li>
<li><p><code>number</code>（数值）</p>
</li>
<li><p><code>string</code>（字符串）</p>
</li>
<li><p><code>userdata</code>（用户数据）</p>
<ul>
<li>允许把任意的C语言数据保存在Lua语言变量中</li>
</ul>
</li>
<li><p><code>function</code>（函数）</p>
</li>
<li><p><code>thread</code>（线程）</p>
</li>
<li><p><code>table</code>（表）</p>
</li>
</ul>
</li>
<li><p><code>type</code>函数</p>
<ul>
<li>获取一个值对应的类型</li>
<li>返回值永远是一个字符串</li>
</ul>
</li>
</ul>
<h2 id="独立解释器"><a href="#独立解释器" class="headerlink" title="独立解释器"></a>独立解释器</h2><ul>
<li><p>是一个可以直接使用Lua语言的小程序</p>
</li>
<li><p>源代码文件第一行以井号<code>#</code>开头，那么解释器在加载文件时会忽略这一行，主要是为了方便在POSIX系统中将Lua作为一种脚本解释器来使用</p>
</li>
<li><p>假设独立解释器位于<code>/usr/local/bin</code>下</p>
<ul>
<li><code>#!/usr/local/bin/lua</code> 或<br>  <code>#!/usr/bin/env lua</code><ul>
<li>不需要显式调用Lua语言解释器也可以直接运行Lua脚本</li>
</ul>
</li>
</ul>
</li>
<li><p>编译器在运行代码前会创建一个名为arg的表</p>
<ul>
<li>索引0中保存的内容为脚本名<ul>
<li><code>arg[0]</code></li>
</ul>
</li>
<li>索引1保存的内容为第一个参数<ul>
<li><code>arg[1]</code></li>
</ul>
</li>
<li>以此类推</li>
</ul>
</li>
<li><p>Lua语言也支持可变长参数(…)</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pishun Huang</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>-->

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","//mhchem.github.io/MathJax-mhchem/ mhchem":false,"js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
