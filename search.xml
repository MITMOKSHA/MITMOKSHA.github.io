<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【C#】语言基础笔记（在更）</title>
      <link href="2021/04/28/%E3%80%90C%20sharp%E3%80%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9C%A8%E6%9B%B4%EF%BC%89/"/>
      <url>2021/04/28/%E3%80%90C%20sharp%E3%80%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9C%A8%E6%9B%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li>表达式主体方法<ul><li>=&gt;操作符引用构成方法主体的表达式，而且没有return语句。表达式的值自动作为返回值；如果表达式不返回值，则方法自动为void方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResult</span>(<span class="params"><span class="built_in">int</span> answer</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>差值表达式<ul><li>$符号表明这是个差值字符串，{和}之间的任何表达式都需求值并置换，字符串差值比+操作符高效得多  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li></ul></li><li>只有<code>float</code>和<code>double</code>除以0得到<code>Infinity</code>（不会出错）</li><li><code>int</code>的最大最小值<code>int.MaxValue</code>和<code>int.MinValue</code></li><li>隐式类型变量<code>var</code>,作用类似于C++的<code>auto</code><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2></li><li>与C++不一致<br>  -<code>if</code>语句中表达式必须是布尔值, 如：<code>if (1)</code> // 错误</li><li><code>switch</code>语句的控制表达式不能用<code>float</code>和<code>double</code>类型</li><li><code>case</code>标签必须是常量表达式，且必须唯一</li><li>C#语句的直通规则<ul><li>直通，标签之间不能有额外语句（即不加<code>break</code>，不允许拥有语句）</li><li>每个<code>case</code>都加上<code>break</code><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2></li></ul></li><li>C#所有方法都必须在类的内部声明</li><li>默认参数中如果参数匹配则不会出现歧义</li><li>默认参数（可选参数）必须放在后面</li><li>具名参数<ul><li><code>optMethod(first: 99, third: &quot;Word&quot;);</code>  // 传递具名参数（参数名:传递的值），实参可以按任意顺序传递，second参数使用<code>默认值</code></li></ul></li></ul><h2 id="结构（结构体）"><a href="#结构（结构体）" class="headerlink" title="结构（结构体）"></a>结构（结构体）</h2><ul><li><p>与C++不一致，结构主体后不加<code>;</code></p></li><li><p>值类型</p><ul><li>对于简单的、比较小的数据值，复制值的效率等同于或基本等同于复制地址的效率，但较复杂的数据就考虑使用类，这样就可选择只复制数据的地址，从而提高代码的执行效率</li></ul></li><li><p>不能为结构声明默认构造器（无参构造器），否则无法编译，因为编译器始终会自动生成默认构造器（不同于类）</p></li><li><p>类的实例字段可在声明时初始化，但结构不允许</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> hours = <span class="number">0</span>;  <span class="comment">// 编译时错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译器不会自动初始化结构中的字段（与类不一致）</p></li><li><p>复制结构变量的前提时<code>=</code>操作符右侧的结构变量已完全初始化，否则编译错误</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2></li><li><p>与C++不一致，枚举主体后不加<code>;</code></p></li><li><p>值类型</p></li><li><p>声明枚举时字面值默认是int类型，可以选择枚举的基础类型</p><ul><li><code>enum Season : short &#123; Spring, Summer &#125;</code></li></ul></li><li><p>为枚举的字面值显式指定常量整数值</p><ul><li><code>enum Season &#123; Spring = 1, Summer &#125;</code></li></ul></li><li><p>编译器自动为它指定比前一个枚举字面值大1的值</p></li><li><p>多个枚举字面值可以具有相同的基础值</p><ul><li><code>enum Season &#123; Spring, Summer, Fall, Autumn = Fall &#125;</code></li></ul></li><li><p>每个枚举定义的字面值名称都只有这个枚举类型的作用域，因此要加枚举类型限定，否则编译错误，如：Season.Fall</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2></li><li><p>与c++不一致，类主体、结构主体后不加分号</p></li><li><p>每个字段和方法声明都要重复<code>public</code>或<code>private</code>关键字</p></li><li><p>省略控制可访问性，默认为<code>private</code></p></li><li><p>类被拆分到多个文件中之后，要在每个文件中使用<code>partial</code>（分部）关键字定义类的不同部分</p></li><li><p>如果把方法或字段声明为<code>static</code>，就可使用类名调用方法或访问字段，而不用先创建对象</p></li><li><p>静态方法只能访问标记为<code>static</code>的其他方法和字段</p></li><li><p>类外访问类中的<code>static</code>字段要以，类名作为前缀，<code>class.function</code></p></li><li><p>静态方法也称为类方法</p></li><li><p>静态字段称为静态字段或静态变量</p></li><li><p>只有数值类型、字符串类型和枚举类型的字段才能声明为const字段</p></li><li><p>静态类</p><ul><li>只能包含静态成员</li><li><code>public static class Math</code></li></ul></li><li><p>using语句允许将类引入作用域，以便在访问静态成员时省略类名</p><ul><li><code>using static System.Math;</code></li></ul></li><li><p>匿名类</p><ul><li>匿名类就是没有名字的类</li><li>不知道类的名称可以使用隐式类型变量来创建正确类型的对象  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAnonymousObject = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">47</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>值类型</p><ul><li>基元类型</li></ul></li><li><p>引用类型</p><ul><li><code>string</code>在运行时动态分配内存</li><li>声明类变量时，编译器分配一小块内存，其中刚好可以容纳一个地址。以后类实际占用内存块的地址会填充到这里。该地址成为对内存块的引用</li><li>实际占用的内存<ul><li>使用<code>new</code>关键字创建对象时分配的内存</li></ul></li></ul></li><li><p>引用类型的变量包含的是引用，引用本身存储在栈上，但该引用指向堆上的对象</p></li><li><p>类可以提供clone方法来返回自己的新实例，并填充相同数据</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Circle <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Circle clone = <span class="keyword">new</span> Circle();</span><br><span class="line">    clone.radius = <span class="keyword">this</span>.radius;</span><br><span class="line">    <span class="comment">// 返回包含克隆数据的新Circle对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果包含任何引用类型的字段，这种引用类型也需要提供Clone方法，否则只是“浅拷贝”，如果提供了Clone方法，能够复制引用的对象，就成为“深拷贝”</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle(<span class="number">42</span>);</span><br><span class="line">Circle copy = <span class="keyword">new</span> Circle(<span class="number">99</span>);</span><br><span class="line">copy = c;</span><br></pre></td></tr></table></figure></li><li><p>这时候copy原来的引用被回收了（垃圾回收机制）</p></li></ul></li><li><p>空条件操作符（问号加在变量名称之后）</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(c?.Area());</span><br></pre></td></tr></table></figure><ul><li>空条件操作符告诉”运行时“在操作符所应用的变量为null的前提下忽略当前语句</li></ul></li><li><p>可空类型</p><ul><li><code>null</code>本身就是引用，不能把它赋值给值类型</li><li>可将变量声明为可空值类型<ul><li><code>int? i = null;</code></li></ul></li><li>可将恰当值的表达式直接赋给可空变量<ul><li><code>i = j;</code></li></ul></li><li>不可将可空的值赋给普通的值类型变量<ul><li><code>j = i;</code></li></ul></li><li>可空类型的两个属性<ul><li><code>HasValue</code><ul><li>判断可空类型是包含一个值，还是包含null</li></ul></li><li><code>Value</code><ul><li>只读的属性</li><li>读取变量的值，但不能修改</li></ul></li></ul></li></ul></li><li><p>引用传参</p><ul><li><code>ref</code>参数<ul><li>要求实参和形参前都加上<code>ref</code>关键字<ul><li><code>DoWork(ref i)</code>;</li></ul></li><li>要求在传参之前必须初始化</li></ul></li><li><code>out</code>参数<ul><li>要求实参和形参前都加上<code>out</code>关键字</li><li>要求在方法中必须初始化，传参前不要求</li></ul></li></ul></li><li><p><code>object</code>类型</p><ul><li><code>object</code>类型的变量能引用任何引用类型的任何对象</li></ul></li><li><p><code>装箱</code></p><ul><li>将值类型赋给<code>object</code>类型的变量<ul><li><code>object o = 42;</code></li></ul></li><li>数据项从栈自动复制到堆的行为</li><li>与泛型异曲同工</li></ul></li><li><p><code>拆箱</code></p><ul><li>将引用了已装箱的值的object引用强制转换成值类型<ul><li><code>int a = (int)o;</code></li></ul></li><li>必须强制转换</li></ul></li><li><p>装箱和拆箱会产生较大的开销</p><ul><li>它们设计不少检查工作，且需要分配额外的堆内存</li></ul></li><li><p>数据的安全转型</p><ul><li>左操作数为对象，右操作数为类型<ul><li>is操作符<ul><li>if (o is WrappedInt)</li><li>如果is表达式正确，结果为true，反之为false</li></ul></li><li>as操作符<ul><li>WrappedInt temp = o as WrappedInt;</li><li>若转换成功，就返回转换成功的结果，失败则为null</li></ul></li></ul></li></ul></li><li><p>在c#中使用c指针必须将代码标记为<code>unsafe</code></p><ul><li><code>unsafe</code>关键字可标记代码块或整个方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"></span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>命名规范</p></li><li><p>公共标识符以大写字母开头</p></li><li><p>非公共标识符（包括局部变量）以小写字母开头</p></li><li><p>类名以大写字母开头</p></li><li><p>均采用驼峰命名法</p></li><li><p><code>TODO:</code>注释通常用于标注以后将进行加工的代码</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2></li><li><p><code>checked</code>语句是<code>checked</code>关键字开头的代码块</p><ul><li>只有直接在checked块中的整数运算才会检查</li><li>溢出则抛出<code>OverflowException</code></li><li><code>checked</code>和<code>unchecked</code>关键字只适合整型运算</li><li>浮点运算永不抛出异常</li></ul></li><li><p><code>catch</code>省略名称默认捕获<code>Exception</code></p><ul><li>异常发生后将运行由”运行时“发现的第一个匹配的异常处理程序<code>catch</code>，其他处理程序会被忽略</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link href="2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>打印出二叉树中节点值的和为输入整数的所有路径（从根节点一直到叶子节点的路径）<br><strong>输入</strong>：<br>给定如下二叉树，以及目标和 target = 22</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><p>由根节点出发，首先想到先序遍历的思路</p><h3 id="2-1-回溯"><a href="#2-1-回溯" class="headerlink" title="2.1 回溯"></a>2.1 回溯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">      vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">      <span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">FindPath</span>(root, target, path, currentSum, ans);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> currentSum, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先序遍历</span></span><br><span class="line">      currentSum += root-&gt;val;  <span class="comment">// 更新当前路径</span></span><br><span class="line">      path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">      <span class="comment">// 如果是叶子节点，并且路径上的节点的和等于输入的值，则打印这条路径</span></span><br><span class="line">      <span class="keyword">bool</span> isLeaf = root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (currentSum == target &amp;&amp; isLeaf) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若不是叶子节点，则遍历它的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在返回父节点之前，在路径上删除当前节点</span></span><br><span class="line">      path.<span class="built_in">pop_back</span>();  <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(N)，N为二叉树的节点数，需要遍历所有节点</li><li><strong>空间复杂度</strong>：O(N)，最差情况下即树退化成链表，path存储所有树节点，使用O(N)额外空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 684. 冗余连接</title>
      <link href="2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
      <url>2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>找出无向图中的冗余连接，即将无向图还原成二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><h3 id="2-1-并查集"><a href="#2-1-并查集" class="headerlink" title="2.1 并查集"></a>2.1 并查集</h3><p>思路：通过并查集寻找附加的边，初始时每个节点都属于不同的连通分量，遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量</p><ul><li>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</li><li>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[index]]); </span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      parent[<span class="built_in">Find</span>(parent, x)] = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(klogk)，其中k时图中的节点个数</li><li>空间复杂度：O(n)</li></ul><h3 id="2-1-使用-按秩合并-路径压缩-的并查集"><a href="#2-1-使用-按秩合并-路径压缩-的并查集" class="headerlink" title="2.1 使用==按秩合并+路径压缩==的并查集"></a>2.1 使用==按秩合并+路径压缩==的并查集</h3><p>优化了空间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[parent[index]]);  <span class="comment">// 路径压缩，使树的层数更少</span></span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      <span class="keyword">int</span> i = <span class="built_in">Find</span>(parent, x), j = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">      <span class="comment">// 按秩合并</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">// 如果i的秩大于j的秩</span></span><br><span class="line">        parent[j] = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[i] = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(klogk)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Mysql】语言基础笔记（在更）</title>
      <link href="2021/04/28/%E3%80%90Mysql%E3%80%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9C%A8%E6%9B%B4%EF%BC%89/"/>
      <url>2021/04/28/%E3%80%90Mysql%E3%80%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9C%A8%E6%9B%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul><li>表名是唯一的</li><li>表中的数据是按行存储的</li><li>行（别名 记录）</li><li>主键：一列，其值能够区分表中每个行<ul><li>每个行都必须有一个主键值（不允许为NULL）</li><li>任意两行都不具有相同的主键值</li><li>不更新主键列中的值</li><li>不在主键列中使用可能会更改的值</li></ul></li><li>命令用分号；结束</li><li>连接到mysql需要以下信息<ul><li>主机名：本地服务器为localhost</li><li>端口：默认为3036</li><li>一个合法的用户名</li><li>用户口令（如果需要的话）</li></ul></li><li><code>use&lt;数据库名字&gt;</code>来选择数据库</li><li><code>show databases</code>返回可用数据库的一个列表</li><li><code>show tables</code>返回该数据库内的可用表的一个列表</li><li><code>show columns from &lt;表名&gt;</code> = <code>describe &lt;表名&gt;</code>来显示表中的所有列</li><li>自动增量：Mysql可以自动地为每个行分配下一个可用的编号，需要create语句</li><li><code>show status</code>显示广泛的服务器状态信息</li><li><code>show create databases/table</code>分别用来显示创建特定数据库或表的语句</li><li><code>show grants</code>显示授予用户的安全权限</li><li><code>show errors</code>和<code>show warnings</code>显示服务器错误或警告信息<h2 id="二、SELECT语句"><a href="#二、SELECT语句" class="headerlink" title="二、SELECT语句"></a>二、SELECT语句</h2></li><li><code>SELECT &lt;列名&gt; FROM &lt;表名&gt;</code>在表中检索单个列<blockquote><p>SELECT检索多个列，列名用逗号分隔<br>检索所有列，用<code>*</code>通配符</p></blockquote></li><li>sql语句不区分大小写</li><li>SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写</li><li>处理SQL语句空格会被忽略</li><li><code>SELECT DISTINCT ... FROM</code>返回不重复的行（distinct要放在列名前面）</li><li>使用完全限定的表名<code>SELECT db.host FROM mysql.db</code></li><li><code>FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT</code>是<code>SELECT</code>的子句，其出现次序必须为上述顺序，次序不对将产生错误信息</li><li><code>ORDER BY</code>子句取一个或多个列的名字对输出进行排序<blockquote><p>默认为asc升序，在列名后加<code>DESC</code>关键字按降序排列，desc关键字只应用到直接位于其前面的列名</p></blockquote></li><li><code>GROUP BY</code>子句，分组允许把数据分为多个逻辑组</li><li><code>HAVING</code>和<code>WHERE</code>的区别：<code>HAVING</code>过滤分组，<code>WHERE</code>过滤行</li><li><code>WHERE</code>是<code>SELECT</code>的子句（在from子句之后给出）用来指定搜索条件</li><li><strong>WHERE子句操作符</strong></li></ul><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">不等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在指定的两个值之间</td></tr></tbody></table><ul><li>空值检查(<code>is NULL</code>子句)<code>where...is NULL;</code></li><li><code>WHERE</code>子句给出了<code>AND, OR, IN, NOT</code>逻辑操作符来进行逻辑操作<h2 id="三、匹配"><a href="#三、匹配" class="headerlink" title="三、匹配"></a>三、匹配</h2></li><li>通配符本身实际是SQL的<code>WHERE</code>子句中有特殊含义的字符，在搜索子句中使用通配符，必须使用<code>LIKE</code>操作符，<code>LIKE</code>只是Mysql后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较</li><li>百分号<code>%</code>通配符匹配任意个数的任意字符，下划线<code>_</code>通配符匹配任意单个字符</li><li>使用通配符的技巧<ul><li>不要过度使用通配符</li><li>把通配符置于搜索模式的开始处搜索起来是最慢的</li></ul></li><li><code>WHERE</code>的子句中<code>REGEXP</code>子句使用正则表达式，在<code>REGEXP</code>关键字后加上<code>BINARY</code>来区分匹配表达式的大小写<br>例：      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Db, User FROM db </span><br><span class="line">WHERE Db REGEXP BINARY &#39;.ys&#39;;</span><br></pre></td></tr></table></figure></li><li>匹配正则表达式内具有特殊意义的所有字符都必须以\\的方式转义</li></ul><p><strong>常用字符类</strong></p><table><thead><tr><th align="center">类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">任意字母和数字（同[a-zA-Z0-9])</td></tr><tr><td align="center">[:alpha:]</td><td align="center">任意字符（同[a-zA-Z]）</td></tr><tr><td align="center">[:blank:]</td><td align="center">空格和制表</td></tr><tr><td align="center">[:cntrl:]</td><td align="center">ASCII控制字符</td></tr><tr><td align="center">[:digit:]</td><td align="center">任意数字</td></tr><tr><td align="center">[:graph:]</td><td align="center">与[:print:]相同，但不包括空格</td></tr><tr><td align="center">[:lower:]</td><td align="center">任意小写字母</td></tr><tr><td align="center">[:print:]</td><td align="center">任意可打印字符</td></tr><tr><td align="center">[:space:]</td><td align="center">任意空白字符</td></tr><tr><td align="center">[:upper:]</td><td align="center">任意大写字母</td></tr><tr><td align="center">[:xdigit:]</td><td align="center">任意十六进制数</td></tr></tbody></table><p><strong>重复元字符</strong></p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>0个或多个匹配</td></tr><tr><td>+</td><td>1个或多个匹配（等于{1,}）</td></tr><tr><td>?</td><td>0个或1个匹配（等于{0,1}）</td></tr><tr><td>{n}</td><td>指定数目的匹配</td></tr><tr><td>{n,}</td><td>不少于指定数目的匹配</td></tr><tr><td>{n,m}</td><td>匹配数目的范围</td></tr></tbody></table><p><strong>定位元字符</strong></p><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">文本的开始</td></tr><tr><td align="center">$</td><td align="center">文本的结束</td></tr><tr><td align="center">[[:&lt;:]]</td><td align="center">词的开始</td></tr><tr><td align="center">[[:&gt;:]]</td><td align="center">词的结束</td></tr></tbody></table><ul><li>正则表达式中<code>.</code>表示匹配任意一个字符</li><li><code>LIKE</code>与<code>REGEXP</code>的区别，<code>LIKE</code>匹配整个串，<code>REGEXP</code>匹配子串</li><li>简单的正则表达式测试，例：<code>SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;</code></li><li><code>SELECT</code>语句中，<code>concat()</code>函数用来拼接字段（与列的意思相同），别名用<code>AS</code>关键字赋予，<code>RTrim()</code>函数去掉右边的所有空格<br>例：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat(Db, &#39;(&#39;, User, &#39;)&#39;) AS link</span><br><span class="line">FROM db;</span><br></pre></td></tr></table></figure><h2 id="四、相关函数"><a href="#四、相关函数" class="headerlink" title="四、相关函数"></a>四、相关函数</h2></li><li><code>Soundex()</code>函数匹配所有发音类似与Y.Lie的联系名<br>例：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE Soundex(cust_contact) &#x3D; Soundex(&#39;Y. Lie&#39;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>常用数值处理函数</strong></p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Abs()</td><td align="center">返回一个数的绝对值</td></tr><tr><td align="center">Cos()</td><td align="center">返回一个角度的余弦</td></tr><tr><td align="center">Exp()</td><td align="center">返回一个数的指数值</td></tr><tr><td align="center">Mod()</td><td align="center">返回余数</td></tr><tr><td align="center">Pi()</td><td align="center">返回圆周率</td></tr><tr><td align="center">Rand()</td><td align="center">返回一个随机数</td></tr><tr><td align="center">Sin()</td><td align="center">返回一个角度的正弦</td></tr><tr><td align="center">Sqrt()</td><td align="center">返回一个角度的平方根</td></tr><tr><td align="center">Tan()</td><td align="center">返回一个角度的正切</td></tr></tbody></table><p><strong>常用时间和日期处理函数</strong></p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">AddDate()</td><td align="center">增加一个日期（天、周等)</td></tr><tr><td align="center">AddTime()</td><td align="center">增加一个时间（时、分等）</td></tr><tr><td align="center">CurDate()</td><td align="center">返回当前日期</td></tr><tr><td align="center">Date()</td><td align="center">返回日期时间的日期部分</td></tr><tr><td align="center">DateDiff()</td><td align="center">计算两个日期之差</td></tr><tr><td align="center">Date_add()</td><td align="center">高度灵活的日期运算函数</td></tr><tr><td align="center">Date_Format()</td><td align="center">返回格式化的日期或时间率</td></tr><tr><td align="center">Day()</td><td align="center">返回一个日期的天数部分</td></tr><tr><td align="center">DayOfWeek()</td><td align="center">对于一个日期，返回对应的星期</td></tr><tr><td align="center">Hour()</td><td align="center">返回一个日期的小时部分</td></tr><tr><td align="center">Minute()</td><td align="center">返回一个日期的分钟部分</td></tr><tr><td align="center">Month()</td><td align="center">返回一个日期的月份</td></tr><tr><td align="center">Now()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">Second()</td><td align="center">返回一个时间的秒部分</td></tr><tr><td align="center">Time()</td><td align="center">返回一个日期时间的时间部分</td></tr><tr><td align="center">Year()</td><td align="center">返回一个日期的年份部分</td></tr></tbody></table><ul><li>子查询，嵌套<code>SELECT</code>语句<br>例：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE prod_id &#x3D; &#39;TNT2&#39;);</span><br></pre></td></tr></table></figure><h2 id="五、联结表"><a href="#五、联结表" class="headerlink" title="五、联结表"></a>五、联结表</h2></li><li><code>WHERE</code>子句在联结表中起配对的作用（用完全限定列名）</li><li>没有联结条件的表关系返回的结果为笛卡尔积（检索出的行的数目将是第一个表中的行数乘以第二个表中的行数）</li><li>应保证所有联结都有<code>WHERE</code>子句</li><li>使用在<code>WHERE</code>子句中使用<code>AND</code>可以联结多个表</li><li>等值连接也称为内部联结</li><li>尽量使用自联结而不用子查询</li><li><strong>联结的方式</strong><br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20210428125629111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2ODAyNzEz,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="联结"></li><li>外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系</li><li>外键的意义：在于解耦合，定义外键的方法<code>FOREIGN KEY (主键）references &lt;表名&gt;(另一个表的主键）</code><h2 id="六、组合查询"><a href="#六、组合查询" class="headerlink" title="六、组合查询"></a>六、组合查询</h2></li><li>组合查询，必须由两条<code>SELECT</code>语句组成，语句之间用<code>UNION</code>关键字分隔</li><li><code>UNION</code>的每个查询必须包含相同的列，表达式或聚集函数</li><li>使用<code>UNION</code>时重复的行会被自动取消（默认行为），若想返回所有的匹配行可以用<code>UNION ALL</code></li><li>在使用<code>UNION</code>组合查询时，只能使用一次<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后<h2 id="七、全文本搜索"><a href="#七、全文本搜索" class="headerlink" title="七、全文本搜索"></a>七、全文本搜索</h2></li><li>全文本搜索会对结果排序，具有较高优先等级（文本中靠前的等级高）的行先返回，搜索默认不区分大小写</li><li>在创建表时跟句子句<code>Fulltext(列名)</code>对它进行索引，函数<code>Match()</code>指定被搜索的列，函数<code>Against()</code>指定要使用的搜索表达式，搭配<code>WHERE</code>子句进行筛选</li><li>使用查询扩展<code>Against(&#39;anvils&#39; WITH QUERY EXPANSION)</code>，找出和搜索相关的其他行<h2 id="八、操作数据"><a href="#八、操作数据" class="headerlink" title="八、操作数据"></a>八、操作数据</h2></li><li><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><ul><li><code>INSERT INTO &lt;表名&gt; (需要插入值的列名) values (给每个列提供一个值)</code></li><li>没有列出的值默认为NULL</li><li><code>INSERT INTO</code>搭配<code>SELECT</code>可以从旧表复制数据到新表</li></ul></li><li><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><ul><li><code>UPDATE &lt;表名&gt; SET 列=值</code></li><li>要更新的表</li><li>列名和他们的新值</li><li>确定要更新行的过滤条件</li></ul></li><li><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li><code>DELETE FROM &lt;表名&gt; WHERE 匹配的列</code></li><li>删除表中所有行<code>TRUNCATE TABLE</code>语句</li></ul></li><li><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul><li><code>CREATE TABLE &lt;表名&gt;(行及相应值)</code></li><li>表的主键可以在创建表时用<code>PRIMARY KEY</code>关键字指定，主键值必须唯一，多个主键使用<code>,</code>分割</li><li>若仅想在一个表不存在时创建它，应该在表名后给出<code>if not exists</code></li><li>指定<code>not null</code>时在插入或更新行时，该列必须有值</li><li><code>AUTO_INCREMENT</code>告诉mysql每当增加一行时自动增量</li><li>每个表只允许一个<code>AUTO_INCREMENT</code>列</li></ul></li><li><h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><ul><li><code>ALTER TABLE &lt;表名&gt; ADD &lt;列&gt; 列的数据类型</code></li></ul></li><li><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><ul><li><code>DROP TABLE &lt;表名&gt;</code></li></ul></li><li><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><ul><li><code>RENAME TABLE &lt;表名&gt; to &lt;重命名的表名&gt;</code> </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Lua】语言基础笔记（在更）</title>
      <link href="2021/04/28/%E3%80%90Lua%E3%80%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9C%A8%E6%9B%B4%EF%BC%89/"/>
      <url>2021/04/28/%E3%80%90Lua%E3%80%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9C%A8%E6%9B%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h2><ul><li><code>lua -i</code>，<code>-i</code>参数用于在运行完其他命令行参数后进入交互模式</li><li>不在交互模式下必须把表达式包在函数<code>print</code>的调用中</li><li>如果不想输出结果，可以在行末加上一个<code>;</code></li></ul><h2 id="词法规范"><a href="#词法规范" class="headerlink" title="词法规范"></a>词法规范</h2><ul><li><p>标识符由任意字母、数字和下划线组成的字符串（不能以数字开头）</p></li><li><p><code>_</code>+大写字母（特殊用途）</p></li><li><p><code>_</code>+小写字母（哑变量）</p></li><li><p>注释</p><ul><li>单行注释<code>--</code></li><li>多行注释<br>  <code>--[[   多行注释 ]]</code></li></ul></li><li><p>分隔符<code>;</code></p><ul><li>增加可读性，不是必须的</li></ul></li><li><p>表达式之间的换行不起任何作用</p></li></ul><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul><li><p>无须声明即可使用</p></li><li><p>使用未经初始化的全局变量，得到的结果时<code>nil</code></p></li><li><p><code>nil</code>赋值给全局变量时，Lua会回收该全局变量</p><h2 id="类型和值"><a href="#类型和值" class="headerlink" title="类型和值"></a>类型和值</h2></li><li><p>Lua语言有8种基本类型</p><ul><li><p><code>nil</code>（空）</p><ul><li>nil赋值给全局变量时，则相当于将其删除（Lua会回收）</li></ul></li><li><p><code>boolean</code>（布尔）</p><ul><li>除false和nil之外的所有值都为真（与C++差异）</li><li>not运算符永远返回boolean类型的值<ul><li><code>not nil</code>  – true</li><li><code>not false</code> – true</li></ul></li></ul></li><li><p><code>number</code>（数值）</p></li><li><p><code>string</code>（字符串）</p></li><li><p><code>userdata</code>（用户数据）</p><ul><li>允许把任意的C语言数据保存在Lua语言变量中</li></ul></li><li><p><code>function</code>（函数）</p></li><li><p><code>thread</code>（线程）</p></li><li><p><code>table</code>（表）</p></li></ul></li><li><p><code>type</code>函数</p><ul><li>获取一个值对应的类型</li><li>返回值永远是一个字符串</li></ul></li></ul><h2 id="独立解释器"><a href="#独立解释器" class="headerlink" title="独立解释器"></a>独立解释器</h2><ul><li><p>是一个可以直接使用Lua语言的小程序</p></li><li><p>源代码文件第一行以井号<code>#</code>开头，那么解释器在加载文件时会忽略这一行，主要是为了方便在POSIX系统中将Lua作为一种脚本解释器来使用</p></li><li><p>假设独立解释器位于<code>/usr/local/bin</code>下</p><ul><li><code>#!/usr/local/bin/lua</code> 或<br><code>#!/usr/bin/env lua</code><ul><li>不需要显式调用Lua语言解释器也可以直接运行Lua脚本</li></ul></li></ul></li><li><p>编译器在运行代码前会创建一个名为arg的表</p><ul><li>索引0中保存的内容为脚本名<ul><li><code>arg[0]</code></li></ul></li><li>索引1保存的内容为第一个参数<ul><li><code>arg[1]</code></li></ul></li><li>以此类推</li></ul></li><li><p>Lua语言也支持可变长参数(…)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
