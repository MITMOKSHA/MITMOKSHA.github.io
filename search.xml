<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vim+vscode+tmux+gdb</title>
      <link href="/2022/05/16/vim-vscode-tmux-gdb/"/>
      <url>/2022/05/16/vim-vscode-tmux-gdb/</url>
      
        <content type="html"><![CDATA[<h1 id="vim-vscode-tmux-gdb-git"><a href="#vim-vscode-tmux-gdb-git" class="headerlink" title="vim+vscode+tmux+gdb+git"></a>vim+vscode+tmux+gdb+git</h1><p>个人的一些认为比较常用以及不经常用到的的快捷操作</p><h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a><strong>vscode</strong></h2><ol><li>查找文件ctrl+p， esc退出</li><li>分割屏幕ctrl+\，通过ctrl+1/2/3来切换分割屏幕的焦点</li><li>ctrl+` 打开/关闭终端</li><li>ctrl+tab, 在tab之间切换</li><li>模糊查找当前工作目录下的所有文件ctrl+p, #</li><li>Ctrl + Shift + Tab 导航tab</li><li>alt + &lt;-/-&gt;切换tab</li></ol><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a><strong>vim</strong></h2><ol><li>跳转到指定行号n, ngg</li><li>复制整行 yy, 复制包括当前行接下来n行， nyy</li><li>复制指定行v模式下指定复制内容，然后y键复制。</li><li>粘贴<br>如复制内容不是一整行：p粘贴到当前光标处，P粘贴到当前行首。<br>如复制内容是一整行：p粘贴到当前行的下一行，P粘贴到当前行的上一行</li><li>剪切dd</li><li>在当前文件查找指定内容，/+内容</li><li>ctrl+] 跳转到函数的定义处，ctrl+t返回上一次光标处</li><li>u撤销，ctrl+r恢复</li><li><code>^y</code>向上移动一行, <code>^e</code>向下移动一行</li><li><code>^b</code>向上移动一页，<code>^f</code>向下移动一页</li><li>number + shift + G, 跳到第number行 </li><li>在<code>tab</code>之间切换, <code>Alt</code>+<code>number</code>.</li><li>可视条件下选中后<code>&lt;</code>或<code>&gt;</code>完成缩进。</li><li>要想跳转到函数定义处，需要在项目目录中输入<code>ctags -R</code>命令。<code>ctrl+]</code>跳转, <code>ctrl+o</code>返回。</li><li>可视模式下注释+<code>d</code>。</li><li>替换变量名<code>:%s/foo/bar/g</code>将整个文件中的<code>foo</code>替换为<code>bar</code></li><li>在vim文件内使用shell命令<code>:! command</code></li><li>在当前文件中打开另一个文件<code>:e file</code></li><li>在Vim中编译代码<code>:!gcc %</code>, 编译并运行代码<code>:!gcc % || ./a.out</code></li></ol><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a><strong>tmux</strong></h2><ol><li>任何命令都需要加ctrl+b前缀</li><li>c创建窗口；n, p切换窗口</li><li>%垂直分屏, “水平分屏</li><li>x关闭窗口</li><li>o在窗口之间切换</li><li>PgUp开启tmux终端界面的翻页，q退出。</li></ol><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a><strong>gdb</strong></h2><ol><li>delete 删除所有断点</li><li>layout src/reg/asm 显示c源代码、寄存器和汇编，但未分屏；focus src/reg/asm在src、reg和asm的tui中来回切换</li><li>layout split获得c和asm的分屏。</li><li>info/i frame 查看栈帧, info/i args查看传递给main的参数, i locals显示当前的本地变量。</li><li>通过backtrace查看栈帧，frame n(n为bt结果的栈帧号)，然后i frame查看当前栈帧号的详细内容</li><li>print/p查看argv数据;print/p *argv(默认打印一个参数);可以通过print/p *argv@n 来选择argv数组中的n个元素即参数; p *argv@argc打印所有参数</li><li><code>print</code>是打印值，<code>x</code>是访问主存。</li><li><code>Ctrl + x</code>，再按1：单窗口模式，显示一个窗口</li><li><code>Ctrl + x</code>，再按2：双窗口模式，显示两个窗口</li><li><code>Ctrl + x</code>，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。</li><li><code>^x+a</code>关闭可视化</li><li><code>wa</code>跟踪某个变量(watch point)</li></ol><h2 id="lt-gt-gdb续"><a href="#lt-gt-gdb续" class="headerlink" title="&lt;&gt;(gdb续)"></a><strong>&lt;<Debug Hacks>&gt;(gdb续)</strong></h2><ol><li><code>break/b</code><ul><li><code>break 函数名</code></li><li><code>break 行号</code></li><li><code>break 文件名:行号</code></li><li><code>break 文件名:函数名</code></li><li><code>break +偏移量</code></li><li><code>break -偏移量</code></li><li><code>break *地址</code></li><li><code>break 断点 if 条件</code></li><li>若不指定位置就默认在下一行代码上设置断点</li><li><code>info break</code>显示断点信息</li></ul></li><li><code>run/r</code>, 如果不加参数，执行到断点位置后暂停运行(和start命令一样的效果)</li><li><code>print/p</code><ul><li><code>p $eax</code>，显示寄存器(寄存器名前加$)</li></ul></li><li><code>p/格式 变量</code>, 显示寄存器可用的格式:<ul><li>x, 显示为十六进制数</li><li>d, 显示为十进制数</li><li>u, 显示无符号十进制数</li><li>o, 显示八进制数</li><li>t, 显示二进制数(two)</li><li>a, 显示地址</li><li>c, 显示为字符</li><li>f, 浮点小数</li><li>s, 显示为字符串</li><li>i, 显示为机器语言</li></ul></li><li><code>x/NFU ADDR</code>, 显示内存的内容(eXamining):<ul><li><code>N</code>为重复次数</li><li><code>F</code>为上述的P格式</li><li><code>U</code>代表的单位：<ul><li>b, 字节</li><li>h, 半字</li><li>w, 字(4字节默认)</li><li>g, 双字</li></ul></li></ul></li></ol><h2 id="cgdb"><a href="#cgdb" class="headerlink" title="cgdb"></a><strong>cgdb</strong></h2><ol><li>使用<code>i</code>切换到<code>GDB command</code>，<code>esc</code>切换到<code>source window</code>。</li><li>在<code>source window</code>下，可以像<code>vim</code>一样用<code>\</code>匹配内容， 且移动到指定行按下<code>space</code>可以可视化打断点。</li><li><code>q</code>或者<code>^c+d</code>退出<code>gdb</code></li><li>调整<code>source window</code>的大小, <code>-</code>缩小一行，<code>=</code>增加一行。</li><li>在<code>source window</code>下<code>^w</code>窗口水平竖直分割切换。</li><li><code>F5</code> = <code>run</code>, <code>F6</code> = <code>continue</code>, <code>F7</code> = <code>finish</code>, <code>F8</code> = <code>next</code>, <code>F10</code> = <code>step</code>。</li><li><code>CGDB</code>的配置, 在<code>~/.cgdb/</code>目录下创建<code>cgdbrc</code>文件并编辑。如果<code>cgdbrc</code>文件存在，<code>CGDB</code>就会执行该文件中的每一行。<ul><li><code>:set disasm</code>，以汇编语言的形式显示。</li><li><code>:set hls</code>，高亮显示匹配到的字符串</li><li><code>:set syn=style</code>设置当前文件对应语法风格的高亮。</li></ul></li></ol><h2 id="git"><a href="#git" class="headerlink" title="git"></a><strong>git</strong></h2><ul><li><code>git clone -b branch XXX</code>克隆指定分支的代码</li><li><code>git reset --hard 1a703e</code>回滚到某个历史commit</li><li><code>git branch -m &lt;branchName&gt;</code>将当前分支名更改为branchName</li><li><code>git checkout -b &lt;newbranch&gt;</code>创建新分支并切换到新分支</li><li><code>git diff</code>查看修改的差异</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Cpp Note</title>
      <link href="/2022/05/16/cpp%20Note/"/>
      <url>/2022/05/16/cpp%20Note/</url>
      
        <content type="html"><![CDATA[<h2 id="一、std-function和bind绑定器"><a href="#一、std-function和bind绑定器" class="headerlink" title="一、std::function和bind绑定器"></a>一、std::function和bind绑定器</h2><h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><ul><li>是一个函数指针</li><li>是一个具有<code>operator()</code>成员函数的类对象（仿函数）</li><li>是一个可被转换为函数指针的类对象</li><li>是一个类成员（函数）指针</li></ul><h3 id="可调用对象包装器std-funtion"><a href="#可调用对象包装器std-funtion" class="headerlink" title="可调用对象包装器std::funtion"></a>可调用对象包装器std::funtion</h3><ul><li>头文件<code>&lt;functional&gt;</code></li><li>可以容纳除了类成员（函数）指针之外的所有可调用对象</li><li>可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们</li><li><code>function</code>比普通函数指针更灵活和便利</li></ul><h3 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h3><ul><li>头文件<code>&lt;functional&gt;</code></li><li>接受一个可调用对象，生成一个新的可调用对象</li><li><code>std::bind</code>用来将可调用对象与其参数一起进行绑定，绑定后的结果可以使用<code>std::function</code>进行保存，并延迟调用到任何我们需要的时候</li><li>作用<ul><li>将可调用对象与其参数一起绑定成一个仿函数(functor)</li><li>将多元（参数个数为n）可调用对象转成一元或者（n-1）元可调用对象，却只绑定部分参数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();  <span class="comment">// 输出：1 2</span></span><br><span class="line">std::<span class="built_in">bind</span>(output, std::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);  <span class="comment">// 输出 ：1 2</span></span><br><span class="line">std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_1)(<span class="number">1</span>);  <span class="comment">// 输出 ：2 1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><code>std::bind</code>的返回类型是一个stl内部定义的仿函数类型</li><li><code>std::placeholders::_1</code>是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代</li><li>组合bind函数<ul><li><code>std::bind(std::greater&lt;int&gt;(), std::placeholders::_1, 5);</code><ul><li>判断是否大于5的功能闭包</li></ul></li></ul></li></ul><h3 id="C-11通过提供std-function和std-bind统一了可调用对象的各种操作"><a href="#C-11通过提供std-function和std-bind统一了可调用对象的各种操作" class="headerlink" title="C++11通过提供std::function和std::bind统一了可调用对象的各种操作"></a>C++11通过提供std::function和std::bind统一了可调用对象的各种操作</h3><h2 id="二、lambda表达式"><a href="#二、lambda表达式" class="headerlink" title="二、lambda表达式"></a>二、lambda表达式</h2><h3 id="语法形式"><a href="#语法形式" class="headerlink" title="语法形式"></a>语法形式</h3><ul><li><code>[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</code></li><li>C++11允许省略lambda表达式返回值定义，这样编译器就会根据<code>return</code>语句自动推导出返回类型<ul><li>初始化列表不能用于返回值的自动推导 </li></ul></li><li>lambda表达式在没有参数列表时，参数列表是可以省略的</li></ul><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><ul><li><code>[]</code>不捕获任何变量</li><li><code>[&amp;]</code>捕获外部作用域中所有变量，并作为引用在函数体中使用（引用捕获）</li><li><code>[=]</code>捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）</li><li><code>[=, &amp;foo]</code>按值捕获外部作用域中所有变量，并按引用捕获foo变量</li><li><code>[bar]</code>按值捕获bar变量，同时不捕获其他变量</li><li><code>[this]</code>捕获当前类中的指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了<code>&amp;</code>或者<code>=</code>，就默认添加此选项</li><li>如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为<code>mutable</code>，如：<code>auto f2 = [=]() mutable &#123;return a++; &#125;</code></li></ul><h3 id="可以认为它是个带有operator-的类，即仿函数"><a href="#可以认为它是个带有operator-的类，即仿函数" class="headerlink" title="可以认为它是个带有operator()的类，即仿函数"></a>可以认为它是个带有operator()的类，即仿函数</h3><ul><li>可以使用<code>std::function</code>和<code>std::bind</code>来存储和操作lambda表达式  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f1 = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">void</span>)&gt; f2 = std::<span class="built_in">bind</span>([](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;, <span class="number">123</span>);</span><br></pre></td></tr></table></figure></li><li>对于没有捕获任何变量的lambda表达式，还可以被转换成一个普通的函数指针  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">int</span> (*)(<span class="type">int</span>);</span><br><span class="line"><span class="type">func_t</span> f = [](<span class="type">int</span>  a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></li><li>捕获变量的lambda表达式则不能转化为普通指针，若转换，lambda表达式本身的this指针就丢失掉了</li><li>lambda和<code>std::function</code>的效果是一样的，一般情况下可直接用lambda来代替<code>function</code></li></ul><h2 id="三、tuple元组"><a href="#三、tuple元组" class="headerlink" title="三、tuple元组"></a>三、tuple元组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>可以把它当作一个通用的结构体来用，不需要创建结构体又获取结构体的特征</li><li>在某些情况下可以取代结构体，使程序更简洁、直观</li><li>如果用tuple来替代3个以上字段的结构体时就不太合适了，不直观，易读性降低（建议）</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>创建元组<ul><li><code>tuple&lt;const char*, int&gt; tp = make_tuple(sendPack, nSendSize);</code></li><li><code>auto tp = return std::tie(1, &quot;aa&quot;, 2);</code>  // tp的实际类型是：std::tuple&lt;int&amp;, string&amp;, int&amp;&gt;</li></ul></li><li>获取元组的值  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* data = tp.<span class="built_in">get</span>&lt;<span class="number">0</span>&gt; ();  <span class="comment">// 获取第一个值</span></span><br><span class="line"><span class="type">int</span> len = tp.<span class="built_in">get</span>&lt;<span class="number">1</span>&gt; ();  <span class="comment">// 获取第二个值</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>std::tie</code>解包tuple  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">string a;</span><br><span class="line">std::<span class="built_in">tie</span>(x, a, y) = tp;</span><br></pre></td></tr></table></figure><ul><li>如果只想了解某个位置的值时，可以用<code>std::ignore</code>占位符来表示不解某个位置的值<br><code>std::tie(std::ignore, std::ignore, y) = tp;</code>  // 只解第3个值</li></ul></li></ul></li><li>创建右值引用元组<ul><li><code>forward_as_tuple</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">m.<span class="built_in">emplace</span>(std::forward_as_tuple(<span class="number">10</span>, std::<span class="built_in">string</span>(<span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>)));</span><br></pre></td></tr></table></figure><ul><li>创建了类似于<code>std::tuple&lt;int&amp;&amp;, std::string&amp;&amp;&gt;</code>类型的tuple</li></ul></li></ul></li><li>连接多个tuple<ul><li><code>tuple_cat</code></li></ul></li></ul><h2 id="四、shared-ptr共享的智能指针"><a href="#四、shared-ptr共享的智能指针" class="headerlink" title="四、shared_ptr共享的智能指针"></a>四、shared_ptr共享的智能指针</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>希望多个智能指针管理同一个资源就用shared_ptr</li><li><code>std::shared_ptr</code>使用引用计数，每一个shared_ptr的拷贝都指向相同的内存</li><li>在最后一个shared_ptr析构的时候，内存才会被释放</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>初始化<ul><li>可以通过使用构造函数、<code>std::make_shared&lt;int&gt;</code>辅助函数和<code>reset</code>方法来初始化shared_ptr  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;  <span class="comment">// 使用动态初始化，后加一个括号为值初始化</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr;</span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li>不能将一个原始指针直接赋值给智能指针</li><li>当智能指针中有值的时候，调用reset会使引用计数减1</li></ul></li><li>获取原始指针<ul><li>可以通过<code>get</code>方法来返回原始指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="type">int</span>* p = ptr.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li>指定删除器<ul><li>智能指针初始化可以指定删除器</li><li>当p的<code>引用计数</code>为0时，自动调用删除器DeleteIntPtr来释放对象的内存<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, DeleteIntPtr)</span></span>;</span><br></pre></td></tr></table></figure></li><li>也可以用lambda表达式指定删除器<ul><li><code>std::shared_ptr&lt;int&gt; p(new int, [](int* p) &#123; delete p; &#125;);</code></li></ul></li><li>当我们用<code>shared_ptr</code>管理动态数组时，需要指定删除器，因为<code>std::shared_ptr</code>的默认删除器不支持数组对象</li><li>也可以将<code>std::default_delete</code>作为删除器</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>1）不要用一个原始指针初始化多个shared_ptr</li><li>2）不要在函数实参中创建shared_ptr<ul><li>可能会因为发生异常而泄露内存</li></ul></li><li>3）通过<code>shared_from_this()</code>返回this指针<ul><li>因为this指针本质上是一个<code>裸指针</code>，因此这样可能会导致重复析构</li><li>解决方法<ul><li>让目标类通过派生<code>std::enable_shared_from_this&lt;T&gt;</code>类，然后使用基类的成员函数<code>shared_from_this</code>来返回this的shared_ptr</li></ul></li></ul></li><li>4）要避免循环引用<ul><li>智能指针最大的一个陷阱就是循环引用，循环引用会导致内存泄露</li><li>导致意外延长对象的生命期</li><li>解决方法<ul><li>使用weak_ptr</li></ul></li></ul></li></ul><h2 id="五、unique-ptr独占的智能指针"><a href="#五、unique-ptr独占的智能指针" class="headerlink" title="五、unique_ptr独占的智能指针"></a>五、unique_ptr独占的智能指针</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>希望只有一个智能指针管理资源或者管理数组就用unique_ptr</li><li>unique_ptr是一个独占型的智能指针</li><li>它不允许其他的智能指针共享其内部的指针</li><li>不允许通过赋值将一个unique_ptr赋值给另外一个unique_ptr</li><li>可以通过<code>std::move</code>来转移到其他的unique_ptr  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br><span class="line">unique_ptr&lt;T&gt; myOtherPtr = std:: <span class="built_in">move</span>(myptr);</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>如果是数组，则判断是否是定长数组<ul><li>若为定长数组则编译不通过（不能这样调用<code>make_unique&lt;T[10]&gt;(10) </code>)</li><li>若为非定长数组，则获取数组中的元素类型，再根据参数size创建动态数组的unique_ptr<ul><li><code>unique_ptr&lt;int[]&gt; ptr5 = make_unique&lt;int[]&gt;(10);</code></li></ul></li></ul></li><li>unique_ptr可以指向数组（而shared_ptr这么做不合法）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span> []&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function">ptr[9] </span>= <span class="number">9</span>;         <span class="comment">// 设置最后一个元素值为9</span></span><br></pre></td></tr></table></figure></li><li>unique_ptr指定删除器的时候需要确定删除器的类型<ul><li><code>std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int (1), [](int* p) &#123; delete p; &#125;);</code></li><li>lambda表达式在没有捕获变量的情况下是可以直接转换为函数指针的，一旦捕获了就无法转换了<ul><li><code>std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int (1), [&amp;](int* p) &#123; delete p; &#125;);</code>  // 错误，捕获了变量</li></ul></li><li>如果希望unique_ptr删除器支持lambda可以这么写<ul><li><code>std::unique_ptr&lt;int, std::function&lt;void(int*)&gt;&gt; ptr(new int(1), [&amp;](int* p) &#123; delete p; &#125;</code></li></ul></li></ul></li></ul><h2 id="六、weak-ptr弱引用的智能指针"><a href="#六、weak-ptr弱引用的智能指针" class="headerlink" title="六、weak_ptr弱引用的智能指针"></a>六、weak_ptr弱引用的智能指针</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>weak_ptr是用来监视shared_ptr的，不会使引用计数加1</li><li>它不管理shared_ptr内部的指针，主要是为了监视shared_ptr的生命周期</li><li>它的构造不会增加引用计数，它的析构也不会减少引用计数</li></ul><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>1）通过<code>use_count()</code>方法来获得当前观测资源的引用计数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 结果将输出1</span></span><br></pre></td></tr></table></figure></li><li>2）通过<code>expired()</code>方法来判断所观测的资源是否已经释放（true为无效）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wp.<span class="built_in">expired</span>())</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weak_ptr无效，所监视的智能指针已经被释放&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weak_ptr有效&quot;</span>;</span><br></pre></td></tr></table></figure></li><li>3）通过<code>lock()</code>方法来获取所监视的shared_ptr  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; gw = sp;</span><br><span class="line"><span class="keyword">auto</span> spt = gw.<span class="built_in">lock</span>();  <span class="comment">// 获取所监视的shared_ptr</span></span><br><span class="line">cout &lt;&lt; *spt &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul><h3 id="weak-ptr返回this指针"><a href="#weak-ptr返回this指针" class="headerlink" title="weak_ptr返回this指针"></a>weak_ptr返回this指针</h3><ul><li><code>std::enable_shared_from_this</code>类中有一个weak_ptr，这个weak_ptr用来观测this智能指针</li><li>调用<code>shared_from_this()</code>方法时，会调用内部这个weak_ptr的<code>lock()</code>方法，将所观测的shared_ptr返回</li><li>获取自身智能指针的函数仅在<code>shared_ptr&lt;T&gt;</code>的构造函数被调用之后才能使用，因为<code>enable_shared_from_this</code>内部的weak_ptr只有通过shared_ptr才能构造</li></ul><h3 id="可以通过weak-ptr解决循环引用问题"><a href="#可以通过weak-ptr解决循环引用问题" class="headerlink" title="可以通过weak_ptr解决循环引用问题"></a>可以通过weak_ptr解决循环引用问题</h3>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 403. 青蛙过河</title>
      <link href="/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
      <url>/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>给定石子位置的列表stones（升序），青蛙可以跳上石子，但不能跳入水中。<br>如果青蛙一步跳跃了k个单位，那么它接下来跳跃的距离只能为k-1、k或k+1个单位。<br>青蛙只能向前方跳跃。<br><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stones = [0,1,3,5,6,8,12,17]</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">青蛙可以成功过河，按照如下方案跳跃：</span><br><span class="line">跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, </span><br><span class="line">然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><p>思路：本题为二维动态规划，使用动态规划的方法，令<code>dp[i][k]</code>为跳跃k个单位能否到达第i个石子，初始化<code>dp[0][0] = true;</code>，得出状态转移方程<code>dp[i][k] = dp[j][k-1] | dp[j][k] | dp[j][k+1];</code>，其中j为上一次所在石子的编号。</p><h3 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;  <span class="comment">// 优化：跳跃距离k必定满足k &lt;= i（可推），此时为青蛙无路可跳</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;  <span class="comment">// 反向枚举</span></span><br><span class="line">                <span class="type">int</span> k = stones[i] - stones[j];  <span class="comment">// 跳跃的距离k，j为上一次所在石子的编号</span></span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;  <span class="comment">// 在第j个石子上至多跳跃j+1的单位</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n^2^)，n为石子的个数，第i个石子后方只有i-1个石子，因此在任意位置，青蛙的上一次跳跃距离至多只有n种，状态总数为 n^2^ </li><li><strong>空间复杂度</strong>：O(n^2^)，需要二维动态数组的空间，其中n是石子的数量</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP Note</title>
      <link href="/2021/04/28/tcp%20note/"/>
      <url>/2021/04/28/tcp%20note/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP详解"><a href="#TCP-IP详解" class="headerlink" title="TCP/IP详解"></a>TCP/IP详解</h1><h2 id="一、TCP超时与重传"><a href="#一、TCP超时与重传" class="headerlink" title="一、TCP超时与重传"></a>一、TCP超时与重传</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li>计时器超时称为重传超时（RTO）</li><li>若TCP累计确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文段时，快速重传会推断出现丢包</li><li>由下层网络（IP）可能出现丢失重复或失序包，TCP重传其认为已经丢失的包</li></ul><h3 id="简单的超时与重传举例"><a href="#简单的超时与重传举例" class="headerlink" title="简单的超时与重传举例"></a>简单的超时与重传举例</h3><ul><li>二进制指数退避<ul><li>每次重传间隔时间加倍</li></ul></li><li>TCP拥有两个阈值来决定如何重传同一个报文段<ul><li>R1表示TCP在向IP层传递“消极建议”（如重新评估当前路径）前，愿意尝试重传的次数</li><li>R2（大于R1）指示TCP应放弃当前连接的时机</li></ul></li></ul><h3 id="设置重传超时"><a href="#设置重传超时" class="headerlink" title="设置重传超时"></a>设置重传超时</h3><ul><li>TCP超时和重传的基础根据给定连接的RTT（往返时间）设置RTO<ul><li>若TCP先于RTT开始重传，可能会在网络中引入不必要的重复数据</li><li>若延迟远大于RTT的间隔发送重传数据，整体网络利用率（及单个连接吞吐量）会随之下降</li></ul></li><li>RTO设置得当是保证TCP性能的关键</li><li>当分组失序（或丢失）时，RTT会被过高估算。较大的RTT估计值使得RTO也更大</li><li>时间戳选项（TSOPT）使得发送端即使在丢包、延时、失序的情况下也能测量RTT</li></ul><h3 id="基于计时器的重传"><a href="#基于计时器的重传" class="headerlink" title="基于计时器的重传"></a>基于计时器的重传</h3><ul><li>对于TCP来说，计时器需要有效地实现被设置、重新设置或取消的功能</li><li>RTO的设置通常大于RTT（两倍或更大）<ul><li>因此基于计时器的重传会导致网络利用率的下降</li></ul></li><li>快速重传不需要计时器超时来触发且比超时重传更高效</li></ul><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><ul><li>快速重传机制基于接收端的反馈信息来引发重传</li><li>快速重传是根据收到重复ACK来推断出现丢包并启动重传，而不必等待重传计时器超时</li><li>快读重传仅在达到重复阈值后才被触发，而不是一旦收到重复ACK就出发，减少了大量不必要的重传发生</li></ul><h3 id="带选择确认（SACK）的重传"><a href="#带选择确认（SACK）的重传" class="headerlink" title="带选择确认（SACK）的重传"></a>带选择确认（SACK）的重传</h3><ul><li>空缺<ul><li>ACK号与接收端缓存中的其他数据之间的间隔</li></ul></li><li>失序数据<ul><li>序列号高于空缺的数据</li></ul></li><li>在很多情况下，合理采用SACK信息能更快地实现空缺填补，且能减少不必要的重传</li><li>SACK接收端行为<ul><li>SACK选项的空间有限，应尽可能确保向TCP发送端提供最新信息，其余的SACK块包含的内容也按照接收的先后依次排序</li></ul></li><li>SACK发送端行为<ul><li>SACK发送端记录接收到的累计ACK信息，还需要记录接收到的SACK信息</li><li>当SACK发送端执行重传时，通常是由于其收到了SACK或重复SACK（D-SACK）</li></ul></li><li>为提高对ACK丢失的鲁棒性，第一个SACK块中需要包含之前的重复SACK信息</li></ul><h3 id="伪超时与重传"><a href="#伪超时与重传" class="headerlink" title="伪超时与重传"></a>伪超时与重传</h3><ul><li><p>伪重传</p><ul><li>即使没有出现数据丢失也可能引发的重传</li><li>主要原因是伪超时</li></ul></li><li><p>DSACK</p><ul><li>主要目的是判断何时重传是不必要的</li><li>因此发送端至少可以判断是否发生了包失序、ACK丢失、包重复</li></ul></li></ul><h3 id="包失序与重复"><a href="#包失序与重复" class="headerlink" title="包失序与重复"></a>包失序与重复</h3><ul><li>失序<ul><li>IP层不能保证包传输是有序进行的</li><li>如果失序发生在正向链路上，TCP可能无法正确识别失序和丢包</li></ul></li><li>重复<ul><li>采用DSACK避免</li></ul></li></ul><h3 id="重新组包"><a href="#重新组包" class="headerlink" title="重新组包"></a>重新组包</h3><ul><li>定义：发送一个更大的报文段来提高性能（不能超过接收端通告的MSS，也不能大于路径MTU）</li><li>当TCP超时重传，它并不需要完全重传相同的报文段</li><li>解决了重传二义性问题</li></ul><h2 id="二、TCP数据流与窗口管理"><a href="#二、TCP数据流与窗口管理" class="headerlink" title="二、TCP数据流与窗口管理"></a>二、TCP数据流与窗口管理</h2><h3 id="交互式通信"><a href="#交互式通信" class="headerlink" title="交互式通信"></a>交互式通信</h3><ul><li>TCP流量中通常90%或者更多的TCP报文段都包含大批量数据（如Web、文件共享、电子邮件、备份），其余部分则包含交互式数据（如远程登陆、网络游戏），批量数据通常较大，而交互式数据段则会比较小</li><li>对于一个ssh连接，客户端对其传输数据加密，意味着用户输入的信息在通过连接传送前已经进行了加密</li><li>每一个交互按键通常都会生成一个单独的数据包，每个按键是独立传输的（每次一个字符而非每次一行）</li><li>每个输入字符会生成4个TCP数据段：客户端的交互击键输入、服务器对击键的确认、服务器端生成的回显、客户端对该回显的确认<ul><li>通常第二段和第三段可以合并，可将对击键的确认与回显一并传送，这种方法称为（捎带延时确认）</li></ul></li></ul><h3 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h3><ul><li>TCP并不对每个到来的数据包都返回ACK<ul><li>利用TCP的累计ACK字段就能实现该功能</li></ul></li><li>捎带传输：<ul><li>累计确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传输的数据结合发送</li></ul></li><li>TCP不能任意时长地延迟ACK，否则对方会误认以为数据丢失而出现不必要的重传</li><li>RFC指出：TCP实现ACK延迟的时延应小于500ms，实践中时延最大取200ms</li></ul><h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><ul><li>当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据），小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送</li><li>ACK返回越快，数据传输越快</li><li>传输包数目更少而长度更大，但同时传输时延也更长</li><li>Nagle算法结合ACK可能会导致某种程度的死锁（这种死锁不是永久的）</li><li>要求延时尽量小的应用，建议禁用Nagle算法<ul><li>TCP_NODELAY选项可以禁用Nagle算法</li></ul></li></ul><h3 id="流量控制与窗口管理"><a href="#流量控制与窗口管理" class="headerlink" title="流量控制与窗口管理"></a>流量控制与窗口管理</h3><ul><li>每一个TCP报文段（除了建立之初的包交换）都包含一个有效的序列号字段、一个ACK号或确认字段以及一个窗口大小字段（包含窗口通告信息）</li><li>窗口通告：表示发送该窗口信息的通信方为即将到来的新数据预留的存储空间</li><li>窗口大小：表明接收端可用缓存空间的大小</li><li>滑动窗口<ul><li>每个TCP活动连接的两端都维护一个发送窗口结构和接收窗口结构</li><li>TCP以字节（而非包）为单位维护其窗口结构</li><li>窗口左右边界的运动<ul><li>1.关闭<ul><li>即窗口左边界右移。当已发送数据得到ACK确认时，窗口会减小</li></ul></li><li>2.打开<ul><li>即窗口右边界右移。使得可发送数据量增大。当已确认数据得到处理，接收端可用缓存变大，窗口也随之变大</li></ul></li><li>3.收缩<ul><li>即窗口右边界左移</li></ul></li></ul></li></ul></li><li>零窗口与TCP持续计时器<ul><li>零窗口：左右边界相等</li><li>当接收端的通告窗口值为0时，可以有效阻止发送端继续发送，直至窗口大小恢复为非零值</li><li>当接收端重新获得可用空间时，会给发送端传输一个”窗口更新“告知其可以继续发送数据<ul><li>该窗口更新通常不包含数据（纯ACK），不能保证其传输的可靠性，容易丢包，造成死锁的发生（发送方等待收到窗口更新告知其可继续发送，接收方等待接收数据）<ul><li>解决方案：发送端会采用一个持续计时器间歇性地查询接收端，看其窗口是否已增长</li></ul></li></ul></li><li>TCP持续计时器会触发”窗口探测“的传输，强制要求接收端返回ACK（其中包含了窗口大小字段）</li><li>窗口探测包含一个字节的数据，采用TCP可靠传输（丢失重传），因此可以避免由窗口更新丢失导致的死锁<ul><li>该一个字节的数据能否被接收，取决于接收端的可用缓存空间大小</li></ul></li><li>当TCP持续计时器超时，就会触发窗口探测的发送</li><li>窗口探测的响应条件：<ul><li>至少为一个MSS</li><li>超过总接收缓存的四分之一</li></ul></li><li>可以采用指数时间退避来计算持续计时器的超时</li></ul></li><li>糊涂窗口综合征（SWS）<ul><li>基于窗口的流量控制机制，尤其是不使用大小固定的报文段情况（如TCP），可能会出现SWS</li><li>当出现该问题时，交换数据段不是全长的而是一些较小的数据段，由于每个报文段中有用数据相对头部信息的比例较小，因此耗费的资源也更多，相应的传输效率也更低</li><li>避免SWS问题<ul><li>1.对于接收端来说，不应通告小的窗口值</li><li>2.对于发送端来说，不应发送小的报文段</li><li>为了避免SWS问题，至少满足以下条件之一时才能传输报文段（发送窗口更新）<ul><li>（a）全长（发送MSS字节）的报文段可以发送</li><li>（b）数据段长度 &gt;= 接收端通告过的最大窗口的一半的，可以发送</li><li>（c）满足以下任一条件的都可以发送：<ul><li>（i）某一ACK不是目前期盼的（即没有未经确认的在传数据）</li><li>（ii）该连接禁用Nagle算法</li></ul></li></ul></li></ul></li><li>TCP需要避免窗口收缩</li><li>优先级：避免窗口收缩 &gt; 避免SWS</li></ul></li><li>大容量缓存与自动调优<ul><li>使用较小接收缓存的TCP应用的吞吐性能更差</li><li>自动调优<ul><li>高效地自动分配缓存大小</li><li>窗口值随着接收数据的增多而增大</li></ul></li></ul></li><li>紧急机制<ul><li>紧急指针字段被设置后，发送端生成的每个TCP头部都包含该字段</li><li>所有序列号大于紧急指针的数据都经接收端确认</li></ul></li></ul><h2 id="三、TCP拥塞控制"><a href="#三、TCP拥塞控制" class="headerlink" title="三、TCP拥塞控制"></a>三、TCP拥塞控制</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><ul><li>TCP拥塞控制的难点在于怎样准确地判断何时需要减缓且如何减缓TCP传输，以及何时恢复其原有速度</li><li>当网络中大量的发送方和接收方被要求承担超负荷的通信任务时，可以考虑采取(降低发送速率)或者(最终丢弃部分数据)的方法</li><li>拥塞<ul><li>路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象</li></ul></li></ul><h3 id="TCP拥塞检测"><a href="#TCP拥塞检测" class="headerlink" title="TCP拥塞检测"></a>TCP拥塞检测</h3><ul><li>针对丢包情况，TCP采取的首要机制是重传<ul><li>超时重传</li><li>快速重传</li></ul></li><li>丢包被用作判断拥塞发生与否的值标</li><li>在有线网络中，出现在路由器或交换机中的拥塞是造成丢包的主要原因</li><li>在无线网络中，传输和接收错误是导致丢包的重要因素</li></ul><h3 id="减缓TCP发送"><a href="#减缓TCP发送" class="headerlink" title="减缓TCP发送"></a>减缓TCP发送</h3><ul><li>TCP头部设置的通知窗口大小字段，是TCP发送方调节发送速率的依据</li><li>TCP发送端发送速率 = min{接收速率，传输速率}</li><li>拥塞窗口（cwnd）<ul><li>反映网络传输能力的变量</li></ul></li><li>发送端实际可用窗口W = min{cwnd，通知窗口(awnd)}</li><li>在外数据值<ul><li>已经发出但还未经确认的数据量大小</li><li>当TCP不使用选择确认机制时，W的限制作用体现为发送方发送的报文段序列号不能大于ACK号的最大值与W之和</li><li>当TCP使用选择确认机制时，W用来限制在外数据值</li></ul></li><li>带宽延迟积（BDP）也称作最佳窗口大小<ul><li>若在传输数据值远高于BDP时，会引入不必要的延时</li></ul></li></ul><h3 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h3><ul><li>TCP通过与接收端交换一个数据包来获得awnd的值</li><li>获得cwnd最佳值的唯一方法是以越来越快的速率不断发送数据，直到出现数据包丢失（或网络拥塞）为止</li><li>拥塞控制操作是由ACK的接收来驱动或“控制”的</li><li>接收到ACK回复表明发送的数据包已被成功接收，因此可以继续发送操作</li><li>自同步<ul><li>由一个ACK到达（称作ACK时钟）触发一个新数据包传输的关系</li></ul></li><li>在稳定传输状态下，整个系统可“自同步”控制</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ul><li>当一个新的TCP连接建立或检测到由重传超时（RTO）导致的丢包时，需执行慢启动</li><li>TCP发送端长时间处于空闲状态也可能调用慢启动算法<ul><li>在这种情况下cwnd初始值将被设置为重启窗口（RW），RW = min（IW，cwnd）</li></ul></li><li>慢启动的目的<ul><li>使TCP在用拥塞避免探寻更多可用宽带之前得到cwnd值，以帮助TCP建立ACK时钟</li></ul></li><li>慢启动算法防止短时间内大量数据注入导致拥塞</li><li>TCP以发送一定数目的数据段开始慢启动（在SYN交换之后），称为初始窗口（IW）</li><li>SMSS = min（接收方MSS，MTU）</li><li>慢启动算法会以min（N，SMSS）来增加cwnd值，N是指在未经确认的传输数据中能通过这一”新接收的ACK号大于之前收到的ACK号“确认的字节数</li><li>快速ACK模式<ul><li>TCP操作只在慢启动阶段完成后才返回ACK</li></ul></li></ul><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul><li>在慢启动阶段，cwnd会快速增长，帮助确立一个慢启动阈值，一旦达到阈值，就意味着可能有更多可用的传输资源。如果立即全部占用这些资源，将会使共享路由器队列的其他连接出现严重的丢包和重传情况，从而导致整个网络性能不稳定</li><li>一旦确立慢启动阈值，TCP会进入拥塞避免阶段</li><li>拥塞避免阶段窗口随时间线性增长，而慢启动阶段呈指数增长<ul><li>cwnd1 = cwnd0+（1/k）*SMSS</li></ul></li></ul><h3 id="慢启动和拥塞避免的选择"><a href="#慢启动和拥塞避免的选择" class="headerlink" title="慢启动和拥塞避免的选择"></a>慢启动和拥塞避免的选择</h3><ul><li>某个TCP连接总是选择运行慢启动和拥塞避免中的一个，不会出现两者同时运行的情况</li><li>当cwnd&lt;ssthresh，使用慢启动算法</li><li>当cwnd&gt;ssthresh，使用拥塞避免</li><li>当cwnd=ssthresh，任何一种算法都可以使用</li><li>慢启动阈值ssthresh不是固定的，是随时间改变的</li><li>慢启动阈值的主要目的是，在没有丢包发生的情况下，记住上一次”最好的“操作窗口估计值</li><li>ssthresh = max（在外数据值/2，2*SMSS）</li><li>如果出现重传情况，慢启动阈值减小至当前窗口大小的一般（但不小于2*SMSS）</li></ul><h3 id="标准TCP"><a href="#标准TCP" class="headerlink" title="标准TCP"></a>标准TCP</h3><ul><li>当接收到一个好的ACK（表明新的数据传输成功）cwnd会相应更新<ul><li>cwnd += SMSS 慢启动</li><li>cwnd += SMSS*SMSS/cwnd 拥塞避免</li></ul></li><li>当收到三次重复ACK（或其他表明需要快速重传的信号）时，会执行以下行为<ul><li>1.ssthresh更新为大于等式ssthresh = min（在外数据值/2，2*SMSS）的值</li><li>2.启用快速重传算法，将cwnd设为（ssthresh+3*SMSS）</li><li>3.每接收一个重复ACK，cwnd值暂时增加1 SMSS</li><li>4.当接收到一个好的ACK，将cwnd重设为ssthresh</li></ul></li></ul><h3 id="转发确认（FACK）和速率减半"><a href="#转发确认（FACK）和速率减半" class="headerlink" title="转发确认（FACK）和速率减半"></a>转发确认（FACK）和速率减半</h3><ul><li>为避免出现等待空闲而又不违背将拥塞窗口减半的做法，提出了转发确认（FACK）策略</li><li>带界定参数的速率减半（RHBP）<ul><li>基本操作：在一个RTT时间内，每接收两个重复ACK，TCP发送方可发送一个新的数据包</li><li>RHBP中区分了调整间隔（cwnd的修正阶段）和恢复间隔（数据重传阶段）</li></ul></li><li>速率减半是调节发送操作或避免集中发送的方法</li></ul><h3 id="限制传输"><a href="#限制传输" class="headerlink" title="限制传输"></a>限制传输</h3><ul><li>TCP发送方每接收两个连续的重复ACK，就能发送一个新数据包</li><li>TCP因此可以避免长时间等待RTO而导致吞吐性能下降</li><li>速率减半也是限制传输的一种形式<h3 id="拥塞窗口校验（CWV）"><a href="#拥塞窗口校验（CWV）" class="headerlink" title="拥塞窗口校验（CWV）"></a>拥塞窗口校验（CWV）</h3></li><li>在发送长时间暂停的情况下，由ssthresh维护cwnd保存的”记忆”，之后cwnd值会衰减。</li><li>需要区分空闲发送端和应用受限发送端</li><li>CWV算法原理：当需要发送新数据时，首先看距离上次发送操作是否超过一个RTO，如果超过则<ul><li>更新ssthresh值，设为max（ssthresh，（3/4）*cwnd）</li><li>每经一个空闲RTT时间，cwnd值就减半，但不小于1 SMSS</li><li>对应用受限阶段<ul><li>已使用的窗口大小为W_used</li><li>更新ssthresh的值，设为max（ssthresh，（3/4）*cwnd）</li><li>cwnd设置为cwnd和W_used的平均值</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C# Note</title>
      <link href="/2021/04/28/c#%20Note/"/>
      <url>/2021/04/28/c#%20Note/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li>表达式主体方法<ul><li>=&gt;操作符引用构成方法主体的表达式，而且没有return语句。表达式的值自动作为返回值；如果表达式不返回值，则方法自动为void方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResult</span>(<span class="params"><span class="built_in">int</span> answer</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>差值表达式<ul><li>$符号表明这是个差值字符串，{和}之间的任何表达式都需求值并置换，字符串差值比+操作符高效得多  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>只有<code>float</code>和<code>double</code>除以0得到<code>Infinity</code>（不会出错）</li><li><code>int</code>的最大最小值<code>int.MaxValue</code>和<code>int.MinValue</code></li><li>隐式类型变量<code>var</code>,作用类似于C++的<code>auto</code></li></ul><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><ul><li>与C++不一致<br>  -<code>if</code>语句中表达式必须是布尔值, 如：<code>if (1)</code> // 错误</li><li><code>switch</code>语句的控制表达式不能用<code>float</code>和<code>double</code>类型</li><li><code>case</code>标签必须是常量表达式，且必须唯一</li><li>C#语句的直通规则<ul><li>直通，标签之间不能有额外语句（即不加<code>break</code>，不允许拥有语句）</li><li>每个<code>case</code>都加上<code>break</code></li></ul></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>C#所有方法都必须在类的内部声明</li><li>默认参数中如果参数匹配则不会出现歧义</li><li>默认参数（可选参数）必须放在后面</li><li>具名参数<ul><li><code>optMethod(first: 99, third: &quot;Word&quot;);</code>  // 传递具名参数（参数名:传递的值），实参可以按任意顺序传递，second参数使用<code>默认值</code></li></ul></li></ul><h2 id="结构（结构体）"><a href="#结构（结构体）" class="headerlink" title="结构（结构体）"></a>结构（结构体）</h2><ul><li>与C++不一致，结构主体后不加<code>;</code></li><li>值类型<ul><li>对于简单的、比较小的数据值，复制值的效率等同于或基本等同于复制地址的效率，但较复杂的数据就考虑使用类，这样就可选择只复制数据的地址，从而提高代码的执行效率</li></ul></li><li>不能为结构声明默认构造器（无参构造器），否则无法编译，因为编译器始终会自动生成默认构造器（不同于类）</li><li>类的实例字段可在声明时初始化，但结构不允许  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> hours = <span class="number">0</span>;  <span class="comment">// 编译时错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译器不会自动初始化结构中的字段（与类不一致）</li><li>复制结构变量的前提时<code>=</code>操作符右侧的结构变量已完全初始化，否则编译错误</li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li>与C++不一致，枚举主体后不加<code>;</code></li><li>值类型</li><li>声明枚举时字面值默认是int类型，可以选择枚举的基础类型<ul><li><code>enum Season : short &#123; Spring, Summer &#125;</code></li></ul></li><li>为枚举的字面值显式指定常量整数值<ul><li><code>enum Season &#123; Spring = 1, Summer &#125;</code></li></ul></li><li>编译器自动为它指定比前一个枚举字面值大1的值</li><li>多个枚举字面值可以具有相同的基础值<ul><li><code>enum Season &#123; Spring, Summer, Fall, Autumn = Fall &#125;</code></li></ul></li><li>每个枚举定义的字面值名称都只有这个枚举类型的作用域，因此要加枚举类型限定，否则编译错误，如：Season.Fall</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p>与c++不一致，类主体、结构主体后不加分号</p></li><li><p>每个字段和方法声明都要重复<code>public</code>或<code>private</code>关键字</p></li><li><p>省略控制可访问性，默认为<code>private</code></p></li><li><p>类被拆分到多个文件中之后，要在每个文件中使用<code>partial</code>（分部）关键字定义类的不同部分</p></li><li><p>如果把方法或字段声明为<code>static</code>，就可使用类名调用方法或访问字段，而不用先创建对象</p></li><li><p>静态方法只能访问标记为<code>static</code>的其他方法和字段</p></li><li><p>类外访问类中的<code>static</code>字段要以，类名作为前缀，<code>class.function</code></p></li><li><p>静态方法也称为类方法</p></li><li><p>静态字段称为静态字段或静态变量</p></li><li><p>只有数值类型、字符串类型和枚举类型的字段才能声明为const字段</p></li><li><p>静态类</p><ul><li>只能包含静态成员</li><li><code>public static class Math</code></li></ul></li><li><p>using语句允许将类引入作用域，以便在访问静态成员时省略类名</p><ul><li><code>using static System.Math;</code></li></ul></li><li><p>匿名类</p><ul><li>匿名类就是没有名字的类</li><li>不知道类的名称可以使用隐式类型变量来创建正确类型的对象  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAnonymousObject = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">47</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>值类型</p><ul><li>基元类型</li></ul></li><li><p>引用类型</p><ul><li><code>string</code>在运行时动态分配内存</li><li>声明类变量时，编译器分配一小块内存，其中刚好可以容纳一个地址。以后类实际占用内存块的地址会填充到这里。该地址成为对内存块的引用</li><li>实际占用的内存<ul><li>使用<code>new</code>关键字创建对象时分配的内存</li></ul></li></ul></li><li><p>引用类型的变量包含的是引用，引用本身存储在栈上，但该引用指向堆上的对象</p></li><li><p>类可以提供clone方法来返回自己的新实例，并填充相同数据</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Circle <span class="title">Clone</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Circle clone = <span class="keyword">new</span> Circle();</span><br><span class="line">    clone.radius = <span class="keyword">this</span>.radius;</span><br><span class="line">    <span class="comment">// 返回包含克隆数据的新Circle对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果包含任何引用类型的字段，这种引用类型也需要提供Clone方法，否则只是“浅拷贝”，如果提供了Clone方法，能够复制引用的对象，就成为“深拷贝”</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle(<span class="number">42</span>);</span><br><span class="line">Circle copy = <span class="keyword">new</span> Circle(<span class="number">99</span>);</span><br><span class="line">copy = c;</span><br></pre></td></tr></table></figure></li><li><p>这时候copy原来的引用被回收了（垃圾回收机制）</p></li></ul></li><li><p>空条件操作符（问号加在变量名称之后）</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(c?.Area());</span><br></pre></td></tr></table></figure><ul><li>空条件操作符告诉”运行时“在操作符所应用的变量为null的前提下忽略当前语句</li></ul></li><li><p>可空类型</p><ul><li><code>null</code>本身就是引用，不能把它赋值给值类型</li><li>可将变量声明为可空值类型<ul><li><code>int? i = null;</code></li></ul></li><li>可将恰当值的表达式直接赋给可空变量<ul><li><code>i = j;</code></li></ul></li><li>不可将可空的值赋给普通的值类型变量<ul><li><code>j = i;</code></li></ul></li><li>可空类型的两个属性<ul><li><code>HasValue</code><ul><li>判断可空类型是包含一个值，还是包含null</li></ul></li><li><code>Value</code><ul><li>只读的属性</li><li>读取变量的值，但不能修改</li></ul></li></ul></li></ul></li><li><p>引用传参</p><ul><li><code>ref</code>参数<ul><li>要求实参和形参前都加上<code>ref</code>关键字<ul><li><code>DoWork(ref i)</code>;</li></ul></li><li>要求在传参之前必须初始化</li></ul></li><li><code>out</code>参数<ul><li>要求实参和形参前都加上<code>out</code>关键字</li><li>要求在方法中必须初始化，传参前不要求</li></ul></li></ul></li><li><p><code>object</code>类型</p><ul><li><code>object</code>类型的变量能引用任何引用类型的任何对象</li></ul></li><li><p><code>装箱</code></p><ul><li>将值类型赋给<code>object</code>类型的变量<ul><li><code>object o = 42;</code></li></ul></li><li>数据项从栈自动复制到堆的行为</li><li>与泛型异曲同工</li></ul></li><li><p><code>拆箱</code></p><ul><li>将引用了已装箱的值的object引用强制转换成值类型<ul><li><code>int a = (int)o;</code></li></ul></li><li>必须强制转换</li></ul></li><li><p>装箱和拆箱会产生较大的开销</p><ul><li>它们设计不少检查工作，且需要分配额外的堆内存</li></ul></li><li><p>数据的安全转型</p><ul><li>左操作数为对象，右操作数为类型<ul><li>is操作符<ul><li>if (o is WrappedInt)</li><li>如果is表达式正确，结果为true，反之为false</li></ul></li><li>as操作符<ul><li>WrappedInt temp = o as WrappedInt;</li><li>若转换成功，就返回转换成功的结果，失败则为null</li></ul></li></ul></li></ul></li><li><p>在c#中使用c指针必须将代码标记为<code>unsafe</code></p><ul><li><code>unsafe</code>关键字可标记代码块或整个方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">swap</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>命名规范</p></li><li><p>公共标识符以大写字母开头</p></li><li><p>非公共标识符（包括局部变量）以小写字母开头</p></li><li><p>类名以大写字母开头</p></li><li><p>均采用驼峰命名法</p></li><li><p><code>TODO:</code>注释通常用于标注以后将进行加工的代码</p></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><code>checked</code>语句是<code>checked</code>关键字开头的代码块<ul><li>只有直接在checked块中的整数运算才会检查</li><li>溢出则抛出<code>OverflowException</code></li><li><code>checked</code>和<code>unchecked</code>关键字只适合整型运算</li><li>浮点运算永不抛出异常</li></ul></li><li><code>catch</code>省略名称默认捕获<code>Exception</code><ul><li>异常发生后将运行由”运行时“发现的第一个匹配的异常处理程序<code>catch</code>，其他处理程序会被忽略</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link href="/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>打印出二叉树中节点值的和为输入整数的所有路径（从根节点一直到叶子节点的路径）<br><strong>输入</strong>：<br>给定如下二叉树，以及目标和 target = 22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><p>由根节点出发，首先想到先序遍历的思路</p><h3 id="2-1-回溯"><a href="#2-1-回溯" class="headerlink" title="2.1 回溯"></a>2.1 回溯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">      vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">      <span class="type">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">FindPath</span>(root, target, path, currentSum, ans);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; path, <span class="type">int</span> currentSum, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先序遍历</span></span><br><span class="line">      currentSum += root-&gt;val;  <span class="comment">// 更新当前路径</span></span><br><span class="line">      path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">      <span class="comment">// 如果是叶子节点，并且路径上的节点的和等于输入的值，则打印这条路径</span></span><br><span class="line">      <span class="type">bool</span> isLeaf = root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (currentSum == target &amp;&amp; isLeaf) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若不是叶子节点，则遍历它的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在返回父节点之前，在路径上删除当前节点</span></span><br><span class="line">      path.<span class="built_in">pop_back</span>();  <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(N)，N为二叉树的节点数，需要遍历所有节点</li><li><strong>空间复杂度</strong>：O(N)，最差情况下即树退化成链表，path存储所有树节点，使用O(N)额外空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 684. 冗余连接</title>
      <link href="/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
      <url>/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>找出无向图中的冗余连接，即将无向图还原成二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><h3 id="2-1-并查集"><a href="#2-1-并查集" class="headerlink" title="2.1 并查集"></a>2.1 并查集</h3><p>思路：通过并查集寻找附加的边，初始时每个节点都属于不同的连通分量，遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量</p><ul><li>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</li><li>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[index]]); </span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      parent[<span class="built_in">Find</span>(parent, x)] = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(klogk)，其中k是图中的节点个数</li><li>空间复杂度：O(n)</li></ul><h3 id="2-2-使用-按秩合并-路径压缩-的并查集"><a href="#2-2-使用-按秩合并-路径压缩-的并查集" class="headerlink" title="2.2 使用==按秩合并+路径压缩==的并查集"></a>2.2 使用==按秩合并+路径压缩==的并查集</h3><p>优化了空间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[parent[index]]);  <span class="comment">// 路径压缩，使树的层数更少</span></span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      <span class="type">int</span> i = <span class="built_in">Find</span>(parent, x), j = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">      <span class="comment">// 按秩合并</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">// 如果i的秩大于j的秩</span></span><br><span class="line">        parent[j] = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[i] = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(klogk)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql Note</title>
      <link href="/2021/04/28/mysql%20note/"/>
      <url>/2021/04/28/mysql%20note/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul><li>表名是唯一的</li><li>表中的数据是按行存储的</li><li>行（别名 记录）</li><li>主键：一列，其值能够区分表中每个行<ul><li>每个行都必须有一个主键值（不允许为NULL）</li><li>任意两行都不具有相同的主键值</li><li>不更新主键列中的值</li><li>不在主键列中使用可能会更改的值</li></ul></li><li>命令用分号；结束</li><li>连接到mysql需要以下信息<ul><li>主机名：本地服务器为localhost</li><li>端口：默认为3036</li><li>一个合法的用户名</li><li>用户口令（如果需要的话）</li></ul></li><li><code>use&lt;数据库名字&gt;</code>来选择数据库</li><li><code>show databases</code>返回可用数据库的一个列表</li><li><code>show tables</code>返回该数据库内的可用表的一个列表</li><li><code>show columns from &lt;表名&gt;</code> = <code>describe &lt;表名&gt;</code>来显示表中的所有列</li><li>自动增量：Mysql可以自动地为每个行分配下一个可用的编号，需要create语句</li><li><code>show status</code>显示广泛的服务器状态信息</li><li><code>show create databases/table</code>分别用来显示创建特定数据库或表的语句</li><li><code>show grants</code>显示授予用户的安全权限</li><li><code>show errors</code>和<code>show warnings</code>显示服务器错误或警告信息</li></ul><h2 id="二、SELECT语句"><a href="#二、SELECT语句" class="headerlink" title="二、SELECT语句"></a>二、SELECT语句</h2><ul><li><code>SELECT &lt;列名&gt; FROM &lt;表名&gt;</code>在表中检索单个列<blockquote><p>SELECT检索多个列，列名用逗号分隔<br>检索所有列，用<code>*</code>通配符</p></blockquote></li><li>sql语句不区分大小写</li><li>SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写</li><li>处理SQL语句空格会被忽略</li><li><code>SELECT DISTINCT ... FROM</code>返回不重复的行（distinct要放在列名前面）</li><li>使用完全限定的表名<code>SELECT db.host FROM mysql.db</code></li><li><code>FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT</code>是<code>SELECT</code>的子句，其出现次序必须为上述顺序，次序不对将产生错误信息</li><li><code>ORDER BY</code>子句取一个或多个列的名字对输出进行排序<blockquote><p>默认为asc升序，在列名后加<code>DESC</code>关键字按降序排列，desc关键字只应用到直接位于其前面的列名</p></blockquote></li><li><code>GROUP BY</code>子句，分组允许把数据分为多个逻辑组</li><li><code>HAVING</code>和<code>WHERE</code>的区别：<code>HAVING</code>过滤分组，<code>WHERE</code>过滤行</li><li><code>WHERE</code>是<code>SELECT</code>的子句（在from子句之后给出）用来指定搜索条件</li><li><strong>WHERE子句操作符</strong></li></ul><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">不等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在指定的两个值之间</td></tr></tbody></table><ul><li>空值检查(<code>is NULL</code>子句)<code>where...is NULL;</code></li><li><code>WHERE</code>子句给出了<code>AND, OR, IN, NOT</code>逻辑操作符来进行逻辑操作</li></ul><h2 id="三、匹配"><a href="#三、匹配" class="headerlink" title="三、匹配"></a>三、匹配</h2><ul><li>通配符本身实际是SQL的<code>WHERE</code>子句中有特殊含义的字符，在搜索子句中使用通配符，必须使用<code>LIKE</code>操作符，<code>LIKE</code>只是Mysql后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较</li><li>百分号<code>%</code>通配符匹配任意个数的任意字符，下划线<code>_</code>通配符匹配任意单个字符</li><li>使用通配符的技巧<ul><li>不要过度使用通配符</li><li>把通配符置于搜索模式的开始处搜索起来是最慢的</li></ul></li><li><code>WHERE</code>的子句中<code>REGEXP</code>子句使用正则表达式，在<code>REGEXP</code>关键字后加上<code>BINARY</code>来区分匹配表达式的大小写<br>例：      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Db, User FROM db </span><br><span class="line">WHERE Db REGEXP BINARY &#x27;.ys&#x27;;</span><br></pre></td></tr></table></figure></li><li>匹配正则表达式内具有特殊意义的所有字符都必须以\\的方式转义</li></ul><p><strong>常用字符类</strong></p><table><thead><tr><th align="center">类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">任意字母和数字（同[a-zA-Z0-9])</td></tr><tr><td align="center">[:alpha:]</td><td align="center">任意字符（同[a-zA-Z]）</td></tr><tr><td align="center">[:blank:]</td><td align="center">空格和制表</td></tr><tr><td align="center">[:cntrl:]</td><td align="center">ASCII控制字符</td></tr><tr><td align="center">[:digit:]</td><td align="center">任意数字</td></tr><tr><td align="center">[:graph:]</td><td align="center">与[:print:]相同，但不包括空格</td></tr><tr><td align="center">[:lower:]</td><td align="center">任意小写字母</td></tr><tr><td align="center">[:print:]</td><td align="center">任意可打印字符</td></tr><tr><td align="center">[:space:]</td><td align="center">任意空白字符</td></tr><tr><td align="center">[:upper:]</td><td align="center">任意大写字母</td></tr><tr><td align="center">[:xdigit:]</td><td align="center">任意十六进制数</td></tr></tbody></table><p><strong>重复元字符</strong></p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>0个或多个匹配</td></tr><tr><td>+</td><td>1个或多个匹配（等于{1,}）</td></tr><tr><td>?</td><td>0个或1个匹配（等于{0,1}）</td></tr><tr><td>{n}</td><td>指定数目的匹配</td></tr><tr><td>{n,}</td><td>不少于指定数目的匹配</td></tr><tr><td>{n,m}</td><td>匹配数目的范围</td></tr></tbody></table><p><strong>定位元字符</strong></p><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">文本的开始</td></tr><tr><td align="center">$</td><td align="center">文本的结束</td></tr><tr><td align="center">[[:&lt;:]]</td><td align="center">词的开始</td></tr><tr><td align="center">[[:&gt;:]]</td><td align="center">词的结束</td></tr></tbody></table><ul><li>正则表达式中<code>.</code>表示匹配任意一个字符</li><li><code>LIKE</code>与<code>REGEXP</code>的区别，<code>LIKE</code>匹配整个串，<code>REGEXP</code>匹配子串</li><li>简单的正则表达式测试，例：<code>SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;</code></li><li><code>SELECT</code>语句中，<code>concat()</code>函数用来拼接字段（与列的意思相同），别名用<code>AS</code>关键字赋予，<code>RTrim()</code>函数去掉右边的所有空格<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat(Db, &#x27;(&#x27;, User, &#x27;)&#x27;) AS link</span><br><span class="line">FROM db;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、相关函数"><a href="#四、相关函数" class="headerlink" title="四、相关函数"></a>四、相关函数</h2><ul><li><code>Soundex()</code>函数匹配所有发音类似与Y.Lie的联系名<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE Soundex(cust_contact) = Soundex(&#x27;Y. Lie&#x27;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>常用数值处理函数</strong></p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Abs()</td><td align="center">返回一个数的绝对值</td></tr><tr><td align="center">Cos()</td><td align="center">返回一个角度的余弦</td></tr><tr><td align="center">Exp()</td><td align="center">返回一个数的指数值</td></tr><tr><td align="center">Mod()</td><td align="center">返回余数</td></tr><tr><td align="center">Pi()</td><td align="center">返回圆周率</td></tr><tr><td align="center">Rand()</td><td align="center">返回一个随机数</td></tr><tr><td align="center">Sin()</td><td align="center">返回一个角度的正弦</td></tr><tr><td align="center">Sqrt()</td><td align="center">返回一个角度的平方根</td></tr><tr><td align="center">Tan()</td><td align="center">返回一个角度的正切</td></tr></tbody></table><p><strong>常用时间和日期处理函数</strong></p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">AddDate()</td><td align="center">增加一个日期（天、周等)</td></tr><tr><td align="center">AddTime()</td><td align="center">增加一个时间（时、分等）</td></tr><tr><td align="center">CurDate()</td><td align="center">返回当前日期</td></tr><tr><td align="center">Date()</td><td align="center">返回日期时间的日期部分</td></tr><tr><td align="center">DateDiff()</td><td align="center">计算两个日期之差</td></tr><tr><td align="center">Date_add()</td><td align="center">高度灵活的日期运算函数</td></tr><tr><td align="center">Date_Format()</td><td align="center">返回格式化的日期或时间率</td></tr><tr><td align="center">Day()</td><td align="center">返回一个日期的天数部分</td></tr><tr><td align="center">DayOfWeek()</td><td align="center">对于一个日期，返回对应的星期</td></tr><tr><td align="center">Hour()</td><td align="center">返回一个日期的小时部分</td></tr><tr><td align="center">Minute()</td><td align="center">返回一个日期的分钟部分</td></tr><tr><td align="center">Month()</td><td align="center">返回一个日期的月份</td></tr><tr><td align="center">Now()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">Second()</td><td align="center">返回一个时间的秒部分</td></tr><tr><td align="center">Time()</td><td align="center">返回一个日期时间的时间部分</td></tr><tr><td align="center">Year()</td><td align="center">返回一个日期的年份部分</td></tr></tbody></table><ul><li>子查询，嵌套<code>SELECT</code>语句<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE prod_id = &#x27;TNT2&#x27;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、联结表"><a href="#五、联结表" class="headerlink" title="五、联结表"></a>五、联结表</h2><ul><li><code>WHERE</code>子句在联结表中起配对的作用（用完全限定列名）</li><li>没有联结条件的表关系返回的结果为笛卡尔积（检索出的行的数目将是第一个表中的行数乘以第二个表中的行数）</li><li>应保证所有联结都有<code>WHERE</code>子句</li><li>使用在<code>WHERE</code>子句中使用<code>AND</code>可以联结多个表</li><li>等值连接也称为内部联结</li><li>尽量使用自联结而不用子查询</li><li><strong>联结的方式</strong><br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20210428125629111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2ODAyNzEz,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="联结"></li><li>外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系</li><li>外键的意义：在于解耦合，定义外键的方法<code>FOREIGN KEY (主键）references &lt;表名&gt;(另一个表的主键）</code></li></ul><h2 id="六、组合查询"><a href="#六、组合查询" class="headerlink" title="六、组合查询"></a>六、组合查询</h2><ul><li>组合查询，必须由两条<code>SELECT</code>语句组成，语句之间用<code>UNION</code>关键字分隔</li><li><code>UNION</code>的每个查询必须包含相同的列，表达式或聚集函数</li><li>使用<code>UNION</code>时重复的行会被自动取消（默认行为），若想返回所有的匹配行可以用<code>UNION ALL</code></li><li>在使用<code>UNION</code>组合查询时，只能使用一次<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后</li></ul><h2 id="七、全文本搜索"><a href="#七、全文本搜索" class="headerlink" title="七、全文本搜索"></a>七、全文本搜索</h2><ul><li>全文本搜索会对结果排序，具有较高优先等级（文本中靠前的等级高）的行先返回，搜索默认不区分大小写</li><li>在创建表时跟句子句<code>Fulltext(列名)</code>对它进行索引，函数<code>Match()</code>指定被搜索的列，函数<code>Against()</code>指定要使用的搜索表达式，搭配<code>WHERE</code>子句进行筛选</li><li>使用查询扩展<code>Against(&#39;anvils&#39; WITH QUERY EXPANSION)</code>，找出和搜索相关的其他行</li></ul><h2 id="八、操作数据"><a href="#八、操作数据" class="headerlink" title="八、操作数据"></a>八、操作数据</h2><ul><li><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><ul><li><code>INSERT INTO &lt;表名&gt; (需要插入值的列名) values (给每个列提供一个值)</code></li><li>没有列出的值默认为NULL</li><li><code>INSERT INTO</code>搭配<code>SELECT</code>可以从旧表复制数据到新表</li></ul></li><li><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><ul><li><code>UPDATE &lt;表名&gt; SET 列=值</code></li><li>要更新的表</li><li>列名和他们的新值</li><li>确定要更新行的过滤条件</li></ul></li><li><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li><code>DELETE FROM &lt;表名&gt; WHERE 匹配的列</code></li><li>删除表中所有行<code>TRUNCATE TABLE</code>语句</li></ul></li><li><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul><li><code>CREATE TABLE &lt;表名&gt;(行及相应值)</code></li><li>表的主键可以在创建表时用<code>PRIMARY KEY</code>关键字指定，主键值必须唯一，多个主键使用<code>,</code>分割</li><li>若仅想在一个表不存在时创建它，应该在表名后给出<code>if not exists</code></li><li>指定<code>not null</code>时在插入或更新行时，该列必须有值</li><li><code>AUTO_INCREMENT</code>告诉mysql每当增加一行时自动增量</li><li>每个表只允许一个<code>AUTO_INCREMENT</code>列</li></ul></li><li><h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><ul><li><code>ALTER TABLE &lt;表名&gt; ADD &lt;列&gt; 列的数据类型</code></li></ul></li><li><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><ul><li><code>DROP TABLE &lt;表名&gt;</code></li></ul></li><li><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><ul><li><code>RENAME TABLE &lt;表名&gt; to &lt;重命名的表名&gt;</code> </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lua Note</title>
      <link href="/2021/04/28/Lua%20Note/"/>
      <url>/2021/04/28/Lua%20Note/</url>
      
        <content type="html"><![CDATA[<h2 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h2><ul><li><code>lua -i</code>，<code>-i</code>参数用于在运行完其他命令行参数后进入交互模式</li><li>不在交互模式下必须把表达式包在函数<code>print</code>的调用中</li><li>如果不想输出结果，可以在行末加上一个<code>;</code></li></ul><h2 id="词法规范"><a href="#词法规范" class="headerlink" title="词法规范"></a>词法规范</h2><ul><li><p>标识符由任意字母、数字和下划线组成的字符串（不能以数字开头）</p></li><li><p><code>_</code>+大写字母（特殊用途）</p></li><li><p><code>_</code>+小写字母（哑变量）</p></li><li><p>注释</p><ul><li>单行注释<code>--</code></li><li>多行注释<br>  <code>--[[   多行注释 ]]</code></li></ul></li><li><p>分隔符<code>;</code></p><ul><li>增加可读性，不是必须的</li></ul></li><li><p>表达式之间的换行不起任何作用</p></li></ul><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul><li>无须声明即可使用</li><li>使用未经初始化的全局变量，得到的结果时<code>nil</code></li><li><code>nil</code>赋值给全局变量时，Lua会回收该全局变量</li></ul><h2 id="类型和值"><a href="#类型和值" class="headerlink" title="类型和值"></a>类型和值</h2><ul><li><p>Lua语言有8种基本类型</p><ul><li><p><code>nil</code>（空）</p><ul><li>nil赋值给全局变量时，则相当于将其删除（Lua会回收）</li></ul></li><li><p><code>boolean</code>（布尔）</p><ul><li>除false和nil之外的所有值都为真（与C++差异）</li><li>not运算符永远返回boolean类型的值<ul><li><code>not nil</code>  – true</li><li><code>not false</code> – true</li></ul></li></ul></li><li><p><code>number</code>（数值）</p></li><li><p><code>string</code>（字符串）</p></li><li><p><code>userdata</code>（用户数据）</p><ul><li>允许把任意的C语言数据保存在Lua语言变量中</li></ul></li><li><p><code>function</code>（函数）</p></li><li><p><code>thread</code>（线程）</p></li><li><p><code>table</code>（表）</p></li></ul></li><li><p><code>type</code>函数</p><ul><li>获取一个值对应的类型</li><li>返回值永远是一个字符串</li></ul></li></ul><h2 id="独立解释器"><a href="#独立解释器" class="headerlink" title="独立解释器"></a>独立解释器</h2><ul><li><p>是一个可以直接使用Lua语言的小程序</p></li><li><p>源代码文件第一行以井号<code>#</code>开头，那么解释器在加载文件时会忽略这一行，主要是为了方便在POSIX系统中将Lua作为一种脚本解释器来使用</p></li><li><p>假设独立解释器位于<code>/usr/local/bin</code>下</p><ul><li><code>#!/usr/local/bin/lua</code> 或<br><code>#!/usr/bin/env lua</code><ul><li>不需要显式调用Lua语言解释器也可以直接运行Lua脚本</li></ul></li></ul></li><li><p>编译器在运行代码前会创建一个名为arg的表</p><ul><li>索引0中保存的内容为脚本名<ul><li><code>arg[0]</code></li></ul></li><li>索引1保存的内容为第一个参数<ul><li><code>arg[1]</code></li></ul></li><li>以此类推</li></ul></li><li><p>Lua语言也支持可变长参数(…)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
