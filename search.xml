<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSAPP Ch3</title>
      <link href="/2022/05/19/CSAPP-Ch3/"/>
      <url>/2022/05/19/CSAPP-Ch3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>书籍推荐</title>
      <link href="/2022/05/18/Recommended_books/"/>
      <url>/2022/05/18/Recommended_books/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一些好书推荐(强烈建议)，可以按照大类先后阅读。以下的书我绝大多数都看过，希望能在接下来有限的时间里都阅读完吧 <span id="more"></span></p></blockquote><h4 id="说在前面preliminary">说在前面(Preliminary)</h4><ul class="task-list"><li><input type="checkbox" disabled>The C Programming Language (K&amp;R)</li><li><input type="checkbox" disabled checked>C++ Primer</li><li><input type="checkbox" disabled checked>Algorithm 4</li><li><input type="checkbox" disabled checked>Computer System: A Programmer's Perspective</li></ul><h4 id="computer-architecture">Computer Architecture</h4><ul class="task-list"><li><input type="checkbox" disabled checked>Introduction to Computing Systems: From Bits and Gates to C</li><li><input type="checkbox" disabled checked>Computer Organization and Design: The Hardware-Software Interface</li><li><input type="checkbox" disabled>Computer Architecture: A Quantitative Approach (6th Edition)</li></ul><h4 id="operating-system">Operating System</h4><ul class="task-list"><li><input type="checkbox" disabled checked>Operating Systems: Three Easy Pieces(OSTEP)</li><li><input type="checkbox" disabled>Operating Systems Principles &amp; Practice (2nd Edition)</li><li><input type="checkbox" disabled>xv6 book</li><li><input type="checkbox" disabled checked>Advanced Programming Unix Environment</li></ul><h4 id="database">Database</h4><ul class="task-list"><li><input type="checkbox" disabled>Database System Concepts (Seventh Edition)</li></ul><h4 id="computer-networks">Computer Networks</h4><ul class="task-list"><li><input type="checkbox" disabled>Computer Networking: A Top Down Approach (8th Edition)</li></ul><h4 id="distributed-systems">Distributed Systems</h4><ul class="task-list"><li><input type="checkbox" disabled>Designing Data-Intensive Application</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Ch2</title>
      <link href="/2022/05/18/CSAPP-Ch2/"/>
      <url>/2022/05/18/CSAPP-Ch2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第二章后面部分Yale patt讲的比较清楚，因此在读第二遍的时候就没有继续总结了</p></blockquote><span id="more"></span><h1 id="信息的表示和处理"><strong>信息的表示和处理</strong></h1><ul><li>编译器维护着数据类型的信息，机器级程序不包含所谓的数据类型信息。</li><li>可以将2的幂次十进制数通过<span class="math inline">\(n=i+4*j\)</span>这个公式来直接转换成十六进制数。其中<span class="math inline">\(0\leq i\leq3\)</span>， 1(i=0), 2(i=1), 4(i=2), 8(i=3)，可以把十六进制数写成高位是<code>i</code>对应的值，后面跟<code>j</code>个0。如：<span class="math inline">\(2^{11}\)</span>转换成十六进制数，<span class="math inline">\(n=11=3+4\times2\)</span>，<code>i</code>对应的值是8，后面跟2个0，得到的结果是<code>0x800</code></li><li><code>大端字节序/网络字节序</code>: 最高有效字节在最前面; <code>小端字节序/主机字节序</code>: 最低有效字节在最前面</li><li><code>ISA</code>可以同时拥有两种以上顺序模式，如：ARM。而具体决定使用什么字节顺序由操作系统来决定。</li><li>书中提到了<code>指针和数组</code>，想起来<code>P&amp;H</code>中提到过C语言中两者的性能差距。通过观察汇编代码可以发现，数组Loop判断越界下标需要在循环体内计算边界条件的地址，相比较于指针loop完成额外的乘法运算(花更多的指令)</li><li><code>强制转换(cast)</code>并不会改变指针的内容，只是告诉<code>编译器</code>以新的<code>数据类型</code>来看待转换后的数据。</li><li><strong>商用的Achitecture按字节编址寻址</strong></li><li><code>strlen()</code>不计算字符串末尾的空字符; <code>sizeof()</code>会计算末尾的空字符的大小</li><li><code>ASCII</code>和<code>UTF-8</code>编码只占用1个字节，而<code>Unicode</code>占用2~4字节</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Ch1</title>
      <link href="/2022/05/18/CSAPP-Ch1/"/>
      <url>/2022/05/18/CSAPP-Ch1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计算机系统总是如此的吸引人</p></blockquote><span id="more"></span><h1 id="计算机系统漫游"><strong>计算机系统漫游</strong></h1><ul><li>计算机系统是由<strong>硬件</strong>和<strong>系统软件</strong>组成的</li><li>源程序中由<code>ASCII</code>字符构成的文件称为<strong>文本文件</strong>, 所有其他文都称为<strong>二进制文件</strong></li><li>预处理阶段预处理器根据以字符<code>#</code>开头的命令，修改原始C程序，读取系统头文件的内容，并把它直接插入程序文本中，如： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">--</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure> <img src="/2022/05/18/CSAPP-Ch1/img-2022-05-17-23-21-05.png"></li><li><code>字(word)</code>: 总线传送定长字节块的大小</li><li>磁盘驱动器(HDD)简单说其实就是磁盘</li><li>适配器: 插在主板插槽的卡(比如图形适配器，显示屏); 控制器：I/O设备本身或系统主板上的芯片组</li><li>在键盘上读取<code>hello</code>命令。通过将数据读取到<code>KBDR</code>中(中间涉及到ASCII到Binary的转换)，再将<code>KBDR</code>中的数据存入主存中。整个过程需要CPU参与，引出了概念<code>可编程I/O</code> <img src="/2022/05/18/CSAPP-Ch1/img-2022-05-17-23-29-59.png"></li><li>因此也延伸出了优化的方案(使用<code>DMA</code>) <img src="/2022/05/18/CSAPP-Ch1/img-2022-05-17-23-34-32.png"></li><li>将字符串显示到显示器上。通过将数据写入到<code>DDR</code>中(要将Binary转换为ASCII)，再将<code>DDR</code>中的数据显示到图形适配器上 <img src="/2022/05/18/CSAPP-Ch1/img-2022-05-17-23-35-01.png"></li><li><code>Cache</code>产生的原因：随着时间的推移<code>DRAM</code>的性能和<code>Disk</code>相差三个数量级; Cache充分利用了<strong>局部性原理</strong>。</li><li><code>Posix标准</code>：标准化<code>Unix</code>的开发</li><li><code>上下文切换</code>涉及到<code>PC</code>和<code>寄存器组</code>的Save和Restore <img src="/2022/05/18/CSAPP-Ch1/img-2022-05-17-23-40-48.png" alt="存储器层次结构"></li><li>进程虚拟内存中的内容存储在磁盘上，而主存作为磁盘的缓存, 造成<code>容量又大速度又快</code>的假象。 <img src="/2022/05/18/CSAPP-Ch1/img-2022-05-17-23-44-21.png" alt="进程虚拟地址空间"></li><li>Unix I/O的读写系统调用为<code>逻辑读写</code></li><li>通过<code>网络适配器</code>可以在不同主机之间在交换主存中的数据</li><li><code>Amdahl's law</code>: <span class="math inline">\(S=\frac{1}{(1-\alpha)+\alpha/k}\)</span>, 其中<span class="math inline">\(S\)</span>为加速比, <span class="math inline">\(\alpha\)</span>为所需执行时间占总时间的比例, <span class="math inline">\(k\)</span>为该部分性能提升的比例; 其中<code>2.2倍</code>可以表示为<code>2.2x</code></li><li><code>TLP</code>, <code>ISP</code>, <code>SIMD</code></li><li><img src="/2022/05/18/CSAPP-Ch1/img-2022-05-18-11-24-10.png" title="fig:" alt="Abstraction"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Letex Note</title>
      <link href="/2022/05/18/Letex-Note/"/>
      <url>/2022/05/18/Letex-Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下记录一些本人常用的公式, 因为deploy之后对部分公式支持较差，因此有部分删减 <span id="more"></span></p></blockquote><h4 id="数学模式"><strong>1. 数学模式</strong></h4><ol type="1"><li>行内公式(inline math)<code>$...$</code>与文本融为一体。</li><li>独立公式(display math)<code>$$..$$</code>独立成段，复杂公式包括微积分方程等都是采用行间公式</li><li>LaTex注释符号为<code>%</code></li></ol><h4 id="输入上下标"><strong>2. 输入上下标</strong></h4><p><code>^</code>表示上标，<code>_</code>表示下标</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>i<span class="built_in">^</span>na<span class="built_in">_</span>i<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><ul><li>显示: <span class="math display">\[\sum_i^na_i\]</span></li></ul><h4 id="输入分数"><strong>3. 输入分数</strong></h4><p>分数的输入形式<code>\frac&#123;分子&#125;&#123;分母&#125;</code></p><ul><li>例子: <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p(v)=<span class="keyword">\frac</span>&#123;1&#125;&#123;1+exp(-v/t)&#125;</span><br></pre></td></tr></table></figure></li><li>显示:</li></ul><p><span class="math display">\[p(v)=\frac{1}{1+exp(-v/t)}\]</span></p><h3 id="输入根号"><strong>4. 输入根号</strong></h3><ul><li>例子: <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;12&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\sqrt</span>[n]&#123;12&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li><li>显示: <span class="math display">\[\sqrt{12} \\\sqrt[n]{12}\]</span></li></ul><table><thead><tr class="header"><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr class="odd"><td></td><td><span class="math inline">\(\langle\)</span></td><td></td><td><span class="math inline">\(\rangle\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\lceil\)</span></td><td></td><td><span class="math inline">\(\rceil\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\lfloor\)</span></td><td></td><td><span class="math inline">\(\rfloor\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\lbrace\)</span></td><td></td><td><span class="math inline">\(\rbrace\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\lvert\)</span></td><td></td><td><span class="math inline">\(\rvert\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\lVert\)</span></td><td></td><td><span class="math inline">\(\rVert\)</span></td></tr></tbody></table><h4 id="积分"><strong>7.积分</strong></h4><ul><li>例子: <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>0<span class="built_in">^</span>1&#123;x+1&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li><li>显示: <span class="math display">\[ \int_0^1{x+1} \]</span></li></ul><h4 id="极限运算"><strong>8. 极限运算</strong></h4><p>使用<code>\lim_&#123;变量 \to 表达式&#125;&#123;表达式&#125;</code>来输入一个极限。 - 例子: <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> <span class="keyword">\infin</span>&#125;<span class="keyword">\frac</span>&#123;1&#125;&#123;n+1&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure> - 显示: <span class="math display">\[\lim_{x \to \infin}\frac{1}{n+1}\]</span></p><h4 id="累加乘积运算"><strong>9. 累加乘积运算</strong></h4><p>使用<code>\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125;</code>来输入一个累加。与之类似，使用 <code>\prod</code>, <code>\bigcup</code>, <code>\bigcap</code>来分别输入累乘、并集和交集。 - 例子: <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n&#123;<span class="keyword">\frac</span>&#123;1&#125;&#123;i<span class="built_in">^</span>2&#125;&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure> - 显示: <span class="math display">\[\prod_{i=1}^n{\frac{1}{i^2}}\]</span></p><h4 id="希腊字符"><strong>10. 希腊字符</strong></h4><table><thead><tr class="header"><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr class="odd"><td></td><td><span class="math inline">\(\alpha\)</span></td><td></td><td><span class="math inline">\(\xi\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\gamma\)</span></td><td></td><td><span class="math inline">\(\sigma\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\epsilon\)</span></td><td></td><td><span class="math inline">\(\Delta\)</span></td></tr><tr class="even"><td></td><td><span class="math inline">\(\lambda\)</span></td><td></td><td><span class="math inline">\(\rho\)</span></td></tr><tr class="odd"><td></td><td><span class="math inline">\(\delta\)</span></td><td></td><td><span class="math inline">\(\theta\)</span></td></tr></tbody></table><h4 id="参考文献"><strong>参考文献</strong></h4><p>[1] <a href="https://www.zybuluo.com/codeep/note/163962#9%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5%E6%9E%81%E9%99%90%E8%BF%90%E7%AE%97">Cmd Markdown 公式指导手册</a></p><p>[2] <a href="https://www.cnblogs.com/nowgood/p/latexstart.html">MarkDown 中使用 LaTeX 数学式</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61B Lec Note</title>
      <link href="/2022/05/18/CS61B-Lec-Note/"/>
      <url>/2022/05/18/CS61B-Lec-Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Data Structure in Java</p></blockquote><span id="more"></span><h1 id="cs61b-data-structure-notes">CS61B Data Structure Notes</h1><h1 id="java-syntax"><strong>Java Syntax</strong></h1><ul><li>Java除了8种基本类型(按值传递)<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>boolean</code>, <code>char</code>之外，其他一切，包括<code>数组</code>，不是原始类型，而是<code>Reference Type</code>(引用类型)，说白了就是指针。</li><li>声明任何引用类型(Reference Type)的变量，java会分配一个64-bit的box，这64-bit种不包含数据(如对象的属性等)，而是包含该数据的在内存中的地址。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;             </span><br><span class="line">b = a;                <span class="comment">// 将a在内存中的地址赋给b，使a和b指向同一内容。</span></span><br></pre></td></tr></table></figure></li><li>嵌套类(Nested Class)。经验法则：如果不使用外部类的任何实例成员，则将嵌套类定义为<code>static</code>。因为被声明为static的嵌套类不能访问外部类的实例成员, 同时也节约了内存。</li><li>文件名必须和类名相同，每个文件必须只包含一个外部类。</li><li>泛型(Generic Type)仅适用于引用类型，尖括号内不能放入原始类型比如:int, double, 但是可以放入原始类型的引用版本，如: <code>Integer</code>, <code>Double</code>, <code>Character</code>, <code>Boolean</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code>, <code>Float</code>。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;genericTypeName&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> genericTypeName item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(IntNode _prev, genericTypeName _item, IntNode _next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = _prev;</span><br><span class="line">            <span class="built_in">this</span>.item = _item;</span><br><span class="line">            <span class="built_in">this</span>.next = _next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLList</span><span class="params">(genericTypeName x)</span> &#123;</span><br><span class="line">        prev = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        DDList&lt;String&gt; d1 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        DDList&lt;Integer&gt; d2 = <span class="keyword">new</span> <span class="title class_">DDList</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 上一行代码和这行是相等的实例化尖括号声明类型可以省略</span></span><br><span class="line">        DDList&lt;Integer&gt; d2 = <span class="keyword">new</span> <span class="title class_">DDList</span>&lt;Integer&gt;(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>创建数组的三种方法: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">y = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] z = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;   <span class="comment">// 类似第二种方法，但只能和声明结合时使用</span></span><br></pre></td></tr></table></figure></li><li>java数组仅在运行时执行边界检查。System.arraycopy()方法非常方便使用。</li><li><code>[]</code>允许我们在运行时指定想要的索引，而类中指定字段就不行。</li><li>创建泛型对象数组的方法(虽然java不允许，而且编译器会报错) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glorp[] items = (Glorp []) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure></li><li>判断两个字符串是否相等使用<code>equals</code>而不是<code>==</code>的原因是，<code>==</code>比较的是地址，而<code>equals</code>比较的是存储单元中的值。</li><li>java不允许使用<code>&gt;</code>运算符在字符串之间比较，而是用<code>str1.compareTo(str2)</code>来进行比较，如果相等则返回0，str1 &gt; str2则返回一个正数。</li><li><code>org.junit</code>库提供了很多方法来简化测试的编写, <a href="https://junit.org/junit4/javadoc/4.12/org/junit/Assert.html">Junit官方文档</a>; <code>import static org.junit.Assert.*</code> <code>import org.junit.Test</code>之后，就可以省略掉<code>org.junit.Assert</code>前缀，进而直接使用<code>assertEquals</code>方法; 需要在每个方法前加上<code>@org.junit.Test</code>来替代<code>@Test</code>, IDEA中Junit可视化测试是根据<code>@Test</code>标签在运行时自动检测的。</li><li>获取String的第i个字符的方法<code>str.charAt(i)</code>。</li><li>Java中字符使用单引号，字符串则使用双引号。</li><li><code>public class AList&lt;Item&gt; implements List61B&lt;Item&gt;&#123;...&#125;</code>, implements, 接口继承，子类可以使用父类的方法，也可以覆盖父类的方法; <code>AList</code>将保证拥有并定义<code>List61B</code>接口中指定的所有属性和方法; <code>AList</code> is a <code>List61B</code>, 他们之间是<code>is a</code>关系; 在<code>AList</code>中实现<code>List61B</code>的方法时，<code>@Override</code>是必要的, 这是为了提醒编译器通知你可能发生的错误。</li><li><code>List61B&lt;Item&gt; lst = new AList&lt;&gt;();</code>完成多态。</li><li><code>StdRandom</code>库生成随机数<a href="https://introcs.cs.princeton.edu/java/stdlib/javadoc/StdRandom.html">文档</a>。</li><li><code>assertEquals(message, expected, actual)</code>, JUnit测试失败时输出有用信息, 将预期值和实际值作为<code>message</code>。</li><li>Difference between <code>implement</code> and <code>extends</code>。</li><li>实现继承<code>extends</code>(is a关系, 继承...)关键字，子类继承父类的所有成员包括(构造函数不被继承)：<ul><li>所有实例和静态变量</li><li>所有方法</li><li>所有嵌套类</li></ul></li><li>在子类的构造函数中需要调用父类的构造函数，在子类的构造函数中使用<code>super()</code>关键字。原因: 比如<code>TA extends Human</code>(TA is a Human), 先需要创建一个人，接着创建TA才有意义; 当然如果我们不这样做，Java会<strong>自动</strong>调用super类的<code>无参构造函数</code>。</li><li>Java中的每个类都是<code>Object Class</code>或者是它的后代(descendant), 类没有<strong>显示地</strong>extends仍然会<strong>隐式地</strong>extends <code>Object Class</code>。</li><li>Java可以用<code>interface</code>(接口)类型来充当函数指针。</li><li>通过接口继承来定义一个比较接口<code>CompareTo</code>，解决<code>Object</code>对象之间不能比较的问题。</li><li>抽象数据类型(Abstract Data Type), 简称ADT, 指的是一种数据类型，只带有行为，没有任何具体的方式来实现展示这些行为(抽象的); <code>java.util</code>库中包含三个最重要的ADT:<ul><li><img src="https://pic4.zhimg.com/80/v2-a8b3d43d066476b5c6eafbcdc5071c5a.png" title="fig:" alt="白色框是接口, 蓝色框是具体的类"></li><li><code>List</code>, 比较流行的实现是(ArrayList)<code>List&lt;String&gt; lst = new ArrayList&lt;String&gt;();</code></li><li><code>Set</code>, 比较流行的实现是(HashSet)<code>Set&lt;String&gt; ss = new HashSet&lt;&gt;();</code></li><li><code>Map</code>。比较流行的实现是(HashMap)<code>Map&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;();</code></li></ul></li><li>接口(interface)的特性:<ul><li>所有方法都必须是<code>public</code></li><li>所有变量都必须是<code>public static final</code>，<code>final</code>类似于cpp的<code>const</code></li><li>无法实例化</li><li><strong>默认情况</strong>下，所有方法都是<code>abstract</code>的，除非指定为<code>defualt</code></li><li>每个类可以<code>Implements</code>多个<code>Interface</code>。</li></ul></li><li>抽象类(Abstract类似cpp), 介于<code>interface</code>和<code>concrete class</code>之间。<ul><li>方法可以是<code>public</code>也可以是<code>private</code>，或者<code>protected</code></li><li>可以有任何类型的变量</li><li>无法实例化</li><li><strong>默认情况</strong>下，方法是<code>concrete</code>的，除非指定为<code>abstract</code></li><li>每个类只能<code>Implements</code>一个<code>Abstract</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GraphicObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meveTo</span><span class="params">(<span class="type">int</span> newX, <span class="type">int</span> newY)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>wrapper class(包装类)，如int的包装类是Integer。Java可以在原始类型和包装类型(也成为引用类型)之间进行<strong>隐式转换</strong>。两个方向的转换成为装箱(box)(int-&gt;Integer), 拆箱(unbox)(Integer-&gt;int); 注意:<ul><li>数组永远不会自动装箱或自动拆箱</li><li>自动装箱和拆箱会对性能产生影响</li><li>包装类型比原始类型使用更多的内存, 关于内存使用信息的拓展<a href="http://www.javamex.com/tutorials/memory/object_memory_usage.shtml">此链接</a>或<a href="http://blog.kiyanpro.com/2016/10/07/system_design/memory-usage-estimation-in-java/">链接</a></li></ul></li><li>Java同如CPP这样的语言，会自动隐式向上类型转换，若占用字节较大的类型转换为较小的类型则需要手动去转换。</li><li>不可变数据类型，如String或加上<code>final</code>关键字修饰的基本类型。<ul><li>优点：防止错误并使调试更容易</li><li>缺点：需要创建一个新对象才能更改属性。</li></ul></li><li>在Java中异常是对象，抛出异常的格式<code>throw new IllegalArgumentException("can't add null");</code></li><li>在Java中可以定义一个迭代器接口, 如ADT需使用则<code>extend</code>或者Implement这个接口，需要有next, hasNext方法。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Java中创建<code>Package</code>(类似于cpp的namespace), 存储package的文件夹名称应该和包一致 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ug.joshh.animal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>JAR</code>文件就像zip文件一样，完全可以将文件解压缩并转换回.java文件。</li><li>public、protected、package-private、private的访问控制权限:<img src="https://pic4.zhimg.com/80/v2-6d77a6127e21f7f37c62dd23bf1df0b9.png" alt="Image"></li><li>Java中操作文件，查看<a href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html">File javadocs</a>和使用<code>Utils.java</code>类，该类具有许多有用的文件操作辅助函数。</li><li>序列化(seralize), 将java<strong>对象</strong>序列化为文件(持久性)，通过implements<code>Serializable</code>接口</li><li>使用<code>Utils</code>类(proj Gitlet提供的子集)中的辅助函数来序列化和反序列化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Model m;</span><br><span class="line"><span class="type">File</span> <span class="variable">outFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializing the Model object</span></span><br><span class="line">writeObject(outFile, m);</span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line">Model m;</span><br><span class="line"><span class="type">File</span> <span class="variable">inFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deserializing the Model object</span></span><br><span class="line">m = readObject(inFile, Model.class);</span><br></pre></td></tr></table></figure></li><li>可变参数形式<code>static void writeContents(File file, Object... contents)</code></li><li>常用ADT的操作<ul><li>Stacks<ul><li><code>push(int x)</code>: 将x放在栈顶</li><li><code>int pop()</code>: 获取栈顶元素</li></ul></li><li>Lists<ul><li><code>add(int i)</code>: 添加一个元素</li><li><code>int get(int i)</code>: 获取索引i处的元素</li></ul></li><li>Sets<ul><li><code>add(int i)</code>: 添加一个元素</li><li><code>contains(int i)</code>: 返回集合是否包含值得布尔值</li></ul></li><li>Maps<ul><li><code>put(K key, V value)</code>: 将键值放入哈希表中</li><li><code>V get(K key)</code>: 获取key对应得值</li></ul></li></ul></li><li>Java泛型<a href="https://docs.oracle.com/javase/tutorial/java/generics/bounded.html">bounded type parameter</a></li><li><code>Collection</code>可以由许多不同的数据结构实例化</li></ul><h1 id="idea-skill"><strong>IDEA Skill</strong></h1><ul><li>左键点击行号的右侧打断点</li><li>条件断点，在断点的基础上右键增加条件。进入Debug模式后，拖动console到右侧可以同时显示console和Debugger。</li><li>比较好用的Plugin: <code>Java visualizer</code>, <code>IdeaVim</code>, IDEA自带的<code>Sheck Style</code>。</li><li><code>Step into</code> vs. <code>Step over</code>, Step into进入函数，而Step over则不进入函数直接向下执行。<code>Step out</code>跳出函数。</li><li><code>Resuming</code>类似于continue，跳到条件断点的下一个条件，在step over的左下侧向右的绿色箭头</li><li><code>Destructive</code> vs. <code>Non-Destructive</code>, 非破坏性调用函数没有修改传入的数据结构，相反破坏性则修改了传入的数据结构。</li><li>创建JAR文件<ul><li>File -&gt; Project Structure -&gt; Artifacts -&gt; JAR -&gt; "From modules with dependencies</li></ul></li><li>IDEA将生成的<code>.class</code>文件存储在<code>out</code>或<code>target</code>文件夹中。</li></ul><h1 id="algorithm"><strong>Algorithm</strong></h1><h2 id="big-thetatheta来代替order-of-growth增长级"><strong>1.(Big-Theta<span class="math inline">\(\Theta\)</span>来代替order of growth(增长级))</strong></h2><pre><code>- Only consider the worst case.- Pick a representative operation (aka: cost model)- Ignore lower order terms- Ignore multiplicative constants.</code></pre><h2 id="并查集"><strong>2.并查集</strong></h2><h3 id="属性和方法">属性和方法</h3><pre><code>- Connect()- isConnect()- find()- parent[]</code></pre><h3 id="优化">优化</h3><ol type="1"><li>路径压缩 <span class="math display">\[lg^*n := \begin{cases}0, &amp; \text {if n $\leq$ 1}\\ 1+lg^*(lgn), &amp; \text{if n $&gt;$ 1} \end{cases}\]</span> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">        id[p] = id[id[p]]; <span class="comment">// 路径压缩，使得下次查找更快</span></span><br><span class="line">        p = id[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>按秩合并</li></ol><ul><li>规则：将<code>height</code>较小的Set连接到<code>height</code>较大的Set ## <strong>3.渐近线分析</strong> 并不是所有两层for循环的复杂度都为<span class="math inline">\(\Theta(N^2)\)</span>, 比如下面这个for loop的复杂度为<span class="math inline">\(C(N) = 1 + 2 + 4 + ... + N = 2N-1\)</span>(如何N为2的幂) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printParty</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j += <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);   </span><br><span class="line">            <span class="type">int</span> <span class="variable">ZUG</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 递归, 复杂度为<span class="math inline">\(C(N) = 1 + 2 + 4 + 8 + ... + 2^{N-1} = 2(2^{N-1})-1 = 2^N-1 = \Theta(N)\)</span> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> f3(n-<span class="number">1</span>) + f3(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <span class="math inline">\(O\)</span>(<code>Big O</code>)是<span class="math inline">\(\Theta\)</span>(<code>Big Theta</code>)在不考虑最好情况和最坏情况下的表示, 在不同的输入，运行时间不同的情况下，它允许我们做出没有实例(case)限定的简单语句</li><li><span class="math inline">\(\Theta\)</span>形式表示增长级(Order of growth)为<span class="math inline">\(F(N)\)</span></li><li><span class="math inline">\(\Omega\)</span>表示增长级小于等于<span class="math inline">\(F(N)\)</span></li><li><span class="math inline">\(\Omicron\)</span>表示增长级大于等于<span class="math inline">\(F(N)\)</span> ## <strong>4.归并排序(Merge Sort)</strong> 结合选择排序来理解，在选择排序上进行优化<span class="math inline">\(\Theta(nlogn)\)</span>, 额外开辟一个存储结果的空间，利用双指针获得最后的排序数组。</li></ul><h2 id="均摊amortized分析"><strong>5.均摊(Amortized)分析</strong></h2><p><span class="math inline">\(\Phi_i = \Phi_{i-1} + a_i - c_i\)</span>, 其中<span class="math inline">\(c_i\)</span>是操作的真实开销，<span class="math inline">\(a_i\)</span>是随机摊销操作的开销，在所有<span class="math inline">\(i\)</span>中必须一致。假设<span class="math inline">\(\Phi_0 = 0\)</span>。 ## <strong>6.二叉搜索树(BST Binary Search Trees)</strong> 除了含有二叉树的属性外，对于树中的每个节点X，要求左子树中的每个键都小于X的键，右子树中的每个键都大于X的键。需要成员为<code>root</code>, 具备的私有内嵌类有<code>BSTNode</code>，其中的成员为<code>key</code>, <code>value</code>, <code>left</code>, <code>right</code>, <code>node count</code>。 ### 插入<code>put</code> - 总是在叶节点插入, 递归找到<code>null</code>节点后创建一个node count为1的<code>Node</code>。 ### 删除 - 被删除节点没有子节点, 直接删除它的父指针 - 被删除节点有1个子节点，将父节点的子指针分配给被删除节点的子节点 - 被删除节点有2个子节点，由新的节点来替换，必须要大于左子树，且小于右子树, 即取右子树的<code>min</code>或者左子树的<code>max</code>两种解决方案。<strong>Hibbard deletion</strong>，维护好删除节点后后BST的平衡性, 要实现的方法有<code>ceiling</code>, <code>floor</code>, <code>deleteMin</code>, <code>deleteMax</code>。 ### 注意 - <code>get</code>递归返回值，而<code>put</code>递归返回一个子树。 ### 属性 - <code>depth</code>, <code>height</code>, <code>average depth</code>: <img src="https://pic4.zhimg.com/80/v2-e925732ad6e4f45795982fe471a6eed9.png" alt="BST"> <span class="math display">\[Average Depth = \frac{\sum^D_{i=0}d_in_i}{N}\]</span> 其中<span class="math inline">\(d_i\)</span>为depth, <span class="math inline">\(n_i\)</span>为当前层节点的数目 <img src="https://pic4.zhimg.com/80/v2-ecdf853a69118f5400c7fa20e1986555.png" alt="BST"> ### BST存在的问题 我们总是在叶子节点处插入，这是导致高度增加的原因。插入顺序不同会导致高度不同。 - 树的<strong>高度</strong>决定了最坏情况的运行时间， - 树的<strong>平均深度</strong>决定了平均情况的运行时间。 <img src="https://pic4.zhimg.com/80/v2-8010a66ab4fb46d6c67ecb5f5f433b84.png" alt="BST"> ## <strong>7.B树(B-Trees)</strong> - B树很好地避免了BST存在的问题, 最糟糕搜索情况为<span class="math inline">\(O(N)\)</span>——以链表的形式展开 - BigO <span class="math inline">\(\not =\)</span> Worst Case - L非常大的情况，在数据库和文件系统中会出现。 - <code>2-3树</code>, 通常指明<code>L</code>(每个节点中项(item)的最大数量)为2，而<code>2-3</code>指的是可以拥有的孩子节点的数量为2或3。 - <code>max-degree</code>指的是所能拥有最多孩子节点的个数, <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B树可视化模拟</a>。 ### B树不变量(Invariant) 保证了B树的<code>bushy</code>。 - 所有叶子节点到根节点有着<strong>相同</strong>的距离 - 含有<code>k</code>项的节点一定含有<code>k+1</code>个子节点。 ### B树的插入 - 向叶子节点中插入，沿着树向下遍历以及根据当前节点项的大小左右遍历 - 将节点添加到叶子节点后，如果项数&gt;L, 则弹出<strong>中左</strong>(middle left)项，加入到父节点中重新排列。 - 如果父节点的项数也大于L，则再次弹出<strong>中左</strong>项目 - 重复完成此过程，直到父节点可以容纳或到达根节点。 ### 搜索B树运行时最坏情况分析 - 总运行时间<span class="math inline">\(O(LlogN)\)</span>, 搜索在树中最大的数，遍历到底部需要<span class="math inline">\(O(logN)\)</span>, 向右遍历得到最大数需要<span class="math inline">\(O(L)\)</span>, 因为当前节点有有L个项。 ### B树的删除 分以下几种情况, 打算做到15445的proj2 B+Tree的时候再review B树删除操作的<a href="https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g508ece10b0_1_1305">slide</a> - Case 1: Multi-Key Sibling - Case 2: Multi-Key Parent - Case 3: Single-Key Parent and Sibling ### B树的特性总结 - Nodes may contain between<code>1</code>and<code>L</code>items. - contains works almost exactly like a normal BST. - add works by adding items to existing leaf nodes. - If nodes are too full, they split. - Resulting tree has perfect balance. Runtime for operations is <span class="math inline">\(O(logN)\)</span>. - B-trees are more complex, but they can efficiently handle ANY insertion order. - B树实现起来比较复杂，相对来说比较慢 ## <strong>8. 红黑树(Red-Black Trees)</strong> - left-Leaning Red Black Binary Search Tree (LLRB) ### 属性 - 不存在节点含有两个<code>red links</code>(意味着4个item一个节点，在2-3树中是不存在的)。 - 叶子节点到root的<code>black links</code>数一致。 ### 规则 - 在2-3树，插入时总是使用<code>red links</code>。 - 通过旋转使得<code>red links</code>在左侧。右侧的<code>Red links</code>是不允许的, 除了<code>temporary 4 node</code>即含有两个red links的子节点 - 如果出现2个连续的左侧连接，则通过右旋转来调整为<code>temporary 4 node</code> - 含有<code>temporary 4 node</code>, 即含有两个red links的子节点, 则<code>color clip</code>来模拟BST的<code>split</code>. <code>Color Flip</code>指将当前节点的两个<code>red links</code>变黑，并将父节点的<code>black links</code>变红。如果当前节点为根节点则，则不存在将父节点变红这一步。 ### 红黑树总结 - 61B的<a href="https://docs.google.com/presentation/d/1jgOgvx8tyu_LQ5Y21k4wYLffwp84putW8iD7_EerQmI/edit#slide=id.g463de7561_042">demo</a>通过insert来理解红黑树的特性。 - 红黑树和B树的复杂度一致 - 将BST转化为红黑树的代码实现<img src="https://pic4.zhimg.com/80/v2-7cd7df921c5da3080ef5c0d352e71b84.png" alt="Image"></p><h2 id="哈希"><strong>9. 哈希</strong></h2><ul><li>Properties of HashCode(哈希值)<ul><li>必须是整数</li><li><code>.hashCode()</code>在同一对象上运行两次，应该返回相同的数字</li><li>被考虑的两个对象<code>.equal()</code>必须具有相同的哈希码</li></ul></li><li>实际上哈希表key-value对，在Java中key在哈希表中的索引是由<code>hashCode()</code>成员函数生成的。</li><li>溢出会引起冲突(出现在哈希值过大的情况下)，比如最大的整型数加1会变成最小的整型数</li><li>避免冲突的方式，取模而不是无限地增大空间。</li><li>尝试用链表数组(ArrayList), 即数组元素为链表，来作为哈希的空间，处理碰撞的复杂度<span class="math inline">\(\Theta(Q)\)</span>, 因为<code>add</code>和<code>contains</code>需要检查当前链表数组元素(即链表)的第<code>Q</code>项是否为存在。最坏的情况下为所有项目的hashCode都是相同的，因此需要<span class="math inline">\(\Theta(N)\)</span>。</li><li>利用<strong>模运算</strong>来减少bucket的数量了。 ### 动态增长哈希表</li><li>假设含有<code>M</code>个Bucket和<code>N</code>个items。Bucket相当于一个链表数组的一个元素。<img src="https://pic4.zhimg.com/80/v2-12a66211e25a00cd7ba604f07378324e.png" alt="Image"></li><li>每隔一段时间就<strong>Double</strong> M创建一个新的哈希表，来确保时间复杂度为<span class="math inline">\(\Theta(N/M)\)</span>即<span class="math inline">\(\Theta(1)\)</span>。</li><li>遍历旧的哈希表，将元素一个个地添加到新的哈希表中。因为哈希表大小的改变，元素对哈希表大小的模数也会发生变化。</li><li><code>Load Factor</code>(即N/M)等于上述最好情况(Best case)的运行时间。如果<code>N</code>在增加，Load Factor也将会持续增加</li><li><code>Load Factor Threshold</code>，当Load factor大于load factor threshold时就<code>resize</code>。 resize需要<span class="math inline">\(\Theta(N)\)</span>的时间，因为需要将N个items添加到哈希表中，每个添加需要<span class="math inline">\(\Theta(1)\)</span>的时间。</li><li>注意: 当resize时，不需要检查项目是否已经存在于Linkedlist中(因为知道没有重复项)，所以<code>Add</code>只需要<span class="math inline">\(\Theta(1)\)</span>的时间 ### 经验法则</li><li>使用<code>base</code>策略，即模数。</li><li>使用一个小的质数作为<code>base</code>。素数非偶特性有助于避免溢出问题，以及更容易计算等等。 ### 注意</li><li>当一个目标变量改变，它的哈希值也改变。因此不要再哈希表中存储能够改变的Objects ### 避免冲突的方法</li><li>开放定址法(open addressing), 如果目标bucket已经存在，则选择不同的bucket<ul><li>linear Probing(线性探测法)，如果当前bucket已被占用，使用下一个bucket，一个接着一个扫描</li></ul></li></ul><h2 id="堆和优先队列"><strong>10. 堆和优先队列</strong></h2><ul><li>涉及到搜索树的优先级?</li><li>堆的数据结构是<strong>二叉搜索树</strong></li></ul><h3 id="最小堆">最小堆</h3><ul><li>属性<ul><li>每个节点都小于等于它的两个子节点。</li></ul></li><li>操作<ul><li>add: 临时添加到堆尾，<code>swimming</code>到合适的位置。</li><li>getSmallest: 返回堆的根。</li><li>removeSmallest: 将堆中的最后一项交换到根中，将层次结构下沉到适当的位置。 ### Implementation of PQ</li></ul></li><li>leftchild(k) = k * 2;</li><li>rightchild(k) = k * 2 - 1;</li><li>parent(k) = k / 2;</li><li>实现基于的数据结构: <code>数组</code>, <code>BST</code>, <code>哈希表</code>，<code>堆</code></li><li><img src="https://pic4.zhimg.com/80/v2-f23000dfd8f9db7487f066e4558fc55d.png" title="fig:" alt="Image"></li></ul><h2 id="树和图的遍历"><strong>树和图的遍历</strong></h2><ul><li>树也是图的一种实现方式, 无环。</li><li>先序遍历(preorder traversal)适合打印目录结构。</li><li>后序遍历(postorder traversal)同样适用计算出当前目录下的文件总大小。</li></ul><h3 id="简单图的定义"><strong>简单图的定义</strong></h3><ul><li>不存在一个顶点的边回到自身。</li><li>不存在两条边连着同样的顶点。</li></ul><h3 id="图的类型"><strong>图的类型</strong></h3><ul><li>Acyclic(非循环) vs. cyclic(循环), 循环指的是第一个顶点和最后一个顶点是同一个。</li><li>Directed(有向) vs. Indirected(无向)</li><li>With edge label(a.k.a. weight)(边权重).</li></ul><h3 id="图的问题"><strong>图的问题</strong></h3><ul><li>s-t Path? 由顶点s到t是否存在路径?</li><li>Connectivity? 每个顶点到其它顶点是否存在路径?</li><li>Biconnectivity? 如果将某两个顶点的边移除，图就不是连通的了。</li><li>Shortest s-t Path?</li><li>Cycle Detection?</li><li>Euler(欧拉) Tour? 是否存在一个cycle使得所有边只使用一次。</li><li>Hamilton Tour? 是否存在一个cycle使得所有顶点只使用一次。</li><li>Planarity(平面化)? 能否画一张图不出现交叉的边。</li><li>Isomorphism? 两个图是否为同构?</li></ul><h3 id="depth-first-traversal"><strong>Depth-First Traversal</strong></h3><ul><li>marks, 可以避免connected(v, t)--(寻找neighborhood)的无限循环。</li><li>marked(), 判断是否被标记</li><li>edgeTo[w] = v, 添加边</li></ul><h3 id="graph-traversal"><strong>Graph Traversal</strong></h3><ul><li>Dfs postorder, 若当前顶点的邻居都被标记时才返回当前顶点的值。</li><li>Dfs preorder, 若遍历到当前顶点即打印值。</li><li>BFS</li></ul><h3 id="graph-api"><strong>Graph API</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span>:               Create empty graph with v vertices</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span>: add an edge v-w</span><br><span class="line">  Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>:      vertices adjacent to v</span><br><span class="line">  <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>:                           number of vertices</span><br><span class="line">  <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>:                           number of edges</span><br></pre></td></tr></table></figure><h3 id="图的实现"><strong>图的实现</strong></h3><ul><li>邻接矩阵(无向图)</li><li>邻接链表(有向图)</li><li>边集合, 如<code>&#123;&#123;0, 2&#125;, &#123;0, 1&#125;&#125;</code>表示顶点0分别指向1和2。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS61B </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61C C Note</title>
      <link href="/2022/05/18/CS61C-C-Note/"/>
      <url>/2022/05/18/CS61C-C-Note/</url>
      
        <content type="html"><![CDATA[<!-- # CS61C C Part Notes. --><blockquote><p>揭示C语言的本质</p></blockquote><span id="more"></span><ol type="1"><li>Array在传递给函数时记得必须要一并传递Array的大小，因为在函数内使用<code>sizeof</code>会得到不正确的结果。</li><li>Array in C don't know their size.</li><li>数组名不是一个变量。</li><li>Struct Alignment.</li><li>A String in C is just an array of characters.</li><li>String end. Last character is followed by a 0 byte('\0')(a.k.a <code>null terminator</code>).</li><li><code>strlen()</code> return the length of string(not including null term).</li><li>Pointer Arithmetic, Pointer+1实际上是加指针指向的类型的大小<code>sizeof(*p)</code>. Pointer arithmetic moves the pointer by the size of the thing it’s pointing to.</li><li>注意<code>postfixal</code>++的优先级要大于dereference(<em>), 注意这两种区别<code>*p++</code>，先将p和后置++捆绑，但是在解引用之后生效，即增以p=p+1。<code>(*p)++</code>表示，先将p和<code>*</code>捆绑，再将解引用后的值++, 即(</em>p) = (*p) + 1.</li><li>声明一个指针如果未初始化，则随机指向任何一个地址<code>garbage</code>，这在<code>dereference</code>时会发生ACV(如果地址为系统地址)。</li><li>dot notation &amp; arrow notationss</li><li>pointers to pointers, 还有一点需要注意。如果传的参数不是当前类型本身的地址，则在函数中改变的值不会对全局造成影响，比如：类型本身是指针就需要传递指针的指针才能改变本身的值。</li><li>Stack frame, which contains location of caller function(调用函数的入口地址)、function arguments(函数参数)、Space for local variables(局部变量所需的空间). Actually in xv6, it contains the additional part of previous stack frame pointer.</li><li>Stack pointer 为最低的(current)Stack frame.</li><li>注意从局部变量返回地址，这个地址在接下来主函数中解引用会出现错误的值，因为栈帧(stack frame)很可能会被覆盖(over write)。印象中Effective cpp书中只是提到这种情况是危险的但并未说清楚其中的原理。So never return pointers to local variable from function.</li><li>Static Data: place for variables that persist. 静态数据会在程序执行的整个过程中持续存在。</li><li><code>String literal</code>字符串字面量同样也是静态数据，比如: <code>char* str = "hi"</code>, 为一个字符指针指向用引号括起来的字符串。切记不要误用为<code>char str[] = "hi"</code>，它会将数据保存到栈(stack)中而不是<code>Static Data</code>区域。</li><li><code>String literal</code>是不能被更改的左值。</li><li><code>Static Data</code>由两种类型组成，一种是<code>Read-only</code>, 比如说<code>String literal</code>; 一种是<code>Read-Write</code>, 比如说<code>Global variable</code>.</li><li><code>Code</code>为<code>Read-only</code> Data，存放machine code.</li><li>地址大小即为指针的大小，取决于Architecture.</li><li><code>Endianness</code>, Big Endian or Little Endian, which just are used in Memory.</li><li><code>sizeof(type/var)</code>函数输出类型的字节大小。</li><li><code>malloc(n)</code>函数，分配n个bytes连续的未初始化的虚存，返回分配块的起始地址(void*类型)。搭配typecaset和sizeof使用，case: <code>int *p = (int *) malloc(n*sizeof(int));</code>, 注意如果为字符串(字符数组)分配空间size则需要+1，为null terminator分配一个location.</li><li><code>calloc(nmember, size)</code>和<code>malloc</code>一致, 只多了一步初始化为<code>0</code>. <code>nmember</code>为成员的数量，<code>size</code>为每个成员的大小。</li><li><code>realloc(ptr, size)</code>, <code>ptr</code>为<code>malloc</code>或<code>calloc</code>返回的指针，<code>size</code>为需要改变的所需要的大小(同malloc)，会复制起始地址为<code>ptr</code>的内容。且可能会移动地址，或者保持在<code>ptr</code>原来的地址不变。</li><li><code>free(p)</code>函数，p必须为最开始分配时的起始地址，否则会抛出异常，因此对<code>p++</code>操作是不明智的。注意<code>free</code>的释放顺序，应该最后释放<strong>源</strong>，否则可能会double free。</li><li>Memory Error: Segmentation Error、Bus Error.</li><li><code>strcpy()</code>的修订版本<code>strncpy</code>保证<code>dst</code>有足够的空间供<code>src</code>来copy.</li><li>Rule of Thumb(经验法则): Malloc的数量超过free意味着内存泄漏；潜在的内存泄漏：改变指针。</li><li><code>free()</code> adds block to the list, combines with adjacent free blocks; <code>malloc()</code> searches free list for block large enough to meet request</li><li>Choose block in malloc(): Best-fit, First-fit, Next-fit.</li></ol>]]></content>
      
      
      <categories>
          
          <category> CS61C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NJU OS Note</title>
      <link href="/2022/05/16/NJU-OS-Note/"/>
      <url>/2022/05/16/NJU-OS-Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直以来被忽略的本科教学</p></blockquote><span id="more"></span><ul><li><code>ld</code>, GNU Linker</li><li><code>gcc</code>支持对汇编代码的预编译(还会定义__ASSEMBLER__宏)。</li><li><code>wget url</code>下载URL的文件内容。</li><li><code>gcc -E foo.c</code>在预处理阶段后停止。</li><li><code>volatile</code>声明的变量不能优化。</li><li><code>asm</code>是<code>GNU</code>的拓展。可以从汇编程序中读取和写入C变量。</li><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html"><code>Extended asm</code></a>: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asm asm-qualifiers ( AssemblerTemplate  </span><br><span class="line">               :OutputOperands  </span><br><span class="line">               [:InputOperands[: Clobbers]]) </span><br></pre></td></tr></table></figure><ul><li>Qualifier: volatile, inline, goto。</li><li>AssemblerTemplate: 包含汇编程序指令的文字字符串。</li><li>OutputOperands(允许使用空列表): <code>[[asmSymbolicName]] constraint(c_variablename)</code>，输出约束必须以<code>=</code>作为开头, 常见的约束<code>r</code> for register, <code>m</code> for memory。约束后还需要有个C的变量名，括号是语法的必须部分。</li><li>InputOperands(允许使用空列表)。</li><li>eample <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> src = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dst;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;mov %1, %0\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;add $1, %0&quot;</span></span><br><span class="line">    : <span class="string">&quot;=r&quot;</span> (dst) </span><br><span class="line">    : <span class="string">&quot;r&quot;</span> (src));</span><br></pre></td></tr></table></figure></li><li>Clobbers: <code>memory</code>( Further, the compiler does not assume that any values read from memory before an asm remain unchanged after that asm;), <code>Compiler barrier</code>.</li></ul></li><li><code>strace</code>追踪当前程序或者进程执行过的系统调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ICS Lab Note</title>
      <link href="/2022/05/16/ICS-Lab-Note/"/>
      <url>/2022/05/16/ICS-Lab-Note/</url>
      
        <content type="html"><![CDATA[<!-- # ICS Lab Note --><blockquote><p>本校的Lab体验总结</p></blockquote><span id="more"></span><h2 id="lab1"><strong>lab1</strong></h2><ol type="1"><li>实际上通过编写发现，为了编写方便，我将ASCII模板0和存放文件起始地址的位置调换(即0x3013和0x3012)，并将文件的内容连续(consecutively)放在从0x3013处的开始；随之变动的也有将LDR R3, x3013改为LEA R3, x3013，最开始没有注意到这个问题debug发现其实x3013里我设的值为'H'即x0048，按照原来的执行，它会提取x0048处的内容，因此单步执行到这行机器代码直接halt掉了，且估计是因为ACV异常导致的结果。</li><li>编写bin文件转化为obj之后调试发现，bin文件第一行的内容并没有被显示在主存中。因此可以推断第一行为程序执行的起始地址(可能是因为我没有仔细看实验手册吧:)。</li><li>fgets执行成功文件指针自动后移; 格式化写入文件fprintf;</li><li>a+: 以追加、可读写的方式打开文件，允许读写。若进行读操作，则从头开始读；若进行写操作，则将内容添加在末尾。若文件不存在，则创建文件。打开成功后返回文件指针，位置指针指向文件头部。</li></ol><ul><li>完成时间3h</li></ul><h2 id="lab2"><strong>lab2</strong></h2><ol type="1"><li>Bug: Loop的次数不是所期望的3，因此需要改变影响loop次数的BR，将BRzp改为BRp，即可达到所期望的3次，结果为30.</li><li>Bug: 应该把LDR改为LEA这样就可以提取存储单元的内容，而不是提取存储单元内容的内容(相当于间接寻址)，修改过后就为正确的了。</li><li>Bug: x300C和x300B行应该调换位置。因为实际上R3寄存器的设置是作为loop的次数，同时LDR同样也可以生成条件码，这会导致意想不到的错误(比如对应文件地址里存储的是负数或者0就会终止循环得到意想不到的结果)</li><li>Bug: 如果x3400地址单元内存的值为0，那么就会出现死循环的问题，单步调试之后发现在x3003处的BR指令并没有判断取数为0的情况，因此我做出了这样的调整。在x3003处将BRn改为BRnz</li></ol><ul><li>完成时间2h</li></ul><h2 id="lab3"><strong>lab3</strong></h2><ol type="1"><li>将输入的 大写/小写字母 转化为 小写/大写字母 输出到显示屏上，如果是别的字符则输出error. <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">       .ORIG  x3000           ; program start at x3000</span><br><span class="line">       LD     R2, TERM        ; Load negative of ASCII 7</span><br><span class="line">AGAIN  TRAP   x23             ; input syscall</span><br><span class="line">; judge the range of R0</span><br><span class="line">       LD     R5, UPMIN       </span><br><span class="line">       ADD    R5, R5, R0     </span><br><span class="line">       BRn    OTH             ; if input &lt; A, jump to OTH</span><br><span class="line">       LD     R5, UPMAX      </span><br><span class="line">       ADD    R5, R5, R0      </span><br><span class="line">       BRnz   U2L             ; if input &lt;= Z, jump to U2L</span><br><span class="line">       LD     R5, LOWMIN      </span><br><span class="line">       ADD    R5, R5, R0      </span><br><span class="line">       BRn    OTH             ; if input &lt; a, jump to OTH</span><br><span class="line">       LD     R5, LOWMAX      </span><br><span class="line">       ADD    R5, R5, R0</span><br><span class="line">       BRnz   L2U             ; if input &lt;= z, jump to L2U</span><br><span class="line">       BR     OTH             ; the rest range of input.</span><br><span class="line">U2L    LD     R3, ASCII       ; load difference value</span><br><span class="line">       BR     OUTPUT</span><br><span class="line">L2U    LD     R3, ASCII2</span><br><span class="line">;</span><br><span class="line">; handle alpha</span><br><span class="line">;</span><br><span class="line">OUTPUT ADD    R1, R2, R0      ; if input 7, jump to halt.</span><br><span class="line">       BRz    EXIT            ; exit</span><br><span class="line">       ADD    R0, R0, R3      ; trasforming u2l/l2u</span><br><span class="line">       TRAP   x21             ; output syscall</span><br><span class="line">       BR     AGAIN           ; unconditional loop</span><br><span class="line">;</span><br><span class="line">; if the character not an alpha, handle from there</span><br><span class="line">;</span><br><span class="line">OTH    ADD    R1, R2, R0</span><br><span class="line">       BRz    EXIT</span><br><span class="line">       LEA    R3, ERROR       ; load prompt pointer</span><br><span class="line">LOOP   LDR    R0, R3, #0      ; load character</span><br><span class="line">       BRz    AGAIN</span><br><span class="line">       TRAP   x21             ; it may change the value in R1</span><br><span class="line">       ADD    R3, R3, #1      ; load next character</span><br><span class="line">       BR     LOOP</span><br><span class="line">TERM   .FILL  xFFC9           ; xFFC9 is negative of ASCII 7(x0037)</span><br><span class="line">ASCII  .FILL  x0020           ; The difference value between upper case and lower case</span><br><span class="line">ASCII2 .FILL  xFFE0           ; xFFE0 is negative of -20</span><br><span class="line">UPMIN  .FILL  xFFBF           ; xFFBF is negative of ASCII A</span><br><span class="line">UPMAX  .FILL  xFFA6           ; xFFA6 is negative of ASCII Z</span><br><span class="line">LOWMIN .FILL  xFF9F           ; xFF9F is negative of ASCII a</span><br><span class="line">LOWMAX .FILL  xFF86           ; xFF86 is negative of ASCII z</span><br><span class="line">EXIT   TRAP   x25             ; halt</span><br><span class="line">ERROR  .STRINGZ &quot;Input character error!&quot;</span><br><span class="line">       .END</span><br></pre></td></tr></table></figure></li><li>gets函不包含换行符(<code>\n</code>)</li></ol><ul><li>完成时间2h</li></ul><h2 id="lab4"><strong>lab4</strong></h2><h3 id="汇编语言">汇编语言</h3><p>1.编写完程序之后发现有报错log, 于是配合上vscode+vim插件可以直接在代码中定位错误信息，将报错log(主要时label名字输入错误)全部修改正确。</p><p>2.汇编成功后，debug发现书上有两个小错误，最开始以为x-0A是0x0A但后面发现并不是，而是0x0A的取补数来判定值, 还有x-03和x-09也是一样的。后来ADD后面只能跟5个Bit的值，遂用#-10表示,因此改为:</p><figure><img src="https://pic4.zhimg.com/80/v2-812c175efddbad0e4dc2b76e381e3064.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>3.debug发现这一段条件码判断的有问题，应该是照着敲的时候敲错了太粗心了...!第一步和负的ASCII的0比较应该是判断BRn才为NOT A integer, 事实上我写成了BRp才造成了这样的错误，而且还漏写了大于9的边界判断，下面是Debug错误图:</p><p><img src="https://pic4.zhimg.com/80/v2-90401b2396aac9499e8c7c5c69eebe6a.png" alt="Image"><img src="https://pic4.zhimg.com/80/v2-790558c0ce2a716b2a8942c46c83b599.png" alt="Image"></p><p><strong>正确</strong>应该改为:</p><figure><img src="https://pic4.zhimg.com/80/v2-3cd596729cfb00576d353da469fe8e5b.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>4.输入+测试会crash，随后我设置断点缩小了BUG的范围，找到了对应的位置，最后确定是因为这一段代码输入错，可以能是因为重复恢复R5寄存器，也可能是以为忘记恢复R7寄存器的值。crash的图片:</p><figure><img src="https://pic4.zhimg.com/80/v2-bae4d8bc8edf58837b97b96dcdd5430a.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>错误代码的图片:</p><figure><img src="https://pic4.zhimg.com/80/v2-dce739185fc63a23b13334f0a3f8b0b7.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>改正了这部分代码, 恢复正常:</p><figure><img src="https://pic4.zhimg.com/80/v2-e9bccf6f55cf7287a06b29ea514e85da.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>5.debug排错技巧，先在某个特定的函数位置打好断点再看源代码是否有误，并屏感觉有不合理的地方对照课本，最后走一遍单步调试.</p><p>6.仔细查看这行代码并没有实际的意义，于是对照可课本发现确实是敲错了:</p><figure><img src="https://pic4.zhimg.com/80/v2-24cbd8d35456387479b36ffc0ab9c213.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>7.查看了Display的源代码发现显示的其实是栈顶元素(一个符号位三个数字)，也就是刚输入的ASCIIBUFF。衍生出了一个问题，如果上上次输入的是一个3位数字，且上次输入的是一个2位数字，那么ASCIIBUF的2位数字会和3位数字的百位一起显示吗？因为实际上在ASCIItoBinary函数中会覆盖掉之前的内容。</p><p>8.测试了一下栈内一共可以存10个元素，于是看了一下地址分布，又确认了一下确实是这样(1 stackbase location + 9 stackmax locations):</p><figure><img src="https://pic4.zhimg.com/80/v2-c16ad818c2c0113c2c065f26ec96a56c.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>9.实际上POP和PUSH操作在发生underflow/overflow时是不会移动栈顶指针的，而是直接打印信息改变寄存器R5的值然后返回:</p><figure><img src="https://pic4.zhimg.com/80/v2-e64de1d0088a29d4552ccaac0bf33758.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>10.每一次ADD操作弹栈取两个操作后求和，会检查值是否超出范围([-999, 999]).</p><p>11.MULT操作专门有一个寄存器存放sign bit, 方便两个操作数进行累加来完成乘法。还有如果其中有一个操作数为0则直接将这个值压入栈中，退出乘法操作。而且乘法只需要将作为累加次数的乘数的值变为正数即可，最后根据符号位取结果的时候，可以发现四种结果都是正确的。</p><p>12.发现有个BUG，在console中输入一个数字之后又backtrace将它清除再输入一个数回车就会出现Not a integer的报错，看了一下它的VALUE_LOOP的实现发现确实是有这么一个缺陷。</p><p>13.PUSH和POP默认操作的都是R0寄存器</p><p>14.查看clear函数源码，发现仅仅是将栈顶指针初始化为空(即初始化为stackbase再-1)</p><p>15.又发现一个BUG：输入百位数Display显示乱码，进而导致相加的结果出错。有两个原因：1.push值到栈中出错(PUSH_VALUE)A2B。2.或者B2A的过程中出错。经过定位之后发现输入到ASCIIBUFF中的三个数字是完整的存在里面的，难道是转换出错？开始往Display函数上打断点，可以发现在单步执行通过Binary2ASCII前后ASCIIBUF的值发生了变化，经过之前:</p><p><img src="https://pic4.zhimg.com/80/v2-f8f064c63aee48c35230e6c2f40972f1.png" alt="Image"> <img src="https://pic4.zhimg.com/80/v2-fc118d61d731129e1ba81f336f17015a.png" alt="Image"></p><p>经过之后，可以看出ASCIIBUFF中的值已经发生了变化：</p><p><img src="https://pic4.zhimg.com/80/v2-943b0e7832ae7bd4226d27f845a828d6.png" alt="Image"> <img src="https://pic4.zhimg.com/80/v2-ac2006c2c1cf9c2b19d0dfb80e4e07ca.png" alt="Image"></p><p>接下来又试了一下两位数，经过这个函数后显示的结果是正确的，难道是课本代码出错？？？Not！又进一步精确了错误的位置，发现如果是两位数，在发现在栈中的值就是所输入的两位数的值，而三位数的时候就变成了随机的值，因此可以推断问题不是出在B2A而是处在A2B往栈中存的值不正确导致最后Display从栈中取二进制数时打印出错!(刚好就只剩A2B的源代码没看哈哈哈)。以下是输入123，栈中值错误：</p><figure><img src="https://pic4.zhimg.com/80/v2-17b94c6024eebac989a7adaf9ec1b6e4.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>仔细阅读了A2B的源代码定位到了错误(从十六进制转化为十进制时使用MASK的对象应该是R4,也就是刚LD过来的内容):</p><figure><img src="https://pic4.zhimg.com/80/v2-c69df62813b011e7fb9b5c15daff2404.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>修改过后，成功了！:</p><figure><img src="https://pic4.zhimg.com/80/v2-634e98e287e5de31e3de86f7f7de08a7.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure><p>16.最后说一下A2B的设计，我本以为是数位的ASCII码来和'0'做减，没想到是和x000F的MASK取模也行，太妙了！</p><ul><li>完成时间5h</li></ul><h3 id="c语言">C语言</h3><p>1.难受了windows下是carriage return + linefeed, 我提取的字符是一位....我很难受。遂换一个策略</p><p>2.scanf后面接个getchar吸收换行符</p><ul><li>完成时间5h</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS186 Note</title>
      <link href="/2022/05/16/CS186-Note/"/>
      <url>/2022/05/16/CS186-Note/</url>
      
        <content type="html"><![CDATA[<!-- # **CS186 Note** --><blockquote><p>SQL真的这么难吗?</p></blockquote><span id="more"></span><h2 id="sql"><strong>SQL</strong></h2><ul><li><code>SELECT</code>后加<code>DISTINCT</code>可以将重复的tuple去掉。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tbl<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="null-value">NULL value</h3><ul><li>任何以<code>NULL</code>值作为操作数的算数运算操作结果都为<code>NULL</code>，所以通常需要<code>IS NULL</code>或<code>IS NOT NULL</code>来提前判断。</li><li><code>NULL</code> is <strong>falsey</strong>.</li></ul><h3 id="aggregate-funtion">Aggregate funtion</h3><ul><li>SUM, AVG, MAX, MIN, COUNT。</li><li>输入是一个列，输出是一个值。</li><li>每个aggregate都忽略掉<code>NULL</code>, 除了<code>COUNT(*)</code>之外。注意<code>COUNT&lt;column&gt;</code>返回具体列非空值的数量。</li><li>注意分组后COUNT(*)计算的是当前组的行数。 <img src="https://pic4.zhimg.com/80/v2-e51e235585811be04b61e04c12a2d1e0.png" alt="Image"></li></ul><h3 id="groups-of-data">Groups of Data</h3><ul><li>GROUP BY</li><li>将当前列中属性值相同的行放入一个组中, 该组中的所有行要合并为一行。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tbl<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span> −− <span class="keyword">Filter</span> <span class="keyword">out</span> <span class="keyword">rows</span> (before <span class="keyword">grouping</span>) .</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>; −− <span class="keyword">Filter</span> <span class="keyword">out</span> <span class="keyword">groups</span> (after <span class="keyword">grouping</span>) .</span><br></pre></td></tr></table></figure></li><li>WHERE用于过滤行，而HAVING用来过滤组。</li></ul><h3 id="有问题的查询语句">有问题的查询语句</h3><ul><li>投影的属性<code>AVG(num dogs)</code>是只有一个值，但是<code>age</code>属性中有很多值。因此形成的表中必须有同样数量的行，error。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, <span class="built_in">AVG</span>(num_dogs)</span><br><span class="line"><span class="keyword">FROM</span> Person;</span><br></pre></td></tr></table></figure></li><li>将age分为一个组之后，无法合并为一行(因为age在当前组中含单个数字，但num_dogs含多个数字)，error。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, num_dogs</span><br><span class="line"><span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age;</span><br></pre></td></tr></table></figure></li></ul><h3 id="order-by">Order By</h3><ul><li>默认是升序排列的，要想降序排列需要具体列名(属性名)后加关键字DESC。下面语句列num_dogs按升序排列，但name按降序排列。我们先对num_dogs排序再对num_dogs中相同的行进行name降序排序。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, num_dogs</span><br><span class="line"><span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num_dogs ,name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="limit">LIMIT</h3><ul><li>限定返回的行数</li></ul><h3 id="语句编写顺序">语句编写顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tbl<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line">LIMIT <span class="operator">&lt;</span>num<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="join">Join</h3><ul><li>cross join(笛卡尔积), filter在笛卡尔积过后的表中寻找对应的行。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li>inner join，和上述语句输出是一样的结果。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line">    <span class="keyword">ON</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 除了加上共有的属性值行...</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 加上左侧表中特有的属性值行，当前右侧表中对应的不存在的属性用<span class="keyword">NULL</span>代替。</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 加上右侧表中特有的属性值行。</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 加上两侧表中特有的属性值行。</span><br><span class="line"><span class="operator">-</span> <span class="keyword">natural</span> <span class="keyword">join</span>, <span class="operator">*</span><span class="operator">*</span>隐式地<span class="operator">*</span><span class="operator">*</span>将属性值一致的列<span class="keyword">inner</span> <span class="keyword">join</span>, 比如在当前例子中，将会自动包含<span class="keyword">join</span> <span class="keyword">condition</span>: courses.num <span class="operator">=</span> enrollment.num。</span><br><span class="line">    ``` <span class="keyword">sql</span></span><br><span class="line">    <span class="keyword">SELECT</span> ∗</span><br><span class="line">    <span class="keyword">FROM</span> courses <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> enrollment;</span><br></pre></td></tr></table></figure></li><li>ON后跟的是连接的predicate。</li></ul><h3 id="name-conflict">Name conflict</h3><ul><li>通过<code>列名.属性</code>来避免命名冲突。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ∗</span><br><span class="line"><span class="keyword">FROM</span> courses <span class="keyword">INNER</span> <span class="keyword">JOIN</span> enrollment</span><br><span class="line"><span class="keyword">ON</span> courses.num <span class="operator">=</span> enrollment.num;</span><br></pre></td></tr></table></figure></li><li>通过AS来指定别名。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> courses <span class="keyword">AS</span> a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> enrollment <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> A.num <span class="operator">=</span> B.num;</span><br></pre></td></tr></table></figure> ### Subqueries</li><li>Notes中举得例子是，需要找到课程的学生人数大于所有课程的平均学生人数的课程。如果单纯进行AVG处理，那么想要获取的行将会被过滤掉了，这时候就需要用到子查询了。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> num</span><br><span class="line"><span class="keyword">FROM</span> enrollment</span><br><span class="line"><span class="keyword">WHERE</span> students <span class="operator">&gt;=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(students)</span><br><span class="line">    <span class="keyword">FROM</span> enrollment;</span><br><span class="line">)</span><br></pre></td></tr></table></figure> ### Set Operators</li><li>ANY, ALL, UNION, INTERSECT, DIFFERENCE, IN.</li></ul><h3 id="correlated-subqueries">Correlated Subqueries</h3><ul><li>子查询可以嵌套在WHERE中，也可以嵌套在FROM中。</li></ul><h3 id="pattern-matching">Pattern matching</h3><ul><li><code>%</code>可以匹配任何子串。</li><li><code>_</code>可以匹配任何单个字符。</li></ul><h3 id="regular-expression">Regular expression</h3><ul><li>使用前需要加~。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> artist_name, first_yr_active</span><br><span class="line"><span class="keyword">FROM</span> Artists</span><br><span class="line"><span class="keyword">WHERE</span> artist_name <span class="operator">~</span><span class="string">&#x27;^B.*&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="relation-algerbra"><strong>Relation Algerbra</strong></h2><p>关系代数中返回结果不包含重复的tuple。</p><h3 id="projectionpi">Projection(<span class="math inline">\(\pi\)</span>)</h3><ul><li><span class="math inline">\(\pi_{name}(dog)\)</span>选择对应的列，类似于SELECT name FROM dogs;</li><li>在关系代数中不存在操作符等价于FROM。</li></ul><h3 id="selectionsigma">Selection(<span class="math inline">\(\sigma\)</span>)</h3><ul><li>根据给定的条件过滤出具体的行。如: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> dogs <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure> 对应关系代数的版本 <span class="math inline">\(\pi_{name, age}(\sigma_{age = 12}(dogs))\)</span> 或者<span class="math inline">\(\sigma_{age = 12}(\pi_{name, age}(dogs))\)</span></li><li>Selection操作符同样支持<code>compound predicate</code>，比如<code>AND</code>可以用<span class="math inline">\(\wedge\)</span>来表示<code>OR</code>可以用<span class="math inline">\(\vee\)</span>来表示, 如: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age </span><br><span class="line"><span class="keyword">FROM</span> dogs </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;Timmy&#x27;</span>;</span><br></pre></td></tr></table></figure> 对应的关系代数版本 <span class="math inline">\(\sigma_{age=12 \wedge name=&#39;Timmy&#39;}(\pi_{name, age}(dogs))\)</span></li></ul><h3 id="unioncup">Union(<span class="math inline">\(\cup\)</span>)</h3><ul><li>Compatible: 要求union的两个操作数必须拥同样数量的attribute, 并且对应的attribute必须拥有同样的类型。</li></ul><h3 id="set-difference-">Set Difference(<span class="math inline">\(-\)</span>)</h3><ul><li>和union一样要求Compatible</li><li>等价于SQL的EXCEPT语句, 比如<span class="math inline">\(\pi_{name}(dogs) - \pi_{name}(cats)\)</span>只显示dogs表的行而不显示cats表的行。</li></ul><h3 id="intersectioncap">Intersection(<span class="math inline">\(\cap\)</span>)</h3><ul><li>和union一样要求Compatible。</li><li>等价于SQL的INTERSECT语句。</li></ul><h3 id="crossproducttimes">CrossProduct(<span class="math inline">\(\times\)</span>)</h3><ul><li>就像在SQL中执行笛卡尔积，输出两个表中行的所有组合。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ∗</span><br><span class="line"><span class="keyword">FROM</span> dogs, parks;</span><br></pre></td></tr></table></figure> 等价于<span class="math inline">\(dogs \times parks\)</span>。</li><li>不必要求属性数量一致。</li></ul><h3 id="joinjoin">Join(<span class="math inline">\(\Join\)</span>)</h3><ul><li><code>inner join</code>: <span class="math inline">\(dogs\Join_{dogs.name=cats.name}cats\)</span>，subscript中表示join的条件，也称作Theta join, "<span class="math inline">\(\Join(\theta)\)</span>"。</li><li><code>Natual join</code>: <span class="math inline">\(dogs\Join cats\)</span>，上面SQL中提到过，自然连接将会把两个表中所有同样的列自动合并。</li><li>和selection操作符一样可以使用compound predicate。</li><li>join都可以由cross和selection生成。</li><li><span class="math inline">\(cats \Join_{\theta} dogs\)</span>和<span class="math inline">\(\sigma_{\theta}(cats \times dogs)\)</span>是等价的。</li><li><span class="math inline">\(cats \Join dogs\)</span>和<span class="math inline">\(\sigma_{cats.col1=dogs.col1\wedge cats.col2=dogs.col2\wedge...\wedge cats.colN=dogs.colN}(cats \times dogs)\)</span>是等价的。</li></ul><h3 id="renamerho">Rename(<span class="math inline">\(\rho\)</span>)</h3><ul><li>等价于SQL中的Alias。</li><li><span class="math inline">\(cats\Join_{name=dname} \rho_{name-&gt;dname}(dogs)\)</span>，将dog中的name属性重命名为dname, 避免冲突。</li></ul><h3 id="group-by-aggregationgamma">Group By/ Aggregation(<span class="math inline">\(\gamma\)</span>)</h3><ul><li>exp1 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age</span><br><span class="line"><span class="keyword">FROM</span> dogs</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure> 等价于<span class="math inline">\(\gamma_{age, COUNT(*)&gt;5}(dogs)\)</span></li><li>exp2 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, <span class="built_in">SUM</span>(weight)</span><br><span class="line"><span class="keyword">FROM</span> dogs</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">8</span>) <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure> 等价于<span class="math inline">\(\gamma_{age, SUM(weight), COUNT(*)&gt;5(dogs)}\)</span></li></ul><h3 id="sql---relation-algebra">SQL -&gt; Relation Algebra</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> teamid <span class="keyword">AS</span> tid</span><br><span class="line"><span class="keyword">FROM</span> players</span><br><span class="line"><span class="keyword">WHERE</span> players.teamid <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> teamid <span class="keyword">FROM</span> teams)</span><br><span class="line"><span class="keyword">AND</span> position<span class="operator">=</span><span class="string">&#x27;shootingGuard&#x27;</span>;</span><br></pre></td></tr></table></figure><p>等价于 <span class="math display">\[\rho_{teamid-&gt;tid}(\pi_{teamid}(\sigma_{position=&#39;shootingGuard&#39;}(players))-\pi_{players.teamid}(players\Join_{players.teamid=teams.teamid}teams))\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 Project1: BUFFER POOL MANAGER</title>
      <link href="/2022/05/16/cmu15445-project1/"/>
      <url>/2022/05/16/cmu15445-project1/</url>
      
        <content type="html"><![CDATA[<!-- # CMU 15-445 Project1: BUFFER POOL MANAGER --><blockquote><p>OS vs. DB</p></blockquote><span id="more"></span><h2 id="task-1---lru-replacement-policy"><strong>TASK #1 - LRU REPLACEMENT POLICY</strong></h2><h3 id="问题描述"><strong>1.1 问题描述</strong></h3><p>需要完成的函数 - Victim(frame_id_t*) : Remove the object that was accessed least recently compared to all the other elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False. - Pin(frame_id_t) : This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer. - Unpin(frame_id_t) : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer. - Size() : This method returns the number of frames that are currently in the LRUReplacer</p><p>想到lc上有类似的实现可以参考一下，双链表+哈希表实现<a href="https://leetcode-cn.com/problems/lru-cache/">LRU</a>，大致思路和本题是一样的。pin时表示该页正在被使用，因此需要将该页从lru_replacer中移除，unpin反之。需要注意的是，不能多次unpin，这点与lc上有差别。</p><h3 id="部分实现"><strong>1.2 部分实现</strong></h3><p><strong>lru_replacer.h</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// TODO(student): implement me!</span></span><br><span class="line"> std::unordered_map&lt;<span class="type">frame_id_t</span>, ListNode*&gt; cache_;</span><br><span class="line"> std::mutex lru_latch_;</span><br><span class="line"> ListNode* head_;  <span class="comment">// dummy.</span></span><br><span class="line"> ListNode* tail_;</span><br><span class="line"> <span class="type">size_t</span> curr_size_;</span><br><span class="line"> <span class="type">size_t</span> capacity_;</span><br></pre></td></tr></table></figure> <strong>lru_replacer.cpp</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;  <span class="comment">// evict the old frame.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(lru_latch_)</span></span>;  <span class="comment">// lock</span></span><br><span class="line">  <span class="keyword">if</span> (curr_size_ == <span class="number">0</span>) &#123;  <span class="comment">// lruReplacer empty.</span></span><br><span class="line">    frame_id = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode* delframe = tail_-&gt;prev;</span><br><span class="line">  <span class="type">frame_id_t</span> delframe_id= delframe-&gt;frame_id;</span><br><span class="line">  *frame_id = delframe_id;</span><br><span class="line">  cache_.<span class="built_in">erase</span>(delframe_id);  <span class="comment">// remove from frame.</span></span><br><span class="line">  curr_size_--;</span><br><span class="line">  <span class="comment">// Evict frame.</span></span><br><span class="line">  <span class="built_in">RemoveFrame</span>(delframe);</span><br><span class="line">  <span class="keyword">delete</span> delframe;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(lru_latch_)</span></span>;  <span class="comment">// lock</span></span><br><span class="line">  <span class="keyword">if</span> (cache_.<span class="built_in">find</span>(frame_id) != cache_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// decrease the attribute size.</span></span><br><span class="line">    curr_size_--;</span><br><span class="line">    ListNode* delframe = cache_[frame_id];</span><br><span class="line">    cache_.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">    <span class="built_in">RemoveFrame</span>(delframe);</span><br><span class="line">    <span class="comment">// release the source.</span></span><br><span class="line">    <span class="keyword">delete</span> delframe;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(lru_latch_)</span></span>;  <span class="comment">// lock</span></span><br><span class="line">  <span class="keyword">if</span> (cache_.<span class="built_in">find</span>(frame_id) == cache_.<span class="built_in">end</span>()) &#123;  <span class="comment">// didn&#x27;t find Unpin frame.</span></span><br><span class="line">    ListNode* frame = <span class="keyword">new</span> <span class="built_in">ListNode</span>(frame_id);</span><br><span class="line">    ++curr_size_;</span><br><span class="line">    <span class="keyword">if</span> (curr_size_ &gt; capacity_) &#123;</span><br><span class="line">      <span class="type">frame_id_t</span> fid;</span><br><span class="line">      <span class="built_in">Victim</span>(&amp;fid);</span><br><span class="line">      cache_[frame_id] = frame;</span><br><span class="line">      curr_size_--;</span><br><span class="line">      <span class="built_in">AddToHead</span>(frame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cache_[frame_id] = frame;</span><br><span class="line">      <span class="built_in">AddToHead</span>(frame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// couldn&#x27;t Unpin many times but once.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">LRUReplacer::Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> curr_size_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::AddToHead</span><span class="params">(ListNode* frame)</span> </span>&#123;</span><br><span class="line">  frame-&gt;next = head_-&gt;next;</span><br><span class="line">  head_-&gt;next-&gt;prev = frame;</span><br><span class="line">  head_-&gt;next = frame;</span><br><span class="line">  frame-&gt;prev = head_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::RemoveFrame</span><span class="params">(ListNode* frame)</span> </span>&#123;</span><br><span class="line">  frame-&gt;prev-&gt;next = frame-&gt;next;</span><br><span class="line">  frame-&gt;next-&gt;prev = frame-&gt;prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## <strong>TASK #2 - BUFFER POOL MANAGER INSTANCE</strong></p><h3 id="问题描述-1"><strong>2.1 问题描述</strong></h3><p>可以联系课程给的slide了解对应的关系，需要理解的概念以及注意的点： 1. free_list、lru_replacer、buffer_pool是独立存在的。 2. free_list中存放的是未被使用的frame，页表中不存在其frame的映射，即page_id为INVALID_PAGE_ID。 3. unpin_page，存放在lru_replacer中，页表中存在其frame的映射，但其在buffer pool中未被使用。 4. pin_page，存在于buffer pool中且正在被使用。 5. 刷盘的时机，只需要在victim、deletePage时刷盘即可，不需要在每次unpinpage时刷盘，在unpinpage时保存其传入的dirty状就行。因此每次fetch或者new一个页，从free_list中返回的页都不是脏页，同时victim时刷盘也保证获取的页不是脏页。 6. 从fetch、new获取lru_replace中的页时，需要在页表中删除原page与frame的映射。 7. 避免加锁函数的嵌套，可能会出现死锁的情况。</p><h3 id="代码实现"><strong>2.2 代码实现</strong></h3><p>可以进一步细化锁粒度，这里只给了未优化的实现。</p><p><strong>NewPgImp</strong></p><p>fetchpage和newpgImp都需要增加pin_count值，实现是差不多的。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call AllocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span></span><br><span class="line">  <span class="comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span></span><br><span class="line">  <span class="comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span></span><br><span class="line">  <span class="comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// step 1</span></span><br><span class="line">  <span class="type">bool</span> all_pinned = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pages_[i].pin_count_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      all_pinned = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (all_pinned)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// allocate a page on disk.</span></span><br><span class="line">  *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line">  </span><br><span class="line">  Page* p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// pick a victim page P.</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid;</span><br><span class="line">  <span class="keyword">if</span> (free_list_.<span class="built_in">empty</span>()) &#123;  <span class="comment">// pick from free list first.</span></span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Victim</span>(&amp;fid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p = &amp;pages_[fid];</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;is_dirty_) &#123;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(p-&gt;page_id_, p-&gt;data_);</span><br><span class="line">        p-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_.<span class="built_in">erase</span>(p-&gt;page_id_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fid = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    p = &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// add P to the page table.</span></span><br><span class="line">  page_table_[*page_id] = fid;</span><br><span class="line">  <span class="comment">// updata P&#x27;s metadata.</span></span><br><span class="line">  p-&gt;page_id_ = *page_id;</span><br><span class="line">  p-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(fid);</span><br><span class="line">  <span class="comment">// zeroes out the data that is held within the page</span></span><br><span class="line">  p-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  <span class="comment">// step 4</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>FetchPgImp</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.     Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.1    If P exists, pin it and return it immediately.</span></span><br><span class="line">  <span class="comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span></span><br><span class="line">  <span class="comment">//        Note that pages are always found from the free list first.</span></span><br><span class="line">  <span class="comment">// 2.     If R is dirty, write it back to the disk.</span></span><br><span class="line">  <span class="comment">// 3.     Delete R from the page table and insert P.</span></span><br><span class="line">  <span class="comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// step 1</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid;</span><br><span class="line">  Page* p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">find</span>(page_id) != page_table_.<span class="built_in">end</span>()) &#123;  <span class="comment">// find.</span></span><br><span class="line">    fid = page_table_[page_id];</span><br><span class="line">    pages_[fid].pin_count_++;</span><br><span class="line">    <span class="comment">// pin it.</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(fid);</span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (free_list_.<span class="built_in">empty</span>()) &#123;  <span class="comment">// pick from free list first.</span></span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Victim</span>(&amp;fid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// the page placed in the lrureplacer need to be flushed.</span></span><br><span class="line">      p = &amp;pages_[fid];</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;is_dirty_) &#123;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(p-&gt;page_id_, p-&gt;data_);</span><br><span class="line">        p-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_.<span class="built_in">erase</span>(p-&gt;page_id_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fid = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    p = &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// step 3</span></span><br><span class="line">  <span class="comment">// insert p.</span></span><br><span class="line">  page_table_[page_id] = fid;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(fid);</span><br><span class="line">  <span class="comment">// update P&#x27;s metadata.</span></span><br><span class="line">  p-&gt;page_id_ = page_id;</span><br><span class="line">  p-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// read in the page content from disk.</span></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, p-&gt;data_);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>DeletePgImp</strong></p><p>删除buffer pool中的页后需要将page的元数据还原到初始值，再放入free_list中。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DeallocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.   If P does not exist, return true.</span></span><br><span class="line">  <span class="comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span></span><br><span class="line">  <span class="comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// P does not exist.</span></span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">find</span>(page_id) == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// P does exist.</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid = page_table_[page_id];</span><br><span class="line">  Page* deletepage = &amp;pages_[fid];</span><br><span class="line">  <span class="keyword">if</span> (deletepage-&gt;pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// flush the page before deallocate it.</span></span><br><span class="line">  <span class="keyword">if</span> (deletepage-&gt;is_dirty_) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, deletepage-&gt;data_);</span><br><span class="line">    deletepage-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="comment">// remove P from the page table.</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page_id);</span><br><span class="line">  <span class="comment">// reset its metadata.</span></span><br><span class="line">  <span class="comment">// the page returned to freelist does not stores any page.</span></span><br><span class="line">  deletepage-&gt;page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  deletepage-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  deletepage-&gt;pin_count_ = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// return it to free_list_.</span></span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(fid);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>UnpinPgImp</strong></p><p>保留传入的dirty状态，在Victim时刷盘。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="type">frame_id_t</span> fid = page_table_[page_id];</span><br><span class="line">  Page* p = &amp;pages_[fid];</span><br><span class="line">  p-&gt;is_dirty_ = is_dirty;  <span class="comment">// hold the state until victim.</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pin_count_ &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  --p-&gt;pin_count_;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Unpin</span>(fid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>FlushPgImp</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure you call DiskManager::WritePage!</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">find</span>(page_id) == page_table_.<span class="built_in">end</span>() || page_id == INVALID_PAGE_ID)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[page_table_[page_id]].data_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="task-3---parallel-buffer-pool-manager"><strong>TASK #3 - PARALLEL BUFFER POOL MANAGER</strong></h2><h3 id="问题描述-2"><strong>3.1 问题描述</strong></h3><p>问题是从task2进一步延出来的，单个缓冲池管理器可能会照成大量的锁争用，因为在这种情况下每个线程和缓冲池交互都争着用单个锁存器，因此需要实现一个并行管理器来管理多个缓冲池管理器，进而实现每个缓冲池都有自己的latch。在这里只需要复用上一个task所实现的缓冲器实例即可，再实现一些基本的逻辑即可通过。 ### <strong>3.2 代码实现</strong></p><p><strong>parallel_buffer_pool_manager.cpp</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ParallelBufferPoolManager::<span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager,</span><br><span class="line">                                                     LogManager *log_manager) &#123;</span><br><span class="line">  <span class="comment">// Allocate and create individual BufferPoolManagerInstances</span></span><br><span class="line">  num_instances_ = num_instances;</span><br><span class="line">  pool_size_ = pool_size;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances; ++i) &#123;</span><br><span class="line">    parallel_.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">BufferPoolManagerInstance</span>(pool_size, num_instances, i, disk_manager, log_manager));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update constructor to destruct all BufferPoolManagerInstances and deallocate any associated memory</span></span><br><span class="line">ParallelBufferPoolManager::~<span class="built_in">ParallelBufferPoolManager</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> bpm : parallel_) &#123;</span><br><span class="line">    <span class="keyword">delete</span> bpm;</span><br><span class="line">  &#125;</span><br><span class="line">  parallel_.<span class="built_in">clear</span>();</span><br><span class="line">  std::<span class="built_in">vector</span>&lt;BufferPoolManager*&gt;().<span class="built_in">swap</span>(parallel_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>parallel_buffer_pool_manager.h</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;BufferPoolManager*&gt; parallel_;</span><br><span class="line">  <span class="type">uint32_t</span> num_instances_;</span><br><span class="line">  <span class="type">size_t</span> pool_size_;</span><br><span class="line">  <span class="type">int</span> start_ = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><strong>总结</strong></h2><p>通过完成lab1，让我站在DBMS的角度去理解了操作系统的工作原理，以及对页表，缓存，刷盘时机，页面调度算法LRU有了更深刻的理解。</p>]]></content>
      
      
      <categories>
          
          <category> CMU15-445 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61C Lab2</title>
      <link href="/2022/05/16/cs61c-lab2/"/>
      <url>/2022/05/16/cs61c-lab2/</url>
      
        <content type="html"><![CDATA[<!-- # CS61C Lab2 --><blockquote><p>覆盖广的一个lab</p></blockquote><span id="more"></span><h2 id="exercise-0-makefiles"><strong>Exercise 0: Makefiles</strong></h2><ol type="1"><li>Which target is part of a rule that deletes all the compiled programs?</li><li>Which target is part of a rule that makes all the compiled programs?</li><li>Which compiler is currently being used?</li><li>What C standard are we currently using?</li><li>How would we reference a variable FOO in a makefile?</li><li>What operating system does the term “Darwin” represent?</li><li>What line creates the lfsr program from its object files? (Give its line number.)</li></ol><p>我的答案: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.clean</span><br><span class="line">2.all</span><br><span class="line">3.gcc</span><br><span class="line">4.c99</span><br><span class="line">5.$(Foo)</span><br><span class="line">6.macos</span><br><span class="line">7.31</span><br></pre></td></tr></table></figure> ## <strong>Exercise 1: Bit Operations</strong> <code>get_bit</code>很简单，<code>set_bit</code>中需要将<code>v</code>的<code>0</code>和<code>1</code>减去1构造一下变成全0和全1来判断条件, 做过csapp的datalab之后一下就有思路了。若<code>v</code>为<code>1</code>则只需要移动<code>n</code>个bit到对应的bit或一下就行了，置为0则需要考虑一下除了移动到的bit之外的bit都置为1，可以在移位前做加上一个<code>1</code>的处理，随后移动到相应位置之后再取反，与一下即可。<code>flip_bit</code>只需要稍加处理在应用<code>set_bit</code>的模式即可，先取到即将要翻转的bit，随后与<code>1</code>做异或运算，使得0变为1，1变为0。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bit_ops.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the nth bit of x.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">get_bit</span><span class="params">(<span class="type">unsigned</span> x,</span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">    <span class="comment">// Returning -1 is a placeholder (it makes</span></span><br><span class="line">    <span class="comment">// no sense, because get_bit only returns</span></span><br><span class="line">    <span class="comment">// 0 or 1)</span></span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; n) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set the nth bit of the value of x to v.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(<span class="type">unsigned</span> * x,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> n,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line"><span class="type">int</span> flag = v<span class="number">-1</span>;</span><br><span class="line">(*x) = (((*x) | (v &lt;&lt; n)) &amp; (~flag)) | ((*x) &amp; (~((v+<span class="number">1</span>) &lt;&lt; n)) &amp; flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Flip the nth bit of the value of x.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flip_bit</span><span class="params">(<span class="type">unsigned</span> * x,</span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line"><span class="type">int</span> v = ((*x) &gt;&gt; n) &amp; <span class="number">0x1</span>;</span><br><span class="line">v ^= <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> flag = v<span class="number">-1</span>;</span><br><span class="line">(*x) = (((*x) | (v &lt;&lt; n)) &amp; (~flag)) | ((*x) &amp; (~((v+<span class="number">1</span>) &lt;&lt; n)) &amp; flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## <strong>Exercise 2: Linear Feedback Shift Register</strong> <img src="https://pic4.zhimg.com/80/v2-704f48aad6446d5640cac655e77e7a19.gif" alt="Linear Feedback Shift Register"></p><p>根据图中信息构造门级电路即可，<code>test</code>中循环已经写好不需要再构建循环。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lfsr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lfsr_calculate</span><span class="params">(<span class="type">uint16_t</span> *reg)</span> &#123;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line"><span class="type">uint16_t</span> regs =*reg; </span><br><span class="line"><span class="type">uint16_t</span> msb = ((regs&amp;<span class="number">0x1</span>)^((regs&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x1</span>)^((regs&gt;&gt;<span class="number">3</span>)&amp;<span class="number">0x1</span>)^((regs&gt;&gt;<span class="number">5</span>)&amp;<span class="number">0x1</span>))&lt;&lt;<span class="number">15</span>;</span><br><span class="line">(*reg) &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">(*reg) |= msb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="exercise-3-linked-lists"><strong>Exercise 3: Linked Lists</strong></h2><p>面试常考的翻转链表 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a node to the end of the linked list. Assume head_ptr is non-null. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">append_node</span> <span class="params">(node** head_ptr, <span class="type">int</span> new_data)</span> &#123;</span><br><span class="line"><span class="comment">/* First lets allocate memory for the new node and initialize its attributes */</span></span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">node* new_node = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">new_node-&gt;val = new_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the list is empty, set the new node to be the head and return */</span></span><br><span class="line"><span class="keyword">if</span> (*head_ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">*head_ptr = new_node;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node* curr = *head_ptr;</span><br><span class="line"><span class="keyword">while</span> (curr-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">curr = curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Insert node at the end of the list */</span></span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">curr-&gt;next = new_node;</span><br><span class="line">new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reverse a linked list in place (in other words, without creating a new list).</span></span><br><span class="line"><span class="comment">   Assume that head_ptr is non-null. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_list</span> <span class="params">(node** head_ptr)</span> &#123;</span><br><span class="line">node* prev = <span class="literal">NULL</span>;</span><br><span class="line">node* curr = *head_ptr;</span><br><span class="line">node* next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/* INSERT CODE HERE */</span></span><br><span class="line">next = curr-&gt;next;</span><br><span class="line">curr-&gt;next = prev;</span><br><span class="line">prev = curr;</span><br><span class="line">curr = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Set the new head to be what originally was the last node in the list */</span></span><br><span class="line">*head_ptr = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="exercise-4-memory-management"><strong>Exercise 4: Memory Management</strong></h2><p>为<code>vector</code>在<code>Makefile</code>中指定目标, 将下列语句添加到<code>Makefile</code>中。 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(VECTOR_PROG)</span>: <span class="variable">$(VECTOR_OBJS)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -g -o <span class="variable">$(VECTOR_PROG)</span> <span class="variable">$(VECTOR_OBJS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure></p><p>分析一下: <code>bad_vector_new</code>。声明的指针变量v未被使用，且没有为结构体<code>vector_t</code>动态开辟堆空间，而是使用野指针，这样很危险; <code>also_bad_vector_new</code>。声明栈上的结构体数据，最后返回之后拷贝的开销非常大，因此也不够合理, 且如果未及时对返回值进行保存，栈帧会有被覆盖的可能，会丢失返回的数据。</p><blockquote><p>$ valgrind --tool=memcheck --leak-check=full --track-origins=yes [OS SPECIFIC ARGS] <code>./&lt;executable&gt;</code> - <code>Valgrind</code>默认使用<code>memcheck</code>工具。还有其它工具包括: <code>Callgrind</code>, <code>Cachegrind</code>, <code>Helgrind</code>, <code>Massif</code>。 - <code>--leak-check=full</code>: 详细地显示每个单独的内存泄露。 - <code>--track-origins=yes</code>: 这会跟踪初始化值的来源。着重于有用的输出而不是速度。</p></blockquote><p>注意在函数<code>vector_set</code>的题意，超出访问的loc超出堆内存的范围需要重新再申请空间<code>realloc</code>，而不是简单地提示错误信息，若重新申请为空则提示错误信息<code>allocation_failed</code>。用<code>cgdb</code>慢慢调就行了。在<code>make vector_test</code>通过后，使用工具<code>Valgrind</code>检测到内存泄露，查看了一下<code>vector_test</code>函数，发现存在使用未初始化元素的行为，随后便可以将问题可以定位到<code>vector_set</code>函数中，在其中加入for循环初始化即可。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new vector with a size (length) of 1</span></span><br><span class="line"><span class="comment">   and set its single component to zero... the</span></span><br><span class="line"><span class="comment">   RIGHT WAY */</span></span><br><span class="line"><span class="type">vector_t</span> *<span class="title function_">vector_new</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* Declare what this function will return */</span></span><br><span class="line">    <span class="type">vector_t</span> *retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First, we need to allocate memory on the heap for the struct */</span></span><br><span class="line">    retval = (<span class="type">vector_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">vector_t</span>));<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check our return value to make sure we got memory */</span></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="literal">NULL</span><span class="comment">/* YOUR CODE HERE */</span>) &#123;</span><br><span class="line">        allocation_failed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we need to initialize our data.</span></span><br><span class="line"><span class="comment">       Since retval-&gt;data should be able to dynamically grow,</span></span><br><span class="line"><span class="comment">       what do you need to do? */</span></span><br><span class="line">    retval-&gt;size = <span class="number">1</span>;<span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line">    retval-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*retval-&gt;size);<span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the data attribute of our vector to make sure we got memory */</span></span><br><span class="line">    <span class="keyword">if</span> (retval-&gt;data == <span class="literal">NULL</span><span class="comment">/* YOUR CODE HERE */</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(retval);<span class="comment">//Why is this line necessary? Because it allocate the memory of vector but not allocate the data that will cause memory leak.</span></span><br><span class="line">        allocation_failed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Complete the initialization by setting the single component to zero */</span></span><br><span class="line">    <span class="comment">/* YOUR CODE HERE */</span> </span><br><span class="line">*(retval-&gt;data) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* and return... */</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at the specified location/component &quot;loc&quot; of the vector */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vector_get</span><span class="params">(<span class="type">vector_t</span> *v, <span class="type">size_t</span> loc)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are passed a NULL pointer for our vector, complain about it and exit. */</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;vector_get: passed a NULL vector.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the requested location is higher than we have allocated, return 0.</span></span><br><span class="line"><span class="comment">     * Otherwise, return what is in the passed location.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (loc &lt; v-&gt;size<span class="comment">/* YOUR CODE HERE */</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> v-&gt;data[loc];<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free up the memory allocated for the passed vector.</span></span><br><span class="line"><span class="comment">   Remember, you need to free up ALL the memory that was allocated. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_delete</span><span class="params">(<span class="type">vector_t</span> *v)</span> &#123;</span><br><span class="line">    <span class="comment">/* YOUR SOLUTION HERE */</span></span><br><span class="line"><span class="built_in">free</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set a value in the vector. If the extra memory allocation fails, call</span></span><br><span class="line"><span class="comment">   allocation_failed(). */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_set</span><span class="params">(<span class="type">vector_t</span> *v, <span class="type">size_t</span> loc, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">/* What do you need to do if the location is greater than the size we have</span></span><br><span class="line"><span class="comment">     * allocated?  Remember that unset locations should contain a value of 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* YOUR SOLUTION HERE */</span></span><br><span class="line"><span class="keyword">if</span> (loc &gt;= v-&gt;size) &#123;</span><br><span class="line">v-&gt;data = (<span class="type">int</span>*)<span class="built_in">realloc</span>(v-&gt;data, <span class="keyword">sizeof</span>(<span class="type">int</span>)*(loc+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            allocation_failed();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = v-&gt;size; i &lt; loc+<span class="number">1</span>; ++i)</span><br><span class="line">v-&gt;data[i] = <span class="number">0</span>;</span><br><span class="line">v-&gt;size = loc+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">v-&gt;data[loc] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> CS61C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stanford CS144 Lab0: Networking Warmup</title>
      <link href="/2022/05/16/cs144-lab0/"/>
      <url>/2022/05/16/cs144-lab0/</url>
      
        <content type="html"><![CDATA[<!-- # Stanford CS144 Lab0: Networking Warmup --><blockquote><p>应用层Overview</p></blockquote><span id="more"></span><h2 id="fetch-a-web-page"><strong>1. Fetch a Web page</strong></h2><p>使用<code>telnet</code>通过<code>http</code>协议访问远端服务器 <img src="https://pic4.zhimg.com/80/v2-0f3f73376b27537497d7778b962aa839.png" alt="Image"></p><h2 id="writing-webget"><strong>2. Writing webget</strong></h2><h3 id="描述"><strong>2.1 描述</strong></h3><p>实现<code>webget</code>来通过Internet获取网页，使用TCP协议和套接字抽象。实现简单的Web客户端，使用上述<code>HTTP</code>的形式。读数据时遇到<code>EOF</code>则结束，使用轮询的方式读取数据。</p><blockquote><p>Please note that in HTTP, each line must be ended with “” (it’s not sufficient to use just “” or endl). • Don’t forget to include the “Connection: close” line in your client’s request. This tells the server that it shouldn’t wait around for your client to send any more requests after this one. Instead, the server will send one reply and then will immediately end its outgoing bytestream (the one from the server’s socket to your socket). You’ll discover that your incoming byte stream has ended because your socket will reach “EOF” (end of file) when you have read the entire byte stream coming from the server. That’s how your client will know that the server has finished its reply. • Make sure to read and print all the output from the server until the socket reaches “EOF” (end of file)—a single call to read is not enough. • We expect you’ll need to write about ten lines of code.</p></blockquote><h3 id="实现"><strong>2.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\n&quot;;</span></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;</span></span><br><span class="line">    TCPSocket client;</span><br><span class="line">    client.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    string message = <span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span> + </span><br><span class="line">                    host + <span class="string">&quot; \r\nConnection: close\r\n\r\n&quot;</span>;</span><br><span class="line">    client.<span class="built_in">write</span>(message);</span><br><span class="line">    client.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!client.<span class="built_in">eof</span>()) &#123;  <span class="comment">// polling</span></span><br><span class="line">        cout &lt;&lt; client.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    client.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="an-in-memory-reliable-byte-stream"><strong>3. An in-memory reliable byte stream</strong></h2><h3 id="描述-1"><strong>3.1 描述</strong></h3><ol type="1"><li><code>ByteStream</code>字节流是有限的, 容量为<code>capacity</code>，允许在内存中存在的最大数量的字节，确保写字节数不超过<code>capacity</code>。</li><li>需要实现一个缓冲区<code>buffer</code>来模拟当前字节流相应的功能。考虑到读端(Output End)队头和写端(Input End)队尾，因此使用<code>stl</code>中的双端队列<code>deque</code>来实现。</li><li><code>eof()</code>返回<code>true</code>, 读端无数据可读有两种情况, 一次读到<code>eof</code>、或者buffer为空。</li><li>从写端取数据分为两种操作, <code>peek</code>和<code>pop</code></li></ol><h3 id="实现-1"><strong>3.2 实现</strong></h3><p>byte_stream.cc <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : <span class="built_in">buffer_</span>(std::<span class="built_in">move</span>(<span class="built_in">deque</span>&lt;<span class="type">char</span>&gt;(<span class="number">0</span>))), <span class="built_in">capacity_</span>(capacity), <span class="built_in">end_write_</span>(<span class="literal">false</span>),</span><br><span class="line">                    <span class="built_in">read_num_</span>(<span class="number">0</span>), <span class="built_in">write_num_</span>(<span class="number">0</span>) &#123; <span class="built_in">DUMMY_CODE</span>(capacity); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(data);</span><br><span class="line">    <span class="type">size_t</span> can_write = <span class="built_in">min</span>(data.<span class="built_in">size</span>(), <span class="built_in">remaining_capacity</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; can_write; ++i) &#123;</span><br><span class="line">        buffer_.<span class="built_in">push_back</span>(data[i]);    <span class="comment">// push from the input side.</span></span><br><span class="line">    &#125;</span><br><span class="line">    write_num_ += can_write;</span><br><span class="line">    <span class="keyword">return</span> can_write;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(len);</span><br><span class="line">    <span class="type">size_t</span> can_peek = <span class="built_in">min</span>(len, buffer_.<span class="built_in">size</span>());</span><br><span class="line">    string peek_data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; can_peek; ++i) &#123;</span><br><span class="line">        peek_data += buffer_[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> peek_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; buffer_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">set_error</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        buffer_.<span class="built_in">pop_front</span>();           <span class="comment">// removed from the output side.</span></span><br><span class="line">    &#125;</span><br><span class="line">    read_num_ += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(len);</span><br><span class="line">    string message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> can_read = <span class="built_in">min</span>(len, buffer_.<span class="built_in">size</span>());  <span class="comment">// next &quot;len&quot; bytes.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; can_read; ++i) &#123;</span><br><span class="line">        message += buffer_.<span class="built_in">front</span>();</span><br><span class="line">        buffer_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    read_num_ += can_read;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; end_write_ = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end_write_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">buffer_empty</span>() &amp;&amp; end_write_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> write_num_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> read_num_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> capacity_ - buffer_.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure> byte_stream.hh <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that&#x27;s a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; buffer_;</span><br><span class="line">    <span class="type">size_t</span> capacity_;     <span class="comment">// capacity in memory.</span></span><br><span class="line">    <span class="type">bool</span> end_write_;</span><br><span class="line">    <span class="type">size_t</span> read_num_;</span><br><span class="line">    <span class="type">size_t</span> write_num_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> _error&#123;&#125;;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab5: xv6 lazy page allocation</title>
      <link href="/2022/05/16/s081-lab5/"/>
      <url>/2022/05/16/s081-lab5/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab5: xv6 lazy page allocation --><p>很多情况都用到了Lazy allocation, 比如: - paging from disk - COW fork - automatically extending stack - memory-mapped files <span id="more"></span></p><p>xv6使用<code>sbrk()</code>申请<strong>物理地址空间</strong>并将其映射到进程的虚拟地址空间(向内核请求堆内存)。这个lab视频上也给了很多提示，重要的是理解并掌握原理。</p><p>实际上复杂的内核会在分配栈空间时做这样的处理, <code>sbrk</code>没有分配物理地址空间，只是记住分配了哪些用户地址，并在用户地址将这些地址标记为无效(invalid)。当进程尝试第一次使用任何给定Lazy Allocation的页面时，CPU会产生Page Fault的异常，该异常错误的类型会存放到<code>scause</code>寄存器，而<code>stval</code>寄存器中从存放着不能被translate的虚拟地址。 <img src="https://pic4.zhimg.com/80/v2-998ad453d6ec0eed41edd98ca61aa644.png" alt="scause"></p><p>Page Fault的类型: - load page faults, load指令不能translate地址 - store page faults，store指令不能translate地址 - instruction page faults，指令地址未能被tanslate ## <strong>1. Eliminate allocation from sbrk()</strong> ### <strong>1.1 Description</strong> 将<code>growproc</code>函数注释掉，不分配物理地址空间，只增加进程内存的大小。 ### <strong>1.2 Implementation</strong> <code>kernel/sysproc.c</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line"></span><br><span class="line">  myproc()-&gt;sz += n;</span><br><span class="line">  <span class="comment">// if(growproc(n) &lt; 0)  // Not need to allocate pysical memory.</span></span><br><span class="line">  <span class="comment">//   return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;  <span class="comment">// return the old size of process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## <strong>2. Lazy allocation</strong> ### <strong>2.1 Description</strong> 比如说要实现<code>Lazy allocation</code>, 在<code>sbrk()</code>系统调用时<code>page fault</code>异常发生，<code>sepc</code>寄存器保证在修补完页表之后到跳转回异常发生时执行指令的位置重新执行指令(原本的疑虑是在<code>usertrapret()</code>中sepc会+4即跳转到当前指令的下一条指令，实际上在lab3中才有自增4这条语句= =)。若没有空闲的物理内存，则返回错误，并且kill进程。如果<code>sbrk()</code>缩减堆内存，<code>page fault</code>就不会发生。</p><p><code>uvmunmap</code>产生panic的原因是因为<code>sbrk()</code>已经分配物理内存但该物理内存未被使用。</p><p>在<code>printf</code>之前修改代码，使得<code>echo hi</code>正确执行。 Some hint: - You can check whether a fault is a page fault by seeing if r_scause() is 13 or 15 in usertrap(). - r_stval() returns the RISC-V stval register, which contains the virtual address that caused the page fault. - Steal code from uvmalloc() in vm.c, which is what sbrk() calls (via growproc()). You'll need to call kalloc() and mappages(). - Use PGROUNDDOWN(va) to round the faulting virtual address down to a page boundary. - uvmunmap() will panic; modify it to not panic if some pages aren't mapped. - If the kernel crashes, look up sepc in kernel/kernel.asm - Use your vmprint function from pgtbl lab to print the content of a page table. - If you see the error "incomplete type proc", include "spinlock.h" then "proc.h". ### <strong>2.2 Implementation</strong> <code>kernel/trap:usertrap</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    <span class="comment">// check whether a fault is a page fault</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page fault: %p\n&quot;</span>, va);</span><br><span class="line">    <span class="comment">// lazy allocation before printf information.</span></span><br><span class="line">    <span class="type">char</span>* mem = kalloc();  <span class="comment">// allocate one page of physical memory. </span></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);  <span class="comment">// set all zeros.</span></span><br><span class="line">      <span class="keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure> <code>kernel/vm.c:uvmunmap</code>, 如果这一部分不用<strong>continue</strong>来处理，在接下来的code，刚分配的物理内存就会被释放掉。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## <strong>3. Lazytests and Usertests</strong> ### <strong>3.1 Description</strong> 如果<code>sbrk()</code>缩减堆空间大小而不是扩大，注意<code>proc.sz</code>为无符号整型数，和一个int型数相加，有符号数会向无符号数发生隐式地转换。还需要注意<code>uvmunmap</code>的<code>walk panic</code>，已经改变sz但未分配物理地址，在释放就会出现<code>panic</code>，只需要执行<code>continue</code>即可。<code>out of memory</code>测试。同时xv6book中第三章有说<code>guard page</code>的<code>PTE_V</code>未设置，注意参考第三章给出的用户地址空间的布局。xv6中为用户栈分配了一个页</p><p>Some hints: - Handle negative sbrk() arguments. - Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk(). - Handle the parent-to-child memory copy in fork() correctly. - Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated. - Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process. - Handle faults on the invalid page below the user stack. ### <strong>3.2 Implementation</strong></p><h2 id="总结"><strong>总结</strong></h2>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab4: Traps</title>
      <link href="/2022/05/16/s081-lab4/"/>
      <url>/2022/05/16/s081-lab4/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab4: Traps --><ul><li>跟着视频走一遍系统调用<code>gdb</code>的流程。<code>tmux</code>分割两个窗口，一个窗口作为服务器<code>make CPUS=1 qemu-gdb</code>，另一个窗口作为<code>gdb</code>调试窗口<code>gdb-multiarch</code>。将断点打在<code>ecall指令处</code>, <code>continue</code>执行，随后再将第二个断点打到<code>print/x $stvec</code>处也就是，<code>TRAPFRAME</code>的起始地址。<code>ecall</code>指令完成三件事，将用户模式切换到管理员模式、将PC保存到sepc寄存器中、将stvec寄存器的值赋给PC跳转到stvec保存的地址处执行。 <span id="more"></span></li><li>进入<code>trampoline.s</code>后，<code>csrrw a0, sscratch, a0</code>首先将非体系结构寄存器<code>sscratch</code>与<code>a0</code>的值交换，<code>sscratch</code>寄存器中保存的时<code>TRAPFRAME</code>的起始地址。</li><li>然后将当前的现场(即寄存器)保存到<code>TRAPFRAME</code>中，再将<code>TRAPFRAME</code>中保存的内核栈指针，<code>hartid</code>，<code>usertrap()</code>的地址，以及内核页表所在的<code>stap</code>寄存器的值加载到当前通用寄存器中。</li><li>随后将寄存器<code>t1</code>保存的内核页目录的地址写入当前<code>satp</code>寄存器中，再刷新<code>TLB</code>，将用户页表切换为内核页表 <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csrw satp, <span class="built_in">t1</span></span><br><span class="line">sfence.vma <span class="built_in">zero</span>, <span class="built_in">zero</span></span><br></pre></td></tr></table></figure></li><li>将用户模式完全切换为内核模式之后，最后跳到<code>t0</code>中保存的<code>usertrap()</code>的入口地址，<code>jr t0</code>跳入<code>usertrap</code>函数。</li><li>进入函数后，首先判断<code>sstatus</code>寄存器的<code>SSP</code>位是否为<code>0</code>(即是否为用户模式下发生的trap)。将<code>stvec</code>赋值为<code>kernelvec</code>的入口地址，即在当前<code>usertrap</code>发生的中断或异常则跳转到<code>stvec</code>处执行。再保存中断返回的地址到<code>sepc</code>。</li><li>中断将会改变<code>sstatus</code>寄存器，因此在修改结束之后才将中断打开<code>intr_on()</code>。</li><li>之后进入系统调用<code>syscall()</code>，根据<code>p-&gt;trapframe-&gt;a7</code>中保存的系统调用号来决定调用哪个系统调用(专门通过一个静态数组查找<code>syscalls[num]</code>), 随后将系统调用的返回值保存到<code>p-&gt;trapframe-&gt;a0</code>中。</li><li>完成系统调用之后，随后计算<code>uservec</code>的虚拟地址并赋值给<code>stvec</code>，以便发生异常或中断的时候处理。接下来将相应的内容restore到<code>trapframe</code>中方便进行下一次<code>trap</code>。随后更新<code>sstatus</code>状态寄存器的值，清空<code>SSP</code>、设置<code>SPIE</code>位。</li><li>更新<code>sepc</code>的值以及将<code>satp</code>的值设为内核页表的地址，将在<code>userret</code>中切换页表。计算<code>userret</code>在<code>trampoline.s</code>中的虚拟地址，跳转到<code>userret</code>，跳转之前传参有个小细节，即将<code>TRAMPOLINE</code>作为第一个参数，这样在<code>a0</code>与<code>sscratch</code>交换后，<code>sscratch</code>就得到<code>TRAMPOLINE</code>的起始地址了。</li><li>进入到收尾阶段，将恢复到<code>trap</code>之前的状态。将<code>TRAMPOLINE</code>中的内容load到通用寄存器中，先将<code>a0</code>寄存器的值写入<code>sscratch</code>寄存器中，这样最后<code>csrrw a0, sscratch, a0</code>即可将这两个寄存器复位为各自的值。最后<code>sret</code>将<code>sepc</code>赋给<code>pc</code>完成系统调用恢复正常执行。</li></ul><h4 id="比较重要的非体系结构寄存器"><strong>比较重要的非体系结构寄存器</strong></h4><ul><li>stvec, 存放系统调用处理程序的地址</li><li>sepc, 当系统调用发生时PC存放到此处，以便系统调用返回时能从下一条指令开始执行<code>sret</code>: sepc -&gt; pc。</li><li>scause, ISA通过它来分析系统调用的种类</li><li>sscratch, 内核将一个值放到这里，方便系统调用的开始(通用寄存器和sscratch寄存器通过csrrw来交换值<code>csrrw a0, sscratch, a0</code>)。</li><li>sstatus, 状态寄存器，类似LC-3来决定是否发生中断，或者决定是用户模式还是系统模式，若存在条件码则存放条件码。</li></ul><h4 id="debug相关"><strong>Debug相关</strong></h4><ul><li><code>add-symbol-file</code>或<code>file</code>命令从文件<code>filename</code>中读取附加的符号表信息存放在<code>ELF</code>文件(可重定向目标文件)中的<code>.symtab</code> Entry中。当文件名（通过其他方式）动态加载到正在运行的程序中时，将使用此命令。</li><li>解决调试alarmtest时<code>usertrap</code> C源代码不显示的, 函数和变量信息不够全，需要<code>add-symbol-file kernel/kernel</code>即可。</li></ul><h2 id="risc-v-assembly"><strong>1. RISC-V assembly</strong></h2><h3 id="description"><strong>1.1 Description</strong></h3><blockquote><p>It will be important to understand a bit of RISC-V assembly, which you were exposed to in 6.004. There is a file user/call.c in your xv6 repo. make fs.img compiles it and also produces a readable assembly version of the program in user/call.asm.</p><p>可以在<code>gdb</code>中使用<code>file</code>来对<code>call.o</code>文件调试，并将断点打到<code>main</code>函数上。解释调试时<code>RISCV</code>汇编出现的一些指令, <code>x</code>表示寄存器, <code>M</code>表示存储器: - <code>auipc</code>, Add Upper Immediate to PC. 将指令编码格式中的<code>Imm[31:12]</code>左移12位后的结果<code>sign-extened</code>后再加上PC。 <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auipc rd, Imm  <span class="comment">; x[rd] = PC + sext(Imm[31:12] &lt;&lt; 12)</span></span><br></pre></td></tr></table></figure> - <code>li</code>(pseudoinstruction), Load Immediate. <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li rd, Imm  <span class="comment">; x[rd] = Imm</span></span><br></pre></td></tr></table></figure> - <code>mv</code>(pseudoinstruction), Move. 注意与<code>x86 ISA</code>的<code>mov</code>传递方向不同。 <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv rd, rs1  <span class="comment">; x[rd] = x[rs1]</span></span><br></pre></td></tr></table></figure> - <code>jalr</code>, Jump And Link Register. <a href="https://stackoverflow.com/questions/40453719/risc-v-why-set-least-significant-bit-to-zero-in-jalr">为什么要将最低有效位置为0?</a>字节对齐。将当前pc+4赋给ra作为返回地址并跳转到offset(rs1), 随后返回到当前指令的下一条指令继续执行。注意如果rd省略了，那么rd就默认为x1(即<code>ra</code>保存返回地址的寄存器)。 <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jalr </span>rd, offset(rs1)  <span class="comment">; t=pc+4; pc=(x[rs1]+sext(offset)) &amp; ~1; x[rd] = t;</span></span><br></pre></td></tr></table></figure> - <code>lbu</code>, Load Byte Unsigned. 取完一个字节后，紧接着零拓展, <code>lb</code>为符号位拓展。 <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lbu </span>rd, offset(rs1)  <span class="comment">; x[rd] M[x[rs1] + sext(offset)] [7:0]</span></span><br></pre></td></tr></table></figure> - <code>seqz</code>(pseudoinstruction), Set if Equal to Zero. <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seqz rd, rs1  <span class="comment">; x[rd] = (x[rs1] == 0)</span></span><br></pre></td></tr></table></figure> - <code>csrrw</code>, Control and Status Register Read and Write. 状态寄存器和通用寄存器之间的读写操作。将状态寄存器中的内容放入rd寄存器，将rs1的内容放入状态寄存器。 <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrrw rd, csr, rs1  <span class="comment">; t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t</span></span><br></pre></td></tr></table></figure> - <code>csrw</code> <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrw csr, rs1</span><br></pre></td></tr></table></figure> - <code>csrr</code> <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrr rd, csr</span><br></pre></td></tr></table></figure> ### <strong>1.2 Implementation</strong> - 不了解RISCV指令集的建议可以把<a href="https://inst.eecs.berkeley.edu/~cs61c/su20/">CS61C</a>的Week2专门讲RISCV的slide或者视频看完，直到把调试过程中遇到的每条指令弄明白再来做这一个task。</p></blockquote><p>分析<code>user/call.asm</code> <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  <span class="number">1</span>c:<span class="number">1141</span>                <span class="keyword">addi</span><span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">16</span></span><br><span class="line">  <span class="number">1</span>e:e406                sd<span class="built_in">ra</span>,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="symbol">  20:</span>e022                sd<span class="built_in">s0</span>,<span class="number">0</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="symbol">  22:</span><span class="number">0800</span>                <span class="keyword">addi</span><span class="built_in">s0</span>,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">  printf(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line"><span class="symbol">  24:</span><span class="number">4635</span>                li<span class="built_in">a2</span>,<span class="number">13</span></span><br><span class="line"><span class="symbol">  26:</span><span class="number">45</span>b1                li<span class="built_in">a1</span>,<span class="number">12</span></span><br><span class="line"><span class="symbol">  28:</span><span class="number">00000517</span>          auipc<span class="built_in">a0</span>,<span class="number">0x0</span></span><br><span class="line">  <span class="number">2</span>c:<span class="number">7</span>c050513          <span class="keyword">addi</span><span class="built_in">a0</span>,<span class="built_in">a0</span>,<span class="number">1984</span> <span class="comment"># 7e8 &lt;malloc+0xea&gt;</span></span><br><span class="line"><span class="symbol">  30:</span><span class="number">00000097</span>          auipc<span class="built_in">ra</span>,<span class="number">0x0</span></span><br><span class="line"><span class="symbol">  34:</span><span class="number">610080</span>e7          <span class="keyword">jalr</span><span class="number">1552</span>(<span class="built_in">ra</span>) <span class="comment"># 640 &lt;printf&gt;</span></span><br><span class="line">  exit(<span class="number">0</span>);</span><br><span class="line"><span class="symbol">  38:</span><span class="number">4501</span>                li<span class="built_in">a0</span>,<span class="number">0</span></span><br><span class="line">  <span class="number">3</span>a:<span class="number">00000097</span>          auipc<span class="built_in">ra</span>,<span class="number">0x0</span></span><br><span class="line">  <span class="number">3</span>e:<span class="number">27</span>e080e7          <span class="keyword">jalr</span><span class="number">638</span>(<span class="built_in">ra</span>) <span class="comment"># 2b8 &lt;exit&gt;</span></span><br></pre></td></tr></table></figure> - Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf? <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2</span><br></pre></td></tr></table></figure> - Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline funtions.) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译器优化: g被inline到了f中，f又进一步被内联到了main中 </span><br></pre></td></tr></table></figure> - At what address is the function printf located? <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auipc ra, 0x0指令将0x30赋给ra中, 而jalr 1552(ra)跳转到的地址为0x640</span><br></pre></td></tr></table></figure> - What value is in the register ra just after the jalr to printf in main? <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果jalr没有第一个操作数，那么返回地址默认存放到ra寄存器中。ra=pc+4即0x38</span><br></pre></td></tr></table></figure> - Run the following code. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line"> ```     </span><br><span class="line"> What is the output? </span><br></pre></td></tr></table></figure> 57616=0xe110, RISCV是little-endian, 因此i在内存中存储的形式为0x726c6400对应的ASCII值为0x72 = 'r', 0x6c = 'l', 0x64 = 'd', 0x00 = '\0'。因此最后printf输出的结果为"He110, World\0"。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If the RISC-V were instead big-endian what would you set i to in order to yield the same output?</span><br></pre></td></tr></table></figure> 如果是大端字节序，为保持相同的输出结果，将i的值反过来即可i = 0x726c6400 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- In the following code, what is going to be printed after &#x27;y=&#x27;? (note: the answer is not a specific value.) Why does this happen?</span><br><span class="line">  ``` c</span><br><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阅读call.asm, 将3存放到a1寄存器后，在调用printf之前并未对a2寄存器进行修改(本应该有第二个参数的), 第二个参数传入的值是a2寄存器中原有的随机值。</span><br></pre></td></tr></table></figure></p><h2 id="backtrace"><strong>2. Backtrace</strong></h2><h3 id="description-1"><strong>2.1 Description</strong></h3><p>在<code>kernel/printf.c</code>中实现<code>backtrace()</code>函数。阅读源码时会有<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">内联汇编</a>的相关知识。实现backtrace函数还需要了解<a href="https://pdos.csail.mit.edu/6.828/2020/lec/l-riscv-slides.pdf">RISCV栈帧</a>布局。当前的<code>stack frame</code>含有对前一个<code>stack frame</code>的指针。高地址往低地址以此为<code>Return Address</code>, <code>To Prev. Frame Pointer</code>, <code>Saved Registers</code>, <code>Local Variables</code>...其中frame pointer指向栈帧第一个entry的顶部。 Some hints - Add the prototype for backtrace to kernel/defs.h so that you can invoke backtrace in sys_sleep. - The GCC compiler stores the frame pointer of the currently executing function in the register s0. Add the following function to kernel/riscv.h: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> and call this function in backtrace to read the current frame pointer. This function uses in-line assembly to read s0. - These lecture notes have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer. - Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using PGROUNDDOWN(fp) and PGROUNDUP(fp) (see kernel/riscv.h. These number are helpful for backtrace to terminate its loop. ### <strong>2.2 Implementation</strong> 要利用好当前栈帧所在页的边界，来通过每个栈帧的prev(类似于链表)，来遍历并打印当前栈帧的返回地址。要注意栈是由高地址向低地址方向增长的，因此需要获取页的Top作为边界, 要理解<strong>回溯</strong>这个词。注意更新fp的时候上一个栈帧的fp是存放在地址单元为当前栈帧的fp-8中的, 因此需要解引用(*)取地址。在xv6中，内核为进程分配一个页大小的栈。 <code>kernel/printf.c</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 fp = r_fp();  <span class="comment">// r_fp() return the fp of current execute function</span></span><br><span class="line">  uint64 ftop = PGROUNDUP(fp);  <span class="comment">// get the top addr of stack frame page.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (fp &lt; ftop) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(fp<span class="number">-8</span>));  <span class="comment">// print return address stored in (fp-8).</span></span><br><span class="line">    fp = *(uint64*)(fp<span class="number">-16</span>);   <span class="comment">//  update fp to previous frame fp.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="alarm"><strong>3. Alarm</strong></h2><h3 id="description-2"><strong>3.1 Description</strong></h3><blockquote><p>In this exercise you'll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you'll be implementing a primitive form of user-level interrupt/fault handlers; you could use something similar to handle page faults in the application, for example</p></blockquote><p>sigalarm(n, fn)表示，在每个n ticks之后将会调用应用程序函数fn, 当fn函数调用结束之后，应用程序将会在它调用fn的地址处恢复执行。 ### <strong>3.2.1 test0: invoke handler</strong> Some hints: - You'll need to modify the Makefile to cause alarmtest.c to be compiled as an xv6 user program. - The right declarations to put in user/user.h are: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure> - Update user/usys.pl (which generates user/usys.S), kernel/syscall.h, and kernel/syscall.c to allow alarmtest to invoke the sigalarm and sigreturn system calls. - For now, your sys_sigreturn should just return zero. - Your sys_sigalarm() should store the alarm interval and the pointer to the handler function in new fields in the proc structure (in kernel/proc.h). - You'll need to keep track of how many ticks have passed since the last call (or are left until the next call) to a process's alarm handler; you'll need a new field in struct proc for this too. You can initialize proc fields in allocproc() in proc.c. - Every tick, the hardware clock forces an interrupt, which is handled in usertrap() in kernel/trap.c. - You only want to manipulate a process's alarm ticks if there's a timer interrupt; you want something like <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) ...</span><br></pre></td></tr></table></figure> - Only invoke the alarm function if the process has a timer outstanding. Note that the address of the user's alarm function might be 0 (e.g., in user/alarmtest.asm, periodic is at address 0). - You'll need to modify usertrap() so that when a process's alarm interval expires, the user process executes the handler function. When a trap on the RISC-V returns to user space, what determines the instruction address at which user-space code resumes execution? - It will be easier to look at traps with gdb if you tell qemu to use only one CPU, which you can do by running <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure> - You've succeeded if alarmtest prints "alarm!". ### <strong>3.2.2 test0 implementation</strong> - <code>kernel/proc.h</code>，在proc结构体中加入结构体成员<code>tick</code>, <code>handler</code>, <code>intervel</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint64 tick;</span><br><span class="line">uint64 handler;</span><br><span class="line">uint64 intervel;</span><br></pre></td></tr></table></figure> - <code>kernel/proc.c</code>，在<code>allocproc</code>函数中初始化<code>tick</code>成员为0。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;tick = <span class="number">0</span>;</span><br></pre></td></tr></table></figure> - <code>kernel/trap.c</code>, 当trap返回时，sret指令将sepc寄存器中的地址赋给pc执行，也就是说在下述代码中，trap返回时将执行alarm的中断处理程序。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;intervel == p-&gt;tick) &#123;  <span class="comment">// expire</span></span><br><span class="line">    p-&gt;tick = <span class="number">0</span>;  <span class="comment">// reset tick</span></span><br><span class="line">    <span class="comment">// save all the needed registers</span></span><br><span class="line">    <span class="comment">// epc store the user program counter(PC).</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;handler;  <span class="comment">// when returned, jump to execute handler.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p-&gt;tick++;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - <code>kernel/sysproc.c</code>, <code>argint</code>和<code>argaddr</code>获取系统调用的第n个参数值, 然后初始化进程中对应的属性。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">int</span> interval;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="comment">// fetch syscall nth argument.</span></span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;interval) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// initialize p&#x27;s attribute.</span></span><br><span class="line">  p-&gt;intervel = interval;</span><br><span class="line">  p-&gt;handler = handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### <strong>3.3.1 test1/test2: resume interrupted code</strong> 需要添加一些操作，确保在alarm处理程序完成后，控制权返回到用户程序最初被时钟中断的指令。必须得确保寄存器内容恢复到中断前的值，以及中断前的位置，所以需要在alarm的handler覆盖掉sepc之前保存好存放返回地址的sepc寄存器。 Some hints: - Your solution will require you to save and restore registers---what registers do you need to save and restore to resume the interrupted code correctly? (Hint: it will be many). - Have usertrap save enough state in struct proc when the timer goes off that sigreturn can correctly return to the interrupted user code. - Prevent re-entrant calls to the handler----if a handler hasn't returned yet, the kernel shouldn't call it again. test2 tests this.</p><h3 id="test1test2-implementation"><strong>3.3.2 test1/test2 Implementation</strong></h3><p>考虑一下第一个提示，是不是可以选择性地<code>save</code>寄存器? 看一下alarmtest.asm中的handler的汇编程序找一找。 - 在<code>kernel/proc.h</code>中加入<code>is_alarm_working</code>属性，防止当前还在执行handler而导致的重入。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> is_alarm_working = <span class="number">0</span>;</span><br></pre></td></tr></table></figure> - <code>kernel/trap.c</code>, 因为为用户级别的中断，因此不涉及到trapframe中保存的有关内核寄存器的修改。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!p-&gt;is_alarm_working &amp;&amp; p-&gt;intervel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;intervel == p-&gt;tick) &#123;  <span class="comment">// expire</span></span><br><span class="line">      p-&gt;tick = <span class="number">0</span>;  <span class="comment">// reset tick</span></span><br><span class="line">      p-&gt;is_alarm_working = <span class="number">1</span>;  <span class="comment">// reprensent executed handler is not terminate.</span></span><br><span class="line">      <span class="comment">// save all the needed registers.</span></span><br><span class="line">      p-&gt;saved_epc = p-&gt;trapframe-&gt;epc; <span class="comment">// save return address.</span></span><br><span class="line">      p-&gt;saved_ra = p-&gt;trapframe-&gt;ra;</span><br><span class="line">      p-&gt;saved_sp = p-&gt;trapframe-&gt;sp;</span><br><span class="line">      p-&gt;saved_gp = p-&gt;trapframe-&gt;gp;</span><br><span class="line">      p-&gt;saved_tp = p-&gt;trapframe-&gt;tp;</span><br><span class="line">      p-&gt;saved_t0 = p-&gt;trapframe-&gt;t0;</span><br><span class="line">      p-&gt;saved_t1 = p-&gt;trapframe-&gt;t1;</span><br><span class="line">      p-&gt;saved_t2 = p-&gt;trapframe-&gt;t2;</span><br><span class="line">      p-&gt;saved_t3 = p-&gt;trapframe-&gt;t3;</span><br><span class="line">      p-&gt;saved_t4 = p-&gt;trapframe-&gt;t4;</span><br><span class="line">      p-&gt;saved_t5 = p-&gt;trapframe-&gt;t5;</span><br><span class="line">      p-&gt;saved_t6 = p-&gt;trapframe-&gt;t6;</span><br><span class="line">      p-&gt;saved_a0 = p-&gt;trapframe-&gt;a0;</span><br><span class="line">      p-&gt;saved_a1 = p-&gt;trapframe-&gt;a1;</span><br><span class="line">      p-&gt;saved_a2 = p-&gt;trapframe-&gt;a2;</span><br><span class="line">      p-&gt;saved_a3 = p-&gt;trapframe-&gt;a3;</span><br><span class="line">      p-&gt;saved_a4 = p-&gt;trapframe-&gt;a4;</span><br><span class="line">      p-&gt;saved_a5 = p-&gt;trapframe-&gt;a5;</span><br><span class="line">      p-&gt;saved_a6 = p-&gt;trapframe-&gt;a6;</span><br><span class="line">      p-&gt;saved_a7 = p-&gt;trapframe-&gt;a7;</span><br><span class="line">      p-&gt;saved_s0 = p-&gt;trapframe-&gt;s0;</span><br><span class="line">      p-&gt;saved_s1 = p-&gt;trapframe-&gt;s1;</span><br><span class="line">      p-&gt;saved_s2 = p-&gt;trapframe-&gt;s2;</span><br><span class="line">      p-&gt;saved_s3 = p-&gt;trapframe-&gt;s3;</span><br><span class="line">      p-&gt;saved_s4 = p-&gt;trapframe-&gt;s4;</span><br><span class="line">      p-&gt;saved_s5 = p-&gt;trapframe-&gt;s5;</span><br><span class="line">      p-&gt;saved_s6 = p-&gt;trapframe-&gt;s6;</span><br><span class="line">      p-&gt;saved_s7 = p-&gt;trapframe-&gt;s7;</span><br><span class="line">      p-&gt;saved_s8 = p-&gt;trapframe-&gt;s8;</span><br><span class="line">      p-&gt;saved_s9 = p-&gt;trapframe-&gt;s9;</span><br><span class="line">      p-&gt;saved_s10 = p-&gt;trapframe-&gt;s10;</span><br><span class="line">      p-&gt;saved_s11 = p-&gt;trapframe-&gt;s11;</span><br><span class="line">      <span class="comment">// epc register store the user program counter(PC).</span></span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;handler;  <span class="comment">// when returned, jump to execute handler.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p-&gt;tick++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - <code>kernel/sysproc.c</code>, <code>sigreturn</code>系统调用在alarm的handler结束之后完成<code>sigalarm</code>发生前现场的保护，即对寄存器的<code>restore</code>和防止重入变量的<code>reset</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;trapframe-&gt;epc = p-&gt;saved_epc; </span><br><span class="line">  p-&gt;trapframe-&gt;ra = p-&gt;saved_ra; </span><br><span class="line">  p-&gt;trapframe-&gt;sp = p-&gt;saved_sp; </span><br><span class="line">  p-&gt;trapframe-&gt;gp = p-&gt;saved_gp; </span><br><span class="line">  p-&gt;trapframe-&gt;tp = p-&gt;saved_tp; </span><br><span class="line">  p-&gt;trapframe-&gt;a0 = p-&gt;saved_a0; </span><br><span class="line">  p-&gt;trapframe-&gt;a1 = p-&gt;saved_a1; </span><br><span class="line">  p-&gt;trapframe-&gt;a2 = p-&gt;saved_a2; </span><br><span class="line">  p-&gt;trapframe-&gt;a3 = p-&gt;saved_a3; </span><br><span class="line">  p-&gt;trapframe-&gt;a4 = p-&gt;saved_a4; </span><br><span class="line">  p-&gt;trapframe-&gt;a5 = p-&gt;saved_a5; </span><br><span class="line">  p-&gt;trapframe-&gt;a6 = p-&gt;saved_a6; </span><br><span class="line">  p-&gt;trapframe-&gt;a7 = p-&gt;saved_a7; </span><br><span class="line">  p-&gt;trapframe-&gt;t0 = p-&gt;saved_t0; </span><br><span class="line">  p-&gt;trapframe-&gt;t1 = p-&gt;saved_t1; </span><br><span class="line">  p-&gt;trapframe-&gt;t2 = p-&gt;saved_t2; </span><br><span class="line">  p-&gt;trapframe-&gt;t3 = p-&gt;saved_t3; </span><br><span class="line">  p-&gt;trapframe-&gt;t4 = p-&gt;saved_t4; </span><br><span class="line">  p-&gt;trapframe-&gt;t5 = p-&gt;saved_t5; </span><br><span class="line">  p-&gt;trapframe-&gt;t6 = p-&gt;saved_t6;</span><br><span class="line">  p-&gt;trapframe-&gt;s0 = p-&gt;saved_s0;</span><br><span class="line">  p-&gt;trapframe-&gt;s1 = p-&gt;saved_s1;</span><br><span class="line">  p-&gt;trapframe-&gt;s2 = p-&gt;saved_s2;</span><br><span class="line">  p-&gt;trapframe-&gt;s3 = p-&gt;saved_s3;</span><br><span class="line">  p-&gt;trapframe-&gt;s4 = p-&gt;saved_s4;</span><br><span class="line">  p-&gt;trapframe-&gt;s5 = p-&gt;saved_s5;</span><br><span class="line">  p-&gt;trapframe-&gt;s6 = p-&gt;saved_s6;</span><br><span class="line">  p-&gt;trapframe-&gt;s7 = p-&gt;saved_s7;</span><br><span class="line">  p-&gt;trapframe-&gt;s8 = p-&gt;saved_s8;</span><br><span class="line">  p-&gt;trapframe-&gt;s9 = p-&gt;saved_s9;</span><br><span class="line">  p-&gt;trapframe-&gt;s10 = p-&gt;saved_s10;</span><br><span class="line">  p-&gt;trapframe-&gt;s11 = p-&gt;saved_s11;</span><br><span class="line">  p-&gt;is_alarm_working = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最后的疑问"><strong>最后的疑问</strong></h3><p>用户级别的时钟中断是在系统调用<code>sigalarm</code>时对硬件进行操作使得其周期性地发生中断?</p><h3 id="all-test-passed"><strong>All Test Passed</strong></h3><figure><img src="https://pic4.zhimg.com/80/v2-a5ba7b96aa580477641e72690d8b2044.png" alt="Test"><figcaption aria-hidden="true">Test</figcaption></figure><h2 id="总结"><strong>总结</strong></h2><p>终于结束lab4了，呼~, gdb调的真舒服，基本的syscall逻辑大致都搞明白了。Backtrace按照hint写入一些函数，实际上就是要理解上一节video讲的frame point的一些概念，当前stack frame的第1个entry会指向前一个frame同时也给出了stack frame的分布图，间接地实现了gdb的查看栈帧的backtrace命令; 系统调用alarm会在进程使用CPU时间定期发出警报，手把手实现一个<strong>用户级别</strong>的中断。通过trap中根据devintr()的返回值判断中断的类型，1为设备中断，2为时钟中断，0为未识别。进而tick控制在指定intervel内调用中断处理程序handler。同时还需要在proc.h中加入字段，防止中断发生时的重入。涉及到部分寄存器的store/restore。另外<code>ecall</code>指令完成三件事：1.将用户模式切换到管理员模式; 2.将PC保存到sepc寄存器中; 3.将跳转到stvec寄存器中存储的地址处执行，即将stvec赋给PC。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab3: Page tables</title>
      <link href="/2022/05/16/s081-lab3/"/>
      <url>/2022/05/16/s081-lab3/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab3: Page tables --><h2 id="print-a-page-table"><strong>1. Print a page table</strong></h2><span id="more"></span><h3 id="description"><strong>1.1 Description</strong></h3><blockquote><p>Define a function called vmprint(). It should take a pagetable_t argument, and print that pagetable in the format described below. Insert if(p-&gt;pid==1) vmprint(p-&gt;pagetable) in exec.c just before the return argc, to print the first process's page table. You receive full credit for this assignment if you pass the pte printout test of make grade.</p></blockquote><h3 id="implementation"><strong>1.2 Implementation</strong></h3><ul><li>将<code>vmprint</code>函数添加到<code>kernel/vm.c</code>文件中并在<code>kernel/defs.h</code>文件中添加该函数的声明。使用格式符<code>%p</code>打印16进制数，使用<code>kernel/riscv.h</code>文件中定义的宏, 参考<code>freewalk</code>函数以递归的形式完成。实现该函数方便接下来的调试, 可以在gdb中测试其正确性。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">3</span>)  <span class="comment">// terminate condition.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      uint64 pa = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; depth; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, pa);</span><br><span class="line">      vmprint((<span class="type">pagetable_t</span>)pa, ++depth);  <span class="comment">// recursive.</span></span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="a-kernel-page-table-per-process"><strong>2. A kernel page table per process</strong></h2><h3 id="description-1"><strong>2.1 Description</strong></h3><blockquote><p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify struct proc to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if usertests runs correctly. - Add a field to struct proc for the process's kernel page table. - A reasonable way to produce a kernel page table for a new process is to implement a modified version of kvminit that makes a new page table instead of modifying kernel_pagetable. You'll want to call this function from allocproc. - Make sure that each process's kernel page table has a mapping for that process's kernel stack. In unmodified xv6, all the kernel stacks are set up in procinit. You will need to move some or all of this functionality to allocproc. - Modify scheduler() to load the process's kernel page table into the core's satp register (see kvminithart for inspiration). Don't forget to call sfence_vma() after calling w_satp(). - scheduler() should use kernel_pagetable when no process is running. - Free a process's kernel page table in freeproc. - You'll need a way to free a page table without also freeing the leaf physical memory pages. - vmprint may come in handy to debug page tables. - It's OK to modify xv6 functions or add new functions; you'll probably need to do this in at least kernel/vm.c and kernel/proc.c. (But, don't modify kernel/vmcopyin.c, kernel/stats.c, user/usertests.c, and user/stats.c.) - A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes sepc=0x00000000XXXXXXXX. You can find out where the fault occurred by searching for XXXXXXXX in kernel/kernel.asm. ### <strong>2.2 Implementation</strong> - 在<code>proc.h</code>进程的结构体中加入内核页表的属性<code>pkpagetable</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="type">pagetable_t</span> pkpagetable;     <span class="comment">// process&#x27;s kernel page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> - 实现<code>kvminit</code>函数的另一个版本来初始化进程的内核页表。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create processes&#x27;s kernel table</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">ukvmcreate</span><span class="params">()</span>  </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  uvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  uvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> kpagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 以及专门将映射加入进程的内核页表的函数<code>uvmmap</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to processes&#x27;s kernel</span></span><br><span class="line"><span class="comment">// page table</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>确保每个进程的内核页表中包含该进程所使用到的内核栈的映射。可以将原来在<code>boot time</code>进程初始化<code>procinit</code>函数中全局内核页表映射内核栈的代码<strong>注释</strong>掉。应题目要求在<code>allocproc</code>函数中实现映射当前进程所对应的内核栈。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="type">char</span> *pa = kalloc();   <span class="comment">// allocate physical memory per page.</span></span><br><span class="line"><span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="type">int</span>) (p - proc));  <span class="comment">// virtual address.</span></span><br><span class="line"><span class="comment">// make sure each process&#x27;s kernel page table has a mapping</span></span><br><span class="line"><span class="comment">// for that process&#x27;s kernel stack.</span></span><br><span class="line">uvmmap(p-&gt;pkpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure></li><li>在<code>scheduler</code>函数内实现，模仿<code>kvminithart</code>函数在调度时切换页表，即将进程的内核页表的地址放入<code>satp</code>寄存器，相应地刷新<code>TLB</code>，当进程没有在运行时，调度器切换回全局内核页表。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  load the process&#x27;s kernel page table into the core&#x27;s satp register.</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;pkpagetable));</span><br><span class="line">        sfence_vma();   <span class="comment">// flush the TLB.</span></span><br><span class="line">        </span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">        <span class="comment">// use kernel_pagetable when no process is running</span></span><br><span class="line">        kvminithart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;   <span class="comment">// wait for interrupt.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在<code>freeproc</code>函数中完成释放进程的内核页表操作, 同时实现函数<code>freeukpagetable</code>, 在释放页表时不释放掉<code>leaf</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;pkpagetable) &#123;</span><br><span class="line">  freeukpagetable(p-&gt;pkpagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freeukpagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;  <span class="comment">// not leaf.</span></span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        freeukpagetable((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## <strong>3. Simplify</strong> ### <strong>3.1 Description</strong> &gt; Your job in this part of the lab is to add user mappings to each process's kernel page table (created in the previous section) that allow copyin (and the related string function copyinstr) to directly dereference user pointers. Replace the body of copyin in kernel/vm.c with a call to copyin_new (defined in kernel/vmcopyin.c); do the same for copyinstr and copyinstr_new. Add mappings for user addresses to each process's kernel page table so that copyin_new and copyinstr_new work. You pass this assignment if usertests runs correctly and all the make grade tests pass.</li><li>Replace copyin() with a call to copyin_new first, and make it work, before moving on to copyinstr.</li><li>At each point where the kernel changes a process's user mappings, change the process's kernel page table in the same way. Such points include fork(), exec(), and sbrk().</li><li>Don't forget that to include the first process's user page table in its kernel page table in userinit.</li><li>What permissions do the PTEs for user addresses need in a process's kernel page table? (A page with PTE_U set cannot be accessed in kernel mode.) Don't forget about the above-mentioned PLIC limit. ### <strong>3.2 Implementation</strong></li><li>用<code>copy_new</code>函数替代<code>copyin</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>copyinstr_new</code>函数替代<code>copyinstr</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在<code>fork()</code>中针对用户页表映射修改，相应进程的内核页表做出的改动。并实现将用户页表copy到内核页表并清空相应<code>PTE_U</code>标志的函数<code>copyupttokpt</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line"><span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line"><span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(np);</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">copyupttokpt(np-&gt;pkpagetable, np-&gt;pagetable, <span class="number">0</span>, np-&gt;sz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy saved user registers.</span></span><br><span class="line">*(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">copyupttokpt</span><span class="params">(<span class="type">pagetable_t</span> ker, <span class="type">pagetable_t</span> user, uint64 old_size, uint64 new_size)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte_from, *pte_to;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  old_size = PGROUNDUP(old_size);</span><br><span class="line">  <span class="keyword">for</span>(i = old_size; i &lt; new_size; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte_from = walk(user, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;copyupttokpt: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((pte_to = walk(ker, i, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;copyupttokpt: walk&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte_from);</span><br><span class="line">    <span class="comment">// clear PTE_U bit because of kernel page table.</span></span><br><span class="line">    flags = PTE_FLAGS(*pte_from) &amp; (~PTE_U);</span><br><span class="line">    *pte_to = PA2PTE(pa) | flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>函数<code>exec()</code>中，替换当前进程的用户页表时，内核页表也随之释放，并<code>copy</code>新用户页表的内容。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line"><span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">  <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    last = s+<span class="number">1</span>;</span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br><span class="line">p-&gt;sz = sz;</span><br><span class="line"></span><br><span class="line">uvmunmap(p-&gt;pkpagetable, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line"></span><br><span class="line">p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure></li><li>函数<code>sbrk()</code>，相应的增加和减少内存时变更用户页表，需要同时更新进程的内核页表。需要判断用户分配地址空间的限制。如果增加的内存大于<code>PLIC</code>则返回<code>-1</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((sz + n) &gt;= PLIC) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// test overflow.</span></span><br><span class="line">    <span class="comment">// mapping the n bytes in process&#x27;s kernel table.</span></span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, sz-n, sz);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// ummaping the n bytes in process&#x27;s kernel table.</span></span><br><span class="line">    uvmunmap(p-&gt;pkpagetable, PGROUNDUP(sz), (PGROUNDUP(p-&gt;sz) - PGROUNDUP(sz))/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>userinit</code>，初始化第一个<code>process</code>时也需要更新进程的内核页表。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><strong>总结</strong></h2><p>简单的写一下lab 3的总结吧，做之前最好把概念理清楚，确实蛮有难度的。</p><p>打印三级也页表页表项的虚拟地址以及物理地址，利用递归就可以完成，leaf pte的判断的判断条件即递归结束条件，可以参考vm.c中部分函数的源代码。leaf pte可以通过pte中的flag进行判断，事实上，也就只有leaf pte才含有PTE_W，PTE_X，PTE_R。</p><p>由于历史原因部分os将内核和用户进程独立分为两个page table，本lab的初衷是为了利用好进程之间的isolation，为每个用户进程分配一个内核页表(初始时的映射和全局内核页表相同, <strong>其中此内核页表中含有用户页表的映射</strong>)，释放进程的同时也要将进程的内核页表释放，注意不将叶子pte的物理内存释放，初始化时也是同样的。注意到procinit函数里已经为每个用户进程通过全局内核页表分配好了内核栈，hint中要求把该部分迁移到分配用户进程是时分配栈，另外kvmpa函数中也有个坑，需要将全局内核页表替换为当前用户进程的内核页表。</p><p>将用户进程页表载入到用户的内核页表后，系统调用传参时所用到的copyin或者copyinstr就不需要再间接的将该参数的虚拟地址通过用户页表转换为物理地址之后再处理了，简化了一步walk的操作，直接dereference即可。copy页表映射时可以参考vmcopy函数，fork中有相关页表复制的内容，但不是全部参考，可能会出现remap的情况，因此考虑不使用mappages函数即可。注意sbrk时相关函数growproc的overflow检测，以及虚拟地址空间减少时要从用户内核页表中unmap掉相关内容，增加时正常复制即可。exec函数中copy前需要将用户内核页表的映射清空。其他都按hint去做就行了，The devil is in the details.</p><h2 id="补充"><strong>补充</strong></h2><p>强调一下<code>walk</code>函数的实现，在xv6中即为遍历三级页表, 很清晰地刻画了真实的页表实现。<code>PTE2PA</code>宏将当前PTE的地址(物理地址)右移10位将10个有效位置0，左移12位加上偏移量(因为页大小为<code>4kb</code>, <span class="math inline">\(2^{12}=4096=4k\)</span>, 所以偏移量为12, <code>byte</code>为寻址能力大小), 最后转化为物理地址。 记住页目录存在于物理地址空间中。虚拟地址空间中的<code>L2</code>, <code>L1</code>, <code>L0</code>字段确定每一级页目录中的<code>Entry</code>。<strong>非叶子节点</strong>的<code>PPN</code>(Physical page number)连结上全0的Offset为下一级页目录的<strong>物理地址</strong>。 <img src="https://pic4.zhimg.com/80/v2-78092855fd01e077d1d69fda55a6f1b2.png" alt="Page table"> - <strong>walk</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];  <span class="comment">// 根据虚拟地址的L字段获取页目录中的Entry</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// 解引用获取当前Entry的地址, 将PPN(物理页号)和Offset(全0)连接后更下一级页目录的物理地址</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];  <span class="comment">// 叶子节点处PPN+虚拟地址的Offset为最终转换的物理地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - <strong>宏</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab2: System Calls</title>
      <link href="/2022/05/16/s081-lab2/"/>
      <url>/2022/05/16/s081-lab2/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab2: System Calls --><h2 id="system-call-tracing"><strong>1. System call tracing</strong></h2><span id="more"></span><h3 id="描述"><strong>1.1 描述</strong></h3><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You'll create a new trace system call that will control tracing. It should take one argument, an integer "mask", whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call's number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don't need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><ul><li>将相应的文件添加到<em>user/user.h</em>和<em>user/usys.pl</em>中，向<em>kernel/syscall.h</em>文件中添加本实验所需要添加的系统调用号。</li><li>向<em>kernel/sysproc.c</em>中添加系统调用函数<em>sys_trace</em>，以及需要在进程的结构体中，新建一个变量Mask由低位开始偏移系统调用号个bit的值(通过观察<em>syscall.h</em>文件以及题目中给的case可以发现系统调用号对应二进制的bit)。</li><li>还需要再<em>kernel/proc.c/fork</em>函数中使得子进程继承父进程的Mask属性。</li><li>参照<em>kernel/syscall.c</em>中别的系统调用，通过阅读<em>user/trace.c</em>代码，使用<em>argint</em>函数来提取命令行中的第一个参数作为掩码赋给进程属性Mask，还需要定义系统调用号对应的系统调用名数组。</li><li>需要注意的点，a0作为返回值且a7作为系统调用号，在<em>trace</em>调用后打印信息时需要用到</li></ul><h3 id="实现"><strong>1.2 实现</strong></h3><p>这里贴出部分代码</p><p>kernel/syscall.c/syscall <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">    num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="comment">// reap return value.</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;mask)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">                p-&gt;pid, p-&gt;name, num);</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> kernel/sysproc.c/sys_trace <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argint</span>(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">myproc</span>()-&gt;mask = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> kernel/proc.c/fork <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;mask = p-&gt;mask;</span><br></pre></td></tr></table></figure></p><h2 id="sysinfo"><strong>2. Sysinfo</strong></h2><h3 id="描述-1"><strong>2.1 描述</strong></h3><blockquote><p>In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints "sysinfotest: OK".</p></blockquote><ul><li>类似trace系统调用将函数添加到相应文件中。</li><li>.需要参考函数<em>kernel/sysfile.c/sys_fstat</em>以及kernel/file.c/filestat中<em>copyout</em>函数的实现，即将内核数据复制到用户的虚拟地址空间。</li><li>需要在<em>kernel/kalloc.c</em>以及<em>kernel/proc.c</em>中添加函数，获取空闲内存的数量(字节为单位)，并获取状态为UNUSED状态的进程数，将两个函数的返回值分别赋给定义在<em>kernel/sysinfo.h</em>中sysinfo结构体的两个属性 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sysinfo</span> &#123;</span><br><span class="line">  uint64 freemem;   <span class="comment">// amount of free memory (bytes)</span></span><br><span class="line">  uint64 nproc;     <span class="comment">// number of process</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>需要注意的是，在获取空闲内存的数量时，空闲链表的一个节点的大小为一个页的大小，遍历空闲链表即可获得结果。</li><li>该lab出现了比较少见的数组初始化方式Designated Initializers，详见<a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">此处</a></li></ul><h3 id="实现-1"><strong>2.2 实现</strong></h3><p>kernel/sysproc.c/sys_sysinfo <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint64 useraddr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;useraddr) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sysinfo</span> sys;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span>* p = <span class="built_in">myproc</span>();</span><br><span class="line">    sys.nproc = <span class="built_in">procnum</span>();</span><br><span class="line">    sys.freemem = <span class="built_in">freemem</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copyout</span>(p-&gt;pagetable, useraddr, (<span class="type">char</span>*)&amp;sys, <span class="built_in">sizeof</span>(sys)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> kernel/kalloc.c/freemem <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">freemem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line">    uint64 n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// every node of the freelist represent a page.</span></span><br><span class="line">    <span class="keyword">for</span> (r = kmem.freelist; r; r = r-&gt;next) &#123;</span><br><span class="line">        n += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;  <span class="comment">// return the bytes of free memory.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> kernel/proc/procnum <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">procnum</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">    uint64 num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结">总结</h2><p>通过对lab2的学习，阅读了<em>kernel/proc.c</em>以及<em>kernel/proc.h</em>。通过熟悉进程的结构，从本质上理解了进程调度，进程上下文，并阅读了fork、exec等系统调用的源代码。lab2以动手实现系统调用形式，让我明白了其通过系统调用号进行索引，也了解了Designated Initializers的数组初始化形式。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab1: Xv6 and Unix utilities</title>
      <link href="/2022/05/16/s081-lab1/"/>
      <url>/2022/05/16/s081-lab1/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab1: Xv6 and Unix utilities --><h2 id="sleep"><strong>1. sleep</strong></h2><span id="more"></span><h3 id="描述"><strong>1.1 描述</strong></h3><blockquote><p>Implement the UNIX program <strong><em>sleep</em></strong> for xv6; your <strong><em>sleep</em></strong> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <strong><em>user/sleep.c</em></strong>.</p></blockquote><p>可以了解一下atoi的简单实现，参考一下user文件中的其他命令的实现。</p><h3 id="实现"><strong>1.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep second\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">sleep</span>(i);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pingpong"><strong>2. pingpong</strong></h2><h3 id="描述-1"><strong>2.1 描述</strong></h3><blockquote><p>Write a program that uses UNIX system calls to ''ping-pong'' a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print "<pid>: received ping", where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print "<pid>: received pong", and exit. Your solution should be in the file user/pingpong.c.</pid></pid></pid></p></blockquote><p>需要熟悉fork、write、read、pipe等系统调用的使用，来实现父进程与子进程之间的通过管道的数据传输，应用在xv6中的实现的一组库函数(在user/user.h中)来实现本例。</p><h3 id="实现-1"><strong>2.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">pipe</span>(p);</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;  <span class="comment">// parent</span></span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(p[<span class="number">1</span>], buf, <span class="built_in">sizeof</span>(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// child</span></span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(p[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// error</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="primes"><strong>3. primes</strong></h2><h3 id="描述-2"><strong>3.1 描述</strong></h3><blockquote><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c.</p></blockquote><p>应用埃氏筛法实现对素数的筛选，下面给出的是迭代实现，注意利用该条件终止迭代<em>Hint: read returns zero when the write-side of a pipe is closed.</em>。每次迭代创建一个管道，父进程通过将原始数据写管道，子进程在读阶段将数据中非素数筛出并保留筛出数据到缓冲区供下次传递使用，并打印数据</p><h3 id="实现-2"><strong>3.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> buf[<span class="number">36</span>];</span><br><span class="line">  <span class="type">int</span> pid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// initialize.</span></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; ++i) &#123;</span><br><span class="line">    buf[index++] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// use the sieve function 埃氏筛法</span></span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">pipe</span>(p);  <span class="comment">// Create pipe every valid loop.</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;     <span class="comment">// child</span></span><br><span class="line">      <span class="comment">// sieve operation.</span></span><br><span class="line">      <span class="type">int</span> prime = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">      <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">read</span>(p[<span class="number">0</span>], &amp;temp, <span class="built_in">sizeof</span>(temp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// handle to sieve prime numbers.</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          prime = temp;</span><br><span class="line">          index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (temp % prime != <span class="number">0</span>) buf[index++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">      <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;  <span class="comment">// parent</span></span><br><span class="line">      <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">        <span class="built_in">write</span>(p[<span class="number">1</span>], &amp;buf[i], <span class="built_in">sizeof</span>(buf[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">wait</span>(<span class="number">0</span>);   <span class="comment">// main process is waiting all child processes to quit.</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork failure.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find"><strong>4. find</strong></h2><h3 id="描述-3"><strong>4.1 描述</strong></h3><blockquote><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user/find.c.</p></blockquote><p>参考<em>user/ls.c</em>文件了解如何读取目录，其实实现是类似的，只不过find命令需要实现递归。</p><h3 id="实现-3"><strong>4.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief transmit the complete filename path to the filename eradicated dir.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param path complete filename path.</span></span><br><span class="line"><span class="comment"> * @return return the filename eradicated part behind the last slash &quot;/&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">char</span>*</span></span><br><span class="line"><span class="function"><span class="title">fmtname</span><span class="params">(<span class="type">char</span>* path)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span>* p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (p = path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--);</span><br><span class="line">  p++;  <span class="comment">// jump the slash.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  <span class="built_in">memmove</span>(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="comment">/* fill the white space into the rest of the DIRSIZ that</span></span><br><span class="line"><span class="comment">   * guarantee the correctness of strcmp func.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  buf[<span class="built_in">strlen</span>(p)] = <span class="number">0</span>;   <span class="comment">// null-terminated string</span></span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">(<span class="type">char</span>* path, <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (st.type)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> T_FILE:</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="built_in">fmtname</span>(path)))</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path)+<span class="number">1</span>+DIRSIZ+<span class="number">1</span> &gt; <span class="built_in">sizeof</span>(buf)) &#123;  <span class="comment">// the two &quot;1&quot; represent the null placeholder.</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* buf store the complete path and hold the buf pointer in front of it that</span></span><br><span class="line"><span class="comment">     * is convenient to print the complete path which we expect to output.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;   <span class="comment">// i.e. *(p++) = &#x27;/&#x27;.</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (de.inum == <span class="number">0</span>)  <span class="comment">// inode number == 0.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">memmove</span>(p, de.name, DIRSIZ);  <span class="comment">// move the dirname to p.</span></span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">find</span>(buf, name);  <span class="comment">// recursive.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find path name...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], argv[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xargs"><strong>5. xargs</strong></h2><h3 id="描述-4"><strong>5.1 描述</strong></h3><blockquote><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user/xargs.c.</p></blockquote><p>需要去了解linux中<a href="https://man7.org/linux/man-pages/man1/xargs.1.html">xargs</a>命令的实现，需要注意的是argv提取的是由xargs之后的参数。将管道一端的标准输出作为管道另一端的标准输入。通过read从标准输入读数据，将其中的参数由''和' '分割，并保存作为最终的参数数组由exec系统调用执行。xargs - build and execute command lines from standard input，完成了用标准输入的内容作为xargs的参数</p><h3 id="实现-4"><strong>5.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; MAXARG) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: arg is too much\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span>* param[MAXARG];</span><br><span class="line">  <span class="type">char</span> line[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> arg_param = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span>* cmd = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">    param[arg_param++] = argv[i];</span><br><span class="line">  <span class="keyword">if</span> ((pid=fork()) &gt; <span class="number">0</span>) &#123;   <span class="comment">// parent.</span></span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;    <span class="comment">// child.</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;  <span class="comment">// index the each line.</span></span><br><span class="line">    <span class="type">char</span>* arg = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">// read the STDIN that is before &quot;|&quot; to param array.</span></span><br><span class="line">    <span class="keyword">while</span>((n = <span class="built_in">read</span>(<span class="number">0</span>, line, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line[i] == <span class="string">&#x27; &#x27;</span> || line[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">          arg[index] = <span class="number">0</span>;  <span class="comment">// &#x27;\0&#x27;</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arg);</span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          param[arg_param++] = arg;</span><br><span class="line">          arg = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          arg[index++] = line[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">exec</span>(cmd, param);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><strong>总结</strong></h2><p>通过完成lab1中xv6相应的命令函数的实现，以及相关代码的阅读，加深了了我对linux部分命令实现原理的理解，同时也熟悉了基本的系统调用函数。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61B GITLET PROJECT</title>
      <link href="/2022/05/16/CS61B-GITLET-PROJECT/"/>
      <url>/2022/05/16/CS61B-GITLET-PROJECT/</url>
      
        <content type="html"><![CDATA[<!-- # CS61B Gitlet --><blockquote><p>简化版Git，深入探索Git的底层结构</p></blockquote><span id="more"></span><h2 id="project-2-getting-startedlab6"><strong>Project 2 Getting Started(Lab6)</strong></h2><h3 id="preperation"><strong>Preperation</strong></h3><p>首先使用<code>git submodule update --init --recursive</code>命令将21sp的library更新，再一并复制过来。记得再当前操作系统中设置<code>REPO_DIR</code>环境变量为所有projA、HW的根目录。切记要注意看文档, 以及其中给出的设置来实现相应的功能, 最后才发现FAQ也给了非常好的提示，另外比如说在我的机器上使用<code>python</code>而不是<code>python3</code>，<code>make check</code>是跑不通的，需要找到<code>Makefile</code>的第25行, 修改为<code>PYTHON = python</code>。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main story <span class="string">&quot;Once upon a time, there was a beautiful dog.&quot;</span></span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main story <span class="string">&quot;That dog was named Fjerf.&quot;</span></span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main story <span class="string">&quot;Fjerf loved to run and jump.&quot;</span></span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line">Fjerf loved to run and jump.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main dog Mammoth <span class="string">&quot;German Spitz&quot;</span> 10</span></span><br><span class="line">Woof! My name is Mammoth and I am a German Spitz! I am 10 years old! Woof!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main dog Qitmir Saluki 3</span> </span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 3 years old! Woof!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main birthday Qitmir</span></span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 4 years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main birthday Qitmir</span></span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 5 years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br></pre></td></tr></table></figure> 准备开始Gitlet:</p><h2 id="gitlet"><strong>Gitlet</strong></h2><h3 id="参考资料"><strong>参考资料</strong></h3><ul><li>Git pro book</li></ul><h3 id="note"><strong>Note</strong></h3><ul><li>往年课程的<a href="https://cdn-uploads.piazza.com/attach/k5eevxebzpj25b/jqr7jm9igtc7l5/k97ipfmgmb3n/Gitlet_Slides.pdf">Slide</a>很好地以图片的形式介绍了<code>Gitlet</code>中的各个命令的实现。</li><li><a href="https://paper.dropbox.com/doc/Gitlet-Persistence-zEnTGJhtUMtGr8ILYhoab">Gitlet Persistence</a></li><li><a href="https://chinese.freecodecamp.org/news/git-internals-objects-branches-create-repo/#:~:text=%E5%9C%A8%20git%20%E4%B8%AD%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84,%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E3%80%82">这里</a>有Git比较详细的图解。</li><li>仔细阅读<code>gitlet.Utils</code>中封装好的方法。</li><li>编写设计文档，<a href="https://sp21.datastructur.es/materials/proj/proj2/design.html">规格</a>和<a href="https://sp21.datastructur.es/materials/proj/proj2/capers-example">示例</a></li><li>Git的内部结构<ul><li>blob(Binary Large Object): 文件的保存内容。一个文件可能对应多个blob：每个blob在不同的<code>Commit</code>中被跟踪。</li><li>Tree: 映射文件名称(name)到blob的reference，或者是映射文件名称到其他tree(子目录)的引用。</li><li>commits: 日志消息，其他元数据(提交日期、作者等), 对树的引用和对Parent Commit的引用。<code>repository</code>还维护了分支头到提交引用的映射(以便某些重要的提交具有符号名称)</li></ul></li><li>Gitlet简化的部分<ul><li>将树合并到Commit中而不处理子目录</li><li>只能两个父级合并</li><li>元数据仅包含时间戳和日志消息，因此Commit将由<code>日志消息</code>, <code>时间戳</code>, <code>文件名</code>到<code>Blob</code>引用的映射，<code>父引用</code>, (用于Merge的)<code>第二个父引用</code>来组成。</li></ul></li><li>每个blob和每个commit都有一个唯一的整数id，用作该对象的<strong>引用</strong>。</li><li>当使用SHA-1哈希一个Commit时，会包括所有的数据和引用。</li><li>区分<code>Commit</code>和<code>Blob</code>的哈希值，一种方法是可以在两个类中各自定义一个属性字段来实现。</li><li>不应该在Main中做完所有事情，而是将需要实现的内容封装成一个函数到<code>Repository</code>类中去。</li><li>序列化最好使用<code>TreeMap</code>而不是<code>HashMap</code>。</li><li><code>Gitlet</code>不会出现<code>deteched head</code>(分离头部)的状态。指的是当前<code>HEAD</code>指向的Commit不表示任何一个分支。</li></ul><h3 id="注意事项"><strong>注意事项</strong></h3><ul><li>在<code>terminal</code>下出现了<code>Esc</code>无法退出<code>insert mode</code>而且还进入了<code>Itellij</code>的编辑界面。解决方案看<a href="https://www.jianshu.com/p/f1ae155cda6e">此处</a></li><li>暂存区包含两个区域, <code>stage for addition</code>和<code>stage for removal</code>。</li><li><code>gitlet</code>中一条命令对应运行一次程序，因此需要将用到的数据结构序列化为字节流后保存到文件中。</li><li>在实验一开始给的<code>Utils</code>类中， 不需要使用<code>createNewFile()</code>来创建文件, 因为<code>writeObject()</code>中会调用<code>WriteContent()</code>，若文件不存在则会自动创建，或者文件存在则覆盖掉它。</li><li>注意要在当前目录下执行<code>make check</code>，测试文件可能跑通(可能需要操作src/目录中的文件)。</li><li>注意每次更新数据时都需要序列化对象和反序列化文件, 保证更新的数据能够及时存储到文件中。</li><li>也需要将<code>blobs</code>的映射集合序列化存储起来(同样用TreeMap)，<code>checkout</code>命令要使用(用SHA-ID(文件名+文件内容)来作为文件名)。在<code>add</code>命令将blob和文件名映射放入<code>stage for addition</code>的同时，将blob和文件内容的映射放入<code>blobs</code>集合。</li><li><code>blob</code>生成<code>blobId</code>(sha-1 id)的时候，需要通过<code>文件名+文件内容(字节流)</code>生成。若只用文件内容生成<code>blobId</code>，不同名的两个文件内容都为空时，生成的<code>blobId</code>是一致的, 使用<code>文件名+文件对象</code>生成的sha-1哈希也是同样的结果。</li><li><code>mkdirs()</code>方法可以一同创建之前未存在的父目录。</li><li>注意写文件内容时用<code>writeContent()</code>而不是<code>writeObject()</code>。注意到<code>writeObject</code>会在调用<code>writeContent</code>前将第二个参数先序列化, 若将字节数组再序列化，可能会在内容中写入额外的信息。</li><li><code>Untracked file</code>，既没有被当前<code>commit</code>跟踪，也没有被放到<code>stage area</code>里。或者是已经被<code>stage for removal</code>但是又重新创建了。(考虑到我这里rm情况下没有将其从暂存区删除，仅仅是将它从<code>stage for removal</code>删除了而已)。</li><li>保证分支头只有一个, <code>get(0)</code>可以直接取(这里我将分支做所处的位置做成了一个目录，目录中是用分支名来命名的文件, 方便直接取头Commit)。</li><li>暂存区使用<code>blobId</code>映射<code>文件对象</code>不可取(序列化后提取的文件内容还是的却决于当前工作目录下的内容，不符合预期)，试试映射文件内容(字符串readContentsAsString)。经过调试发现必须得映射字节流，因为前面生成blobId中需要<code>文件名+文件内容(字节流)</code>。</li><li>注意<code>Utils</code>中的<code>restrictedDelete()</code>方法，是如果文件存在则删除, 如果文件对象不存在则删除未成功返回false, 给我们实现<code>rm</code>指令来删除当前工作目录中的文件提供了一个很好的帮助。</li><li>需要在每次<code>commit</code>命令执行时都更新分支头目录中的数据以及其对应<code>branches</code>目录中的数据。</li><li>除了<code>init</code>之外剩下的命令在处理之前都需要检测当前<code>.gitlet</code>目录是否存在, 若不存在则输出报错信息。</li><li>在开始项目任何一个功能前一定要有一个<code>Big picture</code>和整体思路，确保在实现过程中能够顺利进行。</li></ul><h3 id="测试"><strong>测试</strong></h3><ul><li>查看<code>tester.py</code>文档中一些相应的操作来对应测试文件。测试文件可以从<code>AG</code>中获取。</li></ul><h3 id="init"><strong>init</strong></h3><ul><li>创建<code>.gitlet</code>目录，并在其中新建一些文件来存储序列化信息。</li><li><code>init</code>会自动创建一个包含initial commit信息的<code>Commit</code>开始</li></ul><h3 id="add"><strong>add</strong></h3><ul><li>暂存已经暂存过的文件，会用新内容来覆盖先前的内容。</li><li>若当前需要暂存的文件与Commit跟踪的文件版本一致(包括其修改之后又还原内容的文件，blobId都是一致的)，则不对它进行处理。</li><li>若当前添加文件在<code>Stage for removal</code>中，则将它从里面删除。</li><li>gitlet一次只能添加一个文件。</li><li>维护一个<code>TreeMap</code>来存放<code>stage for addition</code>文件。</li></ul><h3 id="commit"><strong>commit</strong></h3><ul><li>需要考虑在当前跟踪的文件可能在新的Commit中未被跟踪，与rm指令将文件<code>Stage for removal</code>相关。</li><li>当前Commit跟踪的blob需要加上其父Commit跟踪的blob(前提是父Commit中跟踪的blob未被当前Commit跟踪的文件覆盖过)。</li><li><code>commmit</code>后将<code>stage area</code>清空，也就是<code>stage for add</code>和<code>stage for removal</code>。</li><li>若没有文件被暂存，或没有提交信息则中止。</li></ul><h3 id="rm"><strong>rm</strong></h3><ul><li>若当前文件正在<code>stage for addition</code>，则将它从里面移除。</li><li>若文件在当前<code>Commit</code>中被跟踪，则将其放入<code>stage for removal</code>暂存区中, 同时将本地目录文件删除。</li><li>只考虑被当前Commit跟踪的情况下</li><li>维护一个<code>TreeMap</code>来存放<code>stage for removal</code>文件。</li></ul><h3 id="log"><strong>log</strong></h3><ul><li>注意显示的是太平洋标准时间而不是UTC。</li><li>当前操作系统显示时间得调成英文显示，否则打印log会出现中文字样</li></ul><h3 id="find"><strong>find</strong></h3><ul><li>通过<code>Utils</code>类中给的方法<code>plainFilenamesIn</code>, 直接遍历<code>commit Id</code>所处的目录，若出现<code>commit</code>对象不同但提交信息一致的打印情况，分行打印各自的<code>commit id</code>。</li></ul><h3 id="status"><strong>status</strong></h3><ul><li><code>TreeMap</code>数据结构会按照字典序来排序。</li><li><code>Untrack file</code>，既未跟踪也未暂存。未跟踪将当前目录下的文件名和当前最新Commit中track的文件名做对比。若未包含则说明未跟踪。同样包括已经准备删除但又重新创建的文件(说明其还在<code>stage for removal</code>里，因为<code>stage area</code>只在commit时删除)。思考该该怎么标记? rm之后add的文件?</li><li><code>modified</code>, 同样与Commit中track对比，若文件名相同，但BlobId不同则说明被修改过。</li><li>遍历当前跟踪的文件，使用<code>exist</code>判断文件对象是否存在以及是否存在于<code>stage for removal</code>，就能判断文件是否被<code>delete</code>。</li></ul><h3 id="checkout"><strong>checkout</strong></h3><ul><li>有三类<code>checkuout</code>:<ul><li>java gitlet.Main checkout -- [file name]</li><li>java gitlet.Main checkout [commit id] -- [file name]</li><li>java gitlet.Main checkout [branch name]</li></ul></li><li>若<code>checkout</code>切换分支，且当前目录下文件有文件未被跟踪，则打印提示信息并退出。</li><li>注意切换完成，将新分支放入<code>heads</code>目录的同时，从<code>heads</code>目录中删除先前的分支。</li><li><code>checkout filename</code>将当前文件从<code>head commit</code>中拿到当前工作目录。</li><li>切换到另一个分支要将暂存区清空。要将当前commit中跟踪了但切换到的分支commit中没有跟踪的文件删除(如果有则覆盖)。</li><li>考虑两种情况:<ul><li><code>checkout</code>的目标分支跟踪的文件比当前目录的文件多，直接写就行了</li><li><code>checkout</code>的目标分支跟踪的文件比当前目录的文件少，需要删除本地目录中多余的文件</li><li>这两中情况都需要遍历当前目录中的所有文件名来确定。</li></ul></li><li>一个<strong>错误的策略</strong>是切换之前先将当前当前文件下所有的都删除，然后再将切换到的分支commit跟踪的文件写进CWD当前工作目录, 在后续将跟踪文件写入当前工作目录时，取不到文件对象了。</li><li><code>checkout branchName</code>时需要将暂存区清空。</li><li>后面还有一个<code>checkout shortid</code>的测试，需要包括通过commitid的前8就能切换到不同的分支。和commitId一样序列化到磁盘上的文件就行。</li><li>gitlet<strong>不允许</strong>删除提交。</li></ul><h3 id="reset"><strong>reset</strong></h3><ul><li>神似<code>checkout branchName</code>, 只是最后是将<code>当前branch</code>回退而不是切换分支。</li></ul><h3 id="branch"><strong>branch</strong></h3><ul><li>只新建一个分支(即在branches目录中新建一个序列化的分支Commit文件), 但是并未切换到新建的分支。</li></ul><h3 id="merge"><strong>merge</strong></h3><ul><li>将给定分支名为branchName的文件合并到当前分支中。</li><li>如何找到<code>split point</code>? 考虑到gitlet只支持两个分支合并，因此可以把新建分支的commit作为split point?! hhh笑死ucb学生视频里第一个提问和我想得一模一样。我感觉这种方法在gitlet中可行，但在多分支合并时就不行了。还是得去过一遍图的遍历这一节的slide。</li><li><strong>Latest common ancestor</strong>其实指的也就是<code>split point</code>。</li><li>如果给定分支是<code>split point</code>则不做任何处理。</li><li>无论是否发生冲突，<code>merge</code>结束后新建一个<code>Commit</code>。</li><li>如果当前分支是<code>split point</code>, 则<strong>切换</strong>到给定分支。</li><li>发生冲突且修改的内容不同只写当前分支的冲突文件。</li><li>需要复用<code>add</code>和<code>rm</code>以及<code>commit</code>命令。</li><li>git提交后的分布可以看作是个<code>direct graph</code>。</li><li>可以通过将从<code>init commit</code>到当前分支经过的commit放到一个list中，同时将要给定分支的路径也放到一个set中，再通过按指定顺序遍历(由当前分支开始)当前分支的list，使用<code>contains</code>方法来确定遍历经过的commit是否在分支路径的set中。需要使用BFS来遍历。</li><li>之前的策略是在切换分支(checkout, reset)时才将branches目录中的当前分支信息更新，这在这一步中获取当前分支对象是危险的，因此需要调整策略，在每一次commit更新HEAD目录时和reset时，都更新Branches中当前分支信息。这样就能保证当前分支在Head目录和Branches目录中的信息是同步一致的了。</li><li>注意Java中<code>null</code>在字符串比较时不能用<code>equals()</code>来比较。</li><li>别忘了改写冲突文件时需要生成新的<code>blobId</code>放入暂存区中在新的合并Commit中加入当前目录。</li></ul><h4 id="处理case"><strong>处理case</strong></h4><ul><li><img src="https://pic4.zhimg.com/80/v2-5b2470a6def367603e617ea9c709c231.png" title="fig:" alt="Image"></li><li>想到了一个比较情况的好方法，将当前分支，给定分支以及split point三个集合中含有的文件名的并集放到集合里。比较时需要各个集合的BlobId和文件名的映射，以及BlobId和content的映射。</li><li>由两个值来区分所有情况分别是<code>isPresent</code>和<code>IsModified</code>。</li><li><code>Modifed</code>只需要通过当前分支分支或给定分支， 与<code>split point blobId</code>比较来区分就行了, 程序里我将不存在的文件的blobId赋值为空串。</li><li>当前分支和给定分支都modifed也就是case3还需要细分发生冲突，还是不发生冲突。直接通过比较当前分支和给定分支<code>commit Id</code>即可。</li><li><code>git pro</code>中的原话, 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。这点与Gitlet还是不同的。</li><li>发生冲突的内容差异会自动写入冲突文件(按合理性来说只需要写入当前分支头即可)如, 需要解决冲突后，需要打印提示信息，合并的提交跟踪冲突文件: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">contents of file in current branch</span><br><span class="line">=======</span><br><span class="line">contents of file in given branch</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li>处理好每个情况后将每个文件对应的result添加到暂存区等待新的Commit。result的内容为当前分支的内容也需要<code>stage for addition</code>, 但不需要放入<code>blobs</code>集合中。</li><li><code>getBytes</code>方法可以将字符串转化为字节数组(byte[])。</li></ul><figure><img src="https://pic4.zhimg.com/80/v2-de14f3c3a0f560d423afde1fdd05300b.png" alt="Image"><figcaption aria-hidden="true">Image</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> CS61B </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61C CPU PROJECT</title>
      <link href="/2022/05/16/CS61C-CPU-PROJECT/"/>
      <url>/2022/05/16/CS61C-CPU-PROJECT/</url>
      
        <content type="html"><![CDATA[<!-- # **CS61C CPU PROJECT** --><blockquote><p>用时4天，体验CPU设计</p></blockquote><span id="more"></span><h2 id="关于如何debug"><strong>关于如何Debug</strong></h2><p>相信前面的<code>lab5</code>和<code>lab6</code>已经奠定好了使用<code>logisim</code>的基础，前面相关内容同样奠定好了RISC-V ISA的知识基础。接下来Project中的一系列的task可以通过参考: - <code>61C Reference card</code> - <code>ROM</code>表 - 对应测试文件中的汇编代码和测试电路 - 通过<code>change value</code>来对电路中的bit位进行赋值，查看输入输出的值</p><p>需要将所有这些结合起来构建完整的<code>big picture</code>。</p><h2 id="alu"><strong>ALU</strong></h2><p>根据文档中给的功能类别通过门级电路来构造基本的ALU原件，个别功能的实现所用到的元器件还需要查看手册。 <img src="https://pic4.zhimg.com/80/v2-014bf51c0d29af49c1b904c3cb4a28e2.png" alt="ALU"></p><h2 id="regfile"><strong>RegFile</strong></h2><p>需要用到<code>Multiplexer</code>和<code>Demultiplexer</code>，以及一些基本的逻辑，比较废鼠标... <img src="https://pic4.zhimg.com/80/v2-2bc53f743fb481fc3a22f8c141f95071.png" alt="Regfile"></p><h2 id="immediate-generator"><strong>Immediate Generator</strong></h2><p>这一部分跟着61C绿卡里的指令编码表。以下显示的是所有含有imm部分的指令的实现。 <img src="https://pic4.zhimg.com/80/v2-f46d246882abfdf6f28e13266e41c363.png" alt="Imm-gen"></p><h2 id="control-storeimplemented-by-rom"><strong>Control Store(Implemented by ROM)</strong></h2><p>通过分析绿卡上或者是文档里给的指令的功能，来初始化每条指令对应的微指令，需要结合数据通路中每个部分的实现以及PartA中我们已经构建好的ALU。Immsel以及个别控制信号可以自行设计(后面会有介绍修改<code>.csv</code>文件即可, 我这边是修改过后的)，建议PartB部分一开始就完善ROM表。 下面给出我的数据: <img src="https://pic4.zhimg.com/80/v2-3ffb5bc0653de42a33fba13bf38a868d.png" alt="ROM"></p><p>完善ROM表后，将<code>ROM Output</code>复制到控制逻辑的ROM中。需要在控制逻辑电路中根据指令编码中的<code>opcode</code>, <code>fun3</code>, <code>fun7</code>字段来区分每个类型，甚至每条指令，再通过优先级别编码器来索引控存中的微指令, 产生对应的控制信号。 <img src="https://pic4.zhimg.com/80/v2-00828871fd39660bf6ddaf8a32ab38fa.png" alt="Control"> <img src="https://pic4.zhimg.com/80/v2-ee25b2c060400847e6cf55d220704422.png" alt="Control"> 因为优先级别编码器最多只能支持32bit, 但我们的指令有36条, 需拆拆分成两部分输入。剩下四条指令可以通过指令编码格式来各自区分，然后再找到指令编码格式中与前32条指令相异的bit作为控制信号来控制二选一MUX。<img src="https://pic4.zhimg.com/80/v2-4c10eb6557e75cdd3866bd188e5868ff.png" alt="Control"></p><h2 id="branch-and-jump-instruction"><strong>Branch and Jump Instruction</strong></h2><p>通过<code>BrUn</code>信号来实现分支比较器产生对应<code>BrEq</code>和<code>BrLt</code>的控制信号决定分支是否发生跳转。 <img src="https://pic4.zhimg.com/80/v2-b4917e6611d7a6b8aa66d86f9d1362b5.png" alt="Branch Comp"></p><p>B类指令和J类指令产生<code>PCsel</code>控制信号来决定是否修改<code>PC</code>, 同样也通过指令编码格式中的bit来区分jump发生还是branch发生 <img src="https://pic4.zhimg.com/80/v2-941f7fe17956fab75c7e74b1afa5fb17.png" alt="Control"></p><h2 id="loading-and-storing"><strong>Loading and Storing</strong></h2><p>这部分需要细心一些，部分load和部分store无论是字节还是半字都要<strong>符号位拓展</strong>成字的大小。部分load相对部分store来说比较简单，因为部分load只需要考虑从存储器中读出来的数据位置不同即可，而部分store不仅需要将从寄存器中读来的数据分割，还需要将分割的数据存到对应存储器中字的偏移位置(这部分是由Mask来确定写入的位置的)。需要通过低两位来判断具体load的是当前字的哪一个部分。</p><h3 id="partial-load"><strong>Partial Load</strong></h3><p>如果不是取一个字的数据，则要根据当前指令lw来访问存储器的地址字段的低两位来产生控制信号，决定取当前数据字的哪一个部分的数据到寄存器中(通过splitter来划分)。由指令编码中的bit来作为控制信号区分，选择具体是<code>lw</code>还是<code>lh</code>, <code>lb</code>。 <img src="https://pic4.zhimg.com/80/v2-723ccb2b6671606fe4a6ac5b0cbf58c9.png"></p><h3 id="partial-store"><strong>Partial Store</strong></h3><p>同样有指令编码格式来区分三种类型的store指令决定store到存储器中的数据。MemWriteMask有四个二进制bit组成，分别表示store到存储器中数据的位置, 实验中并未提到mask实现的细节。但是需要完成有指令编码和访问存储器的地址来生成mask。生成的mask需要通过指令编码格式中的bit和地址字段的低两位来区分, 额外在利用上优先级别编码器来索引。 生成的mask有<code>lb</code>的0001, 0010, 0100, 1000, 和<code>lh</code>的0011, 1100以及<code>lw</code>的1111, 七种组合。 <img src="https://pic4.zhimg.com/80/v2-1b3b6bfa9c35647d8b7df3225a1e2a6f.png"></p><h2 id="datapath"><strong>Datapath</strong></h2><p>下面是流水过后的数据通路, 两级流水线挺好实现的，看了一下不需要考虑<code>Structure Hazards</code>以及<code>Data Hazards</code>，省去了很多数据通路上的麻烦。需要考虑的只有<code>Control Hazards</code>。当Branch或者Jump发生时，紧随其后进入流水线的只有一条指令，实验文档里解决的方案是插入一条NOP指令来防止冲突。什么时候插入NOP指令根据<code>PCsel</code>控制信号来决定即可。同时注意两个不同stage之间的差异(导致后面利用到PC的指令执行结果不正确)，需要通过在两个stage之间加流水线寄存器来存储一个时钟周期之内的信息(包括指令和PC值)。 <img src="https://pic4.zhimg.com/80/v2-55adeda8be6c453ab203579651619b65.png" alt="Datapath"></p><h2 id="参考书目"><strong>参考书目</strong></h2><ul><li>Introduction to Computing Systems: From Bits &amp; Gates to C &amp; Beyond [3ed.]</li><li>P&amp;H [RISC-V 2ed.]</li><li>CAAQA [6ed.]</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS61C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Lab2: Bomb Lab</title>
      <link href="/2022/05/16/CSAPP-Lab2-Bomb-Lab/"/>
      <url>/2022/05/16/CSAPP-Lab2-Bomb-Lab/</url>
      
        <content type="html"><![CDATA[<!-- # CSAPP Lab2: Bomb Lab --><blockquote><p>熟悉GDB</p></blockquote><span id="more"></span><h2 id="preparation"><strong>Preparation</strong></h2><p>建议在实验大致看一下lab相关的<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f20/www/recitations/f20New/recitation02-bomblab.pdf">pdf</a>。使用<code>man</code>手册来查看库函数，<code>callq … &lt;_exit@plt&gt;</code>类型为C的库函数。注意商用的architecture是以字节为单位编址寻址。</p><p>参考CS61C所了解到的Tool, 做足了准备工作。安装<code>CGDB</code>, 相比较于<code>GDB</code>的<code>tui</code>在调试lab时显示不会出现乱码的情况。从<code>ubuntu</code>中<code>apt-get</code>下载到的版本较低，一些功能不适用。参考<a href="https://cgdb.github.io/">CGDB官网</a>下载最新版本的<code>CGDB</code>, 简单浏览了一下<a href="https://cgdb.github.io/docs/cgdb.pdf">CGDB官方手册</a>, 以及对应<code>CGDB</code>在<code>~/.cgdb/cgdbrc</code>文件中做了如下的配置足以满足调试需求: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set disasm</span><br><span class="line">:set hls</span><br><span class="line">:set syn=style</span><br></pre></td></tr></table></figure> 另外gdb相关内容再推荐这两本书籍 <code>Debugs Hacks</code>和<code>Debugging with GDB</code>。</p><p>需要用<code>chmod</code>命令修改一下<code>bomb</code>二进制文件的可执行权限</p><p>接下来可以愉快地开始<code>bomb lab</code>了~</p><p>运行<code>cgdb</code>且在对应phase打上断点后可以用一个放入输入信息的文本文件标准输入重定向到传递给主函数的参数中，这样就可以避免卡死在读取输入的systemcall上。更多关于<a href="https://stackoverflow.com/questions/19467865/how-to-use-redirection-in-c-for-file-input">重定向</a> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)run &lt; in</span><br></pre></td></tr></table></figure> ## <strong>Phase_1</strong> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp                   # 开辟栈帧保存返回地址和写在文件中的字符串函数参数<span class="built_in">edi</span></span><br><span class="line">  400ee4:be <span class="number">00</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x402400,%esi</span><br><span class="line">  400ee9:e8 4a <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">401338</span> &lt;strings_not_equal&gt;  # <span class="built_in">edi</span>接着传给strings_not_equal</span><br><span class="line">  400eee:<span class="number">85</span> c0                <span class="keyword">test</span>   %eax,%eax                   # 若字符串相等，即函数返回<span class="number">0</span>，则Defuse炸弹</span><br><span class="line">  400ef0:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     400ef7 &lt;phase_1+<span class="number">0x17</span>&gt;</span><br><span class="line">  400ef2:e8 <span class="number">43</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          <span class="keyword">add</span>    <span class="number">$0</span>x8,%rsp                   # 函数调用结束栈顶指针复原</span><br><span class="line">  400efb:c3                   retq </span><br></pre></td></tr></table></figure> 分析一下<code>strings_not_equal</code>，判断两个字符串是否相等。 <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000401338</span> &lt;strings_not_equal&gt;:</span><br><span class="line">  <span class="number">401338</span>:<span class="number">41</span> <span class="number">54</span>                <span class="keyword">push</span>   %r12                             # callee save</span><br><span class="line">  40133a:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp</span><br><span class="line">  40133b:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line">  40133c:<span class="number">48</span> <span class="number">89</span> fb             <span class="keyword">mov</span>    %rdi,%rbx                        # 将两个参数放入local中, 防止后续操作被覆盖</span><br><span class="line">  40133f:<span class="number">48</span> <span class="number">89</span> f5             <span class="keyword">mov</span>    %rsi,%rbp</span><br><span class="line">  <span class="number">401342</span>:e8 d4 ff ff ff       callq  40131b &lt;string_length&gt;           # 第一个参数<span class="built_in">rdi</span>传递给函数返回第一个字符串长度到<span class="built_in">eax</span>中</span><br><span class="line">  <span class="number">401347</span>:<span class="number">41</span> <span class="number">89</span> c4             <span class="keyword">mov</span>    %eax,%r12d</span><br><span class="line">  40134a:<span class="number">48</span> <span class="number">89</span> ef             <span class="keyword">mov</span>    %rbp,%rdi                        # 将当前函数的第二个参数传递给<span class="built_in">rdi</span></span><br><span class="line">  <span class="number">40134d</span>:e8 c9 ff ff ff       callq  40131b &lt;string_length&gt;           # 返回第二个字符串参数的长度</span><br><span class="line">  <span class="number">401352</span>:ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%edx</span><br><span class="line">  <span class="number">401357</span>:<span class="number">41</span> <span class="number">39</span> c4             <span class="keyword">cmp</span>    %eax,%r12d                       # 两个参数的长度比较</span><br><span class="line">  40135a:<span class="number">75</span> 3f                <span class="keyword">jne</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;  # 字符串不相等则到转到restore并返回<span class="built_in">edx</span>中保存的<span class="number">1</span></span><br><span class="line">  40135c:0f b6 <span class="number">03</span>             movzbl (%rbx),%eax                      # 零拓展避免<span class="built_in">eax</span>高位出现杂乱数据, 字符为8bit，将其高位清<span class="number">0</span></span><br><span class="line">  40135f:<span class="number">84</span> c0                <span class="keyword">test</span>   %al,%al                          # 检测第一个参数是否遍历到terminator, 这种形式让<span class="built_in">al</span>与<span class="number">0</span>比较</span><br><span class="line">  <span class="number">401361</span>:<span class="number">74</span> <span class="number">25</span>                <span class="keyword">je</span>     <span class="number">401388</span> &lt;strings_not_equal+<span class="number">0x50</span>&gt;</span><br><span class="line">  <span class="number">401363</span>:3a <span class="number">45</span> <span class="number">00</span>             <span class="keyword">cmp</span>    <span class="number">0x0</span>(%rbp),%al</span><br><span class="line">  <span class="number">401366</span>:<span class="number">74</span> 0a                <span class="keyword">je</span>     <span class="number">401372</span> &lt;strings_not_equal+<span class="number">0x3a</span>&gt;</span><br><span class="line">  <span class="number">401368</span>:eb <span class="number">25</span>                <span class="keyword">jmp</span>    40138f &lt;strings_not_equal+<span class="number">0x57</span>&gt;</span><br><span class="line">  40136a:3a <span class="number">45</span> <span class="number">00</span>             <span class="keyword">cmp</span>    <span class="number">0x0</span>(%rbp),%al</span><br><span class="line">  <span class="number">40136d</span>:0f 1f <span class="number">00</span>             nopl   (%rax)</span><br><span class="line">  <span class="number">401370</span>:<span class="number">75</span> <span class="number">24</span>                <span class="keyword">jne</span>    <span class="number">401396</span> &lt;strings_not_equal+<span class="number">0x5e</span>&gt;</span><br><span class="line">  <span class="number">401372</span>:<span class="number">48</span> <span class="number">83</span> c3 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%rbx                        # 移动读取两个字符串参数中的字符</span><br><span class="line">  <span class="number">401376</span>:<span class="number">48</span> <span class="number">83</span> c5 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%rbp</span><br><span class="line">  40137a:0f b6 <span class="number">03</span>             movzbl (%rbx),%eax</span><br><span class="line">  <span class="number">40137d</span>:<span class="number">84</span> c0                <span class="keyword">test</span>   %al,%al                          # 检测第二个参数是否遍历到terminator</span><br><span class="line">  40137f:<span class="number">75</span> e9                <span class="keyword">jne</span>    40136a &lt;strings_not_equal+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">401381</span>:ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%edx                        # 两参数字符串相等，返回<span class="number">0</span></span><br><span class="line">  <span class="number">401386</span>:eb <span class="number">13</span>                <span class="keyword">jmp</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">401388</span>:ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%edx</span><br><span class="line">  <span class="number">40138d</span>:eb 0c                <span class="keyword">jmp</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  40138f:ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%edx</span><br><span class="line">  <span class="number">401394</span>:eb <span class="number">05</span>                <span class="keyword">jmp</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">401396</span>:ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%edx</span><br><span class="line">  40139b:<span class="number">89</span> d0                <span class="keyword">mov</span>    %edx,%eax                        # <span class="built_in">eax</span>作为返回值</span><br><span class="line">  <span class="number">40139d</span>:5b                   <span class="keyword">pop</span>    %rbx                             # restore</span><br><span class="line">  40139e:<span class="number">5d</span>                   <span class="keyword">pop</span>    %rbp</span><br><span class="line">  40139f:<span class="number">41</span> 5c                <span class="keyword">pop</span>    %r12</span><br><span class="line">  4013a1:c3                   retq </span><br></pre></td></tr></table></figure> 观察<code>phase_1</code>函数，需要进入函数<code>string_not_equal</code>，并通过该函数的返回结果来决定是否引爆炸弹。进入该函数后，可以发现在函数中比较的是<code>rdi</code>和<code>rsi</code>两个字符串参数。<code>rdi</code>是标准输入中输入的字符串。<code>string_length</code>的返回值保存在寄存器<code>eax</code>中为两字符串的长度。长度不相等即表示字符串肯定不相等，则返回寄存器<code>edx</code>中的1。初步可以判断<code>phase_1</code>要求比较的两个字符串要相等才能<code>defuse</code>。再仔细观察<code>phase_1</code>函数中<code>test %eax, %eax</code>测试寄存器<code>eax</code><strong>非0</strong>则跳转到<code>bomb</code>。因此要想不爆炸必须得保证存在于<code>($rdi)</code>, <code>($rsi)</code>中的两个字符串相等，即<code>strings_not_equal</code>的返回值为<strong>0</strong>。</p><p>用<code>x/s</code>查看对应<code>memory</code>中地址单元的的字符串内容, 使标准输入参数<code>rdi</code>等于下述字符串即可<code>defuse</code>。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure> 经分析答案为: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure></p><h2 id="phase_2"><strong>Phase_2</strong></h2><p><code>x86</code>ISA规定，当参数超过6个的时候就会使用栈来保存参数。<code>print (char*) 0x4025c3</code>打印由地址0x4025c3起始的字符串，显示的结果可以发现字符串为<code>"%d %d %d %d %d %d"</code>格式串。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp                       # callee save</span><br><span class="line">  400efd:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line">  400efe:<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x28,%rsp                 # <span class="built_in">rdi</span>为标准输入字符串的地址</span><br><span class="line">  400f02:<span class="number">48</span> <span class="number">89</span> e6             <span class="keyword">mov</span>    %rsp,%rsi                  # <span class="built_in">rsp</span>作为函数read_six_numbers的第二个参数, caller save</span><br><span class="line">  400f05:e8 <span class="number">52</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40145c &lt;read_six_numbers&gt;  # 函数读取六个数字到栈空间上。</span><br><span class="line">  400f0a:<span class="number">83</span> 3c <span class="number">24</span> <span class="number">01</span>          cmpl   <span class="number">$0</span>x1,(%rsp)                # 取第一个数字</span><br><span class="line">  400f0e:<span class="number">74</span> <span class="number">20</span>                <span class="keyword">je</span>     400f30 &lt;phase_2+<span class="number">0x34</span>&gt;</span><br><span class="line">  400f10:e8 <span class="number">25</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:eb <span class="number">19</span>                <span class="keyword">jmp</span>    400f30 &lt;phase_2+<span class="number">0x34</span>&gt;</span><br><span class="line">  400f17:8b <span class="number">43</span> fc             <span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbx),%eax           # 取接下来的数字</span><br><span class="line">  400f1a:<span class="number">01</span> c0                <span class="keyword">add</span>    %eax,%eax                 # double</span><br><span class="line">  400f1c:<span class="number">39</span> <span class="number">03</span>                <span class="keyword">cmp</span>    %eax,(%rbx)</span><br><span class="line">  400f1e:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     400f25 &lt;phase_2+<span class="number">0x29</span>&gt;     # 下一个参数的值需要为上一个参数值的两倍才能确保不发生爆炸</span><br><span class="line">  400f20:e8 <span class="number">15</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:<span class="number">48</span> <span class="number">83</span> c3 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%rbx</span><br><span class="line">  400f29:<span class="number">48</span> <span class="number">39</span> eb             <span class="keyword">cmp</span>    %rbp,%rbx                 # 若读到第六个数字，则将局部变量所使用的寄存器restore到原来的值, <span class="keyword">pop</span>栈指针复原到调用前的位置, 否则继续<span class="keyword">loop</span></span><br><span class="line">  400f2c:<span class="number">75</span> e9                <span class="keyword">jne</span>    400f17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line">  400f2e:eb 0c                <span class="keyword">jmp</span>    400f3c &lt;phase_2+<span class="number">0x40</span>&gt;</span><br><span class="line">  400f30:<span class="number">48</span> <span class="number">8d</span> 5c <span class="number">24</span> <span class="number">04</span>       <span class="keyword">lea</span>    <span class="number">0x4</span>(%rsp),%rbx</span><br><span class="line">  400f35:<span class="number">48</span> <span class="number">8d</span> 6c <span class="number">24</span> <span class="number">18</span>       <span class="keyword">lea</span>    <span class="number">0x18</span>(%rsp),%rbp           # <span class="built_in">rsp</span>~<span class="built_in">rsp</span>-<span class="number">0x10</span>这部分为函数的返回地址和局部变量以及所用的栈空间</span><br><span class="line">  400f3a:eb <span class="built_in">db</span>                <span class="keyword">jmp</span>    400f17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line">  400f3c:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          <span class="keyword">add</span>    <span class="number">$0</span>x28,%rsp</span><br><span class="line">  400f40:5b                   <span class="keyword">pop</span>    %rbx</span><br><span class="line">  400f41:<span class="number">5d</span>                   <span class="keyword">pop</span>    %rbp</span><br><span class="line">  400f42:c3                   retq   </span><br></pre></td></tr></table></figure><p><code>read_six_numbers</code>中会调用C库函数<code>sscanf</code>，<code>man</code>手册中返回值的描述，返回输入数字匹配的个数。 &gt; On success, these functions return the number of input items success‐ fully matched and assigned; this can be fewer than provided for, or even zero, in the event of an early matching failure.</p><p>注意<code>x86</code>栈帧由低地址到高地址，先是返回地址，再到局部变量，再到save register。第1个参数在栈帧低地址 立即数为<code>32bit</code>, 按字节变址寻址, 函数参数为<code>caller save</code>。 <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp                    # 开辟栈帧, <span class="built_in">rdi</span>为第一个参数</span><br><span class="line">  <span class="number">401460</span>:<span class="number">48</span> <span class="number">89</span> f2             <span class="keyword">mov</span>    %rsi,%rdx                     # 第<span class="number">3</span>个参数</span><br><span class="line">  <span class="number">401463</span>:<span class="number">48</span> <span class="number">8d</span> 4e <span class="number">04</span>          <span class="keyword">lea</span>    <span class="number">0x4</span>(%rsi),%rcx                # 第<span class="number">4</span>个参数</span><br><span class="line">  <span class="number">401467</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">46</span> <span class="number">14</span>          <span class="keyword">lea</span>    <span class="number">0x14</span>(%rsi),%rax               # 第<span class="number">8</span>个参数</span><br><span class="line">  40146b:<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>       <span class="keyword">mov</span>    %rax,<span class="number">0x8</span>(%rsp)</span><br><span class="line">  <span class="number">401470</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">46</span> <span class="number">10</span>          <span class="keyword">lea</span>    <span class="number">0x10</span>(%rsi),%rax               # 第<span class="number">7</span>个参数</span><br><span class="line">  <span class="number">401474</span>:<span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>          <span class="keyword">mov</span>    %rax,(%rsp)</span><br><span class="line">  <span class="number">401478</span>:4c <span class="number">8d</span> 4e 0c          <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsi),%r9                 # 第<span class="number">6</span>个参数</span><br><span class="line">  40147c:4c <span class="number">8d</span> <span class="number">46</span> <span class="number">08</span>          <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsi),%r8                 # 第<span class="number">5</span>个参数</span><br><span class="line">  <span class="number">401480</span>:be c3 <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x4025c3,%esi                # 第<span class="number">2</span>个参数，格式串</span><br><span class="line">  <span class="number">401485</span>:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax                     # 初始化返回值</span><br><span class="line">  40148a:e8 <span class="number">61</span> f7 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:<span class="number">83</span> f8 <span class="number">05</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x5,%eax                     # 要求输入数字要大于<span class="number">5</span>个才不会引爆炸弹</span><br><span class="line">  <span class="number">401492</span>:7f <span class="number">05</span>                <span class="keyword">jg</span>     <span class="number">401499</span> &lt;read_six_numbers+<span class="number">0x3d</span>&gt;</span><br><span class="line">  <span class="number">401494</span>:e8 a1 ff ff ff       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401499</span>:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">40149d</span>:c3                   retq  </span><br></pre></td></tr></table></figure> 查看<code>0x4025c3</code>地址单元中的内容为格式串 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4025c3</span><br><span class="line">0x4025c3:       &quot;%d %d %d %d %d %d&quot;</span><br></pre></td></tr></table></figure> 经分析答案为: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure></p><h2 id="phase_3"><strong>Phase_3</strong></h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  400f47:<span class="number">48</span> <span class="number">8d</span> 4c <span class="number">24</span> 0c       <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line">  400f4c:<span class="number">48</span> <span class="number">8d</span> <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line">  400f51:be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x4025cf,%esi         # <span class="string">&quot;%d %d&quot;</span>需要两个无符号十进制数, 少于<span class="number">2</span>个会引爆炸弹</span><br><span class="line">  400f56:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  400f5b:e8 <span class="number">90</span> fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:<span class="number">83</span> f8 <span class="number">01</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">  400f63:7f <span class="number">05</span>                <span class="keyword">jg</span>     400f6a &lt;phase_3+<span class="number">0x27</span>&gt;</span><br><span class="line">  400f65:e8 d0 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:<span class="number">83</span> 7c <span class="number">24</span> <span class="number">08</span> <span class="number">07</span>       cmpl   <span class="number">$0</span>x7,<span class="number">0x8</span>(%rsp)         # 第一个标准输入中的参数大于<span class="number">7</span>则会跳转发生爆炸</span><br><span class="line">  400f6f:<span class="number">77</span> 3c                <span class="keyword">ja</span>     400fad &lt;phase_3+<span class="number">0x6a</span>&gt;</span><br><span class="line">  400f71:8b <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rsp),%eax</span><br><span class="line">  400f75:ff <span class="number">24</span> c5 <span class="number">70</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span> jmpq   *<span class="number">0x402470</span>(,%rax,<span class="number">8</span>)     # indirect jump, 跳转到<span class="number">0x402470</span>+<span class="built_in">rax</span>*<span class="number">8</span>的存储单元中存放的地址即<span class="number">0x400f83</span></span><br><span class="line">  400f7c:b8 cf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>xcf,%eax</span><br><span class="line">  400f81:eb 3b                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f83:b8 c3 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x2c3,%eax</span><br><span class="line">  400f88:eb <span class="number">34</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f8a:b8 <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x100,%eax</span><br><span class="line">  400f8f:eb <span class="number">2d</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f91:b8 <span class="number">85</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x185,%eax</span><br><span class="line">  400f96:eb <span class="number">26</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f98:b8 ce <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>xce,%eax</span><br><span class="line">  400f9d:eb 1f                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f9f:b8 aa <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x2aa,%eax</span><br><span class="line">  400fa4:eb <span class="number">18</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400fa6:b8 <span class="number">47</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x147,%eax</span><br><span class="line">  400fab:eb <span class="number">11</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400fad:e8 <span class="number">88</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  400fb7:eb <span class="number">05</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400fb9:b8 <span class="number">37</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x137,%eax</span><br><span class="line">  400fbe:3b <span class="number">44</span> <span class="number">24</span> 0c          <span class="keyword">cmp</span>    <span class="number">0xc</span>(%rsp),%eax         # 第二个参数和覆写后的<span class="built_in">eax</span>相等才能跳过bomb</span><br><span class="line">  400fc2:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     400fc9 &lt;phase_3+<span class="number">0x86</span>&gt;</span><br><span class="line">  400fc4:e8 <span class="number">71</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  400fcd:c3                   retq   </span><br></pre></td></tr></table></figure><p><code>jmp *Operand</code>为Indirect Jump, 跳转的target存放在寄存器中或者内存中。查看内存中存放的target: <img src="https://pic4.zhimg.com/80/v2-bd761cefa9fec00f19cf892677e0e12d.png" alt="Image"> 再结合上面的汇编代码，可以得出8个答案: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 207</span><br><span class="line">1 311</span><br><span class="line">2 707</span><br><span class="line">3 256</span><br><span class="line">4 389</span><br><span class="line">5 206</span><br><span class="line">6 682</span><br><span class="line">7 327</span><br></pre></td></tr></table></figure> ## <strong>Phase_4</strong> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">401010</span>:<span class="number">48</span> <span class="number">8d</span> 4c <span class="number">24</span> 0c       <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsp),%rcx  # callee save</span><br><span class="line">  <span class="number">401015</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsp),%rdx  # callee save</span><br><span class="line">  40101a:be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x4025cf,%esi  # 格式串, 需要两个十进制数, 因此可以断定标准输入为两个数</span><br><span class="line">  40101f:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  <span class="number">401024</span>:e8 c7 fb ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  <span class="number">401029</span>:<span class="number">83</span> f8 <span class="number">02</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x2,%eax             # 需要在标准输入中传递两个参数(sscanf系统调用的返回值)，否则会引爆炸弹</span><br><span class="line">  40102c:<span class="number">75</span> <span class="number">07</span>                <span class="keyword">jne</span>    <span class="number">401035</span> &lt;phase_4+<span class="number">0x29</span>&gt;</span><br><span class="line">  40102e:<span class="number">83</span> 7c <span class="number">24</span> <span class="number">08</span> 0e       cmpl   <span class="number">$0</span>xe,<span class="number">0x8</span>(%rsp)        # 第一个参数若大于<span class="number">14</span>，则bomb</span><br><span class="line">  <span class="number">401033</span>:<span class="number">76</span> <span class="number">05</span>                <span class="keyword">jbe</span>    40103a &lt;phase_4+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">401035</span>:e8 <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:ba 0e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>xe,%edx             # <span class="number">14</span>作为func4的第三个参数</span><br><span class="line">  40103f:be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%esi             # <span class="number">0</span>作为func4的第二个参数</span><br><span class="line">  <span class="number">401044</span>:8b 7c <span class="number">24</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rsp),%edi        # phase_4的第一个参数作为func4的第一个参数</span><br><span class="line">  <span class="number">401048</span>:e8 <span class="number">81</span> ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  <span class="number">40104d</span>:<span class="number">85</span> c0                <span class="keyword">test</span>   %eax,%eax             # 若返回值<span class="built_in">eax</span>不为<span class="number">0</span>则bomb</span><br><span class="line">  40104f:<span class="number">75</span> <span class="number">07</span>                <span class="keyword">jne</span>    <span class="number">401058</span> &lt;phase_4+<span class="number">0x4c</span>&gt;</span><br><span class="line">  <span class="number">401051</span>:<span class="number">83</span> 7c <span class="number">24</span> 0c <span class="number">00</span>       cmpl   <span class="number">$0</span>x0,<span class="number">0xc</span>(%rsp)        # 若第二个标准输入参数不为<span class="number">0</span>则bomb, 因此可以确定第二个标准输入参数必须为<span class="number">0</span></span><br><span class="line">  <span class="number">401056</span>:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     <span class="number">40105d</span> &lt;phase_4+<span class="number">0x51</span>&gt;</span><br><span class="line">  <span class="number">401058</span>:e8 <span class="built_in">dd</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">40105d</span>:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">401061</span>:c3                   retq   </span><br></pre></td></tr></table></figure> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp              # stack frame</span><br><span class="line">  400fd2:<span class="number">89</span> d0                <span class="keyword">mov</span>    %edx,%eax</span><br><span class="line">  400fd4:<span class="number">29</span> f0                <span class="keyword">sub</span>    %esi,%eax</span><br><span class="line">  400fd6:<span class="number">89</span> c1                <span class="keyword">mov</span>    %eax,%ecx</span><br><span class="line">  400fd8:c1 e9 1f             <span class="keyword">shr</span>    <span class="number">$0</span>x1f,%ecx             # 取符号位</span><br><span class="line">  400fdb:<span class="number">01</span> c8                <span class="keyword">add</span>    %ecx,%eax</span><br><span class="line">  400fdd:d1 f8                <span class="keyword">sar</span>    %eax                   # <span class="built_in">eax</span>  除以<span class="number">2</span>向下取整, 最后的答案与之相关</span><br><span class="line">  400fdf:<span class="number">8d</span> 0c <span class="number">30</span>             <span class="keyword">lea</span>    (%rax,%rsi,<span class="number">1</span>),%ecx</span><br><span class="line">  400fe2:<span class="number">39</span> f9                <span class="keyword">cmp</span>    %edi,%ecx              # 直到<span class="built_in">ecx</span>小于等于第一个标准输入的参数<span class="built_in">edi</span>, 则跳转到<span class="number">0x400ff2</span></span><br><span class="line">  400fe4:7e 0c                <span class="keyword">jle</span>    400ff2 &lt;func4+<span class="number">0x24</span>&gt;</span><br><span class="line">  400fe6:<span class="number">8d</span> <span class="number">51</span> ff             <span class="keyword">lea</span>    -<span class="number">0x1</span>(%rcx),%edx</span><br><span class="line">  400fe9:e8 e0 ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:<span class="number">01</span> c0                <span class="keyword">add</span>    %eax,%eax</span><br><span class="line">  400ff0:eb <span class="number">15</span>                <span class="keyword">jmp</span>    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;</span><br><span class="line">  400ff2:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax              # 此处很关键，要保证不bomb必须返回<span class="number">0</span></span><br><span class="line">  400ff7:<span class="number">39</span> f9                <span class="keyword">cmp</span>    %edi,%ecx  </span><br><span class="line">  400ff9:<span class="number">7d</span> 0c                <span class="keyword">jge</span>    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;    # 跳转到此处之后，要想此处跳转，条件必须是<span class="built_in">ecx</span>==<span class="built_in">edi</span></span><br><span class="line">  400ffb:<span class="number">8d</span> <span class="number">71</span> <span class="number">01</span>             <span class="keyword">lea</span>    <span class="number">0x1</span>(%rcx),%esi</span><br><span class="line">  400ffe:e8 cb ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  <span class="number">401003</span>:<span class="number">8d</span> <span class="number">44</span> <span class="number">00</span> <span class="number">01</span>          <span class="keyword">lea</span>    <span class="number">0x1</span>(%rax,%rax,<span class="number">1</span>),%eax  # 执行到这一步无论<span class="built_in">rax</span>的值为什么都不可能为<span class="number">0</span></span><br><span class="line">  <span class="number">401007</span>:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          <span class="keyword">add</span>    <span class="number">$0</span>x8,%rsp</span><br><span class="line">  40100b:c3                   retq   </span><br></pre></td></tr></table></figure> 经过调试分析, 可得出四个答案, 除此之外可能还有其他答案就不另行分析了： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7 0</span><br><span class="line">3 0</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure> ## <strong>Phase_5</strong> ASCII转化为十六进制时(因为所取数字的下标大于10)需要查看ASCII编码表。关于stack canary的解释可以参考<a href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value/10325915#10325915">文章</a>和<a href="https://qastack.cn/unix/453749/what-sets-fs0x28-stack-canary">文章</a>使用rax寄存器作为间接传递的原因是因为x86中不存在内存到内存的mov指令。 <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000401062</span> &lt;phase_5&gt;:</span><br><span class="line">  <span class="number">401062</span>:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx                     # callee save</span><br><span class="line">  <span class="number">401063</span>:<span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x20,%rsp</span><br><span class="line">  <span class="number">401067</span>:<span class="number">48</span> <span class="number">89</span> fb             <span class="keyword">mov</span>    %rdi,%rbx                # 标准输入字符串参数</span><br><span class="line">  40106a:<span class="number">64</span> <span class="number">48</span> 8b <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> <span class="keyword">mov</span>    %fs:<span class="number">0x28</span>,%rax            # stack-canary</span><br><span class="line">  <span class="number">401071</span>:<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">401073</span>:<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>       <span class="keyword">mov</span>    %rax,<span class="number">0x18</span>(%rsp)</span><br><span class="line">  <span class="number">401078</span>:<span class="number">31</span> c0                <span class="keyword">xor</span>    %eax,%eax                # 对<span class="built_in">eax</span>清<span class="number">0</span></span><br><span class="line">  40107a:e8 9c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  40131b &lt;string_length&gt;   # <span class="built_in">rdi</span>作为参数, 返回<span class="built_in">rdi</span>字符串的长度</span><br><span class="line">  40107f:<span class="number">83</span> f8 <span class="number">06</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x6,%eax                # 如果标准输入的字符串不为<span class="number">6</span>个字符，则bomb</span><br><span class="line">  <span class="number">401082</span>:<span class="number">74</span> 4e                <span class="keyword">je</span>     4010d2 &lt;phase_5+<span class="number">0x70</span>&gt;</span><br><span class="line">  <span class="number">401084</span>:e8 b1 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401089</span>:eb <span class="number">47</span>                <span class="keyword">jmp</span>    4010d2 &lt;phase_5+<span class="number">0x70</span>&gt;</span><br><span class="line">  40108b:0f b6 0c <span class="number">03</span>          movzbl (%rbx,%rax,<span class="number">1</span>),%ecx       # 取字符</span><br><span class="line">  40108f:<span class="number">88</span> 0c <span class="number">24</span>             <span class="keyword">mov</span>    %cl,(%rsp)               # 取最低字节大小的字符</span><br><span class="line">  <span class="number">401092</span>:<span class="number">48</span> 8b <span class="number">14</span> <span class="number">24</span>          <span class="keyword">mov</span>    (%rsp),%rdx</span><br><span class="line">  <span class="number">401096</span>:<span class="number">83</span> e2 0f             <span class="keyword">and</span>    <span class="number">$0</span>xf,%edx                # 将ASCII转化为对应的十六进制数作为索引</span><br><span class="line">  <span class="number">401099</span>:0f b6 <span class="number">92</span> b0 <span class="number">24</span> <span class="number">40</span> <span class="number">00</span> movzbl <span class="number">0x4024b0</span>(%rdx),%edx      # <span class="number">0x4024b0</span>中存放了一串字符, 通过分析可以发现<span class="built_in">rdx</span>作为取字符串字符的索引</span><br><span class="line">  4010a0:<span class="number">88</span> <span class="number">54</span> <span class="number">04</span> <span class="number">10</span>          <span class="keyword">mov</span>    %dl,<span class="number">0x10</span>(%rsp,%rax,<span class="number">1</span>)    # 将取到的字符存入由<span class="built_in">rsp</span>+<span class="number">0x10</span>处的开始向高地址方向增长</span><br><span class="line">  4010a4:<span class="number">48</span> <span class="number">83</span> c0 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%rax                # 减少迭代次数</span><br><span class="line">  4010a8:<span class="number">48</span> <span class="number">83</span> f8 <span class="number">06</span>          <span class="keyword">cmp</span>    <span class="number">$0</span>x6,%rax                # 迭代<span class="number">6</span>次</span><br><span class="line">  4010ac:<span class="number">75</span> <span class="built_in">dd</span>                <span class="keyword">jne</span>    40108b &lt;phase_5+<span class="number">0x29</span>&gt;</span><br><span class="line">  4010ae:c6 <span class="number">44</span> <span class="number">24</span> <span class="number">16</span> <span class="number">00</span>       movb   <span class="number">$0</span>x0,<span class="number">0x16</span>(%rsp)          # 在字符串后添加termimator, 作为字符串比较结束的标志</span><br><span class="line">  4010b3:be 5e <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x40245e,%esi           # <span class="string">&quot;flyers&quot;</span></span><br><span class="line">  4010b8:<span class="number">48</span> <span class="number">8d</span> 7c <span class="number">24</span> <span class="number">10</span>       <span class="keyword">lea</span>    <span class="number">0x10</span>(%rsp),%rdi</span><br><span class="line">  4010bd:e8 <span class="number">76</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">401338</span> &lt;strings_not_equal&gt;    # 比较存放在<span class="number">0x40245e</span>中的字符串和标准输入转化后的字符串</span><br><span class="line">  4010c2:<span class="number">85</span> c0                <span class="keyword">test</span>   %eax,%eax</span><br><span class="line">  4010c4:<span class="number">74</span> <span class="number">13</span>                <span class="keyword">je</span>     4010d9 &lt;phase_5+<span class="number">0x77</span>&gt;</span><br><span class="line">  4010c6:e8 6f <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:0f 1f <span class="number">44</span> <span class="number">00</span> <span class="number">00</span>       nopl   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line">  4010d0:eb <span class="number">07</span>                <span class="keyword">jmp</span>    4010d9 &lt;phase_5+<span class="number">0x77</span>&gt;</span><br><span class="line">  4010d2:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  4010d7:eb b2                <span class="keyword">jmp</span>    40108b &lt;phase_5+<span class="number">0x29</span>&gt;</span><br><span class="line">  4010d9:<span class="number">48</span> 8b <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>       <span class="keyword">mov</span>    <span class="number">0x18</span>(%rsp),%rax  </span><br><span class="line">  4010de:<span class="number">64</span> <span class="number">48</span> <span class="number">33</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> <span class="keyword">xor</span>    %fs:<span class="number">0x28</span>,%rax                 # 若stack canary未被破坏则跳过__stack_chk_fail</span><br><span class="line">  4010e5:<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  4010e7:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     4010ee &lt;phase_5+<span class="number">0x8c</span>&gt;</span><br><span class="line">  4010e9:e8 <span class="number">42</span> fa ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">20</span>          <span class="keyword">add</span>    <span class="number">$0</span>x20,%rsp                    # restore</span><br><span class="line">  4010f2:5b                   <span class="keyword">pop</span>    %rbx</span><br><span class="line">  4010f3:c3                   retq </span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;:  &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:       &quot;flyers&quot;</span><br></pre></td></tr></table></figure> 输入正确结果后内存中存放的内容： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s $rsp+0x10</span><br><span class="line">0x7fffffffdfc0: &quot;flyers&quot;</span><br></pre></td></tr></table></figure> 最后的答案为: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9?&gt;567</span><br></pre></td></tr></table></figure> ## <strong>Phase_6</strong> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:<span class="number">41</span> <span class="number">56</span>                <span class="keyword">push</span>   %r14                         # callee save</span><br><span class="line">  4010f6:<span class="number">41</span> <span class="number">55</span>                <span class="keyword">push</span>   %r13</span><br><span class="line">  4010f8:<span class="number">41</span> <span class="number">54</span>                <span class="keyword">push</span>   %r12</span><br><span class="line">  4010fa:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp</span><br><span class="line">  4010fb:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line">  4010fc:<span class="number">48</span> <span class="number">83</span> ec <span class="number">50</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x50,%rsp                   # stack frame</span><br><span class="line">  <span class="number">401100</span>:<span class="number">49</span> <span class="number">89</span> e5             <span class="keyword">mov</span>    %rsp,%r13</span><br><span class="line">  <span class="number">401103</span>:<span class="number">48</span> <span class="number">89</span> e6             <span class="keyword">mov</span>    %rsp,%rsi</span><br><span class="line">  <span class="number">401106</span>:e8 <span class="number">51</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  40110b:<span class="number">49</span> <span class="number">89</span> e6             <span class="keyword">mov</span>    %rsp,%r14</span><br><span class="line">  40110e:<span class="number">41</span> bc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x0,%r12d                   # 迭代器</span><br><span class="line">  <span class="number">401114</span>:4c <span class="number">89</span> ed             <span class="keyword">mov</span>    %r13,%rbp</span><br><span class="line">  <span class="number">401117</span>:<span class="number">41</span> 8b <span class="number">45</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">0x0</span>(%r13),%eax               # <span class="built_in">r13</span>中存放的数字放入<span class="built_in">eax</span>中</span><br><span class="line">  40111b:<span class="number">83</span> e8 <span class="number">01</span>             <span class="keyword">sub</span>    <span class="number">$0</span>x1,%eax                    # <span class="built_in">eax</span>大于<span class="number">5</span>则bomb, 一轮<span class="keyword">loop</span>之后观察可以推出六个数字的范围是<span class="number">1</span>到<span class="number">6</span>, 且相邻数字不能相同</span><br><span class="line">  40111e:<span class="number">83</span> f8 <span class="number">05</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x5,%eax</span><br><span class="line">  <span class="number">401121</span>:<span class="number">76</span> <span class="number">05</span>                <span class="keyword">jbe</span>    <span class="number">401128</span> &lt;phase_6+<span class="number">0x34</span>&gt;        # be无符号比较, 若参数数减去<span class="number">1</span>小于<span class="number">0</span>则会bomb，进而可以推出参数不能小于<span class="number">1</span></span><br><span class="line">  <span class="number">401123</span>:e8 <span class="number">12</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401128</span>:<span class="number">41</span> <span class="number">83</span> c4 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%r12d </span><br><span class="line">  40112c:<span class="number">41</span> <span class="number">83</span> fc <span class="number">06</span>          <span class="keyword">cmp</span>    <span class="number">$0</span>x6,%r12d</span><br><span class="line">  <span class="number">401130</span>:<span class="number">74</span> <span class="number">21</span>                <span class="keyword">je</span>     <span class="number">401153</span> &lt;phase_6+<span class="number">0x5f</span>&gt;        # 外循环迭代次数到<span class="number">6</span>次则终止<span class="keyword">loop</span></span><br><span class="line">  <span class="number">401132</span>:<span class="number">44</span> <span class="number">89</span> e3             <span class="keyword">mov</span>    %r12d,%ebx</span><br><span class="line">  <span class="number">401135</span>:<span class="number">48</span> <span class="number">63</span> c3             movslq %ebx,%rax</span><br><span class="line">  <span class="number">401138</span>:8b <span class="number">04</span> <span class="number">84</span>             <span class="keyword">mov</span>    (%rsp,%rax,<span class="number">4</span>),%eax           # 取下一个数字放入<span class="built_in">eax</span></span><br><span class="line">  40113b:<span class="number">39</span> <span class="number">45</span> <span class="number">00</span>             <span class="keyword">cmp</span>    %eax,<span class="number">0x0</span>(%rbp)               # 若当前数字与下一个数字相等，则bomb</span><br><span class="line">  40113e:<span class="number">75</span> <span class="number">05</span>                <span class="keyword">jne</span>    <span class="number">401145</span> &lt;phase_6+<span class="number">0x51</span>&gt;</span><br><span class="line">  <span class="number">401140</span>:e8 f5 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;        # 六个数字出现连续相同的数字则发生bomb</span><br><span class="line">  <span class="number">401145</span>:<span class="number">83</span> c3 <span class="number">01</span>             <span class="keyword">add</span>    <span class="number">$0</span>x1,%ebx</span><br><span class="line">  <span class="number">401148</span>:<span class="number">83</span> fb <span class="number">05</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x5,%ebx                    # 若没遍历完六个数字中剩余的数字则<span class="keyword">loop</span></span><br><span class="line">  40114b:7e e8                <span class="keyword">jle</span>    <span class="number">401135</span> &lt;phase_6+<span class="number">0x41</span>&gt;</span><br><span class="line">  <span class="number">40114d</span>:<span class="number">49</span> <span class="number">83</span> c5 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%r13                    # 取下一个数字</span><br><span class="line">  <span class="number">401151</span>:eb c1                <span class="keyword">jmp</span>    <span class="number">401114</span> &lt;phase_6+<span class="number">0x20</span>&gt;</span><br><span class="line">  <span class="number">401153</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">74</span> <span class="number">24</span> <span class="number">18</span>       <span class="keyword">lea</span>    <span class="number">0x18</span>(%rsp),%rsi              # null terminator, 第六个参数后面的字</span><br><span class="line">  <span class="number">401158</span>:4c <span class="number">89</span> f0             <span class="keyword">mov</span>    %r14,%rax</span><br><span class="line">  40115b:b9 <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x7,%ecx</span><br><span class="line">  <span class="number">401160</span>:<span class="number">89</span> ca                <span class="keyword">mov</span>    %ecx,%edx</span><br><span class="line">  <span class="number">401162</span>:2b <span class="number">10</span>                <span class="keyword">sub</span>    (%rax),%edx                  # 将<span class="number">7</span>减去当前位置的参数数字的结果放回到当前位置, 即将六个数字结果都改为<span class="number">7</span>-当前数字</span><br><span class="line">  <span class="number">401164</span>:<span class="number">89</span> <span class="number">10</span>                <span class="keyword">mov</span>    %edx,(%rax)</span><br><span class="line">  <span class="number">401166</span>:<span class="number">48</span> <span class="number">83</span> c0 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%rax                    # 往下移动一个数字的位置</span><br><span class="line">  40116a:<span class="number">48</span> <span class="number">39</span> f0             <span class="keyword">cmp</span>    %rsi,%rax                    # 若未移动到最后一个数字结束则继续<span class="keyword">loop</span></span><br><span class="line">  <span class="number">40116d</span>:<span class="number">75</span> f1                <span class="keyword">jne</span>    <span class="number">401160</span> &lt;phase_6+<span class="number">0x6c</span>&gt;</span><br><span class="line">  40116f:be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%esi</span><br><span class="line">  <span class="number">401174</span>:eb <span class="number">21</span>                <span class="keyword">jmp</span>    <span class="number">401197</span> &lt;phase_6+<span class="number">0xa3</span>&gt;        </span><br><span class="line">  <span class="number">401176</span>:<span class="number">48</span> 8b <span class="number">52</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rdx),%rdx               # 将当前<span class="built_in">rdx</span>中存放地址的下一个<span class="number">8</span>字节中存放地址的内容存放到<span class="built_in">rdx</span>中, 即遍历链表，取到对应的节点</span><br><span class="line">  40117a:<span class="number">83</span> c0 <span class="number">01</span>             <span class="keyword">add</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">  <span class="number">40117d</span>:<span class="number">39</span> c8                <span class="keyword">cmp</span>    %ecx,%eax                    </span><br><span class="line">  40117f:<span class="number">75</span> f5                <span class="keyword">jne</span>    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;        # 若<span class="built_in">eax</span>与做出变更的数字不相等则继续<span class="keyword">loop</span>, 实际上变更的数字为node号</span><br><span class="line">  <span class="number">401181</span>:eb <span class="number">05</span>                <span class="keyword">jmp</span>    <span class="number">401188</span> &lt;phase_6+<span class="number">0x94</span>&gt;</span><br><span class="line">  <span class="number">401183</span>:ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x6032d0,%edx               # <span class="number">0x6032d0</span>为node1</span><br><span class="line">  <span class="number">401188</span>:<span class="number">48</span> <span class="number">89</span> <span class="number">54</span> <span class="number">74</span> <span class="number">20</span>       <span class="keyword">mov</span>    %rdx,<span class="number">0x20</span>(%rsp,%rsi,<span class="number">2</span>)       # 将当前node的地址存放到$<span class="built_in">rsp</span>+<span class="number">0x20</span>开始，以<span class="number">8</span>字节为间隔的连续地址</span><br><span class="line">  <span class="number">40118d</span>:<span class="number">48</span> <span class="number">83</span> c6 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%rsi                    # 移动到下一个变更后的参数</span><br><span class="line">  <span class="number">401191</span>:<span class="number">48</span> <span class="number">83</span> fe <span class="number">18</span>          <span class="keyword">cmp</span>    <span class="number">$0</span>x18,%rsi                   </span><br><span class="line">  <span class="number">401195</span>:<span class="number">74</span> <span class="number">14</span>                <span class="keyword">je</span>     4011ab &lt;phase_6+<span class="number">0xb7</span>&gt;        # 遍历完六个参数则跳转到target, 即取对应参数变更后的node号的地址放入内存中</span><br><span class="line">  <span class="number">401197</span>:8b 0c <span class="number">34</span>             <span class="keyword">mov</span>    (%rsp,%rsi,<span class="number">1</span>),%ecx           # 按顺序取做出变更后的参数</span><br><span class="line">  40119a:<span class="number">83</span> f9 <span class="number">01</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x1,%ecx                    # 若当前数字小于等于<span class="number">1</span>则，直接存放当前节点不需要遍历链表</span><br><span class="line">  <span class="number">40119d</span>:7e e4                <span class="keyword">jle</span>    <span class="number">401183</span> &lt;phase_6+<span class="number">0x8f</span>&gt;</span><br><span class="line">  40119f:b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">  4011a4:ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x6032d0,%edx               # 传递的是地址, gdb调试可以发现存在一个链表, 比如<span class="number">0x6032d8</span>存储单元中存放着的是<span class="number">0x6032e0</span></span><br><span class="line">  4011a9:eb cb                <span class="keyword">jmp</span>    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;</span><br><span class="line">  4011ab:<span class="number">48</span> 8b 5c <span class="number">24</span> <span class="number">20</span>       <span class="keyword">mov</span>    <span class="number">0x20</span>(%rsp),%rbx              # node6的地址</span><br><span class="line">  4011b0:<span class="number">48</span> <span class="number">8d</span> <span class="number">44</span> <span class="number">24</span> <span class="number">28</span>       <span class="keyword">lea</span>    <span class="number">0x28</span>(%rsp),%rax               </span><br><span class="line">  4011b5:<span class="number">48</span> <span class="number">8d</span> <span class="number">74</span> <span class="number">24</span> <span class="number">50</span>       <span class="keyword">lea</span>    <span class="number">0x50</span>(%rsp),%rsi               </span><br><span class="line">  4011ba:<span class="number">48</span> <span class="number">89</span> d9             <span class="keyword">mov</span>    %rbx,%rcx                    </span><br><span class="line">  4011bd:<span class="number">48</span> 8b <span class="number">10</span>             <span class="keyword">mov</span>    (%rax),%rdx                  # node5的地址, 即指针</span><br><span class="line">  4011c0:<span class="number">48</span> <span class="number">89</span> <span class="number">51</span> <span class="number">08</span>          <span class="keyword">mov</span>    %rdx,<span class="number">0x8</span>(%rcx)               # 将node5的指针作为node6的next</span><br><span class="line">  4011c4:<span class="number">48</span> <span class="number">83</span> c0 <span class="number">08</span>          <span class="keyword">add</span>    <span class="number">$0</span>x8,%rax                    # node4指针的地址</span><br><span class="line">  4011c8:<span class="number">48</span> <span class="number">39</span> f0             <span class="keyword">cmp</span>    %rsi,%rax                    # 看一下是否遍历结束</span><br><span class="line">  4011cb:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     4011d2 &lt;phase_6+<span class="number">0xde</span>&gt;        </span><br><span class="line">  4011cd:<span class="number">48</span> <span class="number">89</span> d1             <span class="keyword">mov</span>    %rdx,%rcx</span><br><span class="line">  4011d0:eb eb                <span class="keyword">jmp</span>    4011bd &lt;phase_6+<span class="number">0xc9</span>&gt;        # <span class="keyword">loop</span></span><br><span class="line">  4011d2:<span class="number">48</span> c7 <span class="number">42</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="keyword">movq</span>   <span class="number">$0</span>x0,<span class="number">0x8</span>(%rdx)               # 将尾节点node1的next指向空</span><br><span class="line">  4011d9:<span class="number">00</span>                                                        # 应该是涉及pipeline优化的bubble </span><br><span class="line">  4011da:bd <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x5,%ebp                    # 迭代器</span><br><span class="line">  4011df:<span class="number">48</span> 8b <span class="number">43</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rbx),%rax               # 将下一个node的地址赋给<span class="built_in">rax</span></span><br><span class="line">  4011e3:8b <span class="number">00</span>                <span class="keyword">mov</span>    (%rax),%eax                  # 取下一个node的值(即低32bit)赋给<span class="built_in">eax</span></span><br><span class="line">  4011e5:<span class="number">39</span> <span class="number">03</span>                <span class="keyword">cmp</span>    %eax,(%rbx)                  # 当前node的值若小于(&lt;)下一个node的值，则bomb，到这里可以猜测要将链表要按node值来构造递减序列</span><br><span class="line">  4011e7:<span class="number">7d</span> <span class="number">05</span>                <span class="keyword">jge</span>    4011ee &lt;phase_6+<span class="number">0xfa</span>&gt;        # 初步可以判断需要用<span class="number">7</span>-当前参数值来取node号</span><br><span class="line">  4011e9:e8 4c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:<span class="number">48</span> 8b 5b <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rbx),%rbx               # 将当前node的next赋给<span class="built_in">rbx</span>, 即移动指针遍历到下一个node</span><br><span class="line">  4011f2:<span class="number">83</span> ed <span class="number">01</span>             <span class="keyword">sub</span>    <span class="number">$0</span>x1,%ebp                    # 减少迭代次数</span><br><span class="line">  4011f5:<span class="number">75</span> e8                <span class="keyword">jne</span>    4011df &lt;phase_6+<span class="number">0xeb</span>&gt;</span><br><span class="line">  4011f7:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">50</span>          <span class="keyword">add</span>    <span class="number">$0</span>x50,%rsp</span><br><span class="line">  4011fb:5b                   <span class="keyword">pop</span>    %rbx</span><br><span class="line">  4011fc:<span class="number">5d</span>                   <span class="keyword">pop</span>    %rbp</span><br><span class="line">  4011fd:<span class="number">41</span> 5c                <span class="keyword">pop</span>    %r12</span><br><span class="line">  4011ff:<span class="number">41</span> <span class="number">5d</span>                <span class="keyword">pop</span>    %r13</span><br><span class="line">  <span class="number">401201</span>:<span class="number">41</span> 5e                <span class="keyword">pop</span>    %r14</span><br><span class="line">  <span class="number">401203</span>:c3                   retq   </span><br></pre></td></tr></table></figure> 查看0x6032d0处地址内容(gdb中的字默认为4字节， 而x86的字默认为2字节), 可以猜测出第一个8字节中高4字节为node号，低4字节为值域，第二个8字节为next指针域，下述示例传递的参数为<code>1 2 3 4 5 6</code>: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/12xg 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x000000010000014c      0x0000000000000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x00000002000000a8      0x00000000006032d0</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x000000030000039c      0x00000000006032e0</span><br><span class="line">0x603300 &lt;node4&gt;:       0x00000004000002b3      0x00000000006032f0</span><br><span class="line">0x603310 &lt;node5&gt;:       0x00000005000001dd      0x0000000000603300</span><br><span class="line">0x603320 &lt;node6&gt;:       0x00000006000001bb      0x0000000000603310</span><br></pre></td></tr></table></figure> 6个node的值, 再将其由大到小排序： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node1: 0x14c</span><br><span class="line">node2: 0x0a8</span><br><span class="line">node3: 0x39c</span><br><span class="line">node4: 0x2b3</span><br><span class="line">node5: 0x1dd</span><br><span class="line">node6: 0x1bb</span><br><span class="line">node3 &gt; node4 &gt; node5 &gt; node6 &gt; node1 &gt; node2</span><br></pre></td></tr></table></figure> 由7-nodeNumber得到答案为: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure> <img src="https://pic4.zhimg.com/80/v2-77b2f6513b85ca11bed6e27cf04ea16d.png" alt="Defused"></p>]]></content>
      
      
      <categories>
          
          <category> CMU15-213 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Lab1: Data Lab</title>
      <link href="/2022/05/16/CSAPP-Lab1-Data-Lab/"/>
      <url>/2022/05/16/CSAPP-Lab1-Data-Lab/</url>
      
        <content type="html"><![CDATA[<h2 id="some-restriction"><strong>Some Restriction</strong></h2><!-- # CSAPP Lab1: Data Lab --><blockquote><p>又复习了一次位级表示</p></blockquote><span id="more"></span><h4 id="integer-coding-rules"><strong>Integer Coding Rules</strong></h4><ol type="1"><li>Expr<ol type="1"><li>整型操作数的值被限制在范围[0, 255]。</li><li>不能使用全局变量</li><li>只能使用的一元操作<code>!</code>, <code>~</code></li><li>只能使用的二元操作<code>&amp;</code>, <code>^</code>, <code>|</code>, <code>+</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li><li>一个表达式不会被限制拥有多个操作符</li></ol></li><li>Fobidden<ol type="1"><li>使用控制语句如<code>if</code>, <code>do</code>, <code>while</code>, <code>for</code>, <code>switch</code>等等</li><li>定义或使用任何宏</li><li>在当前文件中定义任何额外的函数</li><li>调用任何函数</li><li>使用其他操作</li><li>使用类型转换</li><li>使用除<code>int</code>之外的任何数据类型，使用<code>arrays</code>, <code>structs</code>, <code>unions</code></li></ol></li><li>假设机器的配置<ol type="1"><li>使用2的补码，<code>int</code>的表示为32-bit</li><li>执行算术右移</li><li>如果左移的位数小于0或者大于31则会出现未预测的行为。</li></ol></li></ol><h4 id="floating-point-coding-rules"><strong>Floating Point Coding Rules</strong></h4><ol type="1"><li>Forbidden<ol type="1"><li>定义或使用任何宏</li><li>定义任何额外的函数</li><li>调用任何函数</li><li>使用任何形式的类型转换</li><li>使用<code>arrays</code>, <code>structs</code>, <code>unions</code></li></ol></li></ol><h4 id="notes"><strong>Notes</strong></h4><ol type="1"><li>使用<code>dlc</code>(data tab checker)编译器来检查解决方案的合理性</li><li>使用<code>btest</code>来检查你的函数的正确性</li><li>使用<code>BDD checker</code>来正式地证实你的函数</li></ol><h4 id="lab-note"><strong>lab Note</strong></h4><ol type="1"><li>64位机器上编译32位程序会出现错误<code>fatal error: bits/libc-header-start.h: 没有那个文件或目录</code>，是因为gcc没有安装<code>multilib</code>库，这个库可以在64位的机器上产生32位的程序<code>sudo apt install gcc-multilib</code></li></ol><h3 id="bitxor"><strong>1. bitXor</strong></h3><p>通过图中所给的与、非和或门构造的异或逻辑电路，再利用德摩根定律将所有的或门转化为与门可得。 <img src="https://pic4.zhimg.com/80/v2-3e52fb0d69b1220a809e2982919296bf.png" alt="XOR gate"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> ~((~(x&amp;(~y))) &amp; (~((~x)&amp;y)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tmin"><strong>2. tmin</strong></h3><p>32位整型数<code>2's complement</code>的范围为<code>[-2^(n-1), 2^(n-1)-1</code>, 很容易得出结果 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="istmax"><strong>3. isTmax</strong></h3><p>摸索了小一段时间，解法很多，<code>-1</code>可以通过取反<code>+1</code>来构造。假设x为<code>Tmax</code>, 对<code>Tmax</code>取反得到<code>Tmin</code>，再减1则会发生<code>underflow</code>会得到<code>Tmax</code>, 通过逻辑运算的结果与<code>x</code>本身异或，看结果是否为<code>0</code>来判断<code>Tmax</code>。这种情况下<code>-1</code>是需要排除的, 因为对<code>-1</code>的<code>2's Complement</code>取反得到<code>0</code>，减1之后会得到<code>-1</code>本身，因此异或结果还是<code>0</code>，需要排除(利用好<code>!!</code>,保证与的操作数要么是<code>0</code>或<code>1</code>)。排除直接让<code>x+1</code>判断即可，否则操作数会超出10个。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (!(((~x)+(~<span class="number">1</span>+<span class="number">1</span>))^x)) &amp; (!!(x+<span class="number">1</span>));</span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure></p><h3 id="alloddbits"><strong>4. allOddBits</strong></h3><p>根据题目给定的操作符数的限制，以及操作数值的限定，即可确定需要利用好<code>0xAA</code>。同样也花了一些时间去斟酌，很多细节需要把握住，得到最终的答案。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !((((x&amp;<span class="number">0xAA</span>)&amp;((x&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xAA</span>))&amp;(((x&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xAA</span>)&amp;((x&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xAA</span>)))^<span class="number">0xAA</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="negate"><strong>5. negate</strong></h3><p>很简单 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isasciidigit"><strong>6. isAsciiDigit</strong></h3><p>可以先将操作数限定在<code>0x3X</code>的范围内，再通过对<code>0x0A</code>取补得到<code>-10</code>，取低4位进行加法运算，得到的结果通过符号位，若符号位为<code>1</code>则为ASCII数字，否则不满足条件。可以通过提取从低位数起第五个bit即<code>0x10</code>来确定符号位。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> neg_A = ~<span class="number">0x0A</span>+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((!((x&gt;&gt;<span class="number">4</span>)^<span class="number">0x3</span>)) &amp; (!!(((x&amp;<span class="number">0xF</span>)+neg_A)&amp;(<span class="number">0x10</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### <strong>7. conditional</strong> 保证<code>x</code>非<code>0</code>即<code>1</code>，再利用<code>0</code>和<code>1</code>补码的特点, 构造全<code>1</code>和全<code>0</code>, 分别和<code>y</code>, <code>z</code>完成与运算来进行排除，这道题还是非常巧妙的。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123; </span><br><span class="line">  <span class="type">int</span> mask = ~(!!(x^<span class="number">0x0</span>))+<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> (y&amp;mask) + (z&amp;(~mask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### <strong>8. isLessOrEqual</strong> 根据两个参数<code>x</code>, <code>y</code>的符号位先分几种情况 1. 满足小于等于 1. 两数相等 2. <code>x&lt;0, y&gt;0</code>, 避免符号位相等时的溢出情况 3. 符号位相等比较。通过第一个操作数加上第二个操作数的取补的形式, 若结果小于0，则<code>x&lt;y</code> - 负负比较, 可能会出现对<code>Tmin</code>取补发生下溢出的特殊情况，因此需要排除第二个操作数为<code>Tmin</code>的情况，恰好该情况要么<strong>相等</strong>(已经判断过了), 要么就是<code>x&gt;y</code>(也判断了)。 - 正正比较 2. 不满足小于等于,即大于等于(<code>x&gt;0, y&lt;0</code>) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_sign_bit = ((x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x01</span>);</span><br><span class="line">  <span class="type">int</span> y_sign_bit = ((y&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x01</span>);</span><br><span class="line">  <span class="type">int</span> Tmin = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (!((~x_sign_bit)&amp;y_sign_bit)) &amp; ((!(x^y)) | (x_sign_bit&amp;(~y_sign_bit)) | ((((x+(~y+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>)&amp;(!!(y^Tmin))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="logicalneg"><strong>9. logicalNeg</strong></h3><p>首先要将想一个办法将0和正数，负数区分开来。因为0和正数的符号位都是0，要区分开来恰好利用到了0的补码还是其本身的特性，正数取反加一后符号位由0变1，可以直接区分开来。再利用算数右移的特性，将0构造成全0，负数和正数构造成全1, 最后<code>+1</code>得到返回值。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((x&gt;&gt;<span class="number">31</span>)|((~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### <strong>10. howManyBits</strong> 坦白说这一题真的是卡了我好久，即便找到了最高bit位要想返回正确的结果几乎是很繁琐的，但肯定会超出操作符的限制。这道题参考了一下各路佬的思想，可以用二分法来实现。还需要注意负数需要按位取反(排除符号位的影响)，正数保持不变即可，可以通过<code>sign_bit</code>减<code>1</code>来构造全<code>0</code>和全<code>1</code>。可以通过右移<code>16</code>、<code>8</code>、<code>4</code>、<code>2</code>、<code>1</code>bit来找到最高的<code>bit 1</code>，这道题还是非常巧妙的。 判断右移<code>n bit</code>后是否为0 - 如果为0，说明需要的位在高<code>n-bit</code>(左半侧)，数则保持不变，故不记录<code>n</code>，继续进行二分搜索。 - 如果不为0，说明需要的位在低<code>n-bit</code>(右半侧), 数向右移动<code>n-bit</code>继续进行搜索，且记录<code>n</code>。 最后将所有移位得到的<code>n</code>都累加起来得到最后的结果 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits  - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> sign_bit = (x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">int</span> flag = sign_bit+(~<span class="number">1</span>+<span class="number">1</span>);   <span class="comment">// neg -&gt; all 0,  not_neg -&gt; all 1</span></span><br><span class="line">  x = ((~flag)&amp;(~x))|(flag&amp;x);  <span class="comment">// if neg, reverse.</span></span><br><span class="line">  b16 = (!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  x &gt;&gt;= b16;</span><br><span class="line">  b8 = (!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">  x &gt;&gt;= b8;</span><br><span class="line">  b4 = (!!(x&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">  x &gt;&gt;= b4;</span><br><span class="line">  b2 = (!!(x&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x &gt;&gt;= b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x &gt;&gt;= b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="floatscale2"><strong>11. floatScale2</strong></h3><p>描述里没有给<code>Infinity</code>的case，通过测试发现，与<code>Nan</code>返回值一致合并一起判断。需要判断几种情况: <code>NaN</code>, <code>Subnormal</code>, <code>+0</code>, <code>-0</code>, <code>Normalize</code>。<code>Normalize</code>的情况只需要对<code>Exponent</code>的最低位增加一个<code>bit</code>即可。注意<code>Subnormal</code>情况<code>Fraction</code>为全<code>1</code>时左移的结果不需要将<code>Exponent</code>清零，按测试用例应该是将<code>Subnormal</code>转化为<code>Normalize</code>了。强调一下移码的意义为<code>IEEE 754</code> Normalize表示部分2的指数部分。 <span class="math display">\[Bias = 2^{Exponent-1}-1\]</span> <span class="math display">\[Normalize = 1.Fraction \times 2^{Exponent + Bias} (1 \leq Exponent \leq 2^{Exponent} - 2)\]</span> <span class="math display">\[Subnormal = 0.Fraction \times 2^{1-Bias}\]</span> <span class="math display">\[Biased = Unsigned - Bias\]</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> exp_mask = <span class="number">0x7F800000</span>;          <span class="comment">// the eight bits of exponent is all 1.</span></span><br><span class="line">  <span class="type">int</span> Neg_zero = <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="type">int</span> sign_mask = Neg_zero;</span><br><span class="line">  <span class="type">int</span> fraction_mask = <span class="number">0x007FFFFF</span>;</span><br><span class="line">  <span class="keyword">if</span> (!((uf &amp; exp_mask)^exp_mask)) &#123;       <span class="comment">// eliminate the case of NaN.</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!uf) &#123;                     <span class="comment">// eliminate the case of +0.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(Neg_zero^uf)) &#123;          <span class="comment">// eliminate the case of -0.</span></span><br><span class="line">    <span class="keyword">return</span> Neg_zero;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(uf &amp; exp_mask)) &#123;              <span class="comment">// elinimate the case of subnormal.</span></span><br><span class="line">    <span class="keyword">return</span> (uf&amp;sign_mask) + (((uf&amp;fraction_mask)&lt;&lt;<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  uf += (<span class="number">0x1</span>&lt;&lt;<span class="number">23</span>);               <span class="comment">// Normalize.</span></span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="floatfloat2int"><strong>12. floatFloat2Int</strong></h3><p>实现到<code>IEEE754</code>单精度浮点数到定点整数的转换。题目中首先要考虑溢出的情况，早在最开始实验就假设机器左移的位数小于0或者大于31都会出现未知的行为，因此需要将这两种情况包含进去。由于<code>Normalize</code>的<code>M</code>部分是<span class="math inline">\(1.Fraction\)</span>因此需要将小数点前面的<code>1</code>提前加入<code>fraction</code>部分。实际上<code>fraction</code>右移<code>23位</code>可以和<span class="math inline">\(2^{Biased}\)</span>的指数部分进行相减<span class="math inline">\(2^{Biased-23}\)</span>，进行对应的移位操作完成<span class="math inline">\(2^n\)</span>幂次运算，最后得到对应的结果。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> bias = <span class="number">1</span>-(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">  <span class="type">int</span> exp_mask = <span class="number">0x7F800000</span>;</span><br><span class="line">  <span class="type">int</span> fraction_mask = <span class="number">0x007FFFFF</span>;</span><br><span class="line">  <span class="type">int</span> fraction = (uf &amp; fraction_mask);</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &amp; exp_mask) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">int</span> sign_bit = (uf&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">int</span> biased = <span class="built_in">exp</span> + bias;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">exp</span>^exp_mask) || biased &gt; <span class="number">31</span>) &#123;  <span class="comment">// NaN and infinity</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!uf || !(uf^<span class="number">0x80000000</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (biased &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">  &#125;</span><br><span class="line">  fraction |= (<span class="number">1</span>&lt;&lt;<span class="number">23</span>);  <span class="comment">// 1.F</span></span><br><span class="line">  <span class="keyword">if</span> (biased &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">    fraction &lt;&lt;= (biased<span class="number">-23</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fraction &gt;&gt;= (<span class="number">23</span>-biased);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sign_bit)</span><br><span class="line">    <span class="keyword">return</span> -fraction;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> fraction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="floatpower2"><strong>13. floatPower2</strong></h3><p>给定argument为<code>Biased</code>，求出其对应无符号<code>IEEE 754</code>单精度浮点数的表示即可。求出exp的值之后，左移23到IEEE754规格的exponent域中。认真读题后还是蛮简单的。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bias = <span class="number">127</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span> = (x + bias)&lt;&lt;<span class="number">23</span>;  <span class="comment">// x = exp - bias</span></span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-127</span>) &#123;              <span class="comment">// too small(exp are all 0s that is Subnormal)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; (<span class="number">255</span><span class="number">-127</span>)) &#123;  <span class="comment">// too large(the floating point number is larger than INF that exp are all 1s)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x7f800000</span>;         <span class="comment">// +INF</span></span><br><span class="line">    &#125;</span><br><span class="line">    f |= <span class="built_in">exp</span>;    <span class="comment">// normalize</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="运行结果">运行结果</h3><p><img src="https://pic4.zhimg.com/80/v2-21774eab522096e708d883dc09a4aa25.png" alt="./btest"> <img src="https://pic4.zhimg.com/80/v2-96d0c54113a6951eed5fe3cbfbba5b5a.png" alt="./dlc"></p>]]></content>
      
      
      <categories>
          
          <category> CMU15-213 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.NULL Video Note</title>
      <link href="/2022/05/16/6-NULL-Video-Note/"/>
      <url>/2022/05/16/6-NULL-Video-Note/</url>
      
        <content type="html"><![CDATA[<!-- # 6.NULL Video Note --><blockquote><p>好的工具总是能带来高的效率</p></blockquote><span id="more"></span><h2 id="video-1-the-shell"><strong>VIDEO 1</strong> The Shell</h2><ol type="1"><li><code>cd -</code>将会在和上一次cd的目录来回切换</li><li><code>rm</code>命令默认非递归的删除，因此删除目录时需要加上-r参数(recursive)，才能完整地将目录下的文件删除;而rmdir只能删除空目录</li><li>解释一下常用命令的含义<code>pwd</code>(print work directory), <code>cd</code>(change directory)</li><li>-表示当前没有允许的权限。d表示目录，注意目录的x位表示当前能够访问该目录的内容，且需要保证当前目录的父目录都含有x位才能访问。</li><li>redirect, &lt; 表示重定向输入, &gt; 表示重定向输出. Some example: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> hello &gt; hello.txt</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure> <code>&gt;&gt;</code>表示追加(append)</li><li><code>ctrl+L</code>清空终端的命令，返回到顶部。</li><li><code>tail -n</code>将数据中的末尾n行显示出来。</li><li>pipe，将两个不相关联的程序连接起来通过input/output连接起来,管道的左边作为一个input, 管道的右边作为一个output。</li><li><code>$</code>表示当前运行在用户模式下; <code>#</code>表示当前运行在系统模式下,可以通过命令<code>sudo su</code>来打开root下的terminal.</li><li>xdg-open命令可以打开文件对应的格式</li><li>double quotes: backslash, <code>\</code>前面加个<code>!</code>就不会被默认移除</li><li>shebang是由脚本开头的字符数字符号和感叹号<code>#!</code>组成的字符序列。当带有shebang的文本文件被用作类Unix操作系统的"可执行文件"时，程序加载器机制将文件初始行的其余部分解析为"解释器指令"。它告诉内核用什么来运行此脚本(比如说python or shell?)</li></ol><h2 id="video-2-shell-tools-and-scripting"><strong>VIDEO 2</strong> Shell Tools and Scripting</h2><ol type="1"><li>different from the single quote<code>(')</code> and double quote<code>(")</code>. echo ""中解析出变量放变量(用<code>$</code>符号来表示)。而单引号不会解析变量。</li><li><ul><li><code>$1</code>到<code>$9</code>表示argv中第一个到第九个参数</li><li><code>$0</code>表示脚本的名字</li><li><code>$_</code>(undersocre)表示上一个command的最后一个参数</li><li><code>$?</code>(question mark)获取上一个command的error code(一般值为<code>0</code>表示ok, <code>1</code>表示执行出错)。</li><li><code>$#</code>(hash)表示参数的个数</li><li><code>$$</code>表示当前进程的ID</li><li><code>$@</code>表示所有参数。</li></ul></li><li><code>!!</code>(bang)代替上一次执行过的command，比如说创建一个目录<code>mkdir ..</code>没有权限，这时候只需要<code>sudo !!</code>, 就会默认表示<code>sudo mkdir ..</code>从而减少了一些重复性的工作。</li><li>;(semicolon)分号可以连接任何命令行。<code>false ; echo "haha"</code></li><li>脚本中变量用双引号引起来<code>"$1"</code>.</li><li>执行脚本<code>source ..</code></li><li>globbing, *(asterisk), {}(curly braces)</li><li><code>tldr</code>(too long, don't read), 精简版带example的man</li><li><code>test</code>, 查看man手册</li><li><strong>查找文件</strong>:</li></ol><ul><li><code>find</code>查看man手册 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -<span class="built_in">type</span> d</span><br><span class="line"><span class="comment"># 查找所有文件夹路径中包含test的python文件</span></span><br><span class="line">find . -path <span class="string">&#x27;*/test/*.py&#x27;</span> -<span class="built_in">type</span> f</span><br><span class="line"><span class="comment"># 查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="comment"># 查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name <span class="string">&#x27;*.tar.gz&#x27;</span></span><br><span class="line"><span class="comment"># 删除全部扩展名为.tmp 的文件</span></span><br><span class="line">find . -name <span class="string">&#x27;*.tmp&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line"><span class="comment"># 查找全部的 PNG 文件并将其转换为 JPG</span></span><br><span class="line">find . -name <span class="string">&#x27;*.png&#x27;</span> -<span class="built_in">exec</span> convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure></li><li><a href="https://github.com/sharkdp/fd">fd</a>, find的替代物</li><li><code>locate</code>, 只能通过文件名，但速度很快。locate(1)当您只是尝试按名称查找特定文件时会更好，该文件您知道存在，但您只是不记得它的确切位置。find(1)当您有一个重点领域需要检查时，或者当您需要其众多优势中的任何一个时，效果会更好</li></ul><ol start="11" type="1"><li><code>shellcheck</code>检查shell脚本的语法。</li><li><strong>查找代码</strong>:<ul><li><code>grep</code></li><li><a href="https://beyondgrep.com/">awk</a></li><li><a href="https://github.com/BurntSushi/ripgrep">rg</a>(ripgrep) <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py <span class="string">&#x27;import requests&#x27;</span></span><br><span class="line"><span class="comment"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match <span class="string">&quot;^#!&quot;</span></span><br><span class="line"><span class="comment"># 查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="comment"># 打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>查找shell命令</strong>:</li></ol><ul><li><code>history</code></li><li><code>Ctrl+R</code>, backward search. 搭配<a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a></li></ul><ol start="14" type="1"><li><strong>文件夹导航</strong>:<ul><li><code>tree</code></li><li><code>broot</code></li><li><a href="https://github.com/jarun/nnn">nnn</a>, 需要接下来去学习</li></ul></li><li>shell中使用变量需要加<code>""</code>(double quote), 当变量中含有命令时需要加括号比如<code>"$(pwd)"</code></li><li>进行比较时需要加<code>[[]]</code>双括号，比如说<code>if [[ n -eq 12 ]]; then</code>, <strong>注意</strong>括号左右要有空格否则出错。</li><li><a href="https://linuxhint.com/bash_globbing_tutorial/">globbing</a></li></ol><h2 id="exercise2"><strong>Exercise2</strong></h2><ol type="1"><li><p>ls</p><ol type="1"><li>所有文件（包括隐藏文件<code>ls -a</code></li><li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954) <code>ls -hl</code></li><li>文件以最近访问顺序排序<code>ls -clt</code></li><li>以彩色文本显示输出结果<code>ls --color=always</code></li></ol></li><li><p>设计一个自动化shell。marco函数保存当前工作目录pwd到home目录的一个log文件中，polo函数通过打开log文件中的路径cd跳到之前所保存的目录中。</p><p>方法一: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$HOME</span>/marco_history.log&quot;</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;save pwd <span class="subst">$(pwd)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">   <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(cat $HOME/marco_history.log)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> <code>export</code>可以增加、修改或删除环境变量，仅效力于该次登陆的操作，和第一种方法的时效类似。</p><p>方法二: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">   <span class="built_in">export</span> MARCO=$(<span class="built_in">pwd</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">   <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$MARCO</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>shell表达式计算的格式为两个<code>(())</code>以及一些逻辑表达式的规范见<a href="https://ss64.com/bash/syntax-brackets.html">此处</a>。关于给的test中的语句中<code>&gt;&amp;2</code>以及一些重定向的问题<a href="https://askubuntu.com/questions/959066/what-does-mean-exactly-in-output-redirection">此处</a>给出了答案。<code>&gt;&amp;2</code>表示<code>2</code>是个文件描述符，不是<code>文件名</code>, 因为重定向的对象是文件名; <code>&amp;&gt;</code>则表示同时发送，比如<code>1&amp;&gt;2</code>表示标准输出和标准错误同时输出。</p><p>for循环的格式: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> u=rwx ./test.sh</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ./test.sh 2&gt; out.log</span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;failed after <span class="variable">$count</span> times&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> out.log</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">   ((count++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure> shellcheck建议增加一行<code>mycmd=$?</code>, 用<code>mycmd</code>来代替<code>$?</code></p></li><li><p>利用xargs命令完成一些操作。xargs命令将标准输入的内容作为参数。<a href="https://unix.stackexchange.com/questions/368753/what-does-this-command-with-a-backslash-at-the-end-do">此处</a>有关于<code>find</code>后的<code>/</code>的作用，目的是方便为了遇到换行符<code>\n</code>停止解析?? <code>tar</code>命令，压缩文件<code>tar -czvf</code>, 解压文件<code>tar -xzvf</code>, <code>-c</code>表示创建备份文件，<code>-x</code>表示从备份文件中还原文件。<code>-f</code>表示指定备份文件, <code>-v</code>表示显示verbose, <code>-z</code>表示<code>--gzip</code>或<code>--ungzip</code> 通过<code>gzip</code>指令处理备份文件。<code>xargs</code>的<code>-d</code>参数后面跟字符表示修改xargs的分隔符(默认为空白字符tab、空格、换行符)。</p><p>方法一, <code>xargs -d '\n'</code>指定输入遇到换行符结束:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&#x27;*.html&#x27;</span> -<span class="built_in">type</span> f | xargs -d <span class="string">&#x27;\n&#x27;</span> tar -cxzf html.zip</span><br></pre></td></tr></table></figure><p>方法二, <code>find -print0</code>打印文件名到标准输出后后面自动跟个<code>null</code>; <code>xargs -0</code>输入遇到<code>null</code>则终止代替空格:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&#x27;*.html&#x27;</span> -<span class="built_in">type</span> f -print0 | xargs -0 tar -cxzf html.zip</span><br></pre></td></tr></table></figure></li><li><p>找出当前文件夹下最近使用的文件, 并按照最近使用的时间列出文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="built_in">type</span> -f | xargs <span class="built_in">ls</span> -tl | head-1 </span><br></pre></td></tr></table></figure></p></li></ol><h2 id="video-3-editorsvim"><strong>VIDEO 3</strong> Editors(Vim)</h2><ol type="1"><li><code>v</code>进入可视化模式; <code>V</code>进入可视化<strong>行模式</strong>; <code>^v</code>(<code>Ctrl + v</code>)进入可视化<strong>块模式</strong></li><li>Vim大量使用<code>Esc键</code>，因此建议将<code>大小写锁定键</code>设置为<code>Esc键</code>, 可以在ubuntu下使用<a href="https://medium.com/@ahmaddynugroho/swap-caps-lock-and-escape-in-ubuntu-19-10-and-use-esc-easily-in-vim-vs-code-1d3d68f18764">gnome-tweaks</a>来配置交换修改大小写和Esc, 这里面同样介绍了VScode下的配置</li><li>Vim 会维护一系列打开的文件，称为“缓存<code>buffer</code>”。一个 Vim 会话包含一系列标签<code>tab</code>页，每个标签页包含 一系列窗口（分隔面板）。每个窗口显示一个缓存。</li><li><code>:qa</code>全部退出, <code>:wq</code>等价于<code>:x</code></li><li><code>:tabnew</code>;</li><li><code>:e &lt;文件名&gt;</code>打开要编辑的文件</li><li><ul><li><code>w</code>移动一个单词</li><li><code>b</code>回退一个单词</li><li><code>e</code>移动到单词末尾, 可以搭配<code>a</code>在光标之后插入文本。</li><li><code>^</code>移动到行首字符</li><li><code>$</code>移动到行尾字符</li><li><code>0</code>移动到行首字符前</li><li><code>^U</code>上翻页</li><li><code>^D</code>下翻页</li><li><code>gg</code>移动到最后一行</li><li>输入<code>number</code>+<code>G</code>则直接跳转到文件中的某一指定行。若不输入<code>number</code>则直接跳到文件第最后一行。</li><li><code>H</code>屏幕首行</li><li><code>M</code>屏幕中间</li><li><code>L</code>屏尾巴行</li></ul></li><li>[<code>f</code>|<code>F</code>|<code>t</code>|<code>T</code>][alpha], find和to功能来找到相应的字母</li><li><code>^g</code>显示当前编辑文件中当前光标所在行位置以及文件状态信息。</li><li><code>u</code>undo, <code>U</code>撤销在一行中做出的所有改动 ;<code>^r</code> redo</li><li><code>d</code>操作会将删除的内容放入vim中的寄存器中, 以便<code>p</code>操作时粘贴。<ul><li><code>de</code>删除从光标处到单词尾</li><li><code>dw</code>删除一个单词</li><li><code>d</code>+上<code>hjkl</code>方向可以删除需要的内容</li></ul></li><li><code>c</code>change，功能类似于<code>d</code>，只是操作<code>c</code>会进入<code>insert</code>模式</li><li>在词尾插入<code>e</code>移动到词尾，随后<code>a</code>在当前词尾插入</li><li><code>x</code>删除当前光标所处的字符, 如果在可视模式下就删除选中部分</li><li><code>r</code>replace, 如<code>ra</code>将当前字符替换为a; <code>R</code>则可以连续替换多个字符。</li><li><code>y</code>yank, <code>p</code>paste, <code>yw</code> copy one word, 都可以搭配可视化<code>v</code>来使用。</li><li><code>~</code>改变字母的大小写</li><li><code>[num[h|j|k|l]</code>, 如<code>4j</code>向下移动四次</li><li>modifier, <code>i</code>指的是<code>inner</code>, <code>a</code>指的是<code>around</code><ul><li><code>ci(</code> 改变当前括号内的内容</li><li><code>ci[</code> 改变当前方括号内的内容</li><li><code>da'</code> 删除一个单引号字符串，包括周围的单引号</li></ul></li><li><code>%</code>在配对的括号(parenthese)如:<code>), ], &#125;</code>之间来回切换。在程序调试时用来找不配对的括号是很有用的。</li><li><code>/</code>后紧随一个字符串是在当前所编辑的文档中<code>正向查找</code>改字符串; <code>?</code>则与<code>/</code>相反，是反向查找。<code>:set ic</code>可以忽略大小写(<code>Ignore Case</code>)会在接下来的查找中持续, <code>:set noic</code>则忽略大小写; <code>:set hls</code>搜索时设置高亮显示, 移除匹配项的高亮显示<code>nohlsearch</code>; <code>:set is</code>(incsearch)查找短语时显示部分匹配, <code>:set noic</code>。</li><li><a href="https://vimways.org/2019/">每日一个vim小技巧</a></li><li>安装并配置插件</li><li>Windows下映射CapsLock到ESC需要用到<code>autohotkey</code>脚本工具，添加语句<code>Capslock::Esc</code>即可</li><li><code>^o</code>回退到光标之前的位置，<code>^i</code>跳转到较新的位置。</li><li><code>s</code> is substitution. The first argument is search string, the second is replacement string.<ul><li>输入<code>:s/old/new</code>则只将光标所在行的第一个串<code>old</code>修改为<code>new</code>-</li><li>输入<code>:s/old/new/g</code>则将全行的匹配串<code>old</code>修改为<code>new</code>。</li><li><code>:%s/old/new/g</code>则替换整个文件中的每个匹配串。</li><li><code>:%s/old/new/gc</code>则会在替换时询问。</li><li><code>:#,#s/old/new/g</code>其中<code>#, #</code>代表的是替换操作的若干行中首尾两行的行号</li></ul></li><li>在vim内执行外部命令的方法，输入<code>:!</code>然后紧接着输入外部的<code>shell</code>命令，如:<code>:!ls</code>，回车结束显示。</li><li>可以搭配可视模式将部分内容<code>:w &lt;filename&gt;</code>写到文件名中。</li><li>将磁盘文件内容提取到当前光标行<code>:r &lt;filename&gt;</code>.</li><li><code>:sp</code>分割窗口，<code>^w ^w</code>(double w)在窗口之间来回切换.</li><li><code>F1</code>或者<code>:help</code>打开帮助文档。下面这些参数可以得到该主题的帮助<ul><li><code>:help w</code></li><li><code>:help c_CTRL-D</code></li><li><code>:help insert-index</code></li><li><code>:help user-manual</code>，阅读Vim的用户手册。</li></ul></li><li><code>.</code>(period)会完成重复性的工作。</li><li>vim命令的补全功能，例如输入<code>:e</code>, 然后按下<code>^D</code>键, Vim会显示以e开始的命令的列表, 接着按下<code>&lt;tab&gt;键</code>会自动自动补全命令。</li><li><code>q:</code> | <code>q?</code>查看vim中的历史命令</li><li>从vim8.0版本开始安装插件只需要将插件<code>git clone</code>到<code>~/.vim/pack/vendor/start/</code>文件里就行。</li></ol><h2 id="exercise3"><strong>Exercise3</strong></h2><ol type="1"><li><code>vimtutor</code></li><li><ul><li>创建文件<code>~/.vimrc</code>能够获得更多的特性。了解更多信息可以输入<code>:help vimrc-intro</code></li><li>文件中注释使用<code>"</code></li><li><code>set nocompatible</code>从默认的<code>Vi</code>兼容模式切换到激活<code>Vim</code>的功能。如果<code>vimrc</code>文件存在它就会默认设置<code>nocompatible</code>, 包含这一条语句是为了以防以一些别的方式加载配置文件。</li><li><code>syntax on</code>打开语法高亮</li><li><code>set shortmess+=I</code>禁止Vim默认的启动信息<code>:intro</code>，也就是解释vim的版本，以及该如何使用。</li><li><code>set number</code>在vim中显示行数</li><li><code>set relativenumber</code>显示与当前行的行号和与其相对的行号，其实<code>set number</code>也可以不用加了</li><li><code>set laststatus=2</code>在vim底部显示当前状态。<code>2</code>表示不管存在几个窗口总是显示状态栏。</li><li><code>set backspace=indent,eol,start</code>。设置backspace的属性，感觉好像vim兼容了对默认情况，经过测试这一行语句似乎没有什么实质性的作用。</li><li><code>set hidden</code>可以告诉Vim你拥有未显示在屏幕上未保存的工作, 多一条提示信息。</li><li><code>set ignorecase</code>不区分大小写</li><li><code>set smartcase</code>只能在<code>ignorecase</code>，它会使得区分大小写更智能。</li><li><code>incsearch</code>使用<code>/</code>搜索时会实时搜索，而不是等到Enter键按下时才进行搜索。</li><li><code>nmap Q &lt;Nop&gt;</code>对按键Q的解绑操作，按键Q会进入Ex mode, <code>&lt;Nop&gt;</code>意为无操作, 且<code>nmap</code>和<code>nnoremap</code>是等价的。<code>nmap</code>是在Normal模式下使用，详情可见<code>:h map-modes</code>。</li><li><code>set noerrorbells visualbell t_vb=</code>, disable Vim的bell beeping。</li><li><code>set mouse+=a</code>鼠标支持, 方便进入可视化选择。<code>a</code>表示all previous modes。应用在vim中的所有五个模式。</li><li><code>nmap &lt;Left&gt; :echoe "Use h"&lt;CR&gt;</code>来使用户养成在Normal模式下使用h来左移的习惯。</li><li><code>imap &lt;Left&gt; &lt;ESC&gt;:echoe "Use h"&lt;CR&gt;</code>来使用户养成在Insert模式下使用h来左移的习惯，若在Insert模式下使用方向键Left，则回到Normal模式并提示信息"Use h"。因为Vim中的命令行换行是以<code>CR</code>来结尾的(也就是敲完命令需要敲回车换行)才能执行该echo命令回显信息, <code>echoe</code>回显的是错误信息，会加上红色高亮。</li></ul></li><li>如果创建多级目录的路径不存在则自动创建<code>mkdir -p</code>使用参数<code>p</code>。安装和配置插件内含帮助文档<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md">ctrlp.vim</a><ul><li><code>^P</code>打开模糊搜索</li><li><code>c-d</code>切换搜索路径和文件的模式</li><li><code>c-t</code>打开该文件作为新的tab; <code>c-v</code>打开该文件分割列; <code>c-x</code>打开该文件分割行; 个人认为这些tmux都可以替代。</li><li><code>c-n</code>和<code>c-p</code>选择next/previous在ctrlp中的搜索记录</li><li>在ctrlp中输入<code>:help ctrlp-mappings</code>查看更多映射的帮助</li><li>查找到文件后加<code>:25</code>即可跳到该文件的25行</li></ul></li><li>使用Chrome上的<code>vimium</code>有关Vim的插件。<ul><li><code>j</code>和<code>k</code>上下移动网页, <code>d</code>和<code>u</code>以翻页的形式上下移动网页, <code>h</code>和<code>l</code>左右移动网页</li><li>同样可以像vim一样前缀加上数字，比如<code>4j</code>等。也可以<code>gg</code>跳至网页头和<code>G</code>跳至网页尾</li><li><code>f</code>通过标签打开当前网页超链接到当前的tab上，<code>F</code>则打开到新的tab上。</li><li>当前tab历史的前进<code>L</code>和回退<code>H</code></li><li>在打开的网页tab之间切换，上一个<code>J</code>, 下一个<code>K</code></li><li>关闭当前标签页<code>x</code>, <code>X</code>恢复关闭的tab</li><li>在历史标签中搜索<code>o</code>，<code>ESC</code>退出</li><li>若标签页太多,可以使用<code>T</code>在已有的标签之中搜索，<code>ESC</code>退出</li><li><code>?</code>打开<code>Vimium</code>的帮助文档。</li><li><code>r</code>(Reload)刷新当前网页</li><li><code>yy</code>将当前的URL复制到剪切板，<code>p</code>将剪切板上的URL在当前tab中打开，<code>P</code>则在新的tab中打开</li><li><code>gi</code>将光标焦距到当前网页的第一个输入栏(即搜索栏)</li><li><code>b</code>搜索书签打开到当前tab，<code>B</code>打开到新的tab中</li><li><code>/</code>在当前网页中使用匹配， 搭配<code>n</code>和<code>N</code></li><li><code>t</code>创建新的tab</li><li><code>alt+p</code>，pin和unpin当前tab</li><li><code>alt+m</code>, 静音和解除静音当前tab</li></ul></li><li>(待做)<code>XML</code>转<code>JSON</code> , <code>:wq</code>等价于<code>:x</code> ## <strong>VIDEO 4</strong> Data Wangling (TODO)</li><li>正则表达式通常以<code>/</code>开始和结束。正则表达式在线调试工具<a href="https://regex101.com/r/qqbZqh/2">regex debugger</a><ul><li><code>.</code>除换行符之外的"任意单个字符"</li><li><code>*</code>匹配前面字符零次或多次</li><li><code>+</code>匹配前面字符一次或多次</li><li><code>[abc]</code>匹配<code>a</code>,<code>b</code>和<code>c</code>中任意一个, 在括号中使用<code>^</code>即为非</li><li><code>(RX1|RX2)</code>任何能够匹配<code>RX1</code>或<code>RX2</code>的结果</li><li><code>^</code>行首</li><li><code>$</code>行尾</li></ul></li><li><code>sed</code>命令<ul><li><code>-E</code>参数支持对正则表达式的拓展</li></ul></li><li><code>uniq</code>命令去除重复行<ul><li><code>-c</code>参数输出过滤后的行数</li></ul></li><li><code>sort</code>命令按照数字顺序对输入进行排序(默认情况下是按照字序列排序)<ul><li><code>-r</code>参数进行倒序排序</li><li><code>-n</code>参数表示仅排序到第<code>n</code>个部分</li></ul></li><li><code>awk</code>编辑器, <code>awk</code>其实是一种编程语言具体可以查看<code>man awk</code>和<code>tldr awk</code></li><li>学习一下<a href="https://regexone.com/lesson/introduction_abcs">交互式正则表达式教程</a></li></ol><h2 id="video-6-version-controlgit"><strong>VIDEO 6</strong> Version Control(Git)</h2><ol type="1"><li>Git中的对象可以是blob(数据对象)、Tree或Commit</li><li>所有的snapshot都可以用<a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1哈希</a>(40位的十六进制字符)来标记，但显然<code>Reference</code>更方便。</li><li><code>HEAD</code>引用可以通过两种方式查看, <code>cat .git/HEAD</code>; <code>git symbolic-ref HEAD</code>。</li><li><strong>基础</strong><ul><li><code>git help &lt;command&gt;</code>:获取git命令的帮助信息</li><li><code>git init</code>:创建一个新的git仓库，其数据会存放在一个名为<code>.git</code>的目录下</li><li><code>git status</code>:显示当前仓库的状态</li><li><code>git add &lt;filename&gt;</code>:添加文件到暂存区(staging Area)</li><li><code>git commit</code>:创建一个新的提交; 如何编写<a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>, 为什么要<a href="https://cbea.ms/git-commit/">编写良好的提交信息</a></li><li><code>git</code>的提交信息<ol type="1"><li>用空行将主体与主体分开</li><li>将主题行限制为50个字符</li><li>将主题行大写</li><li>不要以句点结束主题行</li><li>在主题行中使祈使句语句</li><li>将正文包裹在72个字符处</li><li>用正文来解释<code>what</code> <code>why</code> vs. <code>how</code></li></ol></li><li><code>git log</code>:显示日志历史</li><li><code>git log --all --graph --decorate</code>:可视化历史记录(有向无环图)</li><li><code>git diff &lt;filename&gt;</code>:显示与暂存区文件的差异</li><li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>:显示某个文件两个版本之间的差异</li><li><code>git checkout &lt;revision&gt;</code>:更新HEAD和目前的分支</li></ul></li><li><strong>分支和合并</strong><ul><li><code>git branch</code>:显示分支</li><li><code>git branch &lt;name&gt;</code>:创建分支</li><li><code>git checkout -b &lt;name&gt;</code>:创建分支并切换到该分支, 相当于<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li><li><code>git merge &lt;revision&gt;</code>:合并到当前分支</li><li><code>git mergetool</code>:使用工具来处理合并冲突</li><li><code>git rebase &lt;name&gt;</code>:创建更线性的提交历史</li></ul></li><li><strong>远端操作</strong><ul><li><code>git remote</code>:列出远端</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>:添加一个远端</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>:将对象传送至远端并更新远端引用</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>:创建本地和远端分支关联关系</li><li><code>git fetch</code>:从远端获取对象</li><li><code>git pull</code>:相当于<code>git fetch; git merge</code></li><li><code>git clone &lt;url&gt; &lt;name&gt;</code>:从远端下载仓库并命名为name</li></ul></li><li><strong>撤销</strong><ul><li><code>git commit --amend</code>:编辑提交的内容或信息</li><li><code>git reset HEAD &lt;file&gt;</code>:恢复暂存的文件</li><li>`git checkout -- <file>:丢弃修改</file></li></ul></li><li><strong>Git高级操作</strong><ul><li><code>git config</code>:Git是一个<a href="https://git-scm.com/docs/git-config">高度可定制</a>的工具</li><li><code>git clone --depth=1</code>:浅克隆(shallow clone), 不包括完整的版本历史信息</li><li><code>git add -p</code>:交互式暂存</li><li><code>git blame</code>:查看最后修改某行的人</li><li><code>git stash</code>:暂时移除工作目录下的修改内容</li><li><code>git stash pop</code>:恢复工作目录下的修改内容</li><li><code>git bisect</code>:通过二分查找搜索历史记录</li><li><code>.gitignore</code>:<a href="https://git-scm.com/docs/gitignore">指定</a>故意不追踪的文件</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 6.NULL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile Note</title>
      <link href="/2022/05/16/Makefile-Note/"/>
      <url>/2022/05/16/Makefile-Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux工程构建必备工具</p></blockquote><span id="more"></span><p>参考<a href="https://seisman.github.io/how-to-write-makefile/introduction.html">跟我一起写Makefile</a>做点笔记。 - 第一个<code>target</code>为<code>make</code>的默认目标 - <code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>command</code>所定义的命令就会被执行 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure> - 最开始的实例 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure> - 为了复用可以在<code>Makefile</code>中使用<code>shell</code>的变量 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure> - <code>make</code>会自动推导命令，只要<code>Make</code>看到一个<code>.o</code>文件，它就会自动地把<code>.c</code>文件加在依赖关系中。并且command <code>cc -c xxx.c</code>也会被自动推导出来 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></p><ul><li>更稳健的<code>clean</code>写法: <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean <span class="comment"># `.PHONY`表示`clean`是个伪目标文件</span></span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></li><li><code>Makefile</code>中主要包含的五部分:<ul><li>显示规则, 显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</li><li>隐晦规则, 由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。</li><li>变量的定义</li><li>文件指示, 即<code>Makefile</code>可以使用<code>include</code>将其他makefile包含进来。<code>filename</code>可以用一个或多个空格隔开。如: <code>include foo.make a.mk b.mk c.mk e.mk f.mk</code>。</li><li>注释，和shell一样使用<code>#</code>。</li></ul></li><li><code>make</code>命令开始时，会寻找<code>include</code>所指出的其它<code>Makefile</code>，并把其内容安置在当前的位置。如果还没找到则在当前目录找。如果还是没找到则在以下几个目录找:<ul><li>make命令开始时，会找寻 include 所指出的其它Makefile，并把其内容安置在当前的位置</li><li>如果目录 <prefix>/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。</prefix></li></ul>如果还没找到则会生成警告信息，随后报错。可以在前面加个减号<code>-include &lt;filename&gt;</code>来告诉make无论出现什么错误，都不要报错，继续执行。</li><li>GNU的make工作时的执行步骤:<ol type="1"><li>读入所有的Makefile。</li><li>读入被include的其它Makefile。</li><li>初始化文件中的变量。</li><li>推导隐晦规则，并分析所有规则。</li><li>为所有的目标文件创建依赖关系链。</li><li>根据依赖关系，决定哪些目标要重新生成。</li><li>执行生成命令。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim+vscode+tmux+gdb</title>
      <link href="/2022/05/16/vim-vscode-tmux-gdb/"/>
      <url>/2022/05/16/vim-vscode-tmux-gdb/</url>
      
        <content type="html"><![CDATA[<!-- # vim+vscode+tmux+gdb+git --><blockquote><p>个人的一些认为比较常用以及不经常用到的的快捷操作</p></blockquote><span id="more"></span><h2 id="vscode"><strong>vscode</strong></h2><ol type="1"><li>查找文件ctrl+p， esc退出</li><li>分割屏幕ctrl+，通过ctrl+1/2/3来切换分割屏幕的焦点</li><li>ctrl+` 打开/关闭终端</li><li>ctrl+tab, 在tab之间切换</li><li>模糊查找当前工作目录下的所有文件ctrl+p, #</li><li>Ctrl + Shift + Tab 导航tab</li><li>alt + &lt;-/-&gt;切换tab</li></ol><h2 id="vim"><strong>vim</strong></h2><ol type="1"><li>跳转到指定行号n, ngg</li><li>复制整行 yy, 复制包括当前行接下来n行， nyy</li><li>复制指定行v模式下指定复制内容，然后y键复制。</li><li>粘贴 如复制内容不是一整行：p粘贴到当前光标处，P粘贴到当前行首。 如复制内容是一整行：p粘贴到当前行的下一行，P粘贴到当前行的上一行</li><li>剪切dd</li><li>在当前文件查找指定内容，/+内容</li><li>ctrl+] 跳转到函数的定义处，ctrl+t返回上一次光标处</li><li>u撤销，ctrl+r恢复</li><li><code>^y</code>向上移动一行, <code>^e</code>向下移动一行</li><li><code>^b</code>向上移动一页，<code>^f</code>向下移动一页</li><li>number + shift + G, 跳到第number行</li><li>在<code>tab</code>之间切换, <code>Alt</code>+<code>number</code>.</li><li>可视条件下选中后<code>&lt;</code>或<code>&gt;</code>完成缩进。</li><li>要想跳转到函数定义处，需要在项目目录中输入<code>ctags -R</code>命令。<code>ctrl+]</code>跳转, <code>ctrl+o</code>返回。</li><li>可视模式下注释+<code>d</code>。</li><li>替换变量名<code>:%s/foo/bar/g</code>将整个文件中的<code>foo</code>替换为<code>bar</code></li><li>在vim文件内使用shell命令<code>:! command</code></li><li>在当前文件中打开另一个文件<code>:e file</code></li><li>在Vim中编译代码<code>:!gcc %</code>, 编译并运行代码<code>:!gcc % || ./a.out</code></li></ol><h2 id="tmux"><strong>tmux</strong></h2><ol type="1"><li>任何命令都需要加ctrl+b前缀</li><li>c创建窗口；n, p切换窗口</li><li>%垂直分屏, "水平分屏</li><li>x关闭窗口</li><li>o在窗口之间切换</li><li>PgUp开启tmux终端界面的翻页，q退出。</li></ol><h2 id="gdb"><strong>gdb</strong></h2><ol type="1"><li>delete 删除所有断点</li><li>layout src/reg/asm 显示c源代码、寄存器和汇编，但未分屏；focus src/reg/asm在src、reg和asm的tui中来回切换</li><li>layout split获得c和asm的分屏。</li><li>info/i frame 查看栈帧, info/i args查看传递给main的参数, i locals显示当前的本地变量。</li><li>通过backtrace查看栈帧，frame n(n为bt结果的栈帧号)，然后i frame查看当前栈帧号的详细内容</li><li>print/p查看argv数据;print/p <em>argv(默认打印一个参数);可以通过print/p </em>argv@n 来选择argv数组中的n个元素即参数; p *argv@argc打印所有参数</li><li><code>print</code>是打印值，<code>x</code>是访问主存。</li><li><code>Ctrl + x</code>，再按1：单窗口模式，显示一个窗口</li><li><code>Ctrl + x</code>，再按2：双窗口模式，显示两个窗口</li><li><code>Ctrl + x</code>，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。</li><li><code>^x+a</code>关闭可视化</li><li><code>wa</code>跟踪某个变量(watch point)</li></ol><h2 id="gdb续"><strong>&lt;<Debug hacks>&gt;(gdb续)</Debug></strong></h2><ol type="1"><li><code>break/b</code><ul><li><code>break 函数名</code></li><li><code>break 行号</code></li><li><code>break 文件名:行号</code></li><li><code>break 文件名:函数名</code></li><li><code>break +偏移量</code></li><li><code>break -偏移量</code></li><li><code>break *地址</code></li><li><code>break 断点 if 条件</code></li><li>若不指定位置就默认在下一行代码上设置断点</li><li><code>info break</code>显示断点信息</li></ul></li><li><code>run/r</code>, 如果不加参数，执行到断点位置后暂停运行(和start命令一样的效果)</li><li><code>print/p</code><ul><li><code>p $eax</code>，显示寄存器(寄存器名前加$)</li></ul></li><li><code>p/格式 变量</code>, 显示寄存器可用的格式:<ul><li>x, 显示为十六进制数</li><li>d, 显示为十进制数</li><li>u, 显示无符号十进制数</li><li>o, 显示八进制数</li><li>t, 显示二进制数(two)</li><li>a, 显示地址</li><li>c, 显示为字符</li><li>f, 浮点小数</li><li>s, 显示为字符串</li><li>i, 显示为机器语言</li></ul></li><li><code>x/NFU ADDR</code>, 显示内存的内容(eXamining):<ul><li><code>N</code>为重复次数</li><li><code>F</code>为上述的P格式</li><li><code>U</code>代表的单位：<ul><li>b, 字节</li><li>h, 半字</li><li>w, 字(4字节默认)</li><li>g, 双字</li></ul></li></ul></li></ol><h2 id="cgdb"><strong>cgdb</strong></h2><ol type="1"><li>使用<code>i</code>切换到<code>GDB command</code>，<code>esc</code>切换到<code>source window</code>。</li><li>在<code>source window</code>下，可以像<code>vim</code>一样用<code>\</code>匹配内容， 且移动到指定行按下<code>space</code>可以可视化打断点。</li><li><code>q</code>或者<code>^c+d</code>退出<code>gdb</code></li><li>调整<code>source window</code>的大小, <code>-</code>缩小一行，<code>=</code>增加一行。</li><li>在<code>source window</code>下<code>^w</code>窗口水平竖直分割切换。</li><li><code>F5</code> = <code>run</code>, <code>F6</code> = <code>continue</code>, <code>F7</code> = <code>finish</code>, <code>F8</code> = <code>next</code>, <code>F10</code> = <code>step</code>。</li><li><code>CGDB</code>的配置, 在<code>~/.cgdb/</code>目录下创建<code>cgdbrc</code>文件并编辑。如果<code>cgdbrc</code>文件存在，<code>CGDB</code>就会执行该文件中的每一行。<ul><li><code>:set disasm</code>，以汇编语言的形式显示。</li><li><code>:set hls</code>，高亮显示匹配到的字符串</li><li><code>:set syn=style</code>设置当前文件对应语法风格的高亮。</li></ul></li></ol><h2 id="git"><strong>git</strong></h2><ul><li><code>git clone -b branch XXX</code>克隆指定分支的代码</li><li><code>git reset --hard 1a703e</code>回滚到某个历史commit</li><li><code>git branch -m &lt;branchName&gt;</code>将当前分支名更改为branchName</li><li><code>git checkout -b &lt;newbranch&gt;</code>创建新分支并切换到新分支</li><li><code>git diff</code>查看修改的差异</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Cpp Note</title>
      <link href="/2022/05/16/cpp%20Note/"/>
      <url>/2022/05/16/cpp%20Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工业级的Cpp语法</p></blockquote><span id="more"></span><h2 id="一stdfunction和bind绑定器">一、std::function和bind绑定器</h2><h3 id="可调用对象">可调用对象</h3><ul><li>是一个函数指针</li><li>是一个具有<code>operator()</code>成员函数的类对象（仿函数）</li><li>是一个可被转换为函数指针的类对象</li><li>是一个类成员（函数）指针</li></ul><h3 id="可调用对象包装器stdfuntion">可调用对象包装器std::funtion</h3><ul><li>头文件<code>&lt;functional&gt;</code></li><li>可以容纳除了类成员（函数）指针之外的所有可调用对象</li><li>可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们</li><li><code>function</code>比普通函数指针更灵活和便利</li></ul><h3 id="stdbind绑定器">std::bind绑定器</h3><ul><li>头文件<code>&lt;functional&gt;</code></li><li>接受一个可调用对象，生成一个新的可调用对象</li><li><code>std::bind</code>用来将可调用对象与其参数一起进行绑定，绑定后的结果可以使用<code>std::function</code>进行保存，并延迟调用到任何我们需要的时候</li><li>作用<ul><li>将可调用对象与其参数一起绑定成一个仿函数(functor)</li><li>将多元（参数个数为n）可调用对象转成一元或者（n-1）元可调用对象，却只绑定部分参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();  <span class="comment">// 输出：1 2</span></span><br><span class="line">std::<span class="built_in">bind</span>(output, std::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);  <span class="comment">// 输出 ：1 2</span></span><br><span class="line">std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_1)(<span class="number">1</span>);  <span class="comment">// 输出 ：2 1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><code>std::bind</code>的返回类型是一个stl内部定义的仿函数类型</li><li><code>std::placeholders::_1</code>是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代</li><li>组合bind函数<ul><li><code>std::bind(std::greater&lt;int&gt;(), std::placeholders::_1, 5);</code><ul><li>判断是否大于5的功能闭包</li></ul></li></ul></li></ul><h3 id="c11通过提供stdfunction和stdbind统一了可调用对象的各种操作">C++11通过提供std::function和std::bind统一了可调用对象的各种操作</h3><h2 id="二lambda表达式">二、lambda表达式</h2><h3 id="语法形式">语法形式</h3><ul><li><code>[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</code></li><li>C++11允许省略lambda表达式返回值定义，这样编译器就会根据<code>return</code>语句自动推导出返回类型<ul><li>初始化列表不能用于返回值的自动推导</li></ul></li><li>lambda表达式在没有参数列表时，参数列表是可以省略的</li></ul><h3 id="捕获列表">捕获列表</h3><ul><li><code>[]</code>不捕获任何变量</li><li><code>[&amp;]</code>捕获外部作用域中所有变量，并作为引用在函数体中使用（引用捕获）</li><li><code>[=]</code>捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）</li><li><code>[=, &amp;foo]</code>按值捕获外部作用域中所有变量，并按引用捕获foo变量</li><li><code>[bar]</code>按值捕获bar变量，同时不捕获其他变量</li><li><code>[this]</code>捕获当前类中的指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了<code>&amp;</code>或者<code>=</code>，就默认添加此选项</li><li>如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为<code>mutable</code>，如：<code>auto f2 = [=]() mutable &#123;return a++; &#125;</code></li></ul><h3 id="可以认为它是个带有operator的类即仿函数">可以认为它是个带有operator()的类，即仿函数</h3><ul><li>可以使用<code>std::function</code>和<code>std::bind</code>来存储和操作lambda表达式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f1 = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">void</span>)&gt; f2 = std::<span class="built_in">bind</span>([](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;, <span class="number">123</span>);</span><br></pre></td></tr></table></figure></li><li>对于没有捕获任何变量的lambda表达式，还可以被转换成一个普通的函数指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">int</span> (*)(<span class="type">int</span>);</span><br><span class="line"><span class="type">func_t</span> f = [](<span class="type">int</span>  a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></li><li>捕获变量的lambda表达式则不能转化为普通指针，若转换，lambda表达式本身的this指针就丢失掉了</li><li>lambda和<code>std::function</code>的效果是一样的，一般情况下可直接用lambda来代替<code>function</code></li></ul><h2 id="三tuple元组">三、tuple元组</h2><h3 id="定义">定义</h3><ul><li>可以把它当作一个通用的结构体来用，不需要创建结构体又获取结构体的特征</li><li>在某些情况下可以取代结构体，使程序更简洁、直观</li><li>如果用tuple来替代3个以上字段的结构体时就不太合适了，不直观，易读性降低（建议）</li></ul><h3 id="功能">功能</h3><ul><li>创建元组<ul><li><code>tuple&lt;const char*, int&gt; tp = make_tuple(sendPack, nSendSize);</code></li><li><code>auto tp = return std::tie(1, "aa", 2);</code> // tp的实际类型是：std::tuple&lt;int&amp;, string&amp;, int&amp;&gt;</li></ul></li><li>获取元组的值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* data = tp.<span class="built_in">get</span>&lt;<span class="number">0</span>&gt; ();  <span class="comment">// 获取第一个值</span></span><br><span class="line"><span class="type">int</span> len = tp.<span class="built_in">get</span>&lt;<span class="number">1</span>&gt; ();  <span class="comment">// 获取第二个值</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>std::tie</code>解包tuple <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">string a;</span><br><span class="line">std::<span class="built_in">tie</span>(x, a, y) = tp;</span><br></pre></td></tr></table></figure><ul><li>如果只想了解某个位置的值时，可以用<code>std::ignore</code>占位符来表示不解某个位置的值 <code>std::tie(std::ignore, std::ignore, y) = tp;</code> // 只解第3个值</li></ul></li></ul></li><li>创建右值引用元组<ul><li><code>forward_as_tuple</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">m.<span class="built_in">emplace</span>(std::forward_as_tuple(<span class="number">10</span>, std::<span class="built_in">string</span>(<span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>)));</span><br></pre></td></tr></table></figure><ul><li>创建了类似于<code>std::tuple&lt;int&amp;&amp;, std::string&amp;&amp;&gt;</code>类型的tuple</li></ul></li></ul></li><li>连接多个tuple<ul><li><code>tuple_cat</code></li></ul></li></ul><h2 id="四shared_ptr共享的智能指针">四、shared_ptr共享的智能指针</h2><h3 id="概念">概念</h3><ul><li>希望多个智能指针管理同一个资源就用shared_ptr</li><li><code>std::shared_ptr</code>使用引用计数，每一个shared_ptr的拷贝都指向相同的内存</li><li>在最后一个shared_ptr析构的时候，内存才会被释放</li></ul><h3 id="基本用法">基本用法</h3><ul><li>初始化<ul><li>可以通过使用构造函数、<code>std::make_shared&lt;int&gt;</code>辅助函数和<code>reset</code>方法来初始化shared_ptr <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;  <span class="comment">// 使用动态初始化，后加一个括号为值初始化</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr;</span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li>不能将一个原始指针直接赋值给智能指针</li><li>当智能指针中有值的时候，调用reset会使引用计数减1</li></ul></li><li>获取原始指针<ul><li>可以通过<code>get</code>方法来返回原始指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="type">int</span>* p = ptr.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li>指定删除器<ul><li>智能指针初始化可以指定删除器</li><li>当p的<code>引用计数</code>为0时，自动调用删除器DeleteIntPtr来释放对象的内存 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, DeleteIntPtr)</span></span>;</span><br></pre></td></tr></table></figure></li><li>也可以用lambda表达式指定删除器<ul><li><code>std::shared_ptr&lt;int&gt; p(new int, [](int* p) &#123; delete p; &#125;);</code></li></ul></li><li>当我们用<code>shared_ptr</code>管理动态数组时，需要指定删除器，因为<code>std::shared_ptr</code>的默认删除器不支持数组对象</li><li>也可以将<code>std::default_delete</code>作为删除器</li></ul></li></ul><h3 id="注意事项">注意事项</h3><ul><li>1）不要用一个原始指针初始化多个shared_ptr</li><li>2）不要在函数实参中创建shared_ptr<ul><li>可能会因为发生异常而泄露内存</li></ul></li><li>3）通过<code>shared_from_this()</code>返回this指针<ul><li>因为this指针本质上是一个<code>裸指针</code>，因此这样可能会导致重复析构</li><li>解决方法<ul><li>让目标类通过派生<code>std::enable_shared_from_this&lt;T&gt;</code>类，然后使用基类的成员函数<code>shared_from_this</code>来返回this的shared_ptr</li></ul></li></ul></li><li>4）要避免循环引用<ul><li>智能指针最大的一个陷阱就是循环引用，循环引用会导致内存泄露</li><li>导致意外延长对象的生命期</li><li>解决方法<ul><li>使用weak_ptr</li></ul></li></ul></li></ul><h2 id="五unique_ptr独占的智能指针">五、unique_ptr独占的智能指针</h2><h3 id="概念-1">概念</h3><ul><li>希望只有一个智能指针管理资源或者管理数组就用unique_ptr</li><li>unique_ptr是一个独占型的智能指针</li><li>它不允许其他的智能指针共享其内部的指针</li><li>不允许通过赋值将一个unique_ptr赋值给另外一个unique_ptr</li><li>可以通过<code>std::move</code>来转移到其他的unique_ptr <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br><span class="line">unique_ptr&lt;T&gt; myOtherPtr = std:: <span class="built_in">move</span>(myptr);</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项-1">注意事项</h3><ul><li>如果是数组，则判断是否是定长数组<ul><li>若为定长数组则编译不通过（不能这样调用<code>make_unique&lt;T[10]&gt;(10)</code>)</li><li>若为非定长数组，则获取数组中的元素类型，再根据参数size创建动态数组的unique_ptr<ul><li><code>unique_ptr&lt;int[]&gt; ptr5 = make_unique&lt;int[]&gt;(10);</code></li></ul></li></ul></li><li>unique_ptr可以指向数组（而shared_ptr这么做不合法） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span> []&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function">ptr[9] </span>= <span class="number">9</span>;         <span class="comment">// 设置最后一个元素值为9</span></span><br></pre></td></tr></table></figure></li><li>unique_ptr指定删除器的时候需要确定删除器的类型<ul><li><code>std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int (1), [](int* p) &#123; delete p; &#125;);</code></li><li>lambda表达式在没有捕获变量的情况下是可以直接转换为函数指针的，一旦捕获了就无法转换了<ul><li><code>std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int (1), [&amp;](int* p) &#123; delete p; &#125;);</code> // 错误，捕获了变量</li></ul></li><li>如果希望unique_ptr删除器支持lambda可以这么写<ul><li><code>std::unique_ptr&lt;int, std::function&lt;void(int*)&gt;&gt; ptr(new int(1), [&amp;](int* p) &#123; delete p; &#125;</code></li></ul></li></ul></li></ul><h2 id="六weak_ptr弱引用的智能指针">六、weak_ptr弱引用的智能指针</h2><h3 id="概念-2">概念</h3><ul><li>weak_ptr是用来监视shared_ptr的，不会使引用计数加1</li><li>它不管理shared_ptr内部的指针，主要是为了监视shared_ptr的生命周期</li><li>它的构造不会增加引用计数，它的析构也不会减少引用计数</li></ul><h3 id="基本用法-1">基本用法</h3><ul><li>1）通过<code>use_count()</code>方法来获得当前观测资源的引用计数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 结果将输出1</span></span><br></pre></td></tr></table></figure></li><li>2）通过<code>expired()</code>方法来判断所观测的资源是否已经释放（true为无效） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wp.<span class="built_in">expired</span>())</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weak_ptr无效，所监视的智能指针已经被释放&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weak_ptr有效&quot;</span>;</span><br></pre></td></tr></table></figure></li><li>3）通过<code>lock()</code>方法来获取所监视的shared_ptr <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; gw = sp;</span><br><span class="line"><span class="keyword">auto</span> spt = gw.<span class="built_in">lock</span>();  <span class="comment">// 获取所监视的shared_ptr</span></span><br><span class="line">cout &lt;&lt; *spt &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul><h3 id="weak_ptr返回this指针">weak_ptr返回this指针</h3><ul><li><code>std::enable_shared_from_this</code>类中有一个weak_ptr，这个weak_ptr用来观测this智能指针</li><li>调用<code>shared_from_this()</code>方法时，会调用内部这个weak_ptr的<code>lock()</code>方法，将所观测的shared_ptr返回</li><li>获取自身智能指针的函数仅在<code>shared_ptr&lt;T&gt;</code>的构造函数被调用之后才能使用，因为<code>enable_shared_from_this</code>内部的weak_ptr只有通过shared_ptr才能构造</li></ul><h3 id="可以通过weak_ptr解决循环引用问题">可以通过weak_ptr解决循环引用问题</h3>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 403. 青蛙过河</title>
      <link href="/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
      <url>/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="一题目">一、题目</h1><p>给定石子位置的列表stones（升序），青蛙可以跳上石子，但不能跳入水中。 如果青蛙一步跳跃了k个单位，那么它接下来跳跃的距离只能为k-1、k或k+1个单位。 青蛙只能向前方跳跃。 <span id="more"></span> <strong>输入</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stones = [0,1,3,5,6,8,12,17]</span><br></pre></td></tr></table></figure> <strong>输出</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure> <strong>解释</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">青蛙可以成功过河，按照如下方案跳跃：</span><br><span class="line">跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, </span><br><span class="line">然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure> # 二、解法 思路：本题为二维动态规划，使用动态规划的方法，令<code>dp[i][k]</code>为跳跃k个单位能否到达第i个石子，初始化<code>dp[0][0] = true;</code>，得出状态转移方程<code>dp[i][k] = dp[j][k-1] | dp[j][k] | dp[j][k+1];</code>，其中j为上一次所在石子的编号。 ### 2.1 动态规划 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;  <span class="comment">// 优化：跳跃距离k必定满足k &lt;= i（可推），此时为青蛙无路可跳</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;  <span class="comment">// 反向枚举</span></span><br><span class="line">                <span class="type">int</span> k = stones[i] - stones[j];  <span class="comment">// 跳跃的距离k，j为上一次所在石子的编号</span></span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;  <span class="comment">// 在第j个石子上至多跳跃j+1的单位</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 复杂度分析 - <strong>时间复杂度</strong>：O(n<sup>2</sup>)，n为石子的个数，第i个石子后方只有i-1个石子，因此在任意位置，青蛙的上一次跳跃距离至多只有n种，状态总数为 n<sup>2</sup> - <strong>空间复杂度</strong>：O(n<sup>2</sup>)，需要二维动态数组的空间，其中n是石子的数量</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP Note</title>
      <link href="/2021/04/28/tcp%20note/"/>
      <url>/2021/04/28/tcp%20note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《TCP/IP详解》读书笔记 <span id="more"></span></p></blockquote><h2 id="一tcp超时与重传">一、TCP超时与重传</h2><h3 id="引言">引言</h3><ul><li>计时器超时称为重传超时（RTO）</li><li>若TCP累计确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文段时，快速重传会推断出现丢包</li><li>由下层网络（IP）可能出现丢失重复或失序包，TCP重传其认为已经丢失的包</li></ul><h3 id="简单的超时与重传举例">简单的超时与重传举例</h3><ul><li>二进制指数退避<ul><li>每次重传间隔时间加倍</li></ul></li><li>TCP拥有两个阈值来决定如何重传同一个报文段<ul><li>R1表示TCP在向IP层传递“消极建议”（如重新评估当前路径）前，愿意尝试重传的次数</li><li>R2（大于R1）指示TCP应放弃当前连接的时机</li></ul></li></ul><h3 id="设置重传超时">设置重传超时</h3><ul><li>TCP超时和重传的基础根据给定连接的RTT（往返时间）设置RTO<ul><li>若TCP先于RTT开始重传，可能会在网络中引入不必要的重复数据</li><li>若延迟远大于RTT的间隔发送重传数据，整体网络利用率（及单个连接吞吐量）会随之下降</li></ul></li><li>RTO设置得当是保证TCP性能的关键</li><li>当分组失序（或丢失）时，RTT会被过高估算。较大的RTT估计值使得RTO也更大</li><li>时间戳选项（TSOPT）使得发送端即使在丢包、延时、失序的情况下也能测量RTT</li></ul><h3 id="基于计时器的重传">基于计时器的重传</h3><ul><li>对于TCP来说，计时器需要有效地实现被设置、重新设置或取消的功能</li><li>RTO的设置通常大于RTT（两倍或更大）<ul><li>因此基于计时器的重传会导致网络利用率的下降</li></ul></li><li>快速重传不需要计时器超时来触发且比超时重传更高效</li></ul><h3 id="快速重传">快速重传</h3><ul><li>快速重传机制基于接收端的反馈信息来引发重传</li><li>快速重传是根据收到重复ACK来推断出现丢包并启动重传，而不必等待重传计时器超时</li><li>快读重传仅在达到重复阈值后才被触发，而不是一旦收到重复ACK就出发，减少了大量不必要的重传发生</li></ul><h3 id="带选择确认sack的重传">带选择确认（SACK）的重传</h3><ul><li>空缺<ul><li>ACK号与接收端缓存中的其他数据之间的间隔</li></ul></li><li>失序数据<ul><li>序列号高于空缺的数据</li></ul></li><li>在很多情况下，合理采用SACK信息能更快地实现空缺填补，且能减少不必要的重传</li><li>SACK接收端行为<ul><li>SACK选项的空间有限，应尽可能确保向TCP发送端提供最新信息，其余的SACK块包含的内容也按照接收的先后依次排序</li></ul></li><li>SACK发送端行为<ul><li>SACK发送端记录接收到的累计ACK信息，还需要记录接收到的SACK信息</li><li>当SACK发送端执行重传时，通常是由于其收到了SACK或重复SACK（D-SACK）</li></ul></li><li>为提高对ACK丢失的鲁棒性，第一个SACK块中需要包含之前的重复SACK信息</li></ul><h3 id="伪超时与重传">伪超时与重传</h3><ul><li>伪重传<ul><li>即使没有出现数据丢失也可能引发的重传</li><li>主要原因是伪超时</li></ul></li><li>DSACK<ul><li>主要目的是判断何时重传是不必要的</li><li>因此发送端至少可以判断是否发生了包失序、ACK丢失、包重复</li></ul></li></ul><h3 id="包失序与重复">包失序与重复</h3><ul><li>失序<ul><li>IP层不能保证包传输是有序进行的</li><li>如果失序发生在正向链路上，TCP可能无法正确识别失序和丢包</li></ul></li><li>重复<ul><li>采用DSACK避免</li></ul></li></ul><h3 id="重新组包">重新组包</h3><ul><li>定义：发送一个更大的报文段来提高性能（不能超过接收端通告的MSS，也不能大于路径MTU）</li><li>当TCP超时重传，它并不需要完全重传相同的报文段</li><li>解决了重传二义性问题</li></ul><h2 id="二tcp数据流与窗口管理">二、TCP数据流与窗口管理</h2><h3 id="交互式通信">交互式通信</h3><ul><li>TCP流量中通常90%或者更多的TCP报文段都包含大批量数据（如Web、文件共享、电子邮件、备份），其余部分则包含交互式数据（如远程登陆、网络游戏），批量数据通常较大，而交互式数据段则会比较小</li><li>对于一个ssh连接，客户端对其传输数据加密，意味着用户输入的信息在通过连接传送前已经进行了加密</li><li>每一个交互按键通常都会生成一个单独的数据包，每个按键是独立传输的（每次一个字符而非每次一行）</li><li>每个输入字符会生成4个TCP数据段：客户端的交互击键输入、服务器对击键的确认、服务器端生成的回显、客户端对该回显的确认<ul><li>通常第二段和第三段可以合并，可将对击键的确认与回显一并传送，这种方法称为（捎带延时确认）</li></ul></li></ul><h3 id="延时确认">延时确认</h3><ul><li>TCP并不对每个到来的数据包都返回ACK<ul><li>利用TCP的累计ACK字段就能实现该功能</li></ul></li><li>捎带传输：<ul><li>累计确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传输的数据结合发送</li></ul></li><li>TCP不能任意时长地延迟ACK，否则对方会误认以为数据丢失而出现不必要的重传</li><li>RFC指出：TCP实现ACK延迟的时延应小于500ms，实践中时延最大取200ms</li></ul><h3 id="nagle算法">Nagle算法</h3><ul><li>当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据），小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送</li><li>ACK返回越快，数据传输越快</li><li>传输包数目更少而长度更大，但同时传输时延也更长</li><li>Nagle算法结合ACK可能会导致某种程度的死锁（这种死锁不是永久的）</li><li>要求延时尽量小的应用，建议禁用Nagle算法<ul><li>TCP_NODELAY选项可以禁用Nagle算法</li></ul></li></ul><h3 id="流量控制与窗口管理">流量控制与窗口管理</h3><ul><li>每一个TCP报文段（除了建立之初的包交换）都包含一个有效的序列号字段、一个ACK号或确认字段以及一个窗口大小字段（包含窗口通告信息）</li><li>窗口通告：表示发送该窗口信息的通信方为即将到来的新数据预留的存储空间</li><li>窗口大小：表明接收端可用缓存空间的大小</li><li>滑动窗口<ul><li>每个TCP活动连接的两端都维护一个发送窗口结构和接收窗口结构</li><li>TCP以字节（而非包）为单位维护其窗口结构</li><li>窗口左右边界的运动<ul><li>1.关闭<ul><li>即窗口左边界右移。当已发送数据得到ACK确认时，窗口会减小</li></ul></li><li>2.打开<ul><li>即窗口右边界右移。使得可发送数据量增大。当已确认数据得到处理，接收端可用缓存变大，窗口也随之变大</li></ul></li><li>3.收缩<ul><li>即窗口右边界左移</li></ul></li></ul></li></ul></li><li>零窗口与TCP持续计时器<ul><li>零窗口：左右边界相等</li><li>当接收端的通告窗口值为0时，可以有效阻止发送端继续发送，直至窗口大小恢复为非零值</li><li>当接收端重新获得可用空间时，会给发送端传输一个”窗口更新“告知其可以继续发送数据<ul><li>该窗口更新通常不包含数据（纯ACK），不能保证其传输的可靠性，容易丢包，造成死锁的发生（发送方等待收到窗口更新告知其可继续发送，接收方等待接收数据）<ul><li>解决方案：发送端会采用一个持续计时器间歇性地查询接收端，看其窗口是否已增长</li></ul></li></ul></li><li>TCP持续计时器会触发”窗口探测“的传输，强制要求接收端返回ACK（其中包含了窗口大小字段）</li><li>窗口探测包含一个字节的数据，采用TCP可靠传输（丢失重传），因此可以避免由窗口更新丢失导致的死锁<ul><li>该一个字节的数据能否被接收，取决于接收端的可用缓存空间大小</li></ul></li><li>当TCP持续计时器超时，就会触发窗口探测的发送</li><li>窗口探测的响应条件：<ul><li>至少为一个MSS</li><li>超过总接收缓存的四分之一</li></ul></li><li>可以采用指数时间退避来计算持续计时器的超时</li></ul></li><li>糊涂窗口综合征（SWS）<ul><li>基于窗口的流量控制机制，尤其是不使用大小固定的报文段情况（如TCP），可能会出现SWS</li><li>当出现该问题时，交换数据段不是全长的而是一些较小的数据段，由于每个报文段中有用数据相对头部信息的比例较小，因此耗费的资源也更多，相应的传输效率也更低</li><li>避免SWS问题<ul><li>1.对于接收端来说，不应通告小的窗口值</li><li>2.对于发送端来说，不应发送小的报文段</li><li>为了避免SWS问题，至少满足以下条件之一时才能传输报文段（发送窗口更新）<ul><li>（a）全长（发送MSS字节）的报文段可以发送</li><li>（b）数据段长度 &gt;= 接收端通告过的最大窗口的一半的，可以发送</li><li>（c）满足以下任一条件的都可以发送：<ul><li>（i）某一ACK不是目前期盼的（即没有未经确认的在传数据）</li><li>（ii）该连接禁用Nagle算法</li></ul></li></ul></li></ul></li><li>TCP需要避免窗口收缩</li><li>优先级：避免窗口收缩 &gt; 避免SWS</li></ul></li><li>大容量缓存与自动调优<ul><li>使用较小接收缓存的TCP应用的吞吐性能更差</li><li>自动调优<ul><li>高效地自动分配缓存大小</li><li>窗口值随着接收数据的增多而增大</li></ul></li></ul></li><li>紧急机制<ul><li>紧急指针字段被设置后，发送端生成的每个TCP头部都包含该字段</li><li>所有序列号大于紧急指针的数据都经接收端确认</li></ul></li></ul><h2 id="三tcp拥塞控制">三、TCP拥塞控制</h2><h3 id="引言-1">引言</h3><ul><li>TCP拥塞控制的难点在于怎样准确地判断何时需要减缓且如何减缓TCP传输，以及何时恢复其原有速度</li><li>当网络中大量的发送方和接收方被要求承担超负荷的通信任务时，可以考虑采取(降低发送速率)或者(最终丢弃部分数据)的方法</li><li>拥塞<ul><li>路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象</li></ul></li></ul><h3 id="tcp拥塞检测">TCP拥塞检测</h3><ul><li>针对丢包情况，TCP采取的首要机制是重传<ul><li>超时重传</li><li>快速重传</li></ul></li><li>丢包被用作判断拥塞发生与否的值标</li><li>在有线网络中，出现在路由器或交换机中的拥塞是造成丢包的主要原因</li><li>在无线网络中，传输和接收错误是导致丢包的重要因素</li></ul><h3 id="减缓tcp发送">减缓TCP发送</h3><ul><li>TCP头部设置的通知窗口大小字段，是TCP发送方调节发送速率的依据</li><li>TCP发送端发送速率 = min{接收速率，传输速率}</li><li>拥塞窗口（cwnd）<ul><li>反映网络传输能力的变量</li></ul></li><li>发送端实际可用窗口W = min{cwnd，通知窗口(awnd)}</li><li>在外数据值<ul><li>已经发出但还未经确认的数据量大小</li><li>当TCP不使用选择确认机制时，W的限制作用体现为发送方发送的报文段序列号不能大于ACK号的最大值与W之和</li><li>当TCP使用选择确认机制时，W用来限制在外数据值</li></ul></li><li>带宽延迟积（BDP）也称作最佳窗口大小<ul><li>若在传输数据值远高于BDP时，会引入不必要的延时</li></ul></li></ul><h3 id="经典算法">经典算法</h3><ul><li>TCP通过与接收端交换一个数据包来获得awnd的值</li><li>获得cwnd最佳值的唯一方法是以越来越快的速率不断发送数据，直到出现数据包丢失（或网络拥塞）为止</li><li>拥塞控制操作是由ACK的接收来驱动或“控制”的</li><li>接收到ACK回复表明发送的数据包已被成功接收，因此可以继续发送操作</li><li>自同步<ul><li>由一个ACK到达（称作ACK时钟）触发一个新数据包传输的关系</li></ul></li><li>在稳定传输状态下，整个系统可“自同步”控制</li></ul><h3 id="慢启动">慢启动</h3><ul><li>当一个新的TCP连接建立或检测到由重传超时（RTO）导致的丢包时，需执行慢启动</li><li>TCP发送端长时间处于空闲状态也可能调用慢启动算法<ul><li>在这种情况下cwnd初始值将被设置为重启窗口（RW），RW = min（IW，cwnd）</li></ul></li><li>慢启动的目的<ul><li>使TCP在用拥塞避免探寻更多可用宽带之前得到cwnd值，以帮助TCP建立ACK时钟</li></ul></li><li>慢启动算法防止短时间内大量数据注入导致拥塞</li><li>TCP以发送一定数目的数据段开始慢启动（在SYN交换之后），称为初始窗口（IW）</li><li>SMSS = min（接收方MSS，MTU）</li><li>慢启动算法会以min（N，SMSS）来增加cwnd值，N是指在未经确认的传输数据中能通过这一”新接收的ACK号大于之前收到的ACK号“确认的字节数</li><li>快速ACK模式<ul><li>TCP操作只在慢启动阶段完成后才返回ACK</li></ul></li></ul><h3 id="拥塞避免">拥塞避免</h3><ul><li>在慢启动阶段，cwnd会快速增长，帮助确立一个慢启动阈值，一旦达到阈值，就意味着可能有更多可用的传输资源。如果立即全部占用这些资源，将会使共享路由器队列的其他连接出现严重的丢包和重传情况，从而导致整个网络性能不稳定</li><li>一旦确立慢启动阈值，TCP会进入拥塞避免阶段</li><li>拥塞避免阶段窗口随时间线性增长，而慢启动阶段呈指数增长<ul><li>cwnd1 = cwnd0+（1/k）*SMSS</li></ul></li></ul><h3 id="慢启动和拥塞避免的选择">慢启动和拥塞避免的选择</h3><ul><li>某个TCP连接总是选择运行慢启动和拥塞避免中的一个，不会出现两者同时运行的情况</li><li>当cwnd&lt;ssthresh，使用慢启动算法</li><li>当cwnd&gt;ssthresh，使用拥塞避免</li><li>当cwnd=ssthresh，任何一种算法都可以使用</li><li>慢启动阈值ssthresh不是固定的，是随时间改变的</li><li>慢启动阈值的主要目的是，在没有丢包发生的情况下，记住上一次”最好的“操作窗口估计值</li><li>ssthresh = max（在外数据值/2，2*SMSS）</li><li>如果出现重传情况，慢启动阈值减小至当前窗口大小的一般（但不小于2*SMSS）</li></ul><h3 id="标准tcp">标准TCP</h3><ul><li>当接收到一个好的ACK（表明新的数据传输成功）cwnd会相应更新<ul><li>cwnd += SMSS 慢启动</li><li>cwnd += SMSS*SMSS/cwnd 拥塞避免</li></ul></li><li>当收到三次重复ACK（或其他表明需要快速重传的信号）时，会执行以下行为<ul><li>1.ssthresh更新为大于等式ssthresh = min（在外数据值/2，2*SMSS）的值</li><li>2.启用快速重传算法，将cwnd设为（ssthresh+3*SMSS）</li><li>3.每接收一个重复ACK，cwnd值暂时增加1 SMSS</li><li>4.当接收到一个好的ACK，将cwnd重设为ssthresh</li></ul></li></ul><h3 id="转发确认fack和速率减半">转发确认（FACK）和速率减半</h3><ul><li>为避免出现等待空闲而又不违背将拥塞窗口减半的做法，提出了转发确认（FACK）策略</li><li>带界定参数的速率减半（RHBP）<ul><li>基本操作：在一个RTT时间内，每接收两个重复ACK，TCP发送方可发送一个新的数据包</li><li>RHBP中区分了调整间隔（cwnd的修正阶段）和恢复间隔（数据重传阶段）</li></ul></li><li>速率减半是调节发送操作或避免集中发送的方法</li></ul><h3 id="限制传输">限制传输</h3><ul><li>TCP发送方每接收两个连续的重复ACK，就能发送一个新数据包</li><li>TCP因此可以避免长时间等待RTO而导致吞吐性能下降</li><li>速率减半也是限制传输的一种形式 ### 拥塞窗口校验（CWV）</li><li>在发送长时间暂停的情况下，由ssthresh维护cwnd保存的”记忆"，之后cwnd值会衰减。</li><li>需要区分空闲发送端和应用受限发送端</li><li>CWV算法原理：当需要发送新数据时，首先看距离上次发送操作是否超过一个RTO，如果超过则<ul><li>更新ssthresh值，设为max（ssthresh，（3/4）*cwnd）</li><li>每经一个空闲RTT时间，cwnd值就减半，但不小于1 SMSS</li><li>对应用受限阶段<ul><li>已使用的窗口大小为W_used</li><li>更新ssthresh的值，设为max（ssthresh，（3/4）*cwnd）</li><li>cwnd设置为cwnd和W_used的平均值</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C# Note</title>
      <link href="/2021/04/28/c#%20Note/"/>
      <url>/2021/04/28/c#%20Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>初衷是Unity</p></blockquote><span id="more"></span><h2 id="新特性">新特性</h2><ul><li>表达式主体方法<ul><li>=&gt;操作符引用构成方法主体的表达式，而且没有return语句。表达式的值自动作为返回值；如果表达式不返回值，则方法自动为void方法 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResult</span>(<span class="params"><span class="built_in">int</span> answer</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>差值表达式<ul><li>$符号表明这是个差值字符串，{和}之间的任何表达式都需求值并置换，字符串差值比+操作符高效得多 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="变量">变量</h2><ul><li>只有<code>float</code>和<code>double</code>除以0得到<code>Infinity</code>（不会出错）</li><li><code>int</code>的最大最小值<code>int.MaxValue</code>和<code>int.MinValue</code></li><li>隐式类型变量<code>var</code>,作用类似于C++的<code>auto</code></li></ul><h2 id="逻辑">逻辑</h2><ul><li>与C++不一致 -<code>if</code>语句中表达式必须是布尔值, 如：<code>if (1)</code> // 错误</li><li><code>switch</code>语句的控制表达式不能用<code>float</code>和<code>double</code>类型</li><li><code>case</code>标签必须是常量表达式，且必须唯一</li><li>C#语句的直通规则<ul><li>直通，标签之间不能有额外语句（即不加<code>break</code>，不允许拥有语句）</li><li>每个<code>case</code>都加上<code>break</code></li></ul></li></ul><h2 id="方法">方法</h2><ul><li>C#所有方法都必须在类的内部声明</li><li>默认参数中如果参数匹配则不会出现歧义</li><li>默认参数（可选参数）必须放在后面</li><li>具名参数<ul><li><code>optMethod(first: 99, third: "Word");</code> // 传递具名参数（参数名:传递的值），实参可以按任意顺序传递，second参数使用<code>默认值</code></li></ul></li></ul><h2 id="结构结构体">结构（结构体）</h2><ul><li>与C++不一致，结构主体后不加<code>;</code></li><li>值类型<ul><li>对于简单的、比较小的数据值，复制值的效率等同于或基本等同于复制地址的效率，但较复杂的数据就考虑使用类，这样就可选择只复制数据的地址，从而提高代码的执行效率</li></ul></li><li>不能为结构声明默认构造器（无参构造器），否则无法编译，因为编译器始终会自动生成默认构造器（不同于类）</li><li>类的实例字段可在声明时初始化，但结构不允许 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> hours = <span class="number">0</span>;  <span class="comment">// 编译时错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译器不会自动初始化结构中的字段（与类不一致）</li><li>复制结构变量的前提时<code>=</code>操作符右侧的结构变量已完全初始化，否则编译错误</li></ul><h2 id="枚举">枚举</h2><ul><li>与C++不一致，枚举主体后不加<code>;</code></li><li>值类型</li><li>声明枚举时字面值默认是int类型，可以选择枚举的基础类型<ul><li><code>enum Season : short &#123; Spring, Summer &#125;</code></li></ul></li><li>为枚举的字面值显式指定常量整数值<ul><li><code>enum Season &#123; Spring = 1, Summer &#125;</code></li></ul></li><li>编译器自动为它指定比前一个枚举字面值大1的值</li><li>多个枚举字面值可以具有相同的基础值<ul><li><code>enum Season &#123; Spring, Summer, Fall, Autumn = Fall &#125;</code></li></ul></li><li>每个枚举定义的字面值名称都只有这个枚举类型的作用域，因此要加枚举类型限定，否则编译错误，如：Season.Fall</li></ul><h2 id="类">类</h2><ul><li><p>与c++不一致，类主体、结构主体后不加分号</p></li><li><p>每个字段和方法声明都要重复<code>public</code>或<code>private</code>关键字</p></li><li><p>省略控制可访问性，默认为<code>private</code></p></li><li><p>类被拆分到多个文件中之后，要在每个文件中使用<code>partial</code>（分部）关键字定义类的不同部分</p></li><li><p>如果把方法或字段声明为<code>static</code>，就可使用类名调用方法或访问字段，而不用先创建对象</p></li><li><p>静态方法只能访问标记为<code>static</code>的其他方法和字段</p></li><li><p>类外访问类中的<code>static</code>字段要以，类名作为前缀，<code>class.function</code></p></li><li><p>静态方法也称为类方法</p></li><li><p>静态字段称为静态字段或静态变量</p></li><li><p>只有数值类型、字符串类型和枚举类型的字段才能声明为const字段</p></li><li><p>静态类</p><ul><li>只能包含静态成员</li><li><code>public static class Math</code></li></ul></li><li><p>using语句允许将类引入作用域，以便在访问静态成员时省略类名</p><ul><li><code>using static System.Math;</code></li></ul></li><li><p>匿名类</p><ul><li>匿名类就是没有名字的类</li><li>不知道类的名称可以使用隐式类型变量来创建正确类型的对象 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAnonymousObject = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">47</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>值类型</p><ul><li>基元类型</li></ul></li><li><p>引用类型</p><ul><li><code>string</code>在运行时动态分配内存</li><li>声明类变量时，编译器分配一小块内存，其中刚好可以容纳一个地址。以后类实际占用内存块的地址会填充到这里。该地址成为对内存块的引用</li><li>实际占用的内存<ul><li>使用<code>new</code>关键字创建对象时分配的内存</li></ul></li></ul></li><li><p>引用类型的变量包含的是引用，引用本身存储在栈上，但该引用指向堆上的对象</p></li><li><p>类可以提供clone方法来返回自己的新实例，并填充相同数据 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Circle <span class="title">Clone</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Circle clone = <span class="keyword">new</span> Circle();</span><br><span class="line">    clone.radius = <span class="keyword">this</span>.radius;</span><br><span class="line">    <span class="comment">// 返回包含克隆数据的新Circle对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>如果包含任何引用类型的字段，这种引用类型也需要提供Clone方法，否则只是“浅拷贝”，如果提供了Clone方法，能够复制引用的对象，就成为“深拷贝” <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle(<span class="number">42</span>);</span><br><span class="line">Circle copy = <span class="keyword">new</span> Circle(<span class="number">99</span>);</span><br><span class="line">copy = c;</span><br></pre></td></tr></table></figure></p></li><li><p>这时候copy原来的引用被回收了（垃圾回收机制）</p></li></ul></li><li><p>空条件操作符（问号加在变量名称之后） <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(c?.Area());</span><br></pre></td></tr></table></figure></p><ul><li>空条件操作符告诉”运行时“在操作符所应用的变量为null的前提下忽略当前语句</li></ul></li><li><p>可空类型</p><ul><li><code>null</code>本身就是引用，不能把它赋值给值类型</li><li>可将变量声明为可空值类型<ul><li><code>int? i = null;</code></li></ul></li><li>可将恰当值的表达式直接赋给可空变量<ul><li><code>i = j;</code></li></ul></li><li>不可将可空的值赋给普通的值类型变量<ul><li><code>j = i;</code></li></ul></li><li>可空类型的两个属性<ul><li><code>HasValue</code><ul><li>判断可空类型是包含一个值，还是包含null</li></ul></li><li><code>Value</code><ul><li>只读的属性</li><li>读取变量的值，但不能修改</li></ul></li></ul></li></ul></li><li><p>引用传参</p><ul><li><code>ref</code>参数<ul><li>要求实参和形参前都加上<code>ref</code>关键字<ul><li><code>DoWork(ref i)</code>;</li></ul></li><li>要求在传参之前必须初始化</li></ul></li><li><code>out</code>参数<ul><li>要求实参和形参前都加上<code>out</code>关键字</li><li>要求在方法中必须初始化，传参前不要求</li></ul></li></ul></li><li><p><code>object</code>类型</p><ul><li><code>object</code>类型的变量能引用任何引用类型的任何对象</li></ul></li><li><p><code>装箱</code></p><ul><li>将值类型赋给<code>object</code>类型的变量<ul><li><code>object o = 42;</code></li></ul></li><li>数据项从栈自动复制到堆的行为</li><li>与泛型异曲同工</li></ul></li><li><p><code>拆箱</code></p><ul><li>将引用了已装箱的值的object引用强制转换成值类型<ul><li><code>int a = (int)o;</code></li></ul></li><li>必须强制转换</li></ul></li><li><p>装箱和拆箱会产生较大的开销</p><ul><li>它们设计不少检查工作，且需要分配额外的堆内存</li></ul></li><li><p>数据的安全转型</p><ul><li>左操作数为对象，右操作数为类型<ul><li>is操作符<ul><li>if (o is WrappedInt)</li><li>如果is表达式正确，结果为true，反之为false</li></ul></li><li>as操作符<ul><li>WrappedInt temp = o as WrappedInt;</li><li>若转换成功，就返回转换成功的结果，失败则为null</li></ul></li></ul></li></ul></li><li><p>在c#中使用c指针必须将代码标记为<code>unsafe</code></p><ul><li><code>unsafe</code>关键字可标记代码块或整个方法 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">swap</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>命名规范</p></li><li><p>公共标识符以大写字母开头</p></li><li><p>非公共标识符（包括局部变量）以小写字母开头</p></li><li><p>类名以大写字母开头</p></li><li><p>均采用驼峰命名法</p></li><li><p><code>TODO:</code>注释通常用于标注以后将进行加工的代码</p></li></ul><h2 id="异常">异常</h2><ul><li><code>checked</code>语句是<code>checked</code>关键字开头的代码块<ul><li>只有直接在checked块中的整数运算才会检查</li><li>溢出则抛出<code>OverflowException</code></li><li><code>checked</code>和<code>unchecked</code>关键字只适合整型运算</li><li>浮点运算永不抛出异常</li></ul></li><li><code>catch</code>省略名称默认捕获<code>Exception</code><ul><li>异常发生后将运行由”运行时“发现的第一个匹配的异常处理程序<code>catch</code>，其他处理程序会被忽略</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link href="/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一题目">一、题目</h1><p>打印出二叉树中节点值的和为输入整数的所有路径（从根节点一直到叶子节点的路径） <span id="more"></span> <strong>输入</strong>： 给定如下二叉树，以及目标和 target = 22 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure> <strong>输出</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="二解法">二、解法</h1><p>由根节点出发，首先想到先序遍历的思路 ### 2.1 回溯 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">      vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">      <span class="type">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">FindPath</span>(root, target, path, currentSum, ans);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; path, <span class="type">int</span> currentSum, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先序遍历</span></span><br><span class="line">      currentSum += root-&gt;val;  <span class="comment">// 更新当前路径</span></span><br><span class="line">      path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">      <span class="comment">// 如果是叶子节点，并且路径上的节点的和等于输入的值，则打印这条路径</span></span><br><span class="line">      <span class="type">bool</span> isLeaf = root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (currentSum == target &amp;&amp; isLeaf) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若不是叶子节点，则遍历它的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在返回父节点之前，在路径上删除当前节点</span></span><br><span class="line">      path.<span class="built_in">pop_back</span>();  <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 复杂度分析 - <strong>时间复杂度</strong>：O(N)，N为二叉树的节点数，需要遍历所有节点 - <strong>空间复杂度</strong>：O(N)，最差情况下即树退化成链表，path存储所有树节点，使用O(N)额外空间</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 684. 冗余连接</title>
      <link href="/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
      <url>/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一题目">一、题目</h1><p>找出无向图中的冗余连接，即将无向图还原成二叉树 <span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure></p><h1 id="二解法">二、解法</h1><h3 id="并查集">2.1 并查集</h3><p>思路：通过并查集寻找附加的边，初始时每个节点都属于不同的连通分量，遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量 - 如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。 - 如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[index]]); </span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      parent[<span class="built_in">Find</span>(parent, x)] = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析</h3><ul><li>时间复杂度：O(klogk)，其中k是图中的节点个数</li><li>空间复杂度：O(n)</li></ul><h3 id="使用按秩合并路径压缩的并查集">2.2 使用==按秩合并+路径压缩==的并查集</h3><p>优化了空间复杂度 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[parent[index]]);  <span class="comment">// 路径压缩，使树的层数更少</span></span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      <span class="type">int</span> i = <span class="built_in">Find</span>(parent, x), j = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">      <span class="comment">// 按秩合并</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">// 如果i的秩大于j的秩</span></span><br><span class="line">        parent[j] = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[i] = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 复杂度分析 - 时间复杂度：O(klogk) - 空间复杂度：O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql Note</title>
      <link href="/2021/04/28/mysql%20note/"/>
      <url>/2021/04/28/mysql%20note/</url>
      
        <content type="html"><![CDATA[<h2 id="一基本概念">一、基本概念</h2><span id="more"></span><ul><li>表名是唯一的</li><li>表中的数据是按行存储的</li><li>行（别名 记录）</li><li>主键：一列，其值能够区分表中每个行<ul><li>每个行都必须有一个主键值（不允许为NULL）</li><li>任意两行都不具有相同的主键值</li><li>不更新主键列中的值</li><li>不在主键列中使用可能会更改的值</li></ul></li><li>命令用分号；结束</li><li>连接到mysql需要以下信息<ul><li>主机名：本地服务器为localhost</li><li>端口：默认为3036</li><li>一个合法的用户名</li><li>用户口令（如果需要的话）</li></ul></li><li><code>use&lt;数据库名字&gt;</code>来选择数据库</li><li><code>show databases</code>返回可用数据库的一个列表</li><li><code>show tables</code>返回该数据库内的可用表的一个列表</li><li><code>show columns from &lt;表名&gt;</code> = <code>describe &lt;表名&gt;</code>来显示表中的所有列</li><li>自动增量：Mysql可以自动地为每个行分配下一个可用的编号，需要create语句</li><li><code>show status</code>显示广泛的服务器状态信息</li><li><code>show create databases/table</code>分别用来显示创建特定数据库或表的语句</li><li><code>show grants</code>显示授予用户的安全权限</li><li><code>show errors</code>和<code>show warnings</code>显示服务器错误或警告信息</li></ul><h2 id="二select语句">二、SELECT语句</h2><ul><li><code>SELECT &lt;列名&gt; FROM &lt;表名&gt;</code>在表中检索单个列 &gt;SELECT检索多个列，列名用逗号分隔 &gt;检索所有列，用<code>*</code>通配符</li><li>sql语句不区分大小写</li><li>SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写</li><li>处理SQL语句空格会被忽略</li><li><code>SELECT DISTINCT ... FROM</code>返回不重复的行（distinct要放在列名前面）</li><li>使用完全限定的表名<code>SELECT db.host FROM mysql.db</code></li><li><code>FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT</code>是<code>SELECT</code>的子句，其出现次序必须为上述顺序，次序不对将产生错误信息</li><li><code>ORDER BY</code>子句取一个或多个列的名字对输出进行排序 &gt;默认为asc升序，在列名后加<code>DESC</code>关键字按降序排列，desc关键字只应用到直接位于其前面的列名</li><li><code>GROUP BY</code>子句，分组允许把数据分为多个逻辑组</li><li><code>HAVING</code>和<code>WHERE</code>的区别：<code>HAVING</code>过滤分组，<code>WHERE</code>过滤行</li><li><code>WHERE</code>是<code>SELECT</code>的子句（在from子句之后给出）用来指定搜索条件</li><li><strong>WHERE子句操作符</strong></li></ul><table><thead><tr class="header"><th style="text-align: center;">操作符</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">=</td><td style="text-align: center;">等于</td></tr><tr class="even"><td style="text-align: center;">&lt;&gt;</td><td style="text-align: center;">不等于</td></tr><tr class="odd"><td style="text-align: center;">!=</td><td style="text-align: center;">不等于</td></tr><tr class="even"><td style="text-align: center;">BETWEEN</td><td style="text-align: center;">在指定的两个值之间</td></tr></tbody></table><ul><li>空值检查(<code>is NULL</code>子句)<code>where...is NULL;</code></li><li><code>WHERE</code>子句给出了<code>AND, OR, IN, NOT</code>逻辑操作符来进行逻辑操作</li></ul><h2 id="三匹配">三、匹配</h2><ul><li>通配符本身实际是SQL的<code>WHERE</code>子句中有特殊含义的字符，在搜索子句中使用通配符，必须使用<code>LIKE</code>操作符，<code>LIKE</code>只是Mysql后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较</li><li>百分号<code>%</code>通配符匹配任意个数的任意字符，下划线<code>_</code>通配符匹配任意单个字符</li><li>使用通配符的技巧<ul><li>不要过度使用通配符</li><li>把通配符置于搜索模式的开始处搜索起来是最慢的</li></ul></li><li><code>WHERE</code>的子句中<code>REGEXP</code>子句使用正则表达式，在<code>REGEXP</code>关键字后加上<code>BINARY</code>来区分匹配表达式的大小写 例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Db, User FROM db </span><br><span class="line">WHERE Db REGEXP BINARY &#x27;.ys&#x27;;</span><br></pre></td></tr></table></figure></li><li>匹配正则表达式内具有特殊意义的所有字符都必须以\</li></ul><p><strong>常用字符类</strong></p><table><thead><tr class="header"><th style="text-align: center;">类</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">[:alnum:]</td><td style="text-align: center;">任意字母和数字（同[a-zA-Z0-9])</td></tr><tr class="even"><td style="text-align: center;">[:alpha:]</td><td style="text-align: center;">任意字符（同[a-zA-Z]）</td></tr><tr class="odd"><td style="text-align: center;">[:blank:]</td><td style="text-align: center;">空格和制表</td></tr><tr class="even"><td style="text-align: center;">[:cntrl:]</td><td style="text-align: center;">ASCII控制字符</td></tr><tr class="odd"><td style="text-align: center;">[:digit:]</td><td style="text-align: center;">任意数字</td></tr><tr class="even"><td style="text-align: center;">[:graph:]</td><td style="text-align: center;">与[:print:]相同，但不包括空格</td></tr><tr class="odd"><td style="text-align: center;">[:lower:]</td><td style="text-align: center;">任意小写字母</td></tr><tr class="even"><td style="text-align: center;">[:print:]</td><td style="text-align: center;">任意可打印字符</td></tr><tr class="odd"><td style="text-align: center;">[:space:]</td><td style="text-align: center;">任意空白字符</td></tr><tr class="even"><td style="text-align: center;">[:upper:]</td><td style="text-align: center;">任意大写字母</td></tr><tr class="odd"><td style="text-align: center;">[:xdigit:]</td><td style="text-align: center;">任意十六进制数</td></tr></tbody></table><p><strong>重复元字符</strong></p><table><thead><tr class="header"><th>元字符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>*</td><td>0个或多个匹配</td></tr><tr class="even"><td>+</td><td>1个或多个匹配（等于{1,}）</td></tr><tr class="odd"><td>?</td><td>0个或1个匹配（等于{0,1}）</td></tr><tr class="even"><td>{n}</td><td>指定数目的匹配</td></tr><tr class="odd"><td>{n,}</td><td>不少于指定数目的匹配</td></tr><tr class="even"><td>{n,m}</td><td>匹配数目的范围</td></tr></tbody></table><p><strong>定位元字符</strong></p><table><thead><tr class="header"><th style="text-align: center;">元字符</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">^</td><td style="text-align: center;">文本的开始</td></tr><tr class="even"><td style="text-align: center;">$</td><td style="text-align: center;">文本的结束</td></tr><tr class="odd"><td style="text-align: center;">[[:&lt;:]]</td><td style="text-align: center;">词的开始</td></tr><tr class="even"><td style="text-align: center;">[[:&gt;:]]</td><td style="text-align: center;">词的结束</td></tr></tbody></table><ul><li>正则表达式中<code>.</code>表示匹配任意一个字符</li><li><code>LIKE</code>与<code>REGEXP</code>的区别，<code>LIKE</code>匹配整个串，<code>REGEXP</code>匹配子串</li><li>简单的正则表达式测试，例：<code>SELECT 'hello' REGEXP '[0-9]';</code></li><li><code>SELECT</code>语句中，<code>concat()</code>函数用来拼接字段（与列的意思相同），别名用<code>AS</code>关键字赋予，<code>RTrim()</code>函数去掉右边的所有空格 例： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat(Db, &#x27;(&#x27;, User, &#x27;)&#x27;) AS link</span><br><span class="line">FROM db;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四相关函数">四、相关函数</h2><ul><li><code>Soundex()</code>函数匹配所有发音类似与Y.Lie的联系名 例： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE Soundex(cust_contact) = Soundex(&#x27;Y. Lie&#x27;);</span><br></pre></td></tr></table></figure> <strong>常用数值处理函数</strong></li></ul><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Abs()</td><td style="text-align: center;">返回一个数的绝对值</td></tr><tr class="even"><td style="text-align: center;">Cos()</td><td style="text-align: center;">返回一个角度的余弦</td></tr><tr class="odd"><td style="text-align: center;">Exp()</td><td style="text-align: center;">返回一个数的指数值</td></tr><tr class="even"><td style="text-align: center;">Mod()</td><td style="text-align: center;">返回余数</td></tr><tr class="odd"><td style="text-align: center;">Pi()</td><td style="text-align: center;">返回圆周率</td></tr><tr class="even"><td style="text-align: center;">Rand()</td><td style="text-align: center;">返回一个随机数</td></tr><tr class="odd"><td style="text-align: center;">Sin()</td><td style="text-align: center;">返回一个角度的正弦</td></tr><tr class="even"><td style="text-align: center;">Sqrt()</td><td style="text-align: center;">返回一个角度的平方根</td></tr><tr class="odd"><td style="text-align: center;">Tan()</td><td style="text-align: center;">返回一个角度的正切</td></tr></tbody></table><p><strong>常用时间和日期处理函数</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">AddDate()</td><td style="text-align: center;">增加一个日期（天、周等)</td></tr><tr class="even"><td style="text-align: center;">AddTime()</td><td style="text-align: center;">增加一个时间（时、分等）</td></tr><tr class="odd"><td style="text-align: center;">CurDate()</td><td style="text-align: center;">返回当前日期</td></tr><tr class="even"><td style="text-align: center;">Date()</td><td style="text-align: center;">返回日期时间的日期部分</td></tr><tr class="odd"><td style="text-align: center;">DateDiff()</td><td style="text-align: center;">计算两个日期之差</td></tr><tr class="even"><td style="text-align: center;">Date_add()</td><td style="text-align: center;">高度灵活的日期运算函数</td></tr><tr class="odd"><td style="text-align: center;">Date_Format()</td><td style="text-align: center;">返回格式化的日期或时间率</td></tr><tr class="even"><td style="text-align: center;">Day()</td><td style="text-align: center;">返回一个日期的天数部分</td></tr><tr class="odd"><td style="text-align: center;">DayOfWeek()</td><td style="text-align: center;">对于一个日期，返回对应的星期</td></tr><tr class="even"><td style="text-align: center;">Hour()</td><td style="text-align: center;">返回一个日期的小时部分</td></tr><tr class="odd"><td style="text-align: center;">Minute()</td><td style="text-align: center;">返回一个日期的分钟部分</td></tr><tr class="even"><td style="text-align: center;">Month()</td><td style="text-align: center;">返回一个日期的月份</td></tr><tr class="odd"><td style="text-align: center;">Now()</td><td style="text-align: center;">返回当前日期和时间</td></tr><tr class="even"><td style="text-align: center;">Second()</td><td style="text-align: center;">返回一个时间的秒部分</td></tr><tr class="odd"><td style="text-align: center;">Time()</td><td style="text-align: center;">返回一个日期时间的时间部分</td></tr><tr class="even"><td style="text-align: center;">Year()</td><td style="text-align: center;">返回一个日期的年份部分</td></tr></tbody></table><ul><li>子查询，嵌套<code>SELECT</code>语句 例： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE prod_id = &#x27;TNT2&#x27;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="五联结表">五、联结表</h2><ul><li><code>WHERE</code>子句在联结表中起配对的作用（用完全限定列名）</li><li>没有联结条件的表关系返回的结果为笛卡尔积（检索出的行的数目将是第一个表中的行数乘以第二个表中的行数）</li><li>应保证所有联结都有<code>WHERE</code>子句</li><li>使用在<code>WHERE</code>子句中使用<code>AND</code>可以联结多个表</li><li>等值连接也称为内部联结</li><li>尽量使用自联结而不用子查询</li><li><strong>联结的方式</strong> <img src="https://img-blog.csdnimg.cn/20210428125629111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2ODAyNzEz,size_16,color_FFFFFF,t_70#pic_center" alt="联结"></li><li>外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系</li><li>外键的意义：在于解耦合，定义外键的方法<code>FOREIGN KEY (主键）references &lt;表名&gt;(另一个表的主键）</code></li></ul><h2 id="六组合查询">六、组合查询</h2><ul><li>组合查询，必须由两条<code>SELECT</code>语句组成，语句之间用<code>UNION</code>关键字分隔</li><li><code>UNION</code>的每个查询必须包含相同的列，表达式或聚集函数</li><li>使用<code>UNION</code>时重复的行会被自动取消（默认行为），若想返回所有的匹配行可以用<code>UNION ALL</code></li><li>在使用<code>UNION</code>组合查询时，只能使用一次<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后</li></ul><h2 id="七全文本搜索">七、全文本搜索</h2><ul><li>全文本搜索会对结果排序，具有较高优先等级（文本中靠前的等级高）的行先返回，搜索默认不区分大小写</li><li>在创建表时跟句子句<code>Fulltext(列名)</code>对它进行索引，函数<code>Match()</code>指定被搜索的列，函数<code>Against()</code>指定要使用的搜索表达式，搭配<code>WHERE</code>子句进行筛选</li><li>使用查询扩展<code>Against('anvils' WITH QUERY EXPANSION)</code>，找出和搜索相关的其他行</li></ul><h2 id="八操作数据">八、操作数据</h2><ul><li><h4 id="插入数据">插入数据</h4><ul><li><code>INSERT INTO &lt;表名&gt; (需要插入值的列名) values (给每个列提供一个值)</code></li><li>没有列出的值默认为NULL</li><li><code>INSERT INTO</code>搭配<code>SELECT</code>可以从旧表复制数据到新表</li></ul></li><li><h4 id="更新数据">更新数据</h4><ul><li><code>UPDATE &lt;表名&gt; SET 列=值</code></li><li>要更新的表</li><li>列名和他们的新值</li><li>确定要更新行的过滤条件</li></ul></li><li><h4 id="删除数据">删除数据</h4><ul><li><code>DELETE FROM &lt;表名&gt; WHERE 匹配的列</code></li><li>删除表中所有行<code>TRUNCATE TABLE</code>语句</li></ul></li><li><h4 id="创建表">创建表</h4><ul><li><code>CREATE TABLE &lt;表名&gt;(行及相应值)</code></li><li>表的主键可以在创建表时用<code>PRIMARY KEY</code>关键字指定，主键值必须唯一，多个主键使用<code>,</code>分割</li><li>若仅想在一个表不存在时创建它，应该在表名后给出<code>if not exists</code></li><li>指定<code>not null</code>时在插入或更新行时，该列必须有值</li><li><code>AUTO_INCREMENT</code>告诉mysql每当增加一行时自动增量</li><li>每个表只允许一个<code>AUTO_INCREMENT</code>列</li></ul></li><li><h4 id="更新表">更新表</h4><ul><li><code>ALTER TABLE &lt;表名&gt; ADD &lt;列&gt; 列的数据类型</code></li></ul></li><li><h4 id="删除表">删除表</h4><ul><li><code>DROP TABLE &lt;表名&gt;</code></li></ul></li><li><h4 id="重命名表">重命名表</h4><ul><li><code>RENAME TABLE &lt;表名&gt; to &lt;重命名的表名&gt;</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lua Note</title>
      <link href="/2021/04/28/Lua%20Note/"/>
      <url>/2021/04/28/Lua%20Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>初衷还是Unity</p></blockquote><span id="more"></span><h2 id="交互模式">交互模式</h2><ul><li><code>lua -i</code>，<code>-i</code>参数用于在运行完其他命令行参数后进入交互模式</li><li>不在交互模式下必须把表达式包在函数<code>print</code>的调用中</li><li>如果不想输出结果，可以在行末加上一个<code>;</code></li></ul><h2 id="词法规范">词法规范</h2><ul><li><p>标识符由任意字母、数字和下划线组成的字符串（不能以数字开头）</p></li><li><p><code>_</code>+大写字母（特殊用途）</p></li><li><p><code>_</code>+小写字母（哑变量）</p></li><li><p>注释</p><ul><li>单行注释<code>--</code></li><li>多行注释 <code>--[[       多行注释   ]]</code></li></ul></li><li><p>分隔符<code>;</code></p><ul><li>增加可读性，不是必须的</li></ul></li><li><p>表达式之间的换行不起任何作用</p></li></ul><h2 id="全局变量">全局变量</h2><ul><li>无须声明即可使用</li><li>使用未经初始化的全局变量，得到的结果时<code>nil</code></li><li><code>nil</code>赋值给全局变量时，Lua会回收该全局变量</li></ul><h2 id="类型和值">类型和值</h2><ul><li><p>Lua语言有8种基本类型</p><ul><li><p><code>nil</code>（空）</p><ul><li>nil赋值给全局变量时，则相当于将其删除（Lua会回收）</li></ul></li><li><p><code>boolean</code>（布尔）</p><ul><li>除false和nil之外的所有值都为真（与C++差异）</li><li>not运算符永远返回boolean类型的值<ul><li><code>not nil</code> -- true</li><li><code>not false</code> -- true</li></ul></li></ul></li><li><p><code>number</code>（数值）</p></li><li><p><code>string</code>（字符串）</p></li><li><p><code>userdata</code>（用户数据）</p><ul><li>允许把任意的C语言数据保存在Lua语言变量中</li></ul></li><li><p><code>function</code>（函数）</p></li><li><p><code>thread</code>（线程）</p></li><li><p><code>table</code>（表）</p></li></ul></li><li><p><code>type</code>函数</p><ul><li>获取一个值对应的类型</li><li>返回值永远是一个字符串</li></ul></li></ul><h2 id="独立解释器">独立解释器</h2><ul><li>是一个可以直接使用Lua语言的小程序</li><li>源代码文件第一行以井号<code>#</code>开头，那么解释器在加载文件时会忽略这一行，主要是为了方便在POSIX系统中将Lua作为一种脚本解释器来使用</li><li>假设独立解释器位于<code>/usr/local/bin</code>下<ul><li><code>#!/usr/local/bin/lua</code> 或 <code>#!/usr/bin/env lua</code><ul><li>不需要显式调用Lua语言解释器也可以直接运行Lua脚本</li></ul></li></ul></li><li>编译器在运行代码前会创建一个名为arg的表<ul><li>索引0中保存的内容为脚本名<ul><li><code>arg[0]</code></li></ul></li><li>索引1保存的内容为第一个参数<ul><li><code>arg[1]</code></li></ul></li><li>以此类推</li></ul></li><li>Lua语言也支持可变长参数(...)</li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
