---
title: 【C#】语言基础笔记（在更）
date: 2021-04-28 21:20:57
tags: C#
categories: C#
author: 黄丕舜
---
## 新特性
- 表达式主体方法
	- =>操作符引用构成方法主体的表达式，而且没有return语句。表达式的值自动作为返回值；如果表达式不返回值，则方法自动为void方法
		```csharp
		private void showResult(int answer) => Console.WriteLine($"The answer is {answer}");
		```
- 差值表达式
	- $符号表明这是个差值字符串，{和}之间的任何表达式都需求值并置换，字符串差值比+操作符高效得多
		```csharp
		$"The answer is {answer}"
		```

## 变量
- 只有`float`和`double`除以0得到`Infinity`（不会出错）
- `int`的最大最小值`int.MaxValue`和`int.MinValue`
- 隐式类型变量`var`,作用类似于C++的`auto`

## 逻辑
- 与C++不一致
	-`if`语句中表达式必须是布尔值, 如：`if (1)` // 错误
- `switch`语句的控制表达式不能用`float`和`double`类型
- `case`标签必须是常量表达式，且必须唯一
- C#语句的直通规则
	- 直通，标签之间不能有额外语句（即不加`break`，不允许拥有语句）
	- 每个`case`都加上`break`

## 方法
- C#所有方法都必须在类的内部声明
- 默认参数中如果参数匹配则不会出现歧义
- 默认参数（可选参数）必须放在后面
- 具名参数
	- `optMethod(first: 99, third: "Word");`  // 传递具名参数（参数名:传递的值），实参可以按任意顺序传递，second参数使用`默认值`

## 结构（结构体）
- 与C++不一致，结构主体后不加`;`
- 值类型
	- 对于简单的、比较小的数据值，复制值的效率等同于或基本等同于复制地址的效率，但较复杂的数据就考虑使用类，这样就可选择只复制数据的地址，从而提高代码的执行效率
- 不能为结构声明默认构造器（无参构造器），否则无法编译，因为编译器始终会自动生成默认构造器（不同于类）
- 类的实例字段可在声明时初始化，但结构不允许
	```csharp
	struct Time
		{
		    private int hours = 0;  // 编译时错误
		}
	```
- 编译器不会自动初始化结构中的字段（与类不一致）
- 复制结构变量的前提时`=`操作符右侧的结构变量已完全初始化，否则编译错误

## 枚举
- 与C++不一致，枚举主体后不加`;`
- 值类型
- 声明枚举时字面值默认是int类型，可以选择枚举的基础类型
	- `enum Season : short { Spring, Summer }`
- 为枚举的字面值显式指定常量整数值
	- `enum Season { Spring = 1, Summer }`
- 编译器自动为它指定比前一个枚举字面值大1的值
- 多个枚举字面值可以具有相同的基础值
	- `enum Season { Spring, Summer, Fall, Autumn = Fall }`
- 每个枚举定义的字面值名称都只有这个枚举类型的作用域，因此要加枚举类型限定，否则编译错误，如：Season.Fall

## 类
- 与c++不一致，类主体、结构主体后不加分号
- 每个字段和方法声明都要重复`public`或`private`关键字
- 省略控制可访问性，默认为`private`
- 类被拆分到多个文件中之后，要在每个文件中使用`partial`（分部）关键字定义类的不同部分
- 如果把方法或字段声明为`static`，就可使用类名调用方法或访问字段，而不用先创建对象
- 静态方法只能访问标记为`static`的其他方法和字段
- 类外访问类中的`static`字段要以，类名作为前缀，`class.function`
- 静态方法也称为类方法
- 静态字段称为静态字段或静态变量
- 只有数值类型、字符串类型和枚举类型的字段才能声明为const字段
- 静态类
	- 只能包含静态成员
	- `public static class Math`
- using语句允许将类引入作用域，以便在访问静态成员时省略类名
	- `using static System.Math;`
- 匿名类
	- 匿名类就是没有名字的类
	- 不知道类的名称可以使用隐式类型变量来创建正确类型的对象
		```csharp
		var myAnonymousObject = new { Name = "John", Age = 47 };
		```
- 值类型
	- 基元类型
- 引用类型
	- `string`在运行时动态分配内存
	- 声明类变量时，编译器分配一小块内存，其中刚好可以容纳一个地址。以后类实际占用内存块的地址会填充到这里。该地址成为对内存块的引用
	- 实际占用的内存
		- 使用`new`关键字创建对象时分配的内存
- 引用类型的变量包含的是引用，引用本身存储在栈上，但该引用指向堆上的对象
- 类可以提供clone方法来返回自己的新实例，并填充相同数据
	```csharp
	public Circle Clone()
		{
		    Circle clone = new Circle();
		    clone.radius = this.radius;
		    // 返回包含克隆数据的新Circle对象
		}
	```
	- 如果包含任何引用类型的字段，这种引用类型也需要提供Clone方法，否则只是“浅拷贝”，如果提供了Clone方法，能够复制引用的对象，就成为“深拷贝”
		```csharp
		Circle c = new Circle(42);
		Circle copy = new Circle(99);
		copy = c;
		```

	- 这时候copy原来的引用被回收了（垃圾回收机制）

- 空条件操作符（问号加在变量名称之后）
	```csharp
	Console.Write(c?.Area());
	```
	- 空条件操作符告诉”运行时“在操作符所应用的变量为null的前提下忽略当前语句

- 可空类型

	- `null`本身就是引用，不能把它赋值给值类型
	- 可将变量声明为可空值类型
		- `int? i = null;`
	- 可将恰当值的表达式直接赋给可空变量
		- `i = j;`
	- 不可将可空的值赋给普通的值类型变量
		- `j = i;`
	- 可空类型的两个属性
		- `HasValue`
			- 判断可空类型是包含一个值，还是包含null
		- `Value`
			- 只读的属性
			- 读取变量的值，但不能修改
- 引用传参
	- `ref`参数
		- 要求实参和形参前都加上`ref`关键字
			- `DoWork(ref i)`;
		- 要求在传参之前必须初始化
	- `out`参数
		- 要求实参和形参前都加上`out`关键字
		- 要求在方法中必须初始化，传参前不要求
- `object`类型
	- `object`类型的变量能引用任何引用类型的任何对象
- `装箱`
	- 将值类型赋给`object`类型的变量
		- `object o = 42;`
	- 数据项从栈自动复制到堆的行为
	- 与泛型异曲同工
- `拆箱`
	- 将引用了已装箱的值的object引用强制转换成值类型
		- `int a = (int)o;`
	- 必须强制转换
- 装箱和拆箱会产生较大的开销
	- 它们设计不少检查工作，且需要分配额外的堆内存
- 数据的安全转型
	- 左操作数为对象，右操作数为类型
		- is操作符
			- if (o is WrappedInt)
			- 如果is表达式正确，结果为true，反之为false
		- as操作符
			- WrappedInt temp = o as WrappedInt;
			- 若转换成功，就返回转换成功的结果，失败则为null
- 在c#中使用c指针必须将代码标记为`unsafe`
	- `unsafe`关键字可标记代码块或整个方法
		```csharp
		unsafe {}
		public static unsafe void swap() {}
		```
- 命名规范
- 公共标识符以大写字母开头
- 非公共标识符（包括局部变量）以小写字母开头
- 类名以大写字母开头
- 均采用驼峰命名法
- `TODO:`注释通常用于标注以后将进行加工的代码

## 异常
- `checked`语句是`checked`关键字开头的代码块
	- 只有直接在checked块中的整数运算才会检查
	- 溢出则抛出`OverflowException`
	- `checked`和`unchecked`关键字只适合整型运算
	- 浮点运算永不抛出异常
- `catch`省略名称默认捕获`Exception`
	- 异常发生后将运行由”运行时“发现的第一个匹配的异常处理程序`catch`，其他处理程序会被忽略
