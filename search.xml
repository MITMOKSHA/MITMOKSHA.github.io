<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CAAQA阅读笔记</title>
      <link href="/2023/03/25/CAAQA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/25/CAAQA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<!-- # CAAQA阅读笔记 --><blockquote><p>转行前奏</p></blockquote><span id="more"></span><h2 id="Memory-Hierarchy"><a href="#Memory-Hierarchy" class="headerlink" title="Memory Hierarchy"></a>Memory Hierarchy</h2><h4 id="Cache性能"><a href="#Cache性能" class="headerlink" title="Cache性能"></a>Cache性能</h4><ul><li>$CPU执行时间&#x3D;(CPU时钟周期数 \times 存储器停顿周期数) \times 时钟周期$</li><li>$存储器停顿时钟周期&#x3D;(IC \times \frac{存储器访问数}{指令}\times缺失率\times缺失代价)$<h4 id="四个存储器层次结构的问题"><a href="#四个存储器层次结构的问题" class="headerlink" title="四个存储器层次结构的问题"></a>四个存储器层次结构的问题</h4></li><li>块的放置。通过<code>块地址 mod Cache的组数</code>来放置到对应的插槽中。<strong>如果组中有n个块，就成为n路组相联映射(i.e.相联度)</strong></li><li>块的识别。若有效位为1，且地址中的tag字段和块中的tag字段匹配(这是两个条件通过一个与门)，然后就能取到对应的块，再根据地址字段的块偏移找到对应的块(块偏移字段的bit数&#x3D;log2(块大小&#x2F;主存宽度)，是跟主存宽度相关的)</li><li>块的替换。随机，LRU，FIFO</li><li>写入策略。<ul><li>写回。信息仅更新到Cache中，未更新到低一级的存储器中，只有在Cache中的块发生替换时，才将dirty的块写入低一级的存储器中，效率比较高</li><li>写直达。同时写入Cache和低一级的存储器中，一般会有一个写缓冲，来使得处理器在更新低一级存储器时不停顿。</li></ul></li><li>写缺失<ul><li>写分配。将发生写缺失的块调入Cache中，因此一般搭配写回策略</li><li>非写分配。不将写缺失的块调入Cache中，仅修改低一级的存储器的块，因此一般搭配写直达策略</li></ul></li><li>索引字段的计算${2}^{索引} &#x3D; \frac{Cache大小}{块大小\times相联度}$</li><li>$AMAT(存储器的平均访问时间)&#x3D;命中时间+缺失率\times缺失代价$</li></ul><h2 id="Cache优化"><a href="#Cache优化" class="headerlink" title="Cache优化"></a>Cache优化</h2><ul><li>降低缺失率</li><li>降低不命中的代价</li><li>缩短Cache命中的时间</li><li>3’c不命中<ul><li>强制不命中(冷启动不命中)。第一次访问某个指令或数据时，它肯定不在Cache中，必须读入Cache中执行。</li><li>容量不命中。Cache无法容纳程序执行期间所需要的全部块，由于一些块会被丢失，过会又被提取，就会出现”抖动”</li><li>冲突不命中。针对放置策略为组相联映射或全相联映射</li><li>多处理器中还有一致性缺失。</li></ul></li><li>优化方法<ul><li>增大块大小降低缺失率，块大小会增加硬件比较器的开销</li><li>增大缓存以降低缺失率</li><li>提高相联度以降低缺失率</li><li>采用多级Cache降低缺失代价</li></ul></li><li>Cache TLB与内存结合<br><img src="/2023/03/25/CAAQA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/03/25/CAAQA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/img-2023-03-25-15-53-48.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记《CAAQA》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xv6源码阅读</title>
      <link href="/2023/03/25/xv6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2023/03/25/xv6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<!-- # xv6源码阅读 --><blockquote><p>Talk is cheap. Show me the code.</p></blockquote><span id="more"></span><h2 id="调试篇"><a href="#调试篇" class="headerlink" title="调试篇"></a>调试篇</h2><ul><li>执行<code>make -nB qemu | vim -</code>，在vim中执行<code>:set nowrap</code>，然后利用全局替换<code>%s/ /\r /g</code>将所有的空格替换为换行加空格，即可提取出编译时的选项，包括库的依赖等等</li><li><code>.gdbinit</code>文件会在每次gdb时都会默认执行的命令，比如<code>symbol-file</code>都可以放在里面。在用vscode调试时，要将<code>target remote</code>注释掉，使用gdb调试时就恢复即可</li><li>sscratch中存的是trapframe的地址，在trampoline中与a0寄存器交换。最后会将sscratch中的a0的值赋给t0，然后存入对应a0在trapframe中的位置，然后再从trapframe中读取相关的内核信息(这一部分在trapframe中是不变的)，比如读内核栈指针(将用户栈指针切换为内核栈指针)、读取coreid、读取系统调用的入口地址、读取内核页表地址然后和satp交换(用户页表切换为内核页表)。进入usertrap之后还需要保存用户的PC。</li><li>就像trap一样，需要一个trampoline来保存现场。因此进程之间的上下文切换，每个进程的proc中就需要有一个trapframe结构保存当前进程的上下文</li></ul><h2 id="启程"><a href="#启程" class="headerlink" title="启程"></a>启程</h2><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul><li>结构。<code>noff</code>指的是锁嵌套的层数，<code>intena</code>指的是<code>push_off</code>之前的中断状态，1表示开中断<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="SpinLock"><a href="#SpinLock" class="headerlink" title="SpinLock"></a>SpinLock</h4></li><li>自旋锁底层通过test_and_set不断地轮询是否能获取锁(占用CPU资源)</li><li>结构<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>initlock初始化传入的参数lk锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;   <span class="comment">// 1为持有锁</span></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;      <span class="comment">// 初始化为NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>holding。检查是否当前CPU持有锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>acquire。获取锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off();              <span class="comment">// 关中断并记录中断前的中断状态</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))          <span class="comment">// 若当前CPU已经持有该自旋锁，则报错</span></span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (amoswap, atomic memory operation:swap doubleword)原子双字交换</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)  <span class="comment">// 不断test直到锁未被持有(i.e. locked=0)结束while循环</span></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();  <span class="comment">// 阻止编译器和处理器重排ld和st指令</span></span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = mycpu();     <span class="comment">// 记录获取锁的CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>release。释放锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;  <span class="comment">// 把持有锁的CPU置为NULL</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize(); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);  <span class="comment">// 原子交换，将lk-&gt;locked置为0，C函数赋值不是原子的(会调用很多个st指令)</span></span><br><span class="line"></span><br><span class="line">  pop_off();  <span class="comment">// 减少锁的嵌套相关信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>push_off。记录锁的嵌套信息，必须得调用intr_off()关中断避免死锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 记录关中断前的中断状态</span></span><br><span class="line">  <span class="type">int</span> old = intr_get();     <span class="comment">// 获取状态寄存器的值判断中断使能位是否为1，返回使能位</span></span><br><span class="line"></span><br><span class="line">  intr_off();               <span class="comment">// 关闭中断，对状态寄存器进行逻辑操作</span></span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)    <span class="comment">// 如果无锁嵌套则将关中断前的中断状态记录到当前core中</span></span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;       <span class="comment">// 当前core的锁嵌套数加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>pop_off。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);  <span class="comment">// 如果当前加锁状态下未关中断，则报错</span></span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);  <span class="comment">// 如果未加锁嵌套状态下解锁，则报错</span></span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)  <span class="comment">// 如果无锁嵌套，且在加锁之前是中断使能状态，则打开中断</span></span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4></li><li>QEMU模拟的UART中的控制寄存器的访问是存储器映射I&#x2F;O方式，在xv6物理地址空间中的起始地址是<code>0x10000000</code>其中包括8个I&#x2F;O寄存器顺序从放在该地址起始处，具体寄存器值得设置<a href="http://byterunner.com/16550.html">参见</a></li><li>uartinit<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// disable interrupts.</span></span><br><span class="line">  WriteReg(IER, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// special mode to set baud rate.</span></span><br><span class="line">  WriteReg(LCR, LCR_BAUD_LATCH);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LSB for baud rate of 38.4K.</span></span><br><span class="line">  WriteReg(<span class="number">0</span>, <span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MSB for baud rate of 38.4K.</span></span><br><span class="line">  WriteReg(<span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// leave set-baud mode,</span></span><br><span class="line">  <span class="comment">// and set word length to 8 bits, no parity.</span></span><br><span class="line">  WriteReg(LCR, LCR_EIGHT_BITS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset and enable FIFOs.</span></span><br><span class="line">  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable transmit and receive interrupts.</span></span><br><span class="line">  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;uart_tx_lock, <span class="string">&quot;uart&quot;</span>);  <span class="comment">// 初始化uart串口的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CONSOLE"><a href="#CONSOLE" class="headerlink" title="CONSOLE"></a>CONSOLE</h4></li><li>结构<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// input</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_BUF 128</span></span><br><span class="line">  <span class="type">char</span> buf[INPUT_BUF];</span><br><span class="line">  uint r;  <span class="comment">// Read index</span></span><br><span class="line">  uint w;  <span class="comment">// Write index</span></span><br><span class="line">  uint e;  <span class="comment">// Edit index</span></span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure></li><li>consoleinit<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>);  <span class="comment">// 初始化cons中的自旋锁</span></span><br><span class="line"></span><br><span class="line">  uartinit();                    <span class="comment">// 初始化I/O控制寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// connect read and write system calls</span></span><br><span class="line">  <span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">  <span class="comment">// devsw结构体中存储着设备读写函数，devsw数组的索引为设备号，CONSOLE为1</span></span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IC note</title>
      <link href="/2023/03/23/IC-note/"/>
      <url>/2023/03/23/IC-note/</url>
      
        <content type="html"><![CDATA[<!-- # IC note --><blockquote><p>好好学一学吧！</p></blockquote><span id="more"></span><h2 id="RISCV基础"><a href="#RISCV基础" class="headerlink" title="RISCV基础"></a>RISCV基础</h2><ul><li>FGPA(可编程逻辑阵列)，ASIC(专用集成电路)</li><li>设计ISA的<strong>七种衡量标准</strong><ul><li>成本。处理器是通过集成电路实现的芯片，保持ISA的简洁性可以缩小处理器的尺寸，这样可以减少成本</li><li>简洁性。能够缩短芯片设计和验证的时间，降低文档成本</li><li>性能。CPU性能方程</li><li>架构和具体实现的分离。MIPS的延迟槽设计</li><li>提升空间。ISA必须保留操作码的空间(以便添加指令)。ARM32想使用16位指令来减少代码长度，但没有操作码的空间了，因此16位指令创建了isa(thumb1)，16和32位来组成另外一个isa(thumb2)，然后使用一个模式位在两种长度的指令之间切换。</li><li>程序大小。程序越小(跟指令长度也相关)，存储它所需的芯片面积就越小；还能减少指令cache未命中的次数(访问DRAM需要的时间比访问SRAM需要的时间更久)。</li><li>易于编程&#x2F;编译&#x2F;链接。编译器对寄存器的分配；若ISA支持PIC(位置无关代码)，即可加载而无需重定位的代码，就可以支持动态链接</li></ul></li><li>宏观融合。高端处理器通过将简单的指令组合在一起从而提高性能，从而减少更复杂的ISA给底端实现带来的负担</li><li>RV32I指令<ul><li>六种基本指令<ul><li>R。寄存器-寄存器风格的算数逻辑运算指令</li><li>I。用于短立即数和访问load操作</li><li>S。用于访存store操作</li><li>B。用于条件跳转</li><li>U。用于长立即数</li><li>J。用于无条件跳转</li></ul></li><li>所有指令都是32-bit长，简化了指令译码</li><li>指令编码格式中提供三个寄存器操作数字段</li><li>为减少译码逻辑，指令编码格式中将读&#x2F;写寄存器都放在了固定字段，因此可以在译码前就进行</li><li>立即数字段总是符号拓展，可以在译码前就进行</li><li><img src="/2023/03/23/IC-note/03/23/IC-note/img-2023-03-23-17-26-51.png"></li><li>指令编码格式<ul><li><img src="/2023/03/23/IC-note/03/23/IC-note/img-2023-03-23-17-27-28.png"></li></ul></li><li>B指令和J指令的地址必须向左移动一位(相当于乘以2)，拥有更大的跳转范围</li><li>乱序执行处理器(关键是寄存器重命名，将汇编程序中的寄存器映射到物理寄存器)</li><li>ABI(应用程序二进制接口)</li><li>risc-v没有条件码，可以通过slt(set on less than)指令来比较两个寄存器的大小，然后再将0或1写入具体的寄存器中，通过做一些逻辑运算即可判断出两个寄存器值的大小了(也有立即数版本的slti)</li><li>lui指令，和auipc主要是因为riscv的指令编码长度为32-bit(包括操作码等)，存放不下32位的立即数，因此只能以逻辑的方式操作高20-bit到寄存器里，然后I指令的高12位刚好为数据的低12位，再使用ori搭配lui就可以将32位值加载到一个寄存器里了(需要两条指令)。auipc和jalr的搭配也可以实现用组合成完整的32位值来修改pc。</li><li>与MIPS不同，不支持(delay load)，即load指令在两个指令执行后才可用，与延迟分支的设计类似</li><li>条件码使指令设置的状态，会使得乱序执行的依赖计算复杂化，因此risc-v没有条件码</li><li>使用sltu实现32位数的加法，sltu可以通过加的结果和其中一个操作数进行一次<strong>无符号</strong>比较。如果出现溢出，那么加的结果就会比其中一个操作数要小，这时候stlu可以将其中一个进位位保存到其中一个操作数的寄存器里，然后在高32位相加的时候加上这个进位位</li><li>获取当前的pc可以通过使用auipc，立即数字段设为全0，然后auipc会将结果写到指定的寄存器里，这时候就能获取到PC的值了</li><li>x0寄存器硬连线为0</li><li>特性<ul><li>32位主存空间，8位寻址能力</li><li>所有指令都为32位长</li><li>31个寄存器，全部32位宽，寄存器0硬连线为0</li><li>所有操作都在寄存器之间(寄存器-寄存器风格)</li><li>使用存储器映射I&#x2F;O</li><li>立即数总是符号拓展</li><li>只提供一种数据寻址模式(寄存器+立即数)和PC相对寻址</li><li>无乘法或除法指令</li><li>加载32位常量需要两条指令lui和ori</li></ul></li><li>软件检测加法溢出<ul><li>在无符号加法指令addu后可以加上一个bltu(如果条件满足则会跳转到一个label中)来对相加的结果和其中一个操作数进行比较，如果和小于操作数，说明发生了溢出。</li><li>有符号加法指令后，可以加上两条指令，如果其中一个操作数为负数，那么和才能小于另一个操作数(无论当前操作数是正还是负)，否则就发生了溢出(比如两个正数相加结果小于0)</li></ul></li><li>jalr跳转并链接(链接返回地址)指令，将返回地址(PC+4)放到ra中可以实现过程调用，若使用x0寄存器替换ra，则可以实现无条件跳转</li><li>注意到jal的立即数部分非常混乱，看过immgen的实现以后才发现指令的一部分是可以复用的，减少译码逻辑</li></ul></li><li>寻址模式。指的是操作数的来源(寄存器，立即数，指令编码中)<ul><li>lc-3支持:数据寻址方式(寄存器，立即数)，存储器寻址方式(PC相对寻址，间接寻址，基址+偏移量寻址)，为寄存器-寄存器风格(也成为load&#x2F;store)风格的ISA</li></ul></li></ul><h2 id="超标量处理器设计相关"><a href="#超标量处理器设计相关" class="headerlink" title="超标量处理器设计相关"></a>超标量处理器设计相关</h2><ul><li>ISA是软件与硬件之间的接口</li><li>摩尔定律。处理器性能每18个月翻一番</li><li>RTL，寄存器传输语言</li><li>超标量处理器使得IPC大于1。n-way超标量处理器指的每个时钟周期执行n条指令</li><li>VLIW(Very Long Instruction Word)超长指令字处理器架构，是依靠编译器和程序员决定调度哪些指令并行执行，而超标量处理器是靠硬件自身决定哪些指令可以并行执行</li><li>面向PC端处理器设计性能放在第一位，移动端处理器设计功耗放在第一位</li><li>使用流水后周期时间变为D&#x2F;n+S，S为流水线寄存器的延迟，D为没有流水所需的周期时间，n为流水线的级数；硬件面积变为G+n*L，G为没有流水所消耗的硬件面积，L为流水线寄存器附带的控制逻辑所消耗的硬件面积</li><li>最长的流水段所需要的时间决定了整个处理器的周期时间</li><li>五级流水线<ul><li>IF。使用PC作为地址，从I-Cache中取出指令，并将指令存储在指令译码器中</li><li>ID。根据指令译码的结果找到对应操作的微状态号，当前微指令中有对寄存器组的控制信号(可以不需要通过总线直接传送到ALU)，进行运算之后再写回寄存器组中</li><li>EX。执行算数运算指令或<strong>对访问存储器的地址进行计算</strong></li><li>MEM。ld&#x2F;st指令会访问D-Cache，其他指令在这个stage不会做任何事情</li><li>RB</li></ul></li><li>对流水线中各个stage进行平衡处理<ul><li>合并stage。这不符合高性能处理器对高时钟频率的要求</li><li>细分stage。较深的流水线会导致硬件消耗的增大(需要更多的流水线寄存器和控制逻辑)，同时分支预测失败的惩罚也增大了</li></ul></li><li>超标量处理器的指令相关性<ul><li>数据相关性:RAW先写后读(可以通过转发来解决), WAR先读后写, WAW先写后写<ul><li>ld&#x2F;st指令比较难判别，通常需要带上地址判别相关性</li></ul></li><li>控制相关性:分支指令到跳转发生时与后面跟着的指令存在控制相关</li></ul></li><li>超标量处理器执行指令的方式<ul><li>Frontend阶段(也就是取指令和译码阶段)，这两个阶段很难实现乱序执行(实际上也没有意义)。</li><li>在Issue阶段(也就是ex和mem阶段)乱序执行，<strong>issue表示将指令送到(Function Unit, FU)中执行</strong>，只要指令的源操作数准备好了，就可以将其先于其他指令执行</li><li>在Write back阶段处理器内部使用寄存器重命名，将逻辑寄存器(Architecture Register File)映射到物理寄存器(Physical Register file)中，从而实现乱序方式的写回寄存器。寄存器重命名通常放在一个流水段里(时间比较长)。</li><li>Commit阶段表示一条指令允许更改处理器的状态(如D-Cache与SB相关的更新)，为了保证实现精确异常然后retire，这个阶段需要顺序执行。</li></ul></li><li>顺序执行<ul><li>为了保证wb阶段是顺序执行的，所有的FU都需要经历同样周期数的流水线(即流水段的个数要一致)，这样就会出现有的FU已经完成相关功能了，但还得执行几个什么都不做的stage。<strong>写回阶段统一了，因此WAW和WAR都不会对顺序执行的流水线产生影响</strong></li></ul></li><li>乱序执行<ul><li>发射队列(Issue Queue, IQ)，每个FU都有一个IQ，仲裁(select)电路会从这个IQ部件中挑选出合适的指令送到FU执行。乱序的仲裁电路会很复杂，顺序发射只需要判断IQ中最旧(即队列最前端)那条指令是否就绪就可。IQ中还存在唤醒电路，需要和仲裁电路相互配合进行工作</li><li>每个FU都有自己的流水线级数(不像顺序执行那样都一致)</li><li>重排序缓存(ReOrder Buffer, ROB)，流水线中所有指令按照程序中规定的顺序存储在重排序缓存中。使用ROB来实现程序对处理器状态的顺序更新，这个阶段也称作Commit阶段。ROB会配合异常的处理，<strong>如果不存在异常这条指令就可以离开流水线了(也成为retire)，指令一旦retire就不可能再回到之前的状态了</strong></li><li>Store Buffer(SB)，指令没有retire之前，结果会被写到SB中(防止store结果到主存中之后发生异常，但这时候主存里的数据没办法恢复的情况)。只有指令真正的retire的时候才会将SB中的值写到存储器中。<ul><li>如果在store指令执行后执行load这时候就会出现数据相关，因为加了一个commit stage这时候数据并未写入存储器中，而是在SB中，此时还需要从SB中找数据(增加旁路)</li></ul></li></ul></li><li>恢复电路&amp;预测技术</li><li>经典九级流水线<ul><li>Fetch。从I-Cache中取指令。主要有两大部件构成：I-Cache和分支预测器(决定下一条指令的PC值)</li><li>Decode。用来识别出<strong>指令的类型</strong>、<strong>指令需要的操作数</strong>以及指令的一些<strong>控制信号</strong>(通过对指令编码字段进行译码)。</li><li>Register Renaming。解决WAW和WAR这两种”伪相关性”</li><li>Dispatch。被重命名之后的指令会按照程序中规定的顺序，写到发射队列、ROB和SB中。如果这些部件中没有空闲的空间可以容纳当前的指令，那么这些指令就需要在流水线重命名阶段进行等待，这就相当于暂停了寄存器重命名以及之前的所有流水线，直到这些部件中有空闲的空间位置</li><li>Issue。仲裁(select)电路会从这个部件中挑选出合适的指令送到FU中执行。对于顺序发射仲裁电路只需要判断IQ中最旧那条指令是否<strong>准备</strong>好就可以了</li><li>Register File Read。被仲裁电路选中的指令需要从物理寄存器组(PRF)中读取操作数</li><li>Execute。指令得到操作数之后马上就可以送到对应的FU中执行</li><li>Write Back。这个阶段会将FU计算的结果写到物理寄存器组(PRF)中，同时这个阶段还有一个重要的功能，就是通过转发将这个计算结果送到需要的地方。</li><li>Commit。这个阶段起主要作用的部件时ROB，它会将乱序执行的指令拉回到程序中规定的顺序，还有SB部件，防止出现异常的指令写入存储部件无法恢复</li></ul></li></ul><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><ul><li>组相联和全相联的对比<ul><li>全相联需要更多的硬件(如多路选择器、比较器等)，包括LRU所需的控制位(Use bit)，但冲突不命中的影响降低了。</li><li>组相联存在冲突不命中的影响，但需要的硬件更少了。</li></ul></li><li>3’C不命中<ul><li>冷启动不命中&#x2F;强制不命中。指的是指令和数据第一次被访问<ul><li>缓解方法：指令预取(放入硬件stream buffer中，避免分支指令的污染，但分支预测失败会导致浪费预取的功耗和性能。又分为硬件预取和软件预取)</li></ul></li><li>冲突不命中。为了解决多个数据映射到Cache中的同一个位置的情况<ul><li>缓解方法：Victim Cache(本质上增加了way的个数)，将被替换的块放入其中</li></ul></li><li>容量不命中。比如数据<strong>属于</strong>5个不同的set，但Cache中只有4个set</li></ul></li><li>串行访问和并行访问Cache<ul><li>对于I-Cache来说，<strong>流水线结构</strong>不会有太大影响；对于D-Cache来说，使用流水线会增大load指令的延迟(会导致比如分支的Penalty增加)</li><li>串行访问<ul><li>优点：只需要访问Tag比较正确的那个SRAM，其他的SRAM都不需要被访问，可以将它们的使能信号置为无效，节约功耗</li><li>缺点：延迟增大(对Cache的访问增加了一个时钟周期)</li></ul></li><li>并行访问<ul><li>优点：较低的时钟频率，比较Tag和读取SRAM可以并行</li><li>缺点：较大的功耗，SRAM都需要访问，还需要MUX进行选择</li></ul></li></ul></li><li>Cache的写入<ul><li>写入地址不在Cache中<ul><li>Write Allocate。将数据写到当前一级存储器中，但下一级存储器并未改写</li><li>Non-Write Allocate。将数据写到下一级存储器而不写到当前一级存储器中</li></ul></li><li>写入地址在Cache中<ul><li>Write Back</li><li>Write Through。加入写缓存很重要</li></ul></li><li>一般Write Back搭配Write Allocate， Write Through搭配Non-Write Allocate。<strong>因为写回和写分配都是直接将数据写入到当前一级的存储器中；写通和写不分配都是直接将数据写到当下一级的存储器中</strong></li><li>在替换的时候将脏数据写回，可以提高性能，不必每次脏都写回</li><li>加入<strong>write buffer</strong>，可以在Cache不命中，将脏数据写回时将数据先写到write buffer里，而不是低一级存储器(时间太长)；或者是write through时将数据写到write buffer里；如果Cache发生缺失先要去write buffer里找(里面有最新的数据，通过地址比较)</li></ul></li><li>TLB。加快了虚拟地址-&gt;物理地址的转换速度，存储着PTE(PPN+访问控制位)<ul><li>现代处理器采用两级TLB，第一级哈佛结构(I-TLB, D-TLB。全相联)和第二级组相联</li><li>TLB中记录的所有的页都不允许在物理内存中被替换(即被替换到磁盘中)</li></ul></li><li>Cache的设计<ul><li>PIPT。用物理地址访问Cache</li><li>VIVT。用虚拟地址访问Cache，会出现同义(Synonyms)和同名(Homonyms)的问题。<ul><li>同义。不同的虚拟地址映射到同一个物理地址，可以利用<strong>bank结构</strong>解决(使用物理地址的[12]作为mux的信号选择对应的bank)</li><li>同名。相同的虚拟地址映射到不同的物理地址，通过<strong>设置ASID寄存器</strong>(表示进程，若有256个进程，该寄存器需要8位宽。进程共享时使用G位，此时ASID无效)，或者<strong>清空TLB和虚拟Cache</strong>(开销大)来解决。ASID相当于扩展了虚拟存储器的空间，用ASID来进行页表的寻址(相当于VPN的一部分)</li></ul></li><li>VIPT。充分利用并行性，在访问TLB的同时访问Cache</li></ul></li></ul><h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><ul><li>分支指令包含两个要素：方向和目标地址。对于RISC-V目标地址在指令中可以有两种存在形式：PC相对寻址和间接跳转</li><li>快速解码&#x2F;预解码：只需要辨别解码指令是否是分支指令，找到分支指令对应的PC值送到分支预测器中。如果使用ASID寄存器，就不需要在进程切换时清空TLB、虚拟Cache和分支预测器了</li><li>分支预测都是以PC值(可以是部分)为基础进行的，每个PC值都对应一个两位饱和计数器的值</li></ul><h5 id="基于两位饱和计数器的分支预测"><a href="#基于两位饱和计数器的分支预测" class="headerlink" title="基于两位饱和计数器的分支预测"></a>基于两位饱和计数器的分支预测</h5><ul><li>四种状态：<code>Strongly Taken</code>, <code>Weakly Taken</code>, <code>Weakly Not Taken</code>, <code>Strongly Not Taken</code></li><li>使用部分PC值来寻址(索引)PHT(Pattern History Table)，找到对应的两位饱和计数器的值，在流水线提交阶段，当指令要离开流水线时，更新PHT</li><li>别名问题使用部分PC值必然会导致别名的问题，即两个PC值索引到同一个两位饱和计数器的值，如果这两个PC对应的不是同一条分支指令必然会产生干扰。使用<strong>哈希算法</strong>可以解决别名的问题。</li></ul><h5 id="基于局部历史的分支预测"><a href="#基于局部历史的分支预测" class="headerlink" title="基于局部历史的分支预测"></a>基于局部历史的分支预测</h5><ul><li>使用一个寄存器BHR(Branch History Branch)分支历史寄存器来记录<strong>一条分支指令</strong>在过去的历史状态，再用BHR去寻址PHT，因此BHR的位宽决定了PHT的大小，BHR的宽度由<strong>分支指令序列的循环周期</strong>决定(如果BHR的宽度超过循环周期就会浪费PHT的存储空间)</li><li>分支指令序列：一般规律，如果一个指令序列中<strong>连续相同</strong>的数最多有P位，那么这个指令序列的循环周期就是P</li><li>该分支预测的大前提：每条分支指令都有自己的BHR和PHT</li><li>使用PC来寻址BHT和PHT，相当于很多PC值公用一个BHR，但通过PC的低位字段从PHTs中索引到相应的PHT(但是使用多个PHT会占空间)</li><li>使用哈希算法解决PC索引BHR的别名，使用拼接或者异或方法，解决不同分支指令的BHR的内容是一样，对应的PHT中的饱和计数器的值也一样的问题</li></ul><h5 id="基于全局历史的分支预测"><a href="#基于全局历史的分支预测" class="headerlink" title="基于全局历史的分支预测"></a>基于全局历史的分支预测</h5><ul><li>使用一个寄存器GHR(Global History Register)来记录<strong>所有分支指令</strong>在过去的执行情况</li></ul><h2 id="寄存器重命名"><a href="#寄存器重命名" class="headerlink" title="寄存器重命名"></a>寄存器重命名</h2><ul><li>重命名映射表(Register Alias Table, RAT)<ul><li>用来保存已经存在的映射关系(例如一个逻辑寄存器映射到了哪个物理寄存器)。源寄存器通过读取重命名映射表，就可以得到它的物理寄存器了</li></ul></li><li>空闲寄存器列表(Free Register List, FRL)用来完成这个过程<ul><li>用来记录哪些物理寄存器是空闲的。在寄存器重命名时会通过这个表格来获得空闲的物理寄存器的编号</li></ul></li><li>寄存器重命名方式<ol><li>将逻辑寄存器(ARF)扩展来实现寄存器重命名</li><li>使用统一的物理寄存器(PRF)来实现寄存器重命名</li><li>使用ROB来实现寄存器重命名</li></ol></li></ul><h2 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h2><ul><li>模块(module):包含输入和输出的硬件模块。如与门、多路选择器、优先级别编码器</li><li>模块的功能的主要形式<ul><li>行为模型(behavioral)。描述一个模块做什么</li><li>结构模型(structural)。应用层次化方法描述一个模块怎么由更简单的部件构造</li></ul></li><li>运算符优先级<ul><li><img src="/2023/03/23/IC-note/03/23/IC-note/img-2023-03-28-23-23-49.png"></li></ul></li><li>数字。声明常量的方法<code>N&#39;Bvalue</code>(如<code>9&#39;h25</code>表示9个bit的数十六进制值25), <code>N</code>表示位数，<code>B</code>表示基数(如<code>h</code>表示十六进制，<code>b</code>表示二进制)。注意<strong>这里的N标识bit数</strong><ul><li>若不写<code>N</code>，如<code>&#39;b11</code>，则在assign中赋值时将会自动进行拓展满足左值的位数</li><li>若不写<code>B</code>则默认为十进制数</li></ul></li><li>Z和X<ul><li><code>z</code>表示浮空值，如三态门使能位为0时，输出值为浮空</li><li><code>x</code>表示无效逻辑电平</li></ul></li><li>位混合。<code>assign y = &#123;c[2:1], &#123;3&#123;d[0]&#125;&#125;, c[0], 3&#39;b101&#125;</code>，将y赋予9位值$c_2c_1d_0d_0d_0c_0101$。<code>&#123;&#125;</code>用于连接总线，<code>&#123;3&#123;d[0]&#125;&#125;</code>表示<code>d[0]</code>的3个拷贝</li><li><code>assign</code>描述组合逻辑</li><li>vector(向量)。对相关的信号进行分组<ul><li>声明。注意与C语言不同的是，向量索引写在向量名称之前<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] w;         <span class="comment">// 8-bit wire</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">4</span>:<span class="number">1</span>] x;         <span class="comment">// 4-bit reg</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">0</span>] y;   <span class="comment">// 1-bit reg that is also an output port (this is still a vector)</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:-<span class="number">2</span>] z;  <span class="comment">// 6-bit wire input (negative ranges are allowed)</span></span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] a;       <span class="comment">// 4-bit output wire. Type is &#x27;wire&#x27; unless specified otherwise.</span></span><br><span class="line"><span class="comment">// 可以以这种方式切换大小端的表示方式</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">0</span>:<span class="number">7</span>] b;         <span class="comment">// 8-bit wire where b[0] is the most-significant bit.</span></span><br></pre></td></tr></table></figure></li><li>如果不用<code>[high:low]</code>方式进行声明，则称为<code>隐式网络(implicit nets)</code>会默认声明为<code>1bit</code>变量，注意隐式网络可能带来的错误。比如若向量赋值双方长度不匹配，则进行<code>零拓展</code>或<code>截断</code></li><li>访问向量元素(类似C语言数组)，如<code>w[3:0]</code>, <code>w[0]</code>等</li><li>完成一个四输入的与门可以用<code>=&amp;</code>技巧，对所有bit进行与，相当于C的<code>&amp;=</code><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> out_and,</span><br><span class="line">    <span class="keyword">output</span> out_or,</span><br><span class="line">    <span class="keyword">output</span> out_xor</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out_and =&amp; in;</span><br><span class="line">    <span class="keyword">assign</span> out_or =| in;</span><br><span class="line">    <span class="keyword">assign</span> out_xor =^ in;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li>向量连接运算符<code>&#123;&#125;</code>，可以将多个bit连接到一起</li><li>复制运算符。重复一个向量多次并连接到一起<code>&#123;num&#123;向量&#125;&#125;</code>这将向量<strong>复制</strong><code>num</code>次并连接到一起，num必须是常数。如<code>&#123;2&#123;a,b,c&#125;&#125;</code>与<code>&#123;a,b,c,a,b,c&#125;</code>一致。复制运算符能完成<strong>符号位拓展</strong></li></ul></li><li>模块。类似C语言的函数，可以进行传参<ul><li>构建实例。目的，通过传参将子模块的端口和模块端口连接<ul><li>通过位置<code>模块名 实例名 (wa, wb, wc);  // 按照参数顺序</code>。缺点，如果端口位置变化则需要重新编写</li><li>通过名字<code>模块名 实例名 (.当前模块端口名(wc), .当前模块端口名(wa), .当前模块端口名(wb));  // 可不按照参数顺序传参</code></li></ul></li></ul></li><li>过程<ul><li>always块。**具有更丰富的语句集(如<code>if-then</code>、<code>case</code>)**。<code>always</code>中要写多条语句必须得有<code>begin</code>和<code>end</code><ul><li>组合<code>always@(*)</code>，使用阻塞赋值。等同于<code>assign</code>语句。区别是<code>always块</code>赋值的对象必须是<strong>变量类型</strong>如(reg)；<code>assign</code>赋值的对象必须是**<code>net</code>类型**如(wire);<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> out_assign,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> out_alwaysblock</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always</span>@(*) out_alwaysblock = a &amp; b;</span><br><span class="line">    <span class="keyword">assign</span> out_assign = a &amp; b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li>时序<code>always@(posedge clk)</code>，使用非阻塞赋值。逻辑块的输出端创建一组触发器，逻辑块的输出不是立即可见的，而是仅在下一个(posedge clk)之后立即可见。括号里的<code>posedge</code>关键字指的是上升沿有效，<code>clk</code>为传入的时钟变量</li></ul></li><li><code>if-else</code>语句。如果嵌套中包含多于一条语句，则要搭配<code>begin</code>和<code>end</code><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">begin</span></span><br><span class="line">        out = x;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        out = y;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>if-else</code>语句，如果没有<code>else</code>分支，然后<code>if</code>也不满足的情况下，<strong>会生成一个锁存器存储当前的状态</strong></li></ul></li><li><code>case</code>语句。<code>case</code>以<code>endcase</code>结尾，其中<code>case</code>项中的语句后都需要加一个<code>;</code><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span>     <span class="comment">// This is a combinational circuit</span></span><br><span class="line">    <span class="keyword">case</span> (in)</span><br><span class="line">      <span class="number">1&#x27;b1</span>: <span class="keyword">begin</span> </span><br><span class="line">              out = <span class="number">1&#x27;b1</span>;  <span class="comment">// begin-end if &gt;1 statement</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">      <span class="number">1&#x27;b0</span>: out = <span class="number">1&#x27;b0</span>;</span><br><span class="line">      <span class="keyword">default</span>: out = <span class="number">1&#x27;bx</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>总是以<code>case</code>开头，没有<code>switch</code>语句，case语句的项和C语言一样以<code>:</code>结尾</li><li>每个<code>case</code>项只能执行一条语句，如果需要使用多个语句必须使用<code>begin</code>和<code>end</code></li><li>允许重复(和部分重叠)case的项(C语言不允许)</li></ul></li><li>阻塞分配和非阻塞分配。广义上说，表示组合逻辑内部无执行顺序(称为非阻塞)<ul><li>verilog三种类型的赋值<ul><li>连续赋值(<code>assign x = y;</code>)。不能在过程内部使用(始终阻塞)</li><li>过程阻塞赋值(<code>x=y;</code>)。只能在过程内部使用</li><li>过程非阻塞赋值(<code>x &lt;= y;</code>)。只能在过程内部使用</li></ul></li></ul></li></ul></li><li>三目元运算符实现四选一多路选择器<code>assign q = sel[1]? (sel[0]? c: b): (sel[0]? a: d);</code>。注意在括号中<strong>不需要</strong>加<code>;</code></li><li>对于时序电路硬件设计师应当具备<strong>逆向思维</strong>，先从输出思考，再考虑输入</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>为什么需要发射队列？<ul><li>若想在双发射超标量流水线中同时执行4条指令，就需要用到IQ，因为一些指令可能涉及到写回时相关性的停顿。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> IC设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/2023/03/20/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/03/20/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<!-- # 面经 --><blockquote><p>面试总要总结吧 <span id="more"></span></p></blockquote><ul><li>自我介绍<ul><li>面试官您好，我是，毕业于XXX大学计算机科学与技术专业。</li><li>在校期间，我独立完成了项目..., 在做项目期间遇到问题能谷歌/stackoverflow，查看相关手册，独立思考，并热衷于利用互联网与校外同学或网友交流讨论。</li><li>我对计算机系统方向如操作系统、计算机组成原理、计算机系统结构等相关课程感兴趣。</li><li>我不局限于学校所学内容，喜欢阅读原版技术书籍，文学类书籍。希望贵公司可以给我一个机会。</li></ul></li><li>进程间通信方式？<ul><li>信号</li><li>管道。 半双工通信方式(通常指无名管道PIPE)</li><li>消息队列。用一个链表来存储操作系统内核中的消息，并且使用“消息队列标识符”来标识消息队列。</li><li>共享内存。共享内存使用mmap，不同进程的虚拟地址映射到同一处物理地址进行通信</li><li>套接字</li><li>信号量。信号值为0下调用sem_wait()则会<strong>阻塞</strong>直到信号值大于0或者是信号中断处理的调用</li></ul></li><li>说一下多态？<ul><li>C++支持两种多态性：编译时多态(通过函数重载，泛型编程实现)，运行时多态(通过虚函数实现。常见通过派生类对象指针或引用, 赋给基类对象指针或引用)。</li><li>静态多态是指在编译期间就可以确定函数的地址，而动态多态需要等到运行时才能知道函数的地址</li></ul></li><li>了解线程池吗？<ul><li>一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。<strong>这避免了在处理短时间任务时创建与销毁线程的代价</strong></li><li>半同步半异步模式(采用Reactor模式作为事件处理模式)：分为同步层(用于处理客户逻辑)、队列层、异步层(用于处理I/O事件)三层。同步层的<strong>主线程(异步线程，不会出现阻塞)</strong>处理工作任务并<strong>存入</strong>请求队列，<strong>工作线程(同步线程)</strong>从工作队列<strong>取出</strong>任务执行，取不到任务的工作线程进入挂起状态<ul><li>缺点<ul><li>主线程往请求队列中添加<strong>任务</strong>，或者工作线程从请求队列中取任务都需要对请求队列加锁保护，从而白白耗费cpu时间</li><li>如果客户数量较多，工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢，如果通过添加工作线程来解决这一问题，工作线程的切换也将耗费大量CPU时间</li></ul></li></ul></li><li>领导者/追随者模式：程序仅有一个<strong>领导者</strong>线程(负责监听I/O事件)，其他线程则都是<strong>追随者</strong>。当前领导者如果检测到I/O事件，首先要从线程池中选出新的领导者线程，然后处理I/O事件。此时新的领导者等待新的I/O事件，而原来的领导者处理I/O事件，二者实现了并发<ul><li>优点：不需要在线程之间传递任何额外的数据，也无需像半同步半异步模式那样在线程之间同步请求队列的访问。</li><li>缺点：仅支持一个事件源集合</li></ul></li></ul></li><li>epoll，select，poll的区别？<ul><li>select<ul><li>每次调用select，都需要把fd集合从用户空间拷贝到内核空间(不论这些文件描述符是否就绪)，fd很多时开销就很大</li><li>每次调用select都需在内核遍历传递进来的所有fd, 线性扫描，即轮询是否有就绪的文件描述符, 效率低, 查询时间为O(n)</li><li>select支持的文件描述符数量太少(默认最大支持1024个)</li><li>fds集合不能重用</li></ul></li><li>poll<ul><li>相对于select<ul><li>无最大连接数限制，基于链表存储</li></ul></li><li>水平触发，报告fd后没有被处理，则下次poll时会再次报告该fd</li><li>解决了select第三第四个缺点</li></ul></li><li>epoll<ul><li>水平触发(LT)和边缘触发(ET)<ul><li>边缘触发若存在就绪的文件描述符只提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。所以ET模式下，read一个fd时，一定要把它的buffer读完，即直到read返回值小于请求值或遇到EAGAIN错误。</li><li>采用回调机制(使用<code>epoll_ctl</code>往内核事件表中注册)，即调用read/write处理I/O就绪事件，有信号发生则执行相应的处理函数，激活fd。</li><li>若用LT，若系统中有大量无需读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会降低效率</li></ul></li><li>对比select和poll省略了把fd集合从用户空间拷贝到内核空间(而是通过直接在内核空间中创建)，而且从内核空间拷贝到用户空间的fd集合是就绪fd集合(拷贝开销较小)</li></ul></li><li>三者对比：<ul><li>表面上看epoll性能远优于poll和select，但在连接数少且都十分活跃的情况下，select/poll性能可能比epoll好。</li></ul></li></ul></li><li>红黑树说一下？<ul><li>特化的平衡二叉树</li><li>查找、插入、删除的时间复杂度都是O(logn)</li><li>性质<ul><li>节点是红色或者黑色的</li><li>根节点是黑色</li><li>所有叶子都是黑色</li><li>每个红色结点的两个子结点都是黑色</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点</li></ul></li></ul></li><li>TCP，UDP的区别<ul><li>TCP是面向连接的、可靠的(确认应答、超时重传、冗余ACK)、有序的(序列号)；UDP是无连接的、不可靠的、无序的</li><li>TCP开销比UDP大，TCP头部需要20个字节，UDP头部只需要8个字节</li><li>TCP有拥塞控制，UDP没有拥塞控制</li><li>TCP通过字节流传输，UDP中每一个包都是单独的</li><li>TCP<strong>提供可靠的服务</strong>，适用于可靠性要求高的场景；UDP<strong>传输效率高</strong>，适用于高速传输和实时性要求的场景</li><li>TCP仅支持一对一连接</li></ul></li><li>TCP是如何保证可靠的？<ul><li>确认应答机制</li><li>重传机制(超时重传、冗余ACK)</li><li>序号(一个字节对应一个序号)</li></ul></li><li>UDP什么不可靠？<ul><li>不保证消息交付：不确认、无超时重传</li><li>不保证交付顺序：不设置序列号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不需要拥塞控制：不设置客户端或网路反馈机制</li></ul></li><li>线程池中线程是什么状态<ul><li>RUNNING。能够接收新任务，以及对已添加的任务进行处理</li><li>SHUTDOWN。不能接收新任务，但能处理已添加的任务</li><li>STOP。不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</li><li>TIDYING。当线程池中执行的任务为空时(即线程池中的当前活动线程降为0时)，STOP和SHUTDOWN状态会转换为TIDYING状态</li><li>TERMINATED。TYDYING执行terminated()，线程池彻底终止，变为TERMINATED状态</li></ul></li><li>UDP什么时候会出现丢包的现象<ul><li>UDP报文错误。系统会将错误报文直接丢弃</li><li>UDP接收缓冲区不足。接收报文速率过快，UDP报文超过缓冲区或MTU的大小，</li><li>防火墙</li></ul></li><li>线程切换用到的硬件有什么？<ul><li>寄存器组</li><li>程序计数器(PC)</li></ul></li><li>常见的系统调用有哪些？<ul><li>文件操作<ul><li>creat, read, write, open, close, link, unlink, chmod等</li></ul></li><li>过程控制<ul><li>fork, wait, exit, exec</li></ul></li></ul></li><li>什么是内联函数？<ul><li>内联函数编译时展开，省去了函数调用的开销(如将实参、局部变量、返回地址等压入栈中, 返回时还要弹栈)</li></ul></li></ul><h1 id="补充">补充</h1><h2 id="计网网络编程">计网/网络编程</h2><ul><li>https加密过程？<ul><li>对称加密："和日常中的钥匙差不多"</li><li>非对称加密：简单来说就是有两把钥匙，一把公钥，一把私钥。使用私钥加密的内容用公钥才能解开，同理，使用公钥加密的内容使用私钥才能解开</li><li>https采用非对称加密和对称加密<ol type="1"><li>某网站拥有用于非对称加密的公钥A和私钥A'</li><li>浏览器首先向网站服务器发送请求，服务器发回公钥A给浏览器</li><li>浏览器随机生成一个对称加密的密钥X，用公钥A加密后发给服务器</li><li>服务器用私钥A'解密并得到密钥X</li><li>这样双方都有密钥X了，且其他人都不知道，之后双方所有数据都通过密钥X加密解密即可</li></ol></li><li>中间人攻击解决方案<ul><li>数字证书，证明浏览器收到的公钥一定是该网站的公钥，浏览器进行验证</li></ul></li></ul></li><li>HTTP常见请求方法和区别？<ul><li>GET<ul><li>本质上用来请求服务器上的资源，资源通过一组HTTP头部和呈现数据返回给客户端。GET请求中，永远不会包含<strong>呈现数据</strong>。即GET请求只用来向服务器获取资源，而GET请求本身并不应该携带任何呈现数据</li><li>应用场景：<ol type="1"><li>登录时GET获取服务器数据库用户名和密码进行验证</li><li>下载文本、图片、音频时等获取服务器资源</li></ol></li></ul></li><li>POST<ul><li>用于将实体提交到指定的资源。数据被包含在POST请求体中。POST 请求可能会导致新的资源的建立或已有资源的修改。</li><li>应用场景<ol type="1"><li>提交用户注册信息</li><li>提交修改的用户信息</li></ol></li></ul></li><li>HEAD。<ul><li>和GET方法一样，只是不返回报文的主体部分(返回的响应没有具体内容)。用于确定URI的有效性及资源更新的日期时间等</li><li>应用场景：<ol type="1"><li>向服务器获取某些易过期或丢失的大型文件时，可以用HEAD方法查询是否存在</li></ol></li></ul></li><li>GET和POST的区别<a href="https://www.zhihu.com/question/28586791">见</a><ul><li>GET用来从服务器中的指定资源请求数据，POST将实体提交到服务器中的指定资源中</li><li>GET是幂等的(没有副作用)；POST是不幂等的(不能随意多次执行)</li><li>浏览器可以对GET请求的数据缓存；POST请求不能被浏览器缓存(能缓存意味者比如提交一份订单不会向服务器发送请求)</li><li>GET可收藏为书签; POST不可收藏为书签(因为是不幂等的，比如点一个书签就下一个单是很恐怖的事)</li><li>POST更安全(POST用HTTP请求body携带数据，GET用url携带数据)</li></ul></li></ul></li><li>TCP粘包了解吗？解决方法？UDP为什么不存在粘包？<ul><li><a href="https://developer.aliyun.com/article/644658">文章</a></li><li>通俗的来讲"我客户端调用了两次send，怎么服务器端一个recv就都读出来了？！"</li><li>TCP采用Nagle算法，合并相连的小的数据包，再一次性发送，来达到提升网络传输效率的目的。但是接收方并不知道发送包合并数据包，所以就导致接收方不能还原原始的数据包</li><li>解决方法：<ol type="1"><li>禁用nagle算法，只能解决发送方的问题，粘包还可能因为接收方，而且TCP传输效率降低了</li><li>自定协议，将数据报分为封包(为发送的数据增加包头，包头也可以包含校验信息)和解包</li></ol></li><li>UDP不是面向流的，发送的每个数据包都是独立的</li></ul></li><li>TCP三次握手？<ul><li>主要是为了确认双方接收能力和发送能力是否正常</li><li>第一次握手SYN=1, seq=x(客户端由CLOSED状态变为SYN_SEND), 第二次握手SYN=1, ACK=1, seq=y, ack=x+1(服务器端由LISTEN变为SYN_RCVD)，第三次握手ACK=1, seq=x+1, ack=y+1(客户端和服务器端都变为ESTABLISHED)</li></ul></li><li>为什么TCP握手不是两次？<ul><li>第一次握手确定客户端的发送能力和服务器端的接收能力，第二次握手确认服务器端的发送能力，如果没有第三次握手，不能确定客户端的接收能力是否正常</li></ul></li><li>TCP四次挥手？<ul><li>第一次挥手发送FIN=1，seq=u(客户端由ESTABLISHED变为FIN_WAIT1)，第二次挥手发送ACK=1，seq=v，ack=u+1（服务器端由ESTABLISHED变为CLOSE_WAIT），第三次挥手发送FIN=1，seq=w，ack=u+1(服务器端由CLOSED_WAIT变为LAST_ACK)，第四次挥手发送ACK=1，seq=u+1，ack=w+1</li></ul></li><li>为什么TCP挥手不是三次？<ul><li>服务器端在收到第一次挥手时可以将ACK和FIN一并发送出去，但是服务器并不会立刻关闭socket，只有等到服务器把所有的报文发送完了(TCP的半关闭特性，这样服务器还能发送，客户端还能接收)，才能发送FIN报文，因此是四次挥手</li></ul></li><li>time_wait为什么需要2MSL？<ol type="1"><li>确保被动关闭TCP链接的一端能收到第四次挥手的ACK</li><li>避免上一次TCP连接的数据包影响到下一次的TCP连接(若服务端没有收到ACK，会重发第三次挥手的FIN包，此时客户端新建了一个到服务端的TCP连接，并且客户端使用的还是之前的端口号，那么网络延迟到达的FIN包就会被这个新的TCP连接接收到，这不是客户端希望接收到的数据)</li></ol></li><li>给定一个网址，访问过程是怎么样的？<ol type="1"><li>浏览器向DNS服务器请求解析该URL中的域名所定义的IP地址</li><li>解析出IP地址后，根据该IP地址和默认端口号80，和服务器建立TCP连接</li><li>浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li><li>服务器对浏览器请求作出响应，并把对应的HTML文本发送给浏览器</li><li>释放TCP连接</li><li>浏览器解析该HTML文本并显示内容</li></ol></li><li>网络层有哪些协议？<ul><li>IP、ARP、ICMP、IGMP</li></ul></li><li>TCP第二次握手丢包处理？第三次？<ul><li>客户端第一次握手发送的SYN包、以及服务器端第二次握手的发送的SYN、ACK包会发生重传。有重传最大次数的限制</li><li>第三次握手丢包，第二次握手SYN、ACK包会重传，如果达到最大次数限制还未收到ACK，那么就是一个半连接的状态</li><li>每一次重传RTO(重传超时时间)就会重新计算</li></ul></li><li>网络I/O五层模型？<ul><li>阻塞I/O。执行I/O线程会被阻塞(比如socket缓冲区无数据但调用read去读)</li><li>非阻塞I/O。上述情况执行I/O线程不会被阻塞，返回EAGAIN或EWOULDBLOCK</li><li>I/O复用。在单进程/单线程中一次可以检测多个客户端的事件</li><li>信号驱动I/O(在多线程中不好处理)。<ol type="1"><li>使用linux相关的API(sigaction)，将信号处理程序的注册到服务器上，当读/写事件就绪时调用处理程序(将信号写入管道中)，然后在事件循环中解析该信号</li></ol></li><li>异步I/O</li></ul></li><li>close文件描述符后，epoll会不会把它自动从监听集合中删除呢？<ul><li>如果fd的引用计数是1，close之后会自动删除</li></ul></li><li>广播和多播的区别？<ul><li>广播(客户端绑定本地IP和端口，需要设置一下socket属性)只能用于局域网；多播即可用于局域网也可用于广域网</li><li>多播中客户端需要加入多播组才能接收到多播</li></ul></li><li>I/O多路复用是同步I/O还是异步的？<ul><li>同步</li></ul></li><li>TCP的队头阻塞？</li><li>UDP具体使用过程？</li></ul><h2 id="计组os">计组/OS</h2><ul><li>堆栈有什么区别?<ul><li>申请方式：栈由系统自动分配释放(如函数调用时存放函数的参数值，局部变量的值等)；堆需要程序员自己申请，并指明大小</li><li>申请效率：栈由系统自动分配，申请效率高；堆一般速度较慢，容易产生内存碎片。</li><li>增长方向：栈由高地址向低地址方向增长；堆由低地址向高地址方向增长</li><li>(堆), 空闲链表来管理，动态分配内存时空闲内存的管理：首次适配(不需要排序)、最佳适配(空闲分区按<strong>容量</strong>递增次序排序)、下次适配(在首次适配的基础上，每次分配内存时，从上次查找结束的位置开始查找)、最差适配(空闲分区按<strong>容量</strong>递减次序排序)</li></ul></li><li>静态库与动态库(共享库)？<ul><li>静态库在程序的链接阶段被链接到了程序当中；而动态库是由程序运行时动态加载到进程的虚拟地址空间里的</li><li>库的好处：代码保密、方便部署和分发</li><li>静态库浪费空间和资源，包括对程序更新、部署和发布都需要重新编译(因此衍生出了动态库)</li><li>动态库并不会链接到目标代码中，而是在程序<strong>运行时</strong>才被载入。不同的应用程序如果调用相同的库，那么共享内存(可实现进程间资源的共享)中只需要有一份实例</li></ul></li><li>死锁？<ul><li>死锁是指<strong>两个或两个以上</strong>的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种<strong>阻塞</strong>的现象</li></ul></li><li>自旋锁和互斥锁？<ul><li>加锁失败的处理<ul><li>互斥锁加锁失败后会进行线程切换</li><li>自旋锁(通过CPU提供的CAS(compare and swap), TAS原子操作)加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁</li><li>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁(因为线程互斥锁线程上下文切换的开销)</li></ul></li></ul></li><li>悲观锁和乐观锁（加场景）？<ul><li>悲观锁，认为多线程同时修改共享资源的概率比较高，因此访问共享资源前总会加锁</li><li>乐观锁(无锁编程，并没有加锁)，反之，会先修改完共享资源后再验证这段时间内是否发生冲突，如果没有则操作完成，有则放弃本次操作。</li><li>乐观锁重试的成本非常高，因此只有在锁成本高且冲突概率低的场景时，才考虑使用乐观锁，如：多人在线文档</li></ul></li><li>进程和线程？区别？<ul><li>进程是正在执行的程序实实例，执行程序时，内核会将程序代码载入虚拟内存中，并为程序变量分配空间，建立进程数据结构(记录如进程ID、用户ID、组ID以及终止状态等)。进程虚拟地址空间逻辑上划分为，栈区、堆区、数据区(初始化的全局和静态变量、未初始化的全局和静态变量(BSS))、文本区</li><li>线程共享同一数据区和堆，每个线程都有属于自己的栈，可以通过共享的全局变量进行通信，线程也能利用IPC的方式进行通信，多线程应用能从多处理器硬件的并行处理中得到性能的提升</li><li>区别：<ul><li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li><li>一个线程只能属于一个进程，而一个进程可以有多个线程</li><li>进程在执行过程中拥有独立的内存空间，而多个线程共享进程的内存空间</li><li>进程上下文切换的开销大，线程切换的开销小</li><li>进程间不会相互影响，而线程为了保证同步需要加锁</li></ul></li></ul></li><li>线程间的同步方式？<ul><li>互斥锁、自旋锁、读写锁、条件变量</li></ul></li><li>僵尸进程和孤儿进程？<ul><li>孤儿进程是指，父进程已经退出了，子进程还在运行，那么这些子进程将被init进程所收养，并由init进程对它们完成状态收集工作</li><li>僵尸进程是指，子进程退出了，但父进程并未调用waitpid/wait收集子进程状态信息，那么子进程的进程描述符仍然在系统中(如果有大量的僵尸进程，因为系统所能使用的进程号是有限的，就可能因为没有进程号而导致创建不了新的进程)</li></ul></li><li>死锁及避免？<ul><li>死锁预防，破坏四个必要条件之一：<ul><li>请求并保持，互斥条件，不可剥夺，循环等待</li><li>破坏<ul><li>请求并保持：一次性申请在整个运行过程中需要的全部资源</li><li>互斥条件：无锁编程</li><li>循环等待：按顺序申请资源</li><li>不可剥夺：如果某一个进程进一步的请求资源被拒绝，则释放该进程的资源</li></ul></li></ul></li><li>死锁避免，银行家算法</li></ul></li><li>如何检验死锁？<ul><li>死锁的检测算法通过检测有向图是否存在环来实现，从一个结点出发进行DFS，如果存在环，则出现死锁</li></ul></li><li>什么是mmap？<ul><li>是一种内存映射文件的方法，将一个文件映射到虚拟地址空间，实现这样的映射关系后，进程就可以采用指针的方式读写这一段内存，对文件的操作不再需要用read、write等系统调用。</li><li>mmap由操作系统负责管理</li></ul></li><li>条件变量和信号量的区别？<ul><li><strong>条件变量可以一次唤醒所有等待者</strong>(通过pthread_cond_broadcast唤醒所有阻塞的线程, pthread_cond_signal保证至少唤醒一条，效率较高)；而信号量不行</li><li>信号量可以指明有效资源的数量(是有值的)，而条件变量没有</li></ul></li><li>CAS?<ul><li><code>compare and swap</code>(传入三个参数)，通过检查内存位置中的值是否等于旧值，若未发生变化，则将新值更新到内存位置中。需要搭配Volatile使用(使编译器不再优化对该变量的ld和st)</li></ul></li><li>内存管理的方式？<ul><li>页式管理</li><li>段式管理</li><li>段页式管理</li></ul></li><li>字节对齐的好处？<ul><li>字节对齐能够更好地对指令进行译码，同时使得访问存储器的次数更少(比如获取一个8bit数据，主存宽度为8，如果字节不对齐，取数据需要访问两次存储器)</li></ul></li><li>为什么<code>pthread_create</code>第三个传入的参数为成员函数必须得是静态的？<ul><li>普通成员函数的参数会隐式存在一个默认的底层const的this参数，这就和pthread_create的第四个参数(参数列表)不匹配，编译器会报错。因为传入的是静态成员函数，若想使用成员变量，传入一个this指针即可(因为静态成员函数没有this指针)</li></ul></li><li>进程挂起态和阻塞态的区别？<ul><li>挂起是主动的；阻塞是被动的</li><li>挂起会因为主存资源不够将进程换出到磁盘交换区；</li><li>挂起会占用CPU资源(收到CPU的监督，等待激活)；阻塞可以通过上下文切换，不会占用CPU</li></ul></li><li>中断和异常的区别？<ul><li>中断一般由外部引起(如外部设备的中断)；异常一般由内部引起一般会重新执行处于异常的指令(如缺页异常)</li><li>中断会进行中断优先级的比较；异常没有</li></ul></li><li>虚拟内存的优势？<ul><li>程序的保护(每个进程有自己的虚拟地址空间)和共享(进程间通过共享内存通信)</li><li>内存管理的便利，如malloc可以分配不连续的物理地址空间，减少内存碎片</li><li>使得一个进程所占用的物理空间能够超过主存储器的空间(有一部分在磁盘的交换区)</li><li>可以管理每个页的访问权限(进程虚拟地址空间内核数据的部分是和物理地址空间一一映射的，不需要进行VA到PA的转换)</li></ul></li><li>为什么要引入Cache？<ul><li>充分利用局部性原理(时间局部性和空间局部性)</li><li>CPU和主存的速度相差三个数量级，指令和数据都需要到主存中去取(太慢)</li></ul></li><li>B+树和B树的区别？<ul><li>B+树范围查找更方便</li><li>B+树只有叶子节点存储数据指针；B树叶子节点和内部节点都存储数据指针</li><li>节点数量相同，B+的高度比B树更低</li></ul></li></ul><h2 id="cc">C/C++</h2><ul><li>malloc和new的区别？<ul><li>new是运算符(其中调用malloc)，malloc是库函数</li><li>new申请的堆大小由系统自动判断，malloc需要传递申请大小的参数</li><li>new返回相应类型的指针，malloc返回void*，需要强制转换</li><li>若new申请不到内存则会抛出异常，malloc返回NULL</li><li>new会调用构造函数，而malloc不会</li></ul></li><li>C++为什么构造函数不能是虚函数？<ul><li>因为虚函数的地址是通过虚函数表来查找的，虚函数表由实例化对象中的vptr指向，实例化对象需要构造函数完成初始化，但此时vptr还未初始化</li></ul></li><li>虚函数表在哪？虚函数指针vptr在哪？<ul><li>虚函数表在只读数据区；vptr一般在对象内存分布的第一个位置，对象的地址就是虚函数指针vptr的地址</li></ul></li><li>C++纯虚函数？<ul><li>没有函数体，只有声明</li><li>函数声明的结尾加上=0，告诉编译器这是纯虚函数</li><li>含纯虚函数的类称为抽象类，之所以抽象，因为它无法实例化。</li></ul></li><li>const限定的变量可以修改吗？怎么修改？<ul><li>mutable只能用来修饰类的数据成员，该成员可以在const成员函数内进行修改</li><li>如果是顶层const修饰的变量则不能修改</li><li>如果是指针变量，且用底层const修饰，那么该指针指向的值不能修改，但是指针值可以修改</li><li><code>const int* const p;  // 靠右的是顶层const，靠左的是底层const</code></li></ul></li><li>如何用C语言实现面向对象？<ul><li>面向对象三大特性封装、继承、多态，见<a href="https://schaepher.github.io/2020/03/12/c-oop/">文章</a></li><li>封装。可以将结构体的定义在<code>.c</code>文件中，<code>.h</code>中仅作结构体的声明, 这样其他文件就没办法直接访问结构体的具体内容。若想访问成员变量需要提供访问这些变量的方法,如 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">animalGetName</span><span class="params">(Animal this)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>继承。了解过C++内存模型之后很容易能知道，只需要定义"父类"作为"派生类"结构体成员(必须在第一个位置)，这样转换为父类指针时，子类结构体前面部分就是父类结构体了</li><li>多态。定义一个结构体作为虚函数表，在基类中增加虚表指针。虚表在构造函数中初始化，在析构函数中销毁。</li></ul></li><li>用过函数指针吗？<ul><li>本质上是一个指针，指向函数。通常用于函数回调的应用场景</li></ul></li><li>C++深拷贝和浅拷贝?<ul><li>若没有定义拷贝构造函数，编译器执行的是默认拷贝构造函数(浅拷贝)。如果类成员中有指针成员变量，对指针拷贝后会出现两个指针变量指向同一个内存单元，会出现两次析构，造成内存泄露，此时要采用深拷贝(即自己定义拷贝构造函数, 使拷贝后的对象指针成员有自己的内存空间)</li></ul></li><li>为什么在继承情况下析构函数要为虚函数？<ul><li>如果不是虚函数则会造成内存泄露，比如多态，delete父类指针后，仅调用父类的析构函数，子类析构函数并未被调用。但如果析构函数是虚函数，则会先调用子类析构函数再调用父类虚构函数(析构函数调用的顺序)</li></ul></li><li>C语言sizeof和strlen的区别？<ul><li>sizeof是运算符，用来求指定变量或变量类型所占内存空间的大小(单位为字节)，其值在编译时期就计算好了，因此只能算出静态的大小</li><li>strlen是库函数，用来求字符串的长度，它回去找字符串结尾的'\0'<strong>结束符</strong>(返回值不包括\0)；如果找不到，返回值会是一个不确定的值</li></ul></li><li>构造函数的顺序和析构函数的顺序原因？<ul><li>个人感觉是因为对象模型</li></ul></li><li>空类有哪些函数？空类的大小？<ul><li>有六个:<ol type="1"><li>默认构造函数</li><li>默认拷贝构造函数</li><li>默认拷贝赋值运算符</li><li>默认析构函数</li><li>取地址运算符</li><li>取地址运算符const</li></ol></li><li>编译器默认分配1 byte空间，编译器是支持空类实例化对象的，因此对象必须要被分配内存空间才有意义</li></ul></li><li>RAII机制？<ul><li>资源获取即初始化，利用C++构造的对象最终会被析构函数销毁的原则，进行资源的释放，避免内存泄露的风险</li></ul></li><li>四种类型转换<ul><li>const_cast, 消除底层const</li><li>static_cast, 只要不含底层const都可以使用，</li><li>dynamic_cast, 运行时进行类型转换的安全检查，用于基类和派生类之间的转换</li><li>reinterpreter_cast, 进行位模式上的强制转换</li></ul></li><li>vector在push_back的时候容量满了怎么办？<ul><li>capacity会变为原来的两倍。申请一块新内存，拷贝数据，释放原内存</li></ul></li><li>vector中resize和reserve的区别？<ul><li>resize是改变容器大小，且创建对象，如果改变之后的大小小于当前容器大小，则erase，否则insert</li><li>reserve指定容器预留的空间(改变可用空间的大小)，并未构造对象</li></ul></li><li>map和unordered_map的区别？<ul><li>map的底层是红黑树，存储的键是有序的。缺点:空间的开销</li><li>unordered_map底层是哈希表，存储的键是无序的。缺点：哈希表的建立费时</li></ul></li><li>C++常用<a href="https://refactoringguru.cn/design-patterns/cpp">设计模式</a>？<ul><li>TODO</li><li>工厂模式。抽象工厂定了用于创建不同产品的接口，但实际的创建工作留给了具体的工厂类</li><li>单例模式<ol type="1"><li>保证一个类只有一个实例(控制某些共享资源的访问权限，如数据库、文件)，因此将其构造和虚构函数用private修饰</li><li>为该实例提供一个全局访问的节点(使用一个静态成员变量存储指向该实例的指针，再用静态成员函数获取该静态成员变量)</li></ol></li><li>代理模式</li><li>策略模式</li><li>原型模式</li><li>模板模式</li></ul></li><li>对象的什么函数不能被声明为虚函数？<ul><li>非成员函数</li><li>静态成员函数。该类的所有对象都共享这份代码，<strong>不能被继承</strong>，没有动态绑定的必要性</li><li>内联成员函数。内联函数在编译期展开，virtual函数体现的是运行时机制</li><li>构造函数(上面有说过)</li><li>友元函数。本质上是因为C++不支持友元的继承</li></ul></li><li>指针和引用的区别？<ul><li>指针是存储变量地址的变量，引用是变量的别名</li><li>引用定义时必须初始化，而指针可以不必初始化</li><li>指针可以改变指向的存储单元，而引用初始化之后就<strong>不能改变了</strong></li><li><strong>sizeof</strong>指针变量可以得到一个字长的大小(32/64位机器)，而引用得到所指变量的大小</li><li>指针的自增标识指向下一个地址单元，而引用的自增表示引用变量值的增减</li></ul></li><li>哪几种情况必须用到初始化列表？<ul><li>const成员变量，不能赋值</li><li>引用成员变量，不能赋值</li><li>类成员没有默认构造函数的类类型</li><li>如果类存在继承关系，派生类必须在其初始化列表中调用直接基类的构造函数</li></ul></li><li>struct和class的区别？<ul><li>struct类成员默认是public，class是private(作用域限定)</li><li>struct默认是public继承，而class是private</li></ul></li><li>常见C++四大内存分区<ul><li>代码区</li><li>静态/全局数据区。包括常量区、静态区、全局区</li><li>栈区</li><li>堆区</li><li>其中const修饰的全局变量保存在代码区，const修饰的局部变量保存在栈区</li></ul></li><li>迭代器失效的情况？解决方案？<ul><li>在迭代时调用erase()、insert()、容器扩容(原来容器的迭代器失效)等</li><li>数组型数据容器(如vector、deque等，因为是连续分配的内存，所有元素的迭代器都会失效, 都向前/后移动了一个位置)</li><li>链表型数据容器(如list，因为是链式存储，插入和删除不会对其他迭代器造成影响)</li><li>树型数据容器(如map、set，删除、插入元素不会对其他元素造成影响，因此只是当前被删除的迭代器失效)</li><li>解决方法：<ul><li><strong>erase会返回当前删除的迭代器的下一个迭代器</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里想把大于2的元素都删除</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=q.<span class="built_in">begin</span>();it!=q.<span class="built_in">end</span>();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      it=q.<span class="built_in">erase</span>(it); <span class="comment">// 这里会返回指向下一个元素的迭代器，因此不需要再自加了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>++i和i++是原子操作吗？线程安全？<ul><li>不是，++i先自加再赋值，i++先赋值再自加</li><li>如果i是局部变量，那就是线程安全的(每个线程有自己的栈)</li></ul></li><li>宏和inline的区别<ul><li>宏<ul><li>没有类型检测，不安全，如： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sums(a,b) a+b  <span class="comment">// 这时候调用2*sums(a,b)会被解析为 2*a+b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sums(a,b) (a+b)  <span class="comment">// 这时候调用会被解析为2*(a+b)</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li>inline时将函数展开，减少函数调用的开销，编译器会进行安全检查</li></ul></li><li>C++重写和重载的区别？<ul><li>重写<ul><li>被重写的函数必须是virtual的(C++对象模型虚函数表)</li><li>函数名称、参数列表、参数个数、返回值类型都一致</li><li>访问修饰符(private等)可以不同</li></ul></li><li>重载<ul><li><strong>在一个类中</strong>(相同作用域)</li><li>函数名称相同</li><li>参数个数、参数类型、不同</li></ul></li></ul></li><li>emplace_back vs. push_back？<ul><li>push_back会先创建一个元素然后再将这个元素拷贝/移动到容器的尾部(push_back会优先调用移动构造，如果没有才调用拷贝构造)；而emplace_back直接在容器尾部直接构造，省去了拷贝/移动的过程。</li></ul></li><li>预处理阶段做的事情<ul><li>使用<code>gcc -E</code>，生成<code>.i</code>文件，将注释删去，将将头文件和宏进行展开和替换</li></ul></li><li>include防范？<ul><li>为了避免重复声明</li></ul></li><li>静态成员变量/函数的意义？<ul><li>使用静态成员变量实现<strong>多个对象之间的数据共享</strong>不会破坏隐藏的原则，保证了安全性还可以节省内存</li><li>编译器会在编译一个普通成员函数时，隐式地加上一个this指针。静态成员函数中没有this指针，因此只能访问静态成员变量</li><li>静态成员变量/函数声明时要加<code>static</code>，定义时不需要，编译器会去找声明</li><li><strong>静态成员不能在类内初始化，只能在类外初始化</strong>，<code>类型 类名::变量名 = 值</code></li></ul></li><li>虚函数和纯虚函数的区别？<ul><li>纯虚函数当前抽象基类的子类必须对该纯虚函数进行覆写；虚函数可以不需要</li><li>纯虚函数没有函数体；虚函数有函数体</li><li>纯虚函数在声明结尾加上=0 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚函数声明</span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 纯虚函数声明</span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li>构造函数和析构函数有返回值吗？<ul><li>它们都没有返回值</li></ul></li><li>命名空间的作用？<ul><li>处理常见的同名冲突，实际上是由程序设计者命名的内存区域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开</li></ul></li><li>C++中this指针什么情况下必须要用？<ul><li>重载赋值运算符通常返回<code>*this</code></li><li>把自己作为函数实参。</li></ul></li><li>#define INT 5是什么类型？<ul><li>预处理阶段不会进行类型检查(编译器做的事)，因此它没有类型</li></ul></li><li>NULL和nullptr的区别 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0  <span class="comment">// C++定义的NULL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)  <span class="comment">// C定义的NULL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>在C++中使用<code>nullptr(std::nullptr_t)</code>能隐式转换为其他类型的指针，但C++中不能将<code>void*</code>指针隐式转换为其他类型(反过来是可以的)</li><li>避免出现重载时的二义性，比如一个函数的参数为<code>void*</code>，另一个函数的参数为<code>int</code>，这时候编译器就会报错</li><li>模板的类型推导会将<code>NULL</code>推导为<code>long int</code></li></ul></li><li>C++模板类和普通类的区别？<ul><li>普通类都是在头文件中声明，在源文件中是实现；而模板类必须都放在头文件中</li><li>模板类和普通类都可以在类体中定义，但模板类在类体外定义要用函数模板</li></ul></li><li>函数默认参数？<ul><li>在声明时指定，定义时不指定</li></ul></li></ul><h2 id="other">Other</h2><ul><li>团队遇到分歧怎么办？<ul><li>在分歧中寻找共识，通过共识化解分歧</li><li>想想各自的出发点</li><li>承认冲突并找到解决方案</li></ul></li></ul><h2 id="反问环节">反问环节</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络系统编程笔记</title>
      <link href="/2023/03/20/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/20/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<!-- # 网络编程笔记 --><blockquote><p>捡起来做个毕设 <span id="more"></span></p></blockquote><h2 id="linux网络编程基础api">Linux网络编程基础API</h2><ul><li>创建socket通过socket系统调用，并传入(地址族、服务类型(如SOCK_STREAM)、具体协议(默认为0))，并返回一个socket文件描述符</li><li>使用bind()来命名socket，因为socket创建的时候并未给定socket地址，因此需要将socket绑定到socket地址上(这样客户端才能知道怎么连接它)</li><li>ipv4 socket地址结构(sockaddr_in)，包括地址族(6字节)、端口号(2字节)、IPv4地址结构(4字节) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sin_family;       <span class="comment">// 地址族：AF_INET</span></span><br><span class="line">  <span class="type">u_int16_t</span> sin_port;           <span class="comment">// 端口号，要用网络字节序表示(注意是2字节因此搭配htons使用)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>      <span class="comment">// 在写服务器程序的时候可以赋值为0(或INADDR_ANY)表示本机中所有的ip地址，</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  <span class="type">u_int32_t</span> s_addr;   <span class="comment">// IPv4地址，要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>对于socket来说，read(默认阻塞)返回0(i.e.EOF)就表示对端主动关闭了连接</strong></li><li>之所以区分监听描述符和连接描述符是因为(服务器不单是处理一个客户连接)</li><li>建立连接 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 都需要通用socket地址结构(sockaddr)作为参数(因为那时没有void*指针)，因此sockaddr_in需要强制转换为sockaddr通用socket地址结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// len用sizeof获取，单位为字节。因为strlen返回为字符数，刚好字符也为1字节，因此也可以</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> listenfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> sockaddr_len)</span>;</span><br><span class="line"><span class="comment">// backlog参数&quot;提示&quot;内核监听队列的最大长度，如果最大长度超过backlog服务器将不受理新的客户连接</span></span><br><span class="line"><span class="comment">// backlog只表示处于完全连接(ESTABLISHED)或半连接(SYN_RCVD)的socket上限</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> listenfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">// 默认情况下accept是阻塞的，addr为传出参数，传出的是peer socket(也就是客户端)的socket地址结构</span></span><br><span class="line"><span class="comment">// 成功时返回一个非负的连接文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> sockaddr_len)</span>;</span><br></pre></td></tr></table></figure></li><li>TCP数据读写(send)，UDP数据读写(recvfrom、sendto)，因为UDP没有连接的概念，因此进行读写的时候需要加上socket地址结构作为参数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// flags参数通常设置为0即可</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> socket, <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// src_addr为传出参数，如果不需要接收的socket地址结构信息，可以设置为NULL，*len也设置为NULL</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> socket, <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* src_addr, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line"><span class="comment">// dest_addr为对端socket的地址</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> socket, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* dest_addr, <span class="type">socklen_t</span>* addrlen)</span>;</span><br></pre></td></tr></table></figure></li><li>htons/ntohs，htonl/ntohl完成网络字节序与主机字节序相互之间的转换 在头文件<code>#include &lt;netinet/in.h&gt;</code>中</li><li>socket地址信息函数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr*, <span class="type">socklen_t</span>*)</span>;  <span class="comment">// 将当前连接socket本地端socket地址保存在参数2，3中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr*, <span class="type">socklen_t</span>*)</span>;  <span class="comment">// 将当前连接socket远端socket地址信息保存在参数2，3中</span></span><br></pre></td></tr></table></figure></li><li>IP地址点分十进制字符串与网络字节序整数的相互转换 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">void</span>* dst)</span>;  <span class="comment">// 将点分十进制字符串转换为网络字节序整数</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span>* dst, <span class="type">socklen_t</span>)</span>;  <span class="comment">// 最后一个参数指定目标存储空间的大小</span></span><br></pre></td></tr></table></figure></li><li>网络信息API(Ip地址和端口号不便记忆，可以通过主机名来替代IP地址，服务名来代替端口号)<ul><li>gethostbyname/gethostbyaddr(通过主机名或IP地址获取主机信息) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>; <span class="comment">// 会先再本地的/etc/hosts配置文件中查找，查不到再去本地dns服务器中查找</span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> type)</span>  <span class="comment">// type为地址族</span></span><br><span class="line"><span class="keyword">struct</span> hostent &#123;</span><br><span class="line">  <span class="type">char</span>* h_name;         <span class="comment">// 主机名</span></span><br><span class="line">  <span class="type">char</span>** h_aliases;     <span class="comment">// 主机别名列表</span></span><br><span class="line">  <span class="type">int</span> h_addrtype;       <span class="comment">// 地址族</span></span><br><span class="line">  <span class="type">int</span> h_length;         <span class="comment">// 地址长度</span></span><br><span class="line">  <span class="type">char</span>** h_addr_list;   <span class="comment">// 按网络字节序列出的主机IP地址列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>getservbyname/getservbyport <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent* <span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* proto)</span>;</span><br><span class="line"><span class="keyword">struct</span> servent* <span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span>* proto)</span>;  <span class="comment">// proto参数通常是&quot;tcp&quot;(获取流服务)、&quot;udp&quot;(获取数据报服务)、NULL(获取所有类型的服务)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* s_name;</span><br><span class="line">  <span class="type">char</span>** s_aliases;</span><br><span class="line">  <span class="type">int</span> s_port;</span><br><span class="line">  <span class="type">char</span>* s_proto;   <span class="comment">// 服务类型，通常是tcp或者udp</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>getaddrinfo，根据主机名获得socket地址 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname, <span class="type">const</span> <span class="type">char</span>* service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo* hints, <span class="keyword">struct</span> addrinfo** result)</span>;  <span class="comment">// result参数指向一个链表，该链表用于存储getaddrinfo反馈的结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo* res)</span>;  <span class="comment">// 对result这块区域的释放</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> ai_flags;</span><br><span class="line">  <span class="type">int</span> ai_family;               <span class="comment">// 地址族</span></span><br><span class="line">  <span class="type">int</span> ai_socktype;             <span class="comment">// 服务类型SOCK_STREAM</span></span><br><span class="line">  <span class="type">int</span> ai_protocol;             <span class="comment">// 与socket调用的第三个参数含义相同</span></span><br><span class="line">  <span class="type">socklen_t</span> ai_addrlen;        <span class="comment">// socket地址ai_addr的长度</span></span><br><span class="line">  <span class="type">char</span>* ai_canonname;          <span class="comment">// 主机的别名</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">ai_addr</span>;</span>    <span class="comment">// 指向socket地址</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">ai_next</span>;</span>    <span class="comment">// 指向下一个addrinfo结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>getnameinfo(与getaddrinfo是反着来的)，根据socket地址获得主机名 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回的主机名存储在host参数指向的缓存中，服务名存储在serv指向的缓存中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr* sockaddr, <span class="type">socklen_t</span> addrlen, <span class="type">char</span>* host, <span class="type">socklen_t</span> hostlen, <span class="type">char</span>* serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li>操作进程的命令<ul><li>strace：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹</li><li>ps：列出当前系统中的进程（包括僵尸进程）</li><li>top：打印出关于当前进程资源的使用信息</li></ul></li><li>全局变量environ指向环境变量列表的首地址</li><li>进程相关api <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>; <span class="comment">// 返回str1中第一次出现str2的位置，若不存在则返回NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// 如果overwrite覆写参数为1，如果环境变量列表中出现该变量，则覆写它; 0 otherwise</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 在当前进程的上下文中加载一个程序并运行</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">// 子进程复制父进程的虚拟地址空间，共享文件(继承了打开文件表)，相同但是独立的地址空间(相同的用户栈、堆、全局本地变量，代码段)</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dup2复制描述符表项oldfd到描述符表项newfd(底层中将描述符表项newfd的内容删除，</span></span><br><span class="line"><span class="comment">// 如文件打开表项、v-node表项。再将描述符表项newfd指向文件描述符表项所指的打开文件表项)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure></li><li>读取文件元数据 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// stat函数以一个文件名进行输入，fstat以一个文件描述符输入</span></span><br><span class="line"><span class="comment">// 两个函数用来获取当前文件的元数据并填写到stat结构体中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">dev_t</span> st_dev;              <span class="comment">// 设备</span></span><br><span class="line">  <span class="type">ino_t</span> st_ino;              <span class="comment">// inode</span></span><br><span class="line">  <span class="type">mode_t</span> st_mode;            <span class="comment">// 文件权限和类型</span></span><br><span class="line">  <span class="type">nlink_t</span> st_nlink;          <span class="comment">// 硬链接的个数</span></span><br><span class="line">  <span class="type">uid_t</span> st_uid;              <span class="comment">// 用户id</span></span><br><span class="line">  <span class="type">gid_t</span> st_gid;              <span class="comment">// 组id</span></span><br><span class="line">  <span class="type">dev_t</span> st_rdev;             <span class="comment">// 设备类型</span></span><br><span class="line">  <span class="type">off_t</span> st_size;             <span class="comment">// 整体大小(字节)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> st_blksize;  <span class="comment">// 文件I/O的块大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> st_blocks;   <span class="comment">// 分配块的数量</span></span><br><span class="line">  <span class="type">time_t</span> st_atime;           <span class="comment">// 最后访问的时间</span></span><br><span class="line">  <span class="type">time_t</span> st_mtime;           <span class="comment">// 最后修改的时间</span></span><br><span class="line">  <span class="type">time_t</span> st_ctime;           <span class="comment">// 最后改变的时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用宏</span></span><br><span class="line">S_ISLNK(st_mode)  <span class="comment">//是否是一个连接.</span></span><br><span class="line">S_ISREG(st_mode)  <span class="comment">//是否是一个常规文件.</span></span><br><span class="line">S_ISDIR(st_mode)  <span class="comment">//是否是一个目录</span></span><br><span class="line">S_ISCHR(st_mode)  <span class="comment">//是否是一个字符设备.</span></span><br><span class="line">S_ISBLK(st_mode)  <span class="comment">//是否是一个块设备</span></span><br><span class="line">S_ISFIFO(st_mode) <span class="comment">//是否 是一个FIFO文件.</span></span><br><span class="line">S_ISSOCK(st_mode) <span class="comment">//是否是一个SOCKET文件 </span></span><br></pre></td></tr></table></figure> ## 一些辅助函数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回指向s的指针</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 等同于memset(s, &#x27;\0&#x27;, n)的作用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span>* s, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 获取文件路径名的后缀部分</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">basename</span><span class="params">(filename)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程相关">线程相关</h2><ul><li>Posix线程相关API <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// tid为线程id，attr为线程属性(默认为NULL)，f为线程执行的函数，arg为线程执行函数的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span>* tid, <span class="type">pthread_addr_t</span>* attr, func* f, <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前线程的pid</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个api显示终止当前调用的线程</span></span><br><span class="line"><span class="comment">// 注意exit函数终止进程及所有进程相关的线程，释放内存和打开文件的资源，并返回相应的状态给父进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span>* thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收已终止线程的资源。该函数会阻塞直到线程tid终止，然后回收资源</span></span><br><span class="line"><span class="comment">// 返回thread_return参数，作为pthread_exit的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>;  <span class="comment">// 等待具体线程终止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程分为可分离的和可结合的，可结合的线程能够被其他线程回收和终止</span></span><br><span class="line"><span class="comment">// 在被回收之前它的内存资源(例如栈)是不释放的，调用它能够使线程变为可分离的</span></span><br><span class="line"><span class="comment">// 使得系统能够自动回收线程资源，避免内存泄漏。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br></pre></td></tr></table></figure></li><li>信号量。具有非负整数值的全局计数(用来记录所拥有的资源)，用来记录空闲的线程。如果该全局变量为0该线程将会阻塞(没有资源可取)，直到计数大于0<ul><li>P操作，挂起该线程。</li><li>V操作，唤醒该线程。</li><li>计数为1的信号量可作为锁。</li></ul></li><li>可重入函数(线程安全函数的<strong>真子集</strong>)，当它被多个线程调用时不会引入共享的全局变量</li><li>LWP(lighted weight process)</li><li><code>ps -Lf pid</code>查看当前进程下的线程<code>-f</code>标识整个format展示</li><li>为什么要有线程？<ul><li>进程间信息难以共享</li><li>fork创建进程的开销太大，即便有写时复制技术，还需要复制VA，复制页表，打开文件表(在进程结构中)等</li></ul></li><li>临界区：<strong>访问某一共享资源的代码片段</strong></li><li>pthread_t为无符号整型变量，printf时用<code>%ld</code>格式符</li><li>条件变量<code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</code>将会释解锁mutex并阻塞在条件变量上，成功返回后mutex被锁定并由调用线程拥有</li><li>信号量<code>int sem_init(sem_t* sem, int pshared, unsigned int value); // 在sem地址处初始化一个信号量</code>。如果pshared为0表示信号量在当前进程的线程之间共享(信号量的地址会在全局变量中)，如果pthread为非0则会在进程之间共享(信号量的地址会在共享内存中)</li></ul><h2 id="高级io函数">高级I/O函数</h2><ul><li>宏<ul><li>标准输入 STDIN_FILENO</li><li>标准输出 STDOUT_FILENO</li><li>标准错误 STDERR_FILENO</li></ul></li><li>pipe(用于IPC)<ul><li>内部传输的数据是字节流，linux管道容量的大小默认为65536字节</li><li>定义 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;  <span class="comment">// 两个文件描述符，fd[0]为读端，fd[1]为写端</span></span><br></pre></td></tr></table></figure></li><li>管道是半双工的，若要实现双向数据传输，应使用两个管道</li><li>默认情况下是阻塞的(管道空read就会被阻塞，管道满write就会被阻塞)</li><li>非阻塞管道(将fd[0]和fd[1]设置为非阻塞的)<ul><li>如果fd[0]的引用计数减少为0，即没有任何进程从管道中读数据，则针对fd[1]进行write将失败并引发SIGPIPE信号(默认执行动作时terminate)</li><li>如果fd[1]的引用计数减少为0，则对fd[0]进行read将会返回0，即EOF(表示对端关闭了连接)</li></ul></li><li>双向管道 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 直接创建双向管道(两个fd既可读又可写)，前三个参数与socket系统调用的参数一样</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li>dup2 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span>;  <span class="comment">// 返回一个新的fd，该fd与参数fd指向同一个打开文件表中的项</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;  <span class="comment">// 返回不小于newfd的整数值</span></span><br></pre></td></tr></table></figure></li><li>readv/writev。将多块分散的内存写入/读出fd，通常web服务器中的内容可以放在分散的内存中 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// vector参数类型是iovec结构数组，count表示数组的大小(即分散内存的个数)</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* <span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* <span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">  <span class="type">void</span>* iov_base;  <span class="comment">// 内存起始地址</span></span><br><span class="line">  <span class="type">size_t</span> iov_len;  <span class="comment">// 这块内存的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>snprintf将格式输出到缓冲区中，sprintf将格式输出到指针所指向的内存区域，printf将格式输出到标准输出。</li></ul></li><li>sendfile。函数在两个文件描述符之间直接传递数据(在内核中)，从而避免用户缓冲区和内核缓冲区之间的数据拷贝，实现了零拷贝 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/senfile.h&gt;</span></span></span><br><span class="line">  <span class="comment">// in_fd是写入的fd，out_fd是读出的fd，in_fd必须是一个类似mmap函数的文件描述符</span></span><br><span class="line">  <span class="comment">// 必须指向真实的文件，不能是socket和管道</span></span><br><span class="line">  <span class="comment">// offset指出从读入文件流的哪个位置开始读，如果为空，则使用默认起始位置</span></span><br><span class="line">  <span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span>;</span><br><span class="line">  ``到fd`</span><br><span class="line">- mmap。内存映射文件，可以将申请的这段内存作为进程间通信的共享内存(通过shm_open函数返回共享对象的fd供进程使用)，也可以将文件映射到其中</span><br><span class="line">  ``` c</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line">  <span class="comment">// start为用户虚拟地址，prot用于设置共享内存段的访问权限</span></span><br><span class="line">  <span class="comment">// PROT_READ, PROT_WRITE, PROT_EXEC, PROT_NONE</span></span><br><span class="line">  <span class="comment">// flags参数控制内存段内容被修改后程序的行为</span></span><br><span class="line">  <span class="comment">// mmap函数成功时返回指向目标内存区域的指针</span></span><br><span class="line">  <span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure></li><li>splice在两个文件描述符间移动数据(零拷贝操作)</li><li>tee在两个管道描述符之间复制数据(零拷贝操作)</li><li>fcntl(file control)。<ul><li>定义 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// cmd参数指定执行何种类型的操作，后面是可变参数类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure></li><li>常用操作及参数<ul><li>F_GETFD(无第三个参数)。获取fd的标志，成功时返回fd的标志</li><li>F_SETFD(第三个参数类型为long)。设置fd的标志，成功时返回0</li><li>F_GETFL(第三个参数类型为void)。获取fd的状态标志</li><li>F_SETFL(第三个参数类型为long)。设置fd的状态标志，成功时返回0</li><li>F_GETOWN(无第三个参数)。获得SIGIO和SIGURG信号的素组进程的PID或GID</li><li>F_SETOWN(第三个参数为long)。成功时返回0</li><li>F_GETSIG(无第三个参数)，获取当前应用程序被通知fd可读可写时是哪个信号通知的，返回信号值(0表示SIGIO)</li><li>F_SETSIG(第三个参数为long)，设置当fd可读/写时，系统应该触法哪个信号来通知程序</li></ul></li><li>fcntl函数还可以为目标文件描述符指定宿主进程，宿主进程将捕获信号(将信号和描述符关联起来)</li></ul></li></ul><h2 id="linux服务器程序规范">Linux服务器程序规范</h2><ul><li>服务器程序一般以后台进程(i.e. 守护进程)的方式运行；有一套日志系统(至少能输出日志到文件中)；服务器程序一般以一个专门的非root身份运行；Linux服务器通常是可配置的（用配置文件来管理）；会有一个PID文件记录后台进程的PID；需要考虑到系统资源的限制。</li></ul><h2 id="服务器框架">服务器框架</h2><ul><li>模块 <img src="/2023/03/20/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/img-2023-03-28-09-50-09.png"><ul><li>I/O处理单元:处理客户连接，读写网络数据</li><li>逻辑单元:业务进程或线程</li><li>网络存储单元:数据库、文件或缓存</li><li>请求队列(通常被实现为池的一部分):各单元之间的通信方式</li></ul></li><li>在处理I/O的时候，阻塞(进程放弃处理机处于暂停的状态)和非阻塞都是同步I/O，只有调用特殊的API才是异步I/O</li><li>同步I/O模型<ul><li>阻塞I/O，可能被阻塞的系统调用包括accept、send、recv和connect</li><li>非阻塞I/O，执行的系统调用<strong>无论事件是否发生总是立即返回</strong>。可以根据errno来区分情况：对accept、read、recv，事件未发生errno通常被设置为EAGIN或EWOULDBLOCK；对connect而言errno会被设置为EINPROGRESS(意为"在处理中")</li><li>I/O复用，应用程序通过I/O复用函数向内核注册事件，I/O复用函数本身是阻塞的(因此需要通过并发编程手段来提高服务器的性能)，可同时监听多个I/O事件</li><li>信号驱动I/O，比如<ol type="1"><li>通过SIGIO/SIGURG信号(必须与文件描述符关联使用)报告I/O事件。可以为一个目标文件描述符指定一个宿主进程，然后当描述符fd可读/写时，<strong>系统</strong>将触发相应的信号，目标文件描述符的宿主进程将捕获到信号，执行相应的信号处理函数(这一过程是异步的(注意不是异步I/O))</li><li>完成非阻塞I/O的操作(同步的过程)</li></ol></li></ul></li><li>异步I/O模型<ul><li>异步I/O，由操作系统告诉内核用户读写缓冲区的位置，以及I/O操作完成后内核通知应用程序的方式，包括文件的偏移量。异步I/O的读写操作总是立即返回，真正的I/O操作已经被内核接管(内核来执行I/O操作)。等最后<strong>完成写入</strong>后内核在通知用户写入完成</li></ul></li><li>同步I/O vs. 异步I/O<ul><li><strong>同步I/O</strong>向应用程序通知的是<strong>I/O就绪事件</strong>，而<strong>异步I/O</strong>向应用程序通知的是<strong>I/O完成事件</strong>。<strong>注意这里和接下来事件处理模式的同步和异步指的是何种I/O事件</strong></li></ul></li></ul><h2 id="事件处理模式">事件处理模式</h2><ul><li>服务器通常处理三类事件：I/O事件、信号及定时事件</li><li><strong>Reactor模式</strong>(使用同步I/O模型)，即I/O多路复用+非阻塞I/O<ul><li>利用I/O复用，分为主线程，请求队列，工作线程三部分。主线程往内核事件表中注册socket读就绪事件，epoll_wait等待socket上有数据可读，若有事件发生，通知主线程将事件放入请求队列中，睡眠在请求队列上的工作线程被唤醒，从socket上读取客户请求的数据，再注册socket可写事件，若<strong>socket可写</strong>，epoll_wait通知主线程，主线程将事件放入请求队列，工作线程将往socket上写入服务器处理客户请求的结果。</li></ul></li><li>Proactor模式(使用异步I/O模型)，可以勇reactor来模拟，使用主线程完成数据的读写</li><li>并发模式。是指I/O处理单元和多个逻辑单元之间协调完成任务的方式，这里的"异步"指的是程序的执行需要由系统事件来驱动(比如中断、信号)，半同步半异步模式允许一个线程同时处理多个客户连接</li></ul><h2 id="io复用">I/O复用</h2><ul><li>使用到I/O多路复用的场景<ul><li>客户端要同时处理多个socket</li><li>客户端要同时处理用户输入和网络连接</li><li>服务器要同时监听socket和连接socket</li><li>服务器要同时处理TCP请求和UDP请求</li><li>服务器要同时监听多个端口</li></ul></li><li>select系统调用 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">// nfds为被监听描述符的总数(通常为最大可分配的描述符值加1，因为从0开始)</span></span><br><span class="line"><span class="comment">// 后面三个分别指向事件对应的描述符集合，每一次select内核都会修改这些集合，因此每次select之后都要用宏初始化它</span></span><br><span class="line"><span class="comment">// timeout为0，select立即返回；为NULL则select一直阻塞直到某个fd就绪</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, <span class="keyword">struct</span> timeval* timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="type">long</span> tv_sec;  <span class="comment">// 秒级</span></span><br><span class="line">  <span class="type">long</span> tv_usec; <span class="comment">// 微秒级</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set结构体仅包含一个整型数组，每一位标记一个fd，能容纳的最大fd为1024</span></span><br><span class="line">FD_ZERO(fd_set* fdset);  <span class="comment">// 清除fdset的所有位</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set* fdset);   <span class="comment">// 设置fdset的位fd</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set* fdset);   <span class="comment">// 清除fdset的位fd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* fdset)</span>;  <span class="comment">// 测试fdset的位fd是否被设置</span></span><br></pre></td></tr></table></figure></li><li>poll系统调用 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// nfds为监听事件集合的大小，timeout为0立即返回，-1将阻塞直到有事件发生</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd* fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">short</span> events;  <span class="comment">// 注册的事件</span></span><br><span class="line">  <span class="type">short</span> revents; <span class="comment">// 实际发生的事件，由内核填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>事件类型<ul><li>POLLIN，数据可读</li><li>POLLOUT，数据可写</li><li>POLLRDHUP，TCP连接被对方关闭或对方关闭了写操作</li><li>POLLHUP，挂起</li><li>POLLNVAL，文件描述符没有打开</li></ul></li></ul></li><li>epoll系统调用<ul><li>内核事件表，epoll将关心的fd放入内核事件表中，<strong>epoll需要额外的文件描述符来唯一标识内核事件表，即epoll_create返回的epollfd</strong>。通过函数回调的方式来通知服务器有事件发生(即便有了非阻塞I/O，只有在事件发生的情况下，调用非阻塞I/O才能提高程序的效率)。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// size参数只是给内核一个提示告诉它内核事件表需要多大，返回的epollfd(非负fd)将用作其他所有epoll系统调用的第一个参数</span></span><br><span class="line"><span class="comment">// 手册中明确写了，当返回的epfd不用时，要调用close关闭它</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;  <span class="comment">// size参数在linux 2.6.8以后就被忽略了，但是必须要大于0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作内核事件表</span></span><br><span class="line"><span class="comment">// op参数对fd上的事件进行操作:EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL</span></span><br><span class="line"><span class="comment">// 并将改event参数表(添加/删除/改变)更新到epfd连接的内核事件表中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="type">__unint32_t</span> events; <span class="comment">// epoll事件</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;  <span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">  <span class="type">void</span>* ptr;</span><br><span class="line">  <span class="type">int</span> fd;       <span class="comment">// 用的最多</span></span><br><span class="line">  <span class="type">uint32_t</span> u32;</span><br><span class="line">  <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功时返回就绪fd的个数，只需要遍历+events数组即可处理事件，时间复杂度O(1)</span></span><br><span class="line"><span class="comment">// epoll_wait将就绪的事件(发生变化的fd)从内核事件表复制到第二个参数events中，maxevents限定events结构体的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li>epoll的ET和LT模式<ul><li>LT模式即水平触发，上一次就绪未处理的fd，后续epoll_wait还是会像应用程序通知该事件(就绪fd从内核事件表中复制到第二个参数events数组中)，直到事件被处理</li><li>ET模式即边沿触发，有事件发生应当立即处理，如果不处理后续epoll_wait将不会向应用程序通知该事件(很大程序上降低了一个epoll事件被重复触发的次数)，因此需要一次性读完或者写完。这也决定了使用ET模式的fd必须是非阻塞的，如果fd是阻塞的，读写操作将因为没有后续事件的发生而一直处于阻塞状态</li></ul></li><li>EPOLLONESHOT事件<ul><li>解决了在ET模式下，当一个fd数据未处理完，此时切换到另一个线程继续处理，这时出现了两个线程同时操纵一个fd的局面(我们期望的是一个socket连接在任一时刻都之被一个线程处理)。对于注册了EPOLLONESHOT事件的fd，os最多触发其上注册的一个读或写或异常事件，且<strong>只触发一次</strong>(需要再次注册该事件到fd上)，这时候就不会出现一个fd被两个线程同时读的情况了。</li></ul></li><li>C语言<code>char data[10] = &#123;0&#125;;</code>实际上就是赋值10个0字符</li></ul><h2 id="信号软件中断">信号(软件中断)</h2><ul><li>sigaction <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// signum为具体的信号(除了SIGKILL、SIGSTOP)</span></span><br><span class="line"><span class="comment">// 如果oldact不为NULL，那么之前的action将会被保存到oldact中(传出参数)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="comment">// 信号处理函数</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">// 不常用</span></span><br><span class="line">    <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="comment">// 临时阻塞的信号集，在调用处理程序handler时临时阻塞某些信号</span></span><br><span class="line">    <span class="comment">// 不允许这些信号中断处理程序handler的执行</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="comment">// sa_flag指定是用第一个sa_handler还是sa_sigaction进行处理，使用0是sa_handler</span></span><br><span class="line">    <span class="type">int</span>        sa_flags;</span><br><span class="line">    <span class="comment">// 被废弃掉了</span></span><br><span class="line">    <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>信号集，指定一组将由进程阻塞的信号集合 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标志位为1表示阻塞这个信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 清空信号集中的数据(即接收所有信号)，所有标志位置为0，参数为传出参数set</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将信号集中的标志位都置为1(即阻塞所有信号)，传出参数为set</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 往信号集中添加具体的信号，即阻塞某个具体的信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="netstat">netstat</h2><ul><li>使用<code>netstat -na | grep TIME_WAIT</code>查看time wait状态下的连接</li></ul><h2 id="gcc">gcc</h2><ul><li>参数<ul><li>-c编译而不进行链接</li><li>-S进行汇编</li><li>-E进行预处理</li><li>-I指定头文件所在的目录的相对位置</li><li>-D参数表示程序编译的时候指定一个宏，比如在文件中有<code>#ifdef DEBUG</code>语句，如果编译时不携带宏，那么DEBUG宏的值就默认是0。这个参数方便进行调试，发布release版本时，配合#ifdef屏蔽掉log信息。</li><li>-w参数屏蔽所有的警告，有时候警告会导致程序崩溃</li><li>-Wall生成所有的警告(如声明但未使用的变量就会提示警告)</li><li>-l程序编译时指定使用的库名称</li><li>-L编译时指定搜索库的路径</li><li>-fpic生成位置无关代码</li><li>-shared生成共享目标文件</li><li>-std参数指定C方言，gcc默认方言为GNU C</li></ul></li></ul><h2 id="静态库">静态库</h2><ul><li>命名。linux下静态库的命名位<code>libxxx.a</code></li><li>制作。使用ar(archive)工具，将<code>.o</code>文件制作成一个静态库，ar用到的参数<ul><li>-r。将所选文件添加到一个归档(archive)中</li><li>-c。(create)创建归档</li><li>-s。为这个文件插入一个索引</li></ul></li><li>在分发静态库时要将库文件和头文件一起分发</li></ul><h2 id="makefile">Makefile</h2><ul><li>Makefile其他规则一般都是为第一条规则服务的，如果规则用不到则不必执行。先检查依赖是否存在，再去执行相应的shell命令</li><li>变量。<strong>注意自动变量只能在当前规则中使用</strong><ul><li>自定义变量。<code>变量名=变量值</code></li><li>常用预定义变量。<ul><li><code>AR</code>：归档维护程序的名称，默认值为ar(制作静态库的工具)</li><li><code>CC</code>：C编译器的名称，默认值为cc</li><li><code>CXX</code>：C++编译器的名称，默认值为g++</li><li><code>$@</code>: 获取目标的完整名称</li><li><code>$&lt;</code>: 获取第一个依赖文件的名称</li><li><code>$^</code>: 获取所有的依赖文件</li></ul></li><li>获取变量的值<ul><li><code>$(变量名)</code></li><li><code>%</code>为通配符</li></ul></li><li><code>.PHONY:clean</code>表示clean是个伪目标，不会因为依赖而不执行clean</li></ul></li></ul><h2 id="http协议">HTTP协议</h2><ul><li>请求和响应的头以ASCII的形式给出；而消息内容具有一个类MIME的格式</li><li>请求报文：请求行、请求头部、空行、请求数据</li><li>web服务器解析请求，定位请求资源</li><li>响应报文：状态行、响应头部、空行、响应数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15445Fall2022 P0&amp;P1</title>
      <link href="/2023/02/14/15445Fall2022-P0-P1/"/>
      <url>/2023/02/14/15445Fall2022-P0-P1/</url>
      
        <content type="html"><![CDATA[<!-- # fall2022 --><blockquote><p>DB也算是程序员的浪漫吧</p></blockquote><span id="more"></span><h1 id="一起通关吧！CMU15445fall2022-project0-and-project1"><a href="#一起通关吧！CMU15445fall2022-project0-and-project1" class="headerlink" title="一起通关吧！CMU15445fall2022 project0 and project1"></a>一起通关吧！CMU15445fall2022 project0 and project1</h1><h2 id="Project0-C-Primer"><a href="#Project0-C-Primer" class="headerlink" title="Project0 C++ Primer"></a>Project0 C++ Primer</h2><ul><li><code>explicit</code>关键字用于防止构造函数发生隐式转换</li><li><code>noexcept</code>关键字用于使函数不抛出异常</li><li>左值和右值<ul><li>能对表达式取地址的为左值，否则为右值</li><li>具名变量都为左值，右值不具名</li><li>右值又分为：expiring value(将亡值)和pure rvalue(纯右值)</li><li>C++11中所有的值必属于左值、将亡值(C++11新增)、纯右值</li></ul></li><li>引用<ul><li>无论左值引用和右值引用都必须立即初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名</li><li>右值引用绑定一个右值引用类型变量就可以延长生命周期，利用这一特点可以做一些性能上的优化(如减少拷贝构造函数和析构函数的调用次数)</li><li>左值是指表达式结束后依然存在的持久对象;右值是指表达式结束时就不再存在的临时对象</li></ul></li><li>move constructor(移动构造函数), 移动堆中的资源，即不像拷贝构造函数一样复制现有对象的数据(在栈中)，而是声明对象的指针指向临时对象的数据并清空临时对象的指针。可以防止在内存中不必要地复制数据(i.e.不必要地调用copy constructor)</li><li>深拷贝 vs. 浅拷贝(i.e. 拷贝构造函数 vs. 移动构造函数)</li><li>std::move 并不会真正地移动对象，真正的移动操作是在移动构造函数、移动赋值函数等完成的，std::move 只是将参数转换为右值引用而已（相当于一个static_cast)</li><li>不能将一个unique_ptr直接赋值给另一个unique_ptr, 但可以用<code>std::move</code>来进行赋值，或者通过函数返回</li><li>std::move之后的右值, 表达式结束后就不再存在</li><li>继承关系，如果子类的构造函数没有<strong>显式</strong>地调用父类的构造函数，则默认调用父类的无参构造函数。</li><li>std::unique_ptr的引用不能绑定到派生类的unique_ptr，若想创建派生类的unique_ptr可以用多态</li><li>Trie的Remove需要用到辅助函数</li><li>std::unqiue_ptr有三种初始化方式，构造函数，std::make_unique，std::move</li></ul><h2 id="Project1-Buffer-Pool-Management"><a href="#Project1-Buffer-Pool-Management" class="headerlink" title="Project1 Buffer Pool Management"></a>Project1 Buffer Pool Management</h2><h4 id="Extendible-Hashing"><a href="#Extendible-Hashing" class="headerlink" title="Extendible Hashing"></a>Extendible Hashing</h4><ul><li>直接向下这一部分状态图是project给的本地测试，向右侧这部分状态是自己想的测试<img src="https://pic4.zhimg.com/80/v2-6a36ab1b74c03d7e7faedc5a5496836b.png" alt="状态图"></li><li>override关键字有两个用途:<ul><li>向读者表明这是个虚函数</li><li>编译器也知道这是个重载的方法，因此它可以检查你不是添加或者改变新的方法</li></ul></li><li>const_cast可以将non-const转换为const</li><li>桶在插入之前检测full再进行split</li><li>若global depth和local depth，具体见<a href="https://en.wikipedia.org/wiki/Extendible_hashing">wiki</a><ul><li>相等(即仅一个指针指向bucket)，则对dir_进行扩容</li><li>不相等(即多个指针指向bucket)，不需要对dir_进行扩容</li></ul></li><li>如果桶满了要对桶进行split(通过增加global counter), 然后根据上面的情况选择是否double dir_的大小(通过resize function)，reshuffle bucket, <strong>创建一个新的bucket</strong>，在bucket发生split时，增加新增桶和当前桶的局部深度，再retry</li><li><strong>只需要</strong>split<strong>当前</strong>full的bucket即可，将其映射到别的bucket, 注意bucket删除元素时，迭代器可能会失效(可以用一个del容器来收集要被删除的元素)</li><li>local counter is bookkeeping</li><li>extendible hashing可以将不同的哈希键映射到同一个桶里</li><li>std::vector::resize()函数可以对额外增加的元素数目进行初始化</li><li>remove函数可以在Bucket类中实现对每个bucket元素remove，再extendible hashing类中实现对哈希表元素的remove。</li><li>mutable关键字可以删除const的限定</li><li>std::scoped_lock提供了RAII机制(C++17特性)。</li><li>看了十一佬的博客后，几个关键的问题：<ul><li><strong>dir 扩容时，新的指针应该指向哪里</strong>？ A: split之后，扩容将增加一个bit。若除了增加的一位高位以外的bits都相等，则指向同一个bucket(称其为兄弟指针)，根据其扩容前的global depth和相应的掩码操作。</li><li><strong>如何重新安排指针？</strong> <strong>只需要重新安排split bucket的兄弟指针</strong>即可，可以对原哈希索引和当前索引进行比较，若不相同则需要重新安排指针。每次split都需要重新安排指针，兄弟指针如何分配? dir_中与插入index后local depth位相等的即为兄弟指针，增加local depth之后以掩码的方式重新分配兄弟指针(可以将其分为两组，高位分别是0和1，一组指向原bucket，一组指向新的bucket)</li></ul></li><li>在接口实现中获取数据成员时不要调用线程安全的接口，否则可能并发测试会特别慢</li><li>如果当前split bucket的local depth等于global depth，则不需要重新安排指针。</li><li>整个part的难点在split，可以分为以下几步<ul><li><ol><li>是否索引数组要扩容? 扩容伴随着全局深度的增加</li></ol></li><li><ol start="2"><li>新建bucket</li></ol></li><li><ol start="3"><li>重新安排指针</li></ol></li><li><ol start="4"><li>重新分配split bucket中的键值对</li></ol></li></ul></li><li>IndexOf通过global depth生成的mask与std::hash返回的键值进行<code>&amp;</code>操作返回哈希目录的index，找到具体的bucket。</li><li>这里实现的可扩展哈希，存储的值是<strong>KV对</strong></li><li>可扩展哈希的优势？</li></ul><h4 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h4><ul><li>LRU(LRU-1)为最近使用过1次，LRU-K为最近使用过K次</li><li>若少于K次访问的frame的distance被赋值为+Inf, 当frame的distance都是+Inf时，逐出frame中历史访问中时间戳最早(指的是<strong>当前frame的最早的访问记录</strong>)的那个(也就是经典的LRU算法)</li><li>frame被evict或者remove之后它的access history、映射也要被移除，evictable属性也要设置为false，frame的evictable属性可以用一个bool数组来记录。</li><li><code>[[maybe_unused]]</code>用于抑制未使用实体的警告(C++17特性)</li><li>std::advance可以增加迭代器的值</li><li>建议做这个part之前可以先去实现一下<a href="https://leetcode.cn/problems/lru-cache/">LC.146题</a></li><li>LRU-1可以用哈希表(unordered_map)+双链表(list)来实现</li><li>双链表不支持随机访问, list::splice(具体STFM)可以将被访问或刚插入的元素移动到双链表头。</li><li>list::splice可以将指定list中的迭代器指定的元素插入到this链表中的pos迭代器之前，就可以完成具体想要实现的功能, splice之后迭代器未失效(LRU-K的实现用不到这个方法)</li><li>list中存储<frame_id></frame_id></li><li>哈希表中存储&lt;frame_id, list的迭代器&gt;，方便找到frame id在list中对应的位置</li><li>可以用list::assign()为list进行初始化</li><li>每进行一次RecordAccess就增加timestamp的值，记录frame id每次的访问时间。同时也要更新链表中该frame id所在的位置</li><li>注意: 增加一个辅助的二维数组对K个access history的个数进行标记，每个record[frame_id]中存储timestamp</li><li>insert在当前迭代器之前插入元素</li><li>可以用std::prev和std::next来减少和递增迭代器, 注意std::next返回前进之后的迭代器，而std::advance不返回任何内容</li><li>记得保证所有操作都是线程安全的</li><li>cpp读写锁(c++14特性)。共享锁和排他锁不能同时持有，可以同时多个线程持有多个共享锁，排他锁只能一个线程持有。括头文件<shared_mutex>, 定义一个std::shared_mutex变量。共享锁上锁&#x2F;解锁(lock_shared&#x2F;unlock_shared)，排他锁上锁&#x2F;解锁(lock&#x2F;unlock)</shared_mutex></li><li>size_t(aka.long unsigned)需要8个字节的格式符，因此在printf的时候就不用4字节的%d而是%ld</li><li>如果当前frame的历史访问记录为0，那么再setEvictable()中即可直接返回(terminate)</li><li>frame_id大于等于0，小于replacer的大小</li><li>如果是简单的LRU-1&#x2F;LRU算法，用哈希表+双链表可以各操作保证O(1)的时间复杂度。若page引用大于等于K次即(LRU-K)，既比较最近它们的第K次时间戳，直接遍历record数组(注意要筛去访问次数小于k的frame以及non-evictable的frame)找到具有最早时间戳的frame并驱逐即可; 若page引用小于K次(即LRU-1)，则将这些page单独挑出来用LRU&#x2F;LRU-1即可。这样可以得到最高的效率。</li><li>如果要remove一个访问记录大于等于k的frame，直接删除record数组中的记录即可</li><li>LRU-K就是在LRU的基础上加了一些记录信息的容器而已。RecordAccess方法用来动态维护list;SetEvictable维护replacer的大小，设置evictable属性。</li><li>在维护LRU-1的链表时，如果元素重复访问，且访问记录次数小于k，不需要改变当前链表的状态，记录访问时间即可。 </li><li>注意这里用的unordered_map而不是上一节实现的可扩展哈希</li></ul><h4 id="Buffer-Pool-Managerment-Instance"><a href="#Buffer-Pool-Managerment-Instance" class="headerlink" title="Buffer Pool Managerment Instance"></a>Buffer Pool Managerment Instance</h4><ul><li>了解过OS的虚拟内存机制之后，Buffer pool的大致实现应该能理解。</li><li>对atomic对象的访问可以建立线程间同步并按照std::memory_order的规定对非原子内存访问进行排序; std::atomic即不可复制也不可移动</li><li><strong>Page对象</strong>成员page_id跟踪具体的物理页面，如果Page对象没有包含物理页，那么page_id就被设为INVALID_PAGE_ID(-1)；Page对象还包含了当前页的pin_count_(防止buffer pool evict这个页面)和is_dirty数据成员。p1之前实现的hashtable(page_id到frame_id的映射)和lru_k_replacer(跟踪要被evict的Page对象)将作为bufferpool的数据成员来实现</li><li>取frame先考虑freelist再考虑replacer</li><li>在DB中，又分为latch和lock。lock是高层次的原语，可以防止tuples，tables，databases受其他事务的影响。latch是低层次的原语(os中为lock)，DBMS用于临界区，或者是数据结构(i.e.哈希表)的内部。</li><li>page directory是page ids到数据库文件中page的位置的映射；page table是page ids到frame ids的映射</li><li>page_id<strong>是</strong>从磁盘中调页的页号</li><li>pages_即为<strong>缓冲池</strong>，存放磁盘页在主存中的缓存，free_list<strong>记录空闲帧的ID</strong></li><li>FetchNewPg如果所有frame都被pin住了就返回nullptr</li><li>用一个for循环遍历pages_数组来判断所有的frame是否正在使用，如果否则新建frame_id变量来记录free_list中或这是replacer中逐出的frame的id。</li><li>SetEvictable(frame_id, false)就相当于pin操作，了解过LRU-K的实现后，pin住了的frame就不会被驱逐</li><li>如果page和frame之间没有产生映射，那么page id应该初始化为INVALID_PAGE_ID</li><li>UnpinPgImp()中传入的is_dirty_参数只是告诉BPM刚刚对这个page进行读(FetchPg相当于进行读操作)还是写，unpin时不刷盘(这样也会降低性能)，在fetch页面或者new页面时刷盘(lazy的机制)，注意刷盘时传入FlushPgImg的page_id是刚被替换出去的frame的id，可以通过pages_[f_id].page_id，获取之前在frame上的page id(此时新映射的page id还未更新, 因此未覆盖)</li><li>UnpinPgImp()传入的参数如果为is_dirty，并不是要直接赋给当前的page(如果原先是dirty，传入的参数是false，不可将当前的frame设置为non-dirty)</li><li>ReadPage读page id在磁盘中存储的数据页</li><li>Fetch时先考虑Flush如果当前替换得到的frame上有脏数据先写到磁盘上，再ReadPage从磁盘中读取Fetch目标page在磁盘上的数据到这个frame上。否则会覆盖</li><li>使用memset c库函数初始化页的data_区域，初始化为PAGE_SIZE个’\0’</li><li>切记刷盘之后要初始化当前frame的data数据为空</li><li>Flush操作仅仅是将当前缓冲池中页的数据写回磁盘，然后将dirty flag置为false。</li><li>最后，结合文档中给的hint，加上自己的理解，注意细节，p1就完成啦</li><li><img src="https://pic4.zhimg.com/80/v2-d29cb8fe458758ce6555330b7ccc85bb.png" alt="Image"></li></ul>]]></content>
      
      
      <categories>
          
          <category> CMU15-445 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DB_Reading</title>
      <link href="/2022/12/27/DB-Reading/"/>
      <url>/2022/12/27/DB-Reading/</url>
      
        <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><ul><li>磁头浮在盘片上不接触盘片（否则会出现盘片损坏）</li><li>remapping of bad sectors, 若出现坏块且尝试写这个坏块时，可以重映射到别的物理块。 </li><li>性能指标: I&#x2F;O operations per second(IPOS), mean time to failure(MTTF)</li><li>FLASH: NOR FLASH、NAND FLASH</li><li>SSD are built using NAND flash</li><li>physical page需要定期擦除</li><li>hot data &amp; cold data</li><li>flash translation layer</li><li>flash支持I&#x2F;O并行请求</li><li>Hybird disk drives: 在磁盘中使用SSD作为cache缓存数据</li><li>数据库被映射到一些操作系统管理的文件中。</li><li>大多数db默认使用4到8k的block大小</li><li>一个block中可能包含多个records</li><li>要求records完整地包含在一个block中(即不能即包含在一个block又包含在另一个block中)，这样能加快访问数据的速度<h4 id="Fixed-Length-Records"><a href="#Fixed-Length-Records" class="headerlink" title="Fixed-Length Records"></a>Fixed-Length Records</h4></li><li>可以将最后插入的record放入被删除的record的位置，而不是整体移动插在最后(这样会移动很多次)</li><li>在文件起始位置分配一定数量的file header, 可以记录第一个被删除record的地址，然后第一个被删除的record位置又记录着第二个被删除的record的位置。这样就形成了<code>free list</code></li><li>当插入records时，找到free list的最后一个位置将record插入<h4 id="Variable-Length-Records"><a href="#Variable-Length-Records" class="headerlink" title="Variable-Length Records"></a>Variable-Length Records</h4></li><li>page layout:slotted-pages, log-structured</li><li>varchar类型&lt;偏移量，长度&gt;</li><li>变长记录的空位图记录哪一个属性是空值</li><li><img src="/2022/12/27/DB-Reading/12/27/DB-Reading/img-2022-12-27-17-33-42.png"></li><li>分槽的页结构，块头记录条目的个数，块中空闲空间的末尾处, 即尾部的开始处（方便插入），包含记录位置和大小的记录条目组成的数组</li><li><img src="/2022/12/27/DB-Reading/12/27/DB-Reading/img-2022-12-27-17-33-18.png"></li></ul><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><ul><li>如果数据库的页超过操作系统的标准页(4KB)DBMS将需要利用额外的手段来确保数据页原子写(在系统出现崩溃的时候)</li><li>如果两个表相关，DBMS会’pre-join’这样可以使得两个表在同一个页上，效率更高</li></ul><h4 id="Log-Structure-Storage"><a href="#Log-Structure-Storage" class="headerlink" title="Log-Structure Storage"></a>Log-Structure Storage</h4><ul><li>slotted-pages的一些缺点: Fragmentation、Unless Disk I&#x2F;O、Random Disk I&#x2F;O</li><li>每一个log record包含一个独立的标识符</li><li>DB可以将log压缩到一个表中，称为SSTable(Sorted String Table)</li><li>write amplification: 不断写同样的数据</li></ul><h4 id="Data-Representation"><a href="#Data-Representation" class="headerlink" title="Data Representation"></a>Data Representation</h4><ul><li>在tuple中的数据本质上是字节数组，DBMS将这些字节数组解释为什么属性取决于<code>数据的表示</code></li><li>五种高级数据类型: integers, variable-precision numbers, fixed-point precision numbers, variable length values, and date&#x2F;times.</li><li>整型数(INTEGER, BIGINT, SMALLINT, TINYINT)</li><li>可变精度数字(FLOAT, REAL)</li><li>定点精度数字(NUMERIC, DECIMAL)</li><li>可变长度值(VARCHAR, VARBINARY, TEXT, BLOB)。<ul><li>比较典型的是存在头部储一个跟踪长度的属性，方便跳到下一个值；其中可能也包括校验和</li><li>大多数DBMS不允许tuple的大小超过一个页，因此当tuple过大时，数据会存储在”overflow pages”中，并且tuple中会有到overflow pages的引用。</li><li>一些系统也会允许将数据存储在外部文件上，但DBMS不能操纵这些数据，同时这些数据也不具有持久性和事务保护。</li></ul></li><li>日期和时间(TIME, DATE, TIMESTAMP)<ul><li>可以表示从unix epoch开始的时间</li></ul></li><li>System catalogs<ul><li>为了解析tuple的内容，DBMS维护了一个内部目录来说明数据库的元数据。这些元数据包括表中的哪一列的类型和值是什么等信息。</li></ul></li></ul><h4 id="Database-Workloads"><a href="#Database-Workloads" class="headerlink" title="Database Workloads"></a>Database Workloads</h4><ul><li>OLTP(Online Transaction Processing)。OLTP一般处理更多的写相比于读</li><li>OLAP(Online Analytical Processing)。分析现有的数据并产生新的数据</li></ul><h4 id="Storage-Models"><a href="#Storage-Models" class="headerlink" title="Storage Models"></a>Storage Models</h4><ul><li>N-Ary Storage Model(NSM)。对于一个tuple的所有属性都在一个页里，适配OLTP<ul><li>优点：更快地插入，更新，删除；对需要整个tuple的查询有利</li><li>缺点：不利于扫描表的大部分或者属性的子集</li></ul></li><li>Decomposition Storage Model(DSM)。就是所谓的列存储，将一个属性列存储在一个块中，所有块连续存放。适配OLAP<ul><li>优点：减少大量的I&#x2F;O，因为DBMS在查询中只读数据；更好的查询处理和数据压缩</li><li>缺点：点查询，插入，更新和删除变慢，因为tuple中的属性分离</li><li>将属性列还原成原来的行存储有两种方法:<ul><li>每一列有同样的长度和offset</li><li>使用嵌入的tuple ids(如主键)。但这种方法会造成大量的存储开销</li></ul></li></ul></li></ul><h4 id="Database-Compression"><a href="#Database-Compression" class="headerlink" title="Database Compression"></a>Database Compression</h4><ul><li>压缩可以提高性能，尤其是对于那些只读的分析负载</li><li>压缩和解压也需要开销</li><li>如果数据集是完全的随机bit，将不能压缩</li><li>压缩策略：<ul><li>必须产生固定长度的值，唯一的例外，可变长度数据存储在分离的pools里</li><li>允许DBMS在查询执行过程中推迟解压</li><li>必须是无损的策略，任何有损的压缩将在应用级执行</li></ul></li><li>压缩粒度：<ul><li>Block Level: 压缩同一个表中的元组块</li><li>Tuple Level: 压缩整个tuples的内容(仅支持NSM)</li><li>Attribute Level: 压缩一个tuple的一个属性值，也可以针对同一个tuple的多个属性</li><li>Columnar Level: 压缩多个tuples中的多个属性值(仅支持DSM)</li></ul></li></ul><h4 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h4><ul><li>Spacial Control: 页被写到磁盘的哪个位置，应该保证页在磁盘尽可能物理上地紧挨着</li><li>Temporal Control: 合适将页读到内存中，何时将页写到磁盘中，目标是为了减少从磁盘读页造成的停顿</li><li>Locks vs. Latches: lock是高级原语用于保证的数据库内容(e.g. tuples, databases, tables)不受其他事务的影响；latch是低级原语，用于内部数据结构(e.g., hash tables, regions of memory)的临界区</li><li>Buffer Pool是磁盘页在内存中的缓存<ul><li>元数据: page table(类似于os的page table)，注意与page directory的区别，page directory映射页id到数据库文件中的页的位置，对page directory的所有改变都必须记录在磁盘上，以便DBMS重启时能找到。page table的每一页还可能包含:脏位，pin计数等元数据</li><li>内存分配策略：全局(对于整个工作负载有利)和局部(对于单个查询或事务有利)策略。tradeoff，大多数系统一般组合它们使用</li><li>优化：pre-fetching</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP: Attack Lab</title>
      <link href="/2022/06/15/CSAPP-Lab3-Attack-Lab/"/>
      <url>/2022/06/15/CSAPP-Lab3-Attack-Lab/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个人几乎可以在任何他怀有无限热忱的事情上成功。</p></blockquote><span id="more"></span><h2 id="Part-I-Code-Injection-Attacks"><a href="#Part-I-Code-Injection-Attacks" class="headerlink" title="Part I: Code Injection Attacks"></a>Part I: Code Injection Attacks</h2><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><ul><li>要注意<strong>小端字节序</strong>在内存中的布局</li><li>若Gets函数返回值不为1则出现<code>segmentation fault</code></li><li>进入gdb进入buf函数之后，<code>info frame</code>查看栈帧信息。<code>getbuf</code>函数没有参数，局部变量的起始地址都为<code>0x5561dc70</code>，在开辟栈帧时先将返回地址(i.e.getbuf函数下一条指令的地址)压入栈中<code>0x5561dca0</code>处，再将栈顶指针<code>rsp</code>减少<code>0x28</code>到<code>0x5561dc78</code>。注意输入的<code>exploit string</code>的末尾会自动加上一个<code>null</code>(i.e.<code>\0000</code>)。还要注意<code>little endian</code>的问题(比如局部变量buf数组会将栈中连续地址的内容以<strong>字节</strong>按照小端字节序来排列，返回地址是指针值64-bit，8个字节按照小端字节序排列)。因为栈开辟的栈的大小为40个字节，一个字符为1字节。因此输入40个空字符(0x00)后，再紧跟着14个十六进制数(最后会自动补上一个00)表示返回地址(i.e.<code>touch1</code>的入口地址<code>0x4018c0</code>)，即<code>c0 18 40 00 00 00 00</code>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info frame</span><br><span class="line">Stack level <span class="number">0</span>, frame at <span class="number">0x5561dca8</span>:                         ; level <span class="number">0</span>表示帧由高地址向低地址增长</span><br><span class="line"> rip = <span class="number">0x4017ac</span> in getbuf (buf.c:<span class="number">14</span>); saved rip = <span class="number">0x401976</span>  ; 返回地址<span class="number">0x401976</span></span><br><span class="line"> called by frame at <span class="number">0x5561dcb8</span>                              ; 调用者栈帧的地址</span><br><span class="line"> source language c.</span><br><span class="line"> Arglist at <span class="number">0x5561dc70</span>, args:</span><br><span class="line"> Locals at <span class="number">0x5561dc70</span>, Previous frame<span class="number">&#x27;</span>s sp is <span class="number">0x5561dca8</span>    ; 上一帧的栈指针指向的地址为<span class="number">0x5561dca8</span></span><br><span class="line"> Saved registers:</span><br><span class="line">  rip at <span class="number">0x5561dca0</span>                                         ; 返回地址被保存到<span class="number">0x5561dca0</span> </span><br></pre></td></tr></table></figure></li><li>紧接着输入<code>./ctarget &lt; exploit01-raw.txt -q</code>，phase1 passed!<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: <span class="number">0x59b997fa</span></span><br><span class="line">Type <span class="built_in">string</span>:Touch1!: You called <span class="title function_">touch1</span><span class="params">()</span></span><br><span class="line">Valid solution <span class="keyword">for</span> level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 </span><br></pre></td></tr></table></figure></li></ul><h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><ul><li>附录B中提到了，可以先编写汇编代码，通过GCC进行编译汇编但不链接，产生obj文件。最后再将obj文件用<code>objdump</code>进行反汇编，将指令的<code>bytes code</code>提取出来，并通过<code>./hex2raw</code>生成带有C风格的注释</li><li>根据题目的意思，应该就是在<code>level 1</code>的基础上<code>getbuf</code>返回到一段自己的注入代码(在缓冲区中)，完成将cookie传递到rdi后再执行ret指令返回到<code>touch2</code>并传递一个参数来供<code>touch2</code>函数进行检查。所以我们先创建一个<code>example.s</code>文件然后通过GCC进行编译汇编但不进行链接，最后再使用<code>objdump</code>来反汇编代码得到<code>byte code</code>然后放到我们的<code>exploit string</code>中，进行攻击代码注入。</li><li>注意ret会将栈顶元素弹出并赋给PC(因此在从注入代码返回到<code>touch2</code>时需要执行<code>pushq</code>指令将<code>touch2</code>的地址压入栈中，再执行<code>ret</code>)。下面是攻击代码，这里我将它放到栈帧顶处<code>0x5561dc78</code>。因为栈帧顶为低地址，程序执行由低地址到高地址，我们将mov指令放到栈帧顶。试了一下好像只有<code>AT&amp;T</code>语法进行反汇编才能PASS(别忘了这是GCC、OBJDUMP和其他一些工具的默认格式)。这是进行反汇编后的代码：<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">example.o:</span>     file format elf64-x86-<span class="number">64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of <span class="meta">section</span> .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;.text&gt;:</span><br><span class="line">   <span class="number">0</span>:<span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span> <span class="keyword">mov</span>    <span class="number">$0</span>x59b997fa,%rdi</span><br><span class="line">   <span class="number">7</span>:<span class="number">68</span> ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span>       pushq  <span class="number">$0</span>x4017ec</span><br><span class="line"><span class="symbol">   c:</span>c3                   retq   </span><br></pre></td></tr></table></figure></li><li>phase2 passed!<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: <span class="number">0x59b997fa</span></span><br><span class="line">Type <span class="built_in">string</span>:Touch2!: You called <span class="title function_">touch2</span><span class="params">(<span class="number">0x59b997fa</span>)</span></span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00</span><br></pre></td></tr></table></figure></li></ul><h3 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h3><ul><li>应题目要求，先将cookie中的8个hex以ASCII字符的形式来表示，随后将这个字符串放入缓冲区中，再将它的起始地址放入rdi中作为touch3的第一个参数，其中调用的hexmatch会将cookie的hex形式与ASCII形式进行比较看输出是否正确，输入参数的过程需要代码注入</li><li>我的cookie为<code>0x59b997fa</code>转换为ASCII为<code>35 39 62 39 39 37 66 61</code>，别忘了以空字符<code>00</code>作为结尾，一共占用9个字节。因为<code>hexmatch</code>中<code>s</code>的位置是随机的有可能会覆盖掉getbuf中的缓冲区(实验手册说明的)，因此我们得把字符串的地址放在比较安全的地方，也就是调用<code>getbuf</code>之前，在<code>text</code>的栈帧中，于是我们选择放在<code>text</code>的栈帧顶<code>0x5561dca8</code>也就是getbuf缓冲区中第48个字节起始的位置。在level2的基础上，需要考虑<strong>缓冲区被随机覆盖</strong>的情况</li><li>反汇编后的代码:<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">example3.o:</span>     file format elf64-x86-<span class="number">64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of <span class="meta">section</span> .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;.text&gt;:</span><br><span class="line">   <span class="number">0</span>:<span class="number">48</span> c7 c7 a8 dc <span class="number">61</span> <span class="number">55</span> <span class="keyword">mov</span>    <span class="number">$0</span>x5561dca8,%rdi</span><br><span class="line">   <span class="number">7</span>:<span class="number">68</span> fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span>       pushq  <span class="number">$0</span>x4018fa</span><br><span class="line"><span class="symbol">   c:</span>c3                   retq   </span><br></pre></td></tr></table></figure></li><li>提取指令的字节序列放入缓冲区中</li><li>phase3 passed!:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: <span class="number">0x59b997fa</span></span><br><span class="line">Type <span class="built_in">string</span>:Touch3!: You called <span class="title function_">touch3</span><span class="params">(<span class="string">&quot;59b997fa&quot;</span>)</span></span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 </span><br></pre></td></tr></table></figure></li></ul><h2 id="Part-II-Return-Oriented-Programming"><a href="#Part-II-Return-Oriented-Programming" class="headerlink" title="Part II: Return-Oriented Programming"></a>Part II: Return-Oriented Programming</h2><ul><li>RTARGET相比较于CTARGET用到了栈随机化的方式，因此很难决定注入代码的位置。以及因为可执行控制位的限制，在那一部分内存中执行注入代码会出现，<code>segmentation fault</code>的错误</li><li>ROP(return-oriented programming)，区分已经存在的字节序列，这些指令后面紧跟着ret指令。<h3 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2"></a>Level 2</h3></li><li>只能使用前八个寄存器(%rax~%rdi)；提示了当前所需的指令序列在start_farm到mid_farm之间；只能使用两个gadgets</li><li>建议中提示使用会使用到<code>pop</code>指令，可以将<code>cookie</code>放到test栈帧顶，然后通过pop指令将其送到指定的rdi寄存器中。但是很遗憾没有找到字节编码为<code>0x5f</code>的<code>pop %rdi</code>指令，然后想到可不可以将它pop到rax寄存器后再将它mov到rdi寄存器中呢?!答案是可以的</li><li>从farm中提取<code>movq %rdi, %rsi</code>指令，指令起始地址为<code>0x4019c5</code>:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000004019</span>c3 &lt;setval_426&gt;:</span><br><span class="line">  <span class="number">4019</span>c3:c7 <span class="number">07</span> <span class="number">48</span> <span class="number">89</span> c7 <span class="number">90</span>    movl   $<span class="number">0x90c78948</span>,(%rdi)</span><br><span class="line">  <span class="number">4019</span>c9:c3                   retq   </span><br></pre></td></tr></table></figure></li><li>从farm中提取<code>popq %rdi</code>指令，指令起始地址为<code>0x4091ab</code>:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000004019</span>a7 &lt;addval_219&gt;:</span><br><span class="line">  <span class="number">4019</span>a7:<span class="number">8</span>d <span class="number">87</span> <span class="number">51</span> <span class="number">73</span> <span class="number">58</span> <span class="number">90</span>    lea    <span class="number">-0x6fa78caf</span>(%rdi),%eax</span><br><span class="line">  <span class="number">4019</span>ad:c3                   retq  </span><br></pre></td></tr></table></figure></li><li>在返回地址处存放gadget0&lt;addval_219+4&gt;的入口地址，也就是getbuf栈帧执行结束返回的地址。getbuf执行结束后，将入口地址赋给PC，程序将跳转到addval_219+4处执行popq指令，将存储在test栈帧顶的cookie弹出，然后栈顶指针rsp向高地址移动8个bit，此时指向的是gadget1&lt;setval_426+2&gt;的入口地址。在gadget0执行结束时，执行ret，会将gadget1的地址弹出作为PC的跳转地址并将栈顶指针向高地址移动8个bit，随后跳转到gadget1执行。紧接着在连续的地址单元中存放的是touch2的入口地址，在gadget1返回后，已经将cookie放入到rdi寄存器中作为参数，执行ret后将存放在test栈帧中的入口地址弹出，跳转到touch2中执行，完成ROP！</li><li>注意ret弹的是64位的地址值。</li><li>这时候仔细想想，前面几个level是不是也能按照这样的思路完成呢？比如说在返回地址处也放一条pop指令，随后在test栈帧处注入攻击代码。</li><li>phase4 passed!:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: <span class="number">0x59b997fa</span></span><br><span class="line">Type <span class="built_in">string</span>:Touch2!: You called <span class="title function_">touch2</span><span class="params">(<span class="number">0x59b997fa</span>)</span></span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><blockquote><p>Option考上master之后再继续完成吧</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> CMU15-213 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DLX Lab</title>
      <link href="/2022/06/01/DLX-Lab/"/>
      <url>/2022/06/01/DLX-Lab/</url>
      
        <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><h2 id="Lab1-WinDLX使用及指令流水线冲突性分析"><a href="#Lab1-WinDLX使用及指令流水线冲突性分析" class="headerlink" title="Lab1 WinDLX使用及指令流水线冲突性分析"></a>Lab1 WinDLX使用及指令流水线冲突性分析</h2><ul><li>首先载入<code>GCM.S</code>和<code>INPUT.S</code>两个汇编程序(GCM.S中需要用到INPUT.S程序代码)，它们会被<strong>重定向</strong>到同一个目标文件中。</li><li>通过观察<code>WinDLX</code>的<code>Code</code>窗口、<code>Clock Cycle Diagram</code>窗口以及<code>Memory/Symbols</code>菜单栏，可以发现<code>Data</code>段是由<code>0x1000</code>开始的，而且<code>0x1000</code>存放的同时也是<code>Prompt1</code>标号的起始地址。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-02-15-31-53.png"></li><li><code>GCM.S</code>中，首先将<code>Prompt1</code>提示符保存到<code>R1</code>寄存器中之后然后<code>jal指令</code>无条件跳转到<code>InputUnsigned</code>标号处(在<code>Text</code>段中，地址为<code>0x144</code>)。这里会出现一次<strong>控制冲突</strong>，紧跟在<code>jal指令</code>后面的<code>add指令</code>会被清空(注意跳转发生在第二个stage，因此只清空后面紧跟着的一条指令)。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-02-15-36-49.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-09-25-30.png"></li><li>进入<code>InputUnsigned</code>的内部先完成<code>Callee save</code>，将<code>R2</code>到<code>R5</code>寄存器保存到<code>SaveR2</code>到<code>SaveR5</code>(分别用<code>space.</code>指令以4字节填充地址单元的地址)</li><li>无论何时遇到一条trap指令时，DLX处理器的流水线将被清空(即<code>trap</code>一直在<code>IF</code>阶段停顿直到当前流水线中的指令执行完毕)<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-09-22-43.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-09-24-56.png"></li><li><code>.word</code>指令表示就将后面的内容以字为单位连续存储到内存中。</li><li><code>trap 5</code>将<code>r14</code>中的字符串重定向到标准输出(i.e.显示提示符)</li><li><code>trap 3</code>将标准输入重定向到<code>r14</code>中(i.e.从控制台中读取用户输入的数字，以回车作为结束)</li><li>在循环处理前将<code>r1</code>置为0用于保存最后的结果。</li><li>循环读取输到<code>ReadBuffer</code>中的数据直到读取到<code>Line Feed</code>回车键，通过<code>seqi</code>指令将<code>r3</code>寄存器与回车键的<code>ASCII</code>值进行比较对<code>r5</code>寄存器进行赋值。然后<code>bnez</code>根据<code>r5</code>寄存器的值来选择是否跳转到<code>Finish</code>标号。再将当前数值减去48(0x30)将ASCII数字字符转换为二进制数。将<code>r1</code>乘10之后再加上从<code>ReadBuffer</code>中读取的数字(目的是为了将控制台中输入的数字转换成二进制数)，最后再移动<code>ReadBuffer</code>指针以取下一个字符。最后完成<code>restore</code>回到<code>GCM.S</code>中。</li><li>观察可以发现<code>jar</code>跳转到label前会把当前指令的下一条指令的地址放入<code>r31</code>中以便返回。</li><li><code>lbu r3, 0x0(r2)</code>和<code>seqi r5, r3, 0xa</code>之前存在r3寄存器RAW数据相关导致的数据冲突。因为lbu指令需要访问存储器，最快取出数据也是在MEM阶段末，但在此时seqi指令已经处于第三个阶段并已经经过ALU了。为了解决这种数据冲突，只通过转发是不能解决的(时光不能倒流)，还需要通过在两条指令之间插入nop指令，插入之后lbu处于MEM阶段，seqi处于ID阶段，seqi完全可以在进行ALU运算之前使用到通过转发部件(由MEM阶段末转发到ID&#x2F;EX寄存器)传送的lbu取出的结果，就可以解决数据冲突。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-09-39-41.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-09-42-10.png"></li><li><code>seqi r5, r3, 0xa</code>和<code>bnez r5, Finish</code>之间存在r5寄存器RAW数据相关导致的数据冲突。之前老师上课专门有让大家讨论过Branch放到第二个阶段会带来什么问题。因为seqi指令在EX阶段的时钟周期末尾才更新r5的值，但bnez在ID阶段的时钟周期初就需要R5的值来决定是否要发生跳转(时光不能倒流)。同样也不能只用转发部件来转发，还需要在两条指令之间插个气泡(bnez已经随着seqi因为上一条指令的数据相关停顿过一次了)。此时再从EX阶段末得到的值转发到IF&#x2F;ID寄存器中。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-09-48-46.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-09-49-03.png"></li><li><code>multu r1, r1, r4</code>和<code>add r1, r1, r3</code>之间存在r1寄存器RAW的数据相关导致的数据冲突。因为multu指令是完成浮点数乘法，实验开始时就要求将浮点的所有运算设定为4个时钟周期。因此add指令也需要停顿四个时钟周期等待multu浮点运算完成后更新r1寄存器才进行转发(由EX阶段末转发到ID&#x2F;EX寄存器)，这样才能解决数据冲突。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-10-02-22.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-10-02-34.png"></li><li><code>subi r3, r3, 0x30</code>和<code>add r1, r1, r3</code>之前存在r3寄存器RAW的数据相关导致的数据冲突。直接通过转发(而不是等到WB阶段)就能解决。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-10-14-10.png"></li><li><code>j Loop</code>指令会导致控制冲突，因此紧跟在jump指令之后的lw指令就被清空了。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-10-16-58.png"></li><li><code>j r31</code>后会插入一个<code>nop</code>指令到延迟槽中。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-10-19-46.png"></li><li><code>seq r3, r1, r2</code>和<code>bnez r3, Result</code>之间存在r3寄存器RAW的数据相关导致的数据冲突。需要插入一个气泡，再将EX阶段末得到的r3更新后的数据转发到ID&#x2F;EX寄存器，从而解决控制冲突。同理，<code>sgt r3, r1, r2</code>和<code>bnez r3, Result</code>也是类似的。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-10-25-41.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-03-10-28-38.png"></li><li>最后再来分析一下使用转发部件解决冲突和不使用转发部件的性能差异。由图可以看出，使用转发部件后，停顿减少了13次。这13次都是RAW Stall，结合所学知识，其他三类LD指令、分支指令以及浮点指令导致的冲突都是不能单靠转发部件能解决的。同时注意到增加转发部件执行程序的时钟周期也从146降到了129，由CPU性能方程可知，提高了整体的性能。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-13-17-01.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-13-17-10.png"></li></ul><h2 id="Lab2-DLX处理器程序设计"><a href="#Lab2-DLX处理器程序设计" class="headerlink" title="Lab2 DLX处理器程序设计"></a>Lab2 DLX处理器程序设计</h2><ul><li>浮点数除法DLX汇编代码实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">;fdiv.s</span><br><span class="line">.data</span><br><span class="line">;data for input</span><br><span class="line">Scanf0:.asciiz&quot;\nEnter the 1st number:&quot;</span><br><span class="line">Scanf1:.asciiz&quot;\nEnter the 2nd number:&quot;</span><br><span class="line"></span><br><span class="line">;data for print</span><br><span class="line">Printf0:.asciiz&quot;\n(1st number) %g divided by (2nd number) %g = %g&quot;</span><br><span class="line">Printf1:.asciiz&quot;\n divide by 0!!&quot;</span><br><span class="line">.align2</span><br><span class="line">Printf:     .wordPrintf0</span><br><span class="line">Printf3:     .word      Printf1</span><br><span class="line">PrintfValue1:.space    8</span><br><span class="line">PrintfValue2:.space     8</span><br><span class="line">PrintfValue3:.space     8</span><br><span class="line">.text</span><br><span class="line">.global main</span><br><span class="line">main:</span><br><span class="line">addir1,r0,Scanf0;input dividend</span><br><span class="line">jalInputUnsigned     ;This function convert ASCII to Binary</span><br><span class="line"></span><br><span class="line">addr2,r1,r0      ;r2=dividend</span><br><span class="line">addir1,r0,Scanf1;input divisor</span><br><span class="line">jalInputUnsigned</span><br><span class="line"></span><br><span class="line">bnezr1,num2notzero;(r1!=0) PC=num2notzero. This instruction to guarantee divisor is not zero</span><br><span class="line">addir14,r0,Printf3;when num2=0 print the prompt message</span><br><span class="line">trap5                 ;print this message to standard output</span><br><span class="line">jResult     ;jump to the end and interrupt the running program</span><br><span class="line">num2notzero:</span><br><span class="line">;convert interger num1 and num2 to double floating-point</span><br><span class="line">movi2fpf1,r1        ;Copies one word from integer register r1 to fp register f1.</span><br><span class="line">movi2fpf2,r2</span><br><span class="line">cvti2df0,f1        ;Converts a signed integer to double precision float.</span><br><span class="line">cvti2df2,f2</span><br><span class="line">sd      PrintfValue1,f2</span><br><span class="line">sd      PrintfValue2,f0</span><br><span class="line"></span><br><span class="line">divdf8,f2,f0        ;divide for double precision floats</span><br><span class="line">;print the quotient</span><br><span class="line">sdPrintfValue3,f8</span><br><span class="line">addir14,r0,Printf       ;r14 is specialized for trap instruction</span><br><span class="line">trap5</span><br><span class="line">Result:</span><br><span class="line">trap0</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>程序运行结果图<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-14-10-48.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-14-11-32.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-14-11-56.png"></li><li>首先查看DLX指令编码表，通过Chrome浏览器中的vim插件进行模糊查找定位到双精度浮点除法指令divd。因为除法程序需要用到input.s文件将从命令行输入的ASCII字符转换成二进制整型数字（因此先不采用浮点寄存器，最后再进行整型到浮点的转换）。分析InputUnsigned可以发现，它会将转换后的结果放入到R1寄存器中。</li><li>注意trap 5需要的r14存放的是字符串起始地址的间接地址，否则会出现“address wrong”的报错。</li><li>在实现最后打印语句<code>printf(&quot;\n(1st number) %g divided by (2nd number) %g = %g&quot;,   (double)num1, (double)num2, num3 );</code>时，需要将后面的参数的地址连续存放在提示串的后面才能正确显示，同时也需要注意参数的大小，双精度浮点数参数要分配8个地址单元(DLX按字节编址寻址，且双精度浮点数为64-bit)。</li><li>movi2fp-cvi2d指令存在浮点寄存器f1的数据相关导致的数据冲突。这两条指令的f2也有同样的情况。解决这种控制冲突可以通过将movi2fp在MEM阶段末的值转发给cvi2d的EX阶段使用。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-13-58-31.png"></li><li>cvi2d-sd指令之间存在浮点寄存器f2之间的数据相关导致的数据冲突。解决这种数据冲突可以通过在cvi2d指令的EX阶段或者是在MEM阶段进行转发，转发到sd指令的MEM阶段来解决数据冲突。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-13-58-53.png"></li><li>divd-sd指令之间存在浮点寄存器f8的数据相关导致的数据冲突。因为浮点除法指令的在EX阶段需要执行的周期为4个周期，因此只使用转发也不能解决冲突，还得需要加以停顿。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-13-59-45.png"></li><li>分析使用转发和不使用转发的性能差异。可以发现在使用转发部件后程序的执行周期由153降到了132，RAW停顿由43下降到了27，由CPU性能方程可知，程序整体性能得到提升。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-14-06-30.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-14-07-06.png"></li><li>观察指令<code>bnezr1,num2notzero</code>。如果不分支发生，程序数据分析就如上图所示，即进行浮点的除法运算。如果分支发生(因为除数为0)则直接输出提示信息并跳转到结束处，数据分析如下图所示。对比可以发现，在使用转发部件的情况下，分支不发生程序执行所需的时钟周期是132，而分支发生所需的时钟周期是121；在不使用转发部件的情况下，分支不发生程序执行所需的时钟周期是153，分支发生所需的时钟周期是137。可以得出结论，在分支发生时程序所使用的时钟周期更短，程序整体性能更高。<br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-14-44-42.png"><br><img src="/2022/06/01/DLX-Lab/06/01/DLX-Lab/img-2022-06-11-14-45-21.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS专业学生应具备的品质</title>
      <link href="/2022/05/22/CS%E4%B8%93%E4%B8%9A%E5%AD%A6%E7%94%9F%E5%BA%94%E5%85%B7%E5%A4%87%E7%9A%84%E5%93%81%E8%B4%A8/"/>
      <url>/2022/05/22/CS%E4%B8%93%E4%B8%9A%E5%AD%A6%E7%94%9F%E5%BA%94%E5%85%B7%E5%A4%87%E7%9A%84%E5%93%81%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Top ten factors.</p></blockquote><span id="more"></span><ol><li><strong>Communication skills(verbal and written)</strong></li><li><strong>Honesty&#x2F;integrity</strong></li><li><strong>Teamwork skills</strong></li><li><strong>Interpersonal skills</strong></li><li><strong>Motivation&#x2F;initiative</strong></li><li><strong>Strong work ethic</strong></li><li><strong>Analytical skills</strong></li><li><strong>Flexibility&#x2F;adaptability</strong></li><li><strong>Computer skills</strong></li><li><strong>Self-confidence</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三章 数据链路层</title>
      <link href="/2022/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2022/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>朝着Distribution前进</p></blockquote><span id="more"></span><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><strong>数据链路层</strong></h1><ul><li>数据链路层的协议传输单元，<strong>帧(Frame)</strong></li><li>帧的长度等于帧的<strong>数据部分长度</strong>加上<strong>帧首部</strong>和<strong>帧尾部</strong>的长度</li><li><strong>最大传送单元(Maximum Transfer Unit, MTU)</strong> 规定了帧的<code>数据部分长度</code>的上限</li><li><strong>透明传输</strong>指在发送给上层之前的传输数据没有任何限制(i.e. 将帧定界符删除)</li><li>为了解决透明传输的问题，使用<strong>字节填充</strong>，即在含有数据部分中含有控制字符的前面插入<strong>转义字符</strong></li><li><strong>零比特填充法</strong>，只要在<code>发送端</code>发现有5个连续的1，则在后面插入1个0；在<code>接收端</code>发现有5个连续1，则将其后面的0删除</li><li>$误码率&#x3D;\frac{传输错误的比特}{传输比特总数}$</li><li><strong>差错检测码(Error-Dectecting Code, EDC)<strong>，通常在</strong>每个帧</strong>的尾部设置一个差错检验字段(存放着整个帧，包括首部和数据)的差错检测码，这个差错检验字段成为<strong>帧检验序列(Frame Check Sequence, FCS)</strong><br><img src="/2022/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/img-2022-05-21-19-08-22.png"></li><li><strong>循环冗余检验(Cyclic Redundancy Check, CRC)<strong>，<code>G</code>的长度为<code>r+1</code>，<code>D</code>为待传送的数据，<code>R</code>为余数作为<code>EDC</code>，若<code>R</code>为0则未出现误码。$R&#x3D;\frac{D \cdot 2^r}{G}的余数$; 模2运算等价于</strong>按位异或</strong><br><img src="/2022/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/img-2022-05-21-19-10-07.png"><br><img src="/2022/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/img-2022-05-21-19-09-20.png"></li><li>**停止等待协议(Stop-and-Wait)**，发送方发完一个分组时启动<code>超时计时器</code>，一般可以将重传时间设为略大于平均<code>RTT</code>; 过早超时会使发送方收到重复的确认分组，因此确认分组也需要进行编号，但数据链路层中的RTT是确定的，所以在此不必进行编号; 发送方发完一个分组后必须保留已发送的分组的副本; 停止等待协议的优点是<code>简单</code>，缺点是<code>信道利用率太低</code>; <strong>信道利用率</strong>$U&#x3D;\frac{T_D}{T_D+RTT+T_A}$，其中$T_D$为发送方发送分组所需要的时间，$T_A$为接收方发送确认分组所需要的时间<br><img src="/2022/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/05/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/img-2022-05-21-19-18-41.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于三篇经典论文的总结</title>
      <link href="/2022/05/20/%E5%85%B3%E4%BA%8E%E4%B8%89%E7%AF%87%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/20/%E5%85%B3%E4%BA%8E%E4%B8%89%E7%AF%87%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>疫情原因，体系结构课程要求写三篇经典论文的读书报告。。</p></blockquote><span id="more"></span><h3 id="Amdahl’s-Law"><a href="#Amdahl’s-Law" class="headerlink" title="Amdahl’s Law"></a><strong>Amdahl’s Law</strong></h3><p>&amp;emsp;&amp;emsp;十年前预言家们已经预言单处理机已经达到了它的限制，并且真正有意义的改进可以通过将多处理机相连来协作解决达到。处理机指的是以分离元件制造的计算机(冯诺依曼模型)。CPU&#x3D;control+datapath(1971年Intel的4004将它们都做到了一个芯片上)。多处理机有两种连接方式：将多个通用目的计算机以多个存储器相连或者将多个专用的计算机以几何相关的存储器相连并由一个或多个指令流控制。这篇文章基于斯坦福大学商学院的研究数据，给出关于家务管理的例子。十年以来它的计算负载一直保持在占可执行指令的百分之四十，在特殊的环境下它能够减少到两倍，但是它根本不可能减少到三倍，因为顺序执行的指令不可能服从并行处理技术(有些是可以并行执行的，有些不可能去并行执行)。整体性能提升受五到七倍的上限限制。无论并行执行那一部分分配多少个处理机加速(并行执行那一部分时间可以缩到尽可能短，比顺序执行所需的时间还要短)，但总体运行时间还是得受限于顺序执行那一部分。如果家务管理部分是由单个处理机完成(占百分之四十)，非家务管理部分将会是家务管理部分性能的三到四倍。总的来说，通过上面举的例子，尽可能达到高度并行处理的速率的努力是白费的，除非顺序执行的速率也和并行执行那部分的速率达到同一个量级，这样整体的速率才能得到提高。</p><h3 id="Slave-Memories-and-Dynamic-Storage-Allocation"><a href="#Slave-Memories-and-Dynamic-Storage-Allocation" class="headerlink" title="Slave Memories and Dynamic Storage Allocation"></a><strong>Slave Memories and Dynamic Storage Allocation</strong></h3><p>&amp;emsp;&amp;emsp;文中fast core memory&#x2F;slave memory指的是Cache，slow core memory指的是Main memory，Magnetic drums指的是磁盘。在这些系统中以块为单位和内存进行数据交换是高效的。如果仅仅是将block调到cache中却不使用是浪费的。Cache能够保证这些字在接下来的是可用的，而不是去以更长的时间访问主存。因为Cache的存储空间大小只是主存的一小部分，所以字不能一直保存在Cache中，需要使用一些算法来保证这些字被逐步地覆盖(组相联和全相联映射还需要考虑替换策略，即应用如LRU这样的替换算法)。在比较理想的情况下，一部分字能够在Cache中保持足够长的时间，起到明显的加速作用。Cache在现代处理器中又分为Instruction Cache和Data Cache，可以减少访问指令和数据的时间(不需要到低一级的存储器中去找)。如果指令出现在小的循环体中，因为局部性原理，就可以获得相当可观的访问速度。假设主存有32K个字，十六个地址位；Cache有32个字，五个地址位。Cache每个line&#x2F;slot的长度等于主存数据的16个bits加上11个bits的标签字段。主存存储单元地址对32取余后，根据余数将存储单元内容放到对应Cache的插槽上，而存储单元地址的高11个bit作为Cache的tag字段，来区分映射到同一个插槽的是主存上的哪一个块。比如说主存的地址字段为$10259 &#x3D; 320 \cdot2^5+19$，对32(字的数量)取余后结果为19，那么这个地址对应的存储单元的内容就会被放到Cache的19号插槽上对应的16bits的数据部分，地址中的tag字段为320。如果写操作发生了，会存在一致性的问题，就需要在写Cache的同时要写主存，这也就是write through策略。<br><br>&amp;emsp;&amp;emsp;下面讨论应用更大的Cache(32K个插槽)的分时系统的应用场景，大量的用户程序在辅存中等待激活。为了支持进程之间的Isolation，需要引入分段机制。当一个程序被激活时，直到它已经完成或者处理I&#x2F;O中断，或者是直到它的时间片被用尽的时候才切换到另一个程序。工作集的概念，每次程序被激活时不需要将所有块都调入Cache中，这样是浪费的，只需要调入需要用到的部分即可。在Cache中分别增加1bit的控制位(valid bit和dirty bit)。当基址寄存器中的内容切换时(意味着新的程序被激活了)，需要扫描Cache看是否存在不一致的问题(控制位会使得扫描过程完成得更快)。只有当valid bit和dirty bit同时为1时，才需要将当前的block写回到Main memory中，这也就是write back策略。可以将Cache划分为多个段，这需要提供多个base register，这也意味着Cache中有些部分可以是不允许被更改的，比如说系统经常需要用到的部分。假设有七个基址寄存器，每个寄存器表示主存中程序块的起始地址，那么在Cache中可以使用四个控制位。前三个bit用来标识使用的基址寄存器号(全0时表示字已经调入Cache中但还未被使用)，第四个bit是脏位。从表面上看，这种方案为两级核心存储系统提供了基础，又没有过高的硬件复杂度。</p><h3 id="The-Future-of-Microprocessors"><a href="#The-Future-of-Microprocessors" class="headerlink" title="The Future of Microprocessors"></a><strong>The Future of Microprocessors</strong></h3><p>&amp;emsp;&amp;emsp;这篇文章分五部分对微处理器的发展过程进行阐述。<br><br>&amp;emsp;&amp;emsp;现代计算机的微处理器的性能呈指数级增长主要归因于：随着时间的推移晶体管器件变得更快，以及因为集成电路上可容纳的晶体管数量的增加，硬件设计师能够利用更多的晶体管来从软件中获得更多的并行性。文章中提到说是从”软件”中提取并行性，我首先想到的是Data-Level Parallelism和Task-Level Parallelism，以及它们的底层实现，TLP(Thread-Level Parallelism)，每个core里都提供多个寄存器组和PC寄存器，这样就可以支持多线程来提高处理器的性能从而达到线程级并行。除此之外，比如ILP(Instruction-Level Parallelism)和DLP(Data-Level Parallelism)也同样可以提高处理器的性能。指令集并行可以通过流水线和多发射等技术，数据级并行可以通过支持向量寄存器(Vector Register)来达到数据级并行，这些并行都是软件程序员不可见的。因为向后兼容所带来的经济效益，导致这种抽象维护了几十年。随着时间的推移，CPU和主存的速度相差了三个数量级，随后Cache产生了，文中中还提到了寄存器是由编译器来管理的。<br><br>&amp;emsp;&amp;emsp;在处理器内部还可以进行一些改进，比如说应用多发射技术(多发射又分为动态多发射和静态多发射)来增加每个时钟周期所发射的指令数(比如动态地查找在每个时钟周期并行执行的指令)，或者是将流水线细分为多个阶段来增加流水线的深度从而提高时钟频率。这些技术在程序员的角度，看不到重叠执行也看不到乱序执行。除此之外，程序员和编译器也可以通过调整指令的顺序或者是数据的分布，来高效地利用流水线或者是并行架构、Cache(局部性原理)。更重要的是，在这些改进之后，以前的代码仍然可以正确执行，只不过它们的运行速度低于峰值。<br><br>&amp;emsp;&amp;emsp;很不幸的是，硬件设计师难以利用这些技术来提高现代处理器的速度了。因为指令流在指令之间只存在有限数量的并行指令，因此超标量处理器在超过4发射之后就很难在大多数应用中带来性能的提升了。从文章图2中看出ILP最近几年的性能提高趋于缓和了。另外，超标量处理器每个时钟周期内利用多条指令将会非常昂贵，因为需要额外复杂的逻辑来动态地找到并行的指令，这样的复杂度大约和同时发射的指令数的平方成正比。类似地，因为流水线阶段更细地划分，一个阶段甚至无法执行简单的两个整型数相加的指令。此外硬件电路的开销，比如增加的流水线寄存器以及转发部件，或者是增加的多路选择器，这样的开销甚至都超过了30级以上流水线带来的性能提升(tradeoff)。以及包括只有少量研究这些技术的大公司才能支付得起薪水来雇佣足够的工程师。所以，这些因素在一定程度上减缓了处理器性能的发展。<br><br>&amp;emsp;&amp;emsp;因为能耗的限制，传统的处理器开发基本上已经停止。Dennard’s Law指出随着设备尺寸的减小，能耗也会下降。在这种情况下，较小的晶体管运行功耗更低。图3展示了因为硬件设计师使用更多晶体管来改进流水线和多发射技术，并以更高的速率切换它们，导致处理器功耗呈指数级增长。但是冷却技术(比如说散热器)并没有能耗增长的速率那么快，照这样下去下一代微处理器就得使用经济上不实用的水冷技术了。因为种种因素对处理器发展的限制，使得Intel和AMD这样主要的处理器制造商调整他们的营销重点，而不是仅仅是时钟频率(同学们在购买电脑的时候应该会注意到，早些年这些主要的制造商主要营销点是处理器的时钟频率的提高)。从微处理器的市场划分的角度，来对它们的性能需求进行研究，进而引出了下一个主题，带宽性能的提升。<br><br>&amp;emsp;&amp;emsp;大多数多处理器使用同一个总线相连或者是共享主存等资源，相比较于传统的单处理器，多处理器所需要的功耗更小。因为多个核能够共享硬盘、存储器这样的大元器件以及功耗的供给。因为互联网的发展，数据中心的压力越来越大，尽管将服务器改造成多核以及使它们共享耗电的组件，这些短期的解决方案引出了CMP(Chip Multiprocessor)的发展。CMP将多个传统的超标量处理器整合到一个die上(减少了容量)。在同一个die上的处理器可以共享单个连接系统外的总线，减少了功耗。在要求高吞吐量的服务器中延迟不是关键因素(“latency is unimportant”)，基于CMP的系统设计可以利用这种情况来更进一步地减少功耗。比如使用两路的CMP来代替单处理器，可以得到两倍的吞吐率，但时钟频率慢了一半(相比于单处理，多处理器需要两倍的时间去处理请求)。请求处理时间主要取决于内存和外存性能的限制，而不只是处理器的性能。因为两个请求可以同时处理，整体的吞吐量将会与原来一致(可能出现一些对主存或者磁盘资源的争用)或者更好。通过将单处理器替换成CMP，性能与原来相同，或者变的稍微好一些了(这样的调整仍然能带来好处)。需要注意的是，降低时钟频率意味着降低了能耗(2-way CMP的能耗降低了大约一半，因为能耗和电压的平方成正比，1&#x2F;4能耗就等于一半电压的平方)！不过这种下降仍然会受到静态损耗和底层晶体管的最低电压的限制。<br><br>&amp;emsp;&amp;emsp;典型的服务器的工作负载通常只有少量的指令集并行和Memory stall(这与老师上课提到的影响流水线性能的六个因素相关)，因此大多数与超标量相关的硬件就浪费了。但是利用CMP能充分利用每个core来达到请求级并行，这也是H&amp;P中提到的RLP(Request-Level Parallelism)。可以通过在每个core内部增加多个寄存器组和PC寄存器，应用multithreading技术来获得更高的吞吐量(同时意味着处理请求需要更长的时延)。比如说当前thread在等待I&#x2F;O时，处理器可以切换到另一个thread去执行，这样在memory stall时执行计算以及同时执行多个内存访问，获得的好处远远超过了系统上较长的请求时延。因为可能涉及到对处理器核的争用，thread的请求时延通常会长一些。Intel的Hyperthreading技术允许两个threads共享多个核。<br><br>&amp;emsp;&amp;emsp;许多应用的性能是根据单个任务执行的时延来决定的而不是多个本质上不相关任务的高吞吐量。事实上，大多数用户更关心命令行的响应速度而不是他们的计算机能同时处理多个命令的能力；对于许多计算能力受限的应用，比如模拟和编译，程序员更在意的是程序的执行时间而不是有多少任务在并行执行。在过去，处理器之间的通信非常慢，因此对于程序员来说确保线程在独立的处理器上运行时减少处理器的相互通信很重要(这部分课程往往在研究生级别才会开设，需要程序员投入大量的时间和精力来并行化程序。但在大多数情况下程序员往往只是希望下一代单处理器能够出现并加速他们的程序，而不是投入精力来并行化他们的程序)。结果是多处理器很难与单处理器竞争，除非在非常大的系统中。随着”free”技术(超标量，流水线)带来的性能提升被耗尽，为了提高单个程序的性能，程序员必须切换到更多的并行编程模型来获得更高的性能。只有三个维度的性能提升超越了摩尔定律：时钟频率，超标量指令发射，多处理器(前两个已经受限了)。<br><br>&amp;emsp;&amp;emsp;从多芯片系统切换到CMP大大简化了并行编程的问题，多芯片系统线程之间的通信开销需要几百甚至几千个时钟周期，而CMP中共享在Chip中的Cache，每个线程之间通信只需非常少的时钟周期。通信时延减少了，但程序员仍然需要保证内部线程的同步，避免出现死锁或者是不正确的结果。增加支持事务的硬件或者是增加缓冲逻辑(只适用于紧耦合的并行机器)，可以使得应用程序的并行变得更简单。这种并行的转变应该适用于”典型”的程序员而不是只限制在研究生级别的程序员。<br><br>&amp;emsp;&amp;emsp;处理器家族的每一代成员只需要增加额外的主题或者在原来的基础上做一些修改即可，而不需要去重新设计处理器核的逻辑，系统主板也只需要做微调。随着CMP的规模增加，主板需要去处理更高的I&#x2F;O带宽的需求。同样的工程也可以分摊到处理器家族中，比如只需改变处理器数量和时钟频率就可以让相同的硬件以不同的价格或者性能运行。这就是硬件的优势。<br><br>&amp;emsp;&amp;emsp;向CMP转变是无法避免的，这种转变不会更改基本的冯诺依曼模型。直到软件工业完全接受并行编程时，这些结构的优势才能被最大化地利用起来。多处理器编程比单处理器更复杂，需要理解新的计算原理、算法和编程工具。<br></p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li>[1] “Validity of the single processor approach to achieving large scale computing capabilities” by DR. GENE M. AMDAHL</li><li>[2] “Slave Memories and Dynamic Storage Allocation” by M. V. WILKES</li><li>[3] “The Future Of Microprocessors” by KUNLE OLUKOTUN AND LANCE HAMMOND, STANFORD UNIVERSITY</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP PartI Virtualization</title>
      <link href="/2022/05/19/OSTEP-Virtualization/"/>
      <url>/2022/05/19/OSTEP-Virtualization/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Don’t let yesterday take up too much of today.</p></blockquote><span id="more"></span><h1 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a><strong>Virtualization</strong></h1><ul><li>GCC编译创建线程的代码时需要加<code>-pthread</code>参数</li><li><code>Batch processing</code>: 开始一些作业(jobs)并且然后由接线员来按批运行</li><li><strong>程序</strong>是如何转变为<strong>进程</strong>的。<br><img src="/2022/05/19/OSTEP-Virtualization/05/19/OSTEP-Virtualization/img-2022-05-20-16-08-28.png"></li><li>在<code>Loading</code>的过程中可以用到<strong>lazy</strong>，程序在执行时需要这一部分数据才<code>load</code>到内存中，从而加快<code>加载</code>的速度。加载到内存中之后，运行<code>main() routine</code>操作系统将CPU的控制权传给新创建的进程，随后程序开始执行。</li><li>进程的状态转换<br><img src="/2022/05/19/OSTEP-Virtualization/05/19/OSTEP-Virtualization/img-2022-05-20-16-23-40.png"></li><li><code>Process List</code>，记录进程的相关信息(PCB, <code>Process Control Block</code>)。<code>Process List</code>的每个条目为<code>PCB</code>，下面是<strong>xv6</strong>的<code>Process Structure</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the registers xv6 will save and restore</span></span><br><span class="line"><span class="comment">// to stop and subsequently restart a process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> eip;</span><br><span class="line">    <span class="type">int</span> esp;</span><br><span class="line">    <span class="type">int</span> ebx;</span><br><span class="line">    <span class="type">int</span> ecx;</span><br><span class="line">    <span class="type">int</span> edx;</span><br><span class="line">    <span class="type">int</span> esi;</span><br><span class="line">    <span class="type">int</span> edi;</span><br><span class="line">    <span class="type">int</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// the different states a process can be in</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">                  RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the information xv6 tracks about each process</span></span><br><span class="line"><span class="comment">// including its register context and state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *mem; <span class="comment">// Start of process memory</span></span><br><span class="line">    uint sz; <span class="comment">// Size of process memory</span></span><br><span class="line">    <span class="type">char</span> *kstack; <span class="comment">// Bottom of kernel stack</span></span><br><span class="line">    <span class="comment">// for this process</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">int</span> pid; <span class="comment">// Process ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process</span></span><br><span class="line">    <span class="type">void</span> *chan; <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">    <span class="type">int</span> killed; <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// Open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span> <span class="comment">// Current directory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// Switch here to run process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span> <span class="comment">// Trap frame for the</span></span><br><span class="line">    <span class="comment">// current interrupt</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>上下文切换</strong>，如进程A将切换到进程B时，先将<code>PC</code>和<strong>微体系结构寄存器(e.g. PSR)<strong>保存到当前的内核栈，再将当前</strong>通用寄存器</strong>(i.e. physical registers)的信息<code>save</code>到进程数据结构中的<code>context</code>上下文结构体中。随后将进程B的数据结构中的上下文结构信息<code>restore</code>到当前<strong>通用寄存器</strong>中，最后从进程B的内核栈中<code>restore</code>相关<code>PC</code>和<strong>微体系结构寄存器</strong><br><img src="/2022/05/19/OSTEP-Virtualization/05/19/OSTEP-Virtualization/img-2022-05-20-16-45-34.png"></li><li>处于<code>zombile state</code>的进程(它的父进程未执行<code>wait()</code>来获取子进程的信息从而指示OS来将它从相关的数据结构中删除)被<code>init</code>进程接管</li><li><code>fork()</code>创建子进程后，实际上就是不同的文件描述符指向同一个Open File Table中的条目；调用fork之后父进程返回子进程的<code>PID(Process Identifier)</code>，而子进程返回<code>0</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line">        <span class="type">int</span> rc_wait = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (rc_wait:%d) (pid:%d)\n&quot;</span>,</span><br><span class="line">                rc, rc_wait, (<span class="type">int</span>) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">- `exec()`</span><br></pre></td></tr></table></figure></li><li></li></ul><p><strong>未完待续。。。。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记《OSTEP》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Ch3 程序的机器级表示</title>
      <link href="/2022/05/19/CSAPP-Ch3/"/>
      <url>/2022/05/19/CSAPP-Ch3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>It is never too late to be what you might have been.</p></blockquote><span id="more"></span><h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a><strong>程序的机器级表示</strong></h1><ul><li><code>IA32</code>的64位扩展，也成为<code>x86-64</code></li><li><code>gcc -Og -S mstore.c</code>，GCC会编译该代码且编译器会进行优化</li><li><code>objdump -d mstore.o</code>，由反汇编器将机器级代码转换成汇编代码，同时反汇编器会在汇编代码的<code>Label</code>旁注上它所对应的地址; 需要注意的是反汇编后的汇编代码地址为链接阶段<code>重定向</code>之后所处的地址，<code>链接器</code>在程序代码中会插入<code>nop</code>来提高访问存储器的性能(更好地放置下一个代码块)。</li><li><code>x86-64</code>指令长由从1到15个字节不等。</li><li><code>Variable Instruction</code> vs. <code>Fixed Instruction</code>，基于变长指令的ISA生成程序代码所需要的存储空间相对于定长指令更小，但增加了<code>DECODE</code>的开销，这也是一个<code>Tradeoffs</code></li><li><code>ATT</code>格式的汇编代码，<code>AT&amp;T</code>是运营贝尔实验室的公司，这种格式是<code>GCC</code>，<code>OBJDUMP</code>等工具的默认格式</li><li>根据<code>x86 AT&amp;T</code>语法，寄存器前要加<code>%</code>，立即数前要加<code>$</code>，注释用<code>#</code>来表示。</li><li>要想在C语言中编写汇编代码，可以通过<code>GCC</code>的<code>内联汇编</code>，用<code>asm</code>伪指令来包含简短的汇编代码</li><li>Intel用术语<code>字</code>来表示16位数据类型，老大补充字为<code>CPU</code>和<code>Cache</code>之间的数据交换单位，且RISC风格的ISA的<code>字</code>为32位</li><li><code>GCC</code>生成<code>x86</code>的汇编代码指令都有一个操作数大小的字符后缀<code>b</code>、<code>w</code>、<code>l</code>、<code>q</code>，如：<code>movq</code></li><li>区分<code>x86</code>不同大小的寄存器，前缀为<code>r</code>的寄存器的大小为<strong>四字</strong>，前缀为<code>e</code>的大小为<strong>双字</strong>，后缀为<code>l</code>或者<code>b</code>寄存器的大小为<strong>字节</strong>，其余的归为大小为<strong>字</strong>的寄存器<br><img src="/2022/05/19/CSAPP-Ch3/05/19/CSAPP-Ch3/img-2022-05-19-13-49-56.png"></li><li><code>x86</code>的操作数格式，其中比例因子必须是1、2、4、8<br><img src="/2022/05/19/CSAPP-Ch3/05/19/CSAPP-Ch3/img-2022-05-19-13-51-36.png"></li><li><code>x86</code>规定<strong>任何为寄存器生成32位值的指令都会把该寄存器的高四字节置为0</strong>，如：<code>movl $256, %eax</code>，会把<code>rax</code>寄存器的高32位置0</li><li>常规的<code>movq</code>指令只能以表示<strong>32位</strong>补码数字的<code>立即数</code>作为<code>源操作数</code></li><li><code>movq</code>会将32位的<code>立即数</code>拓展为64位再进行传送，而<code>movabsq</code>直接使用64位的立即数作为源操作数使用</li><li><code>mov</code>的两个操作数不能<strong>同时</strong>为内存地址</li><li><code>x86-64</code>的内存引用总是用<code>4字长</code>的寄存器(因为地址空间大小为64位)，如：<code>movw %dx, (%rax)</code></li><li><code>强制转换</code>先考虑大小，在考虑符号</li><li><code>pushq</code>等价为<code>subq</code>加上<code>movq</code>两条指令的操作，<code>popq</code>同理，操作的数据大小为<strong>四字</strong></li><li><code>x86</code>的二元<code>算术</code>和<code>逻辑</code>操作的第二个操作数既是<code>源</code>也是<code>目的</code></li><li><code>lea</code>加载有效地址指令，在x86中可以充当算术运算(编译器经常会这么优化)，比如<code>%rdi</code>表示x，<code>%rsi</code>表示y，那么<code>leaq (%rdi, %rsi, 4), %rax</code>就可以等价于<code>x + 4*y</code></li><li>移位操作中的寄存器操作数，只有最低字节才指示移位量，因为8个bit以内足以表示四字的偏移量了</li><li><code>x86 ISA</code>支持两个64有符号或者无符号的<code>乘法</code>或者<code>除法</code>，结果是<strong>128位</strong>。乘法运算，乘法得到的结果的高64位保存到<strong>rdx</strong>中，低64位保存到<strong>rax</strong>中；除法运算，将商保存到<strong>rax</strong>中，余数存到<strong>rdx</strong>中; 高64前老大有提到过两个32位<strong>补码</strong>(i.e. 有符号数)在<code>mips</code>中相加得到的结果该怎么处理，因为mips没有这样的指令，可以通过编程来实现，无论是两个32位补码相加还是两个64位补码相加，得到的结果的低32位永远是<strong>无符号数</strong>，其余都是<strong>有符号数</strong></li><li>x86有四种条件码分别是: <code>CF: 进位标志</code>, <code>ZF: 零标志</code>, <code>SF: 符号标志</code>, <code>OF溢出标志</code></li><li><code>CMP</code>指令类似于<code>SUB</code>指令，但不更新目的寄存器；同样<code>TEST</code>类似于<code>AND</code>指令，也不更新目的寄存器；e.g. <code>testq %rax, %rax</code>就生成与<strong>零</strong>比较所产生的条件码</li><li><code>比较和测试</code>指令以及<code>算数运算指令(lea除外)</code>都会<strong>设置条件码</strong></li><li><code>SET</code>指令的目的操作数是低位单字节寄存器，它根据条件码的组合，将结果(<code>0</code>或<code>1</code>)放到寄存器中。比如:<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpq %rsi, %rdi</span><br><span class="line"><span class="keyword">setl</span> %al</span><br></pre></td></tr></table></figure></li><li>比如<code>j</code>, <code>set</code>, <code>cmov</code>这些指令，后缀为<code>g</code>或者<code>l</code>表示有符号的大于和小于；后缀为<code>a</code>或者<code>b</code>表示无符号的大于和小于，来将生成条件码的结果和0进行比较。</li><li>直接跳转<code>jmp Label</code>; 间接跳转<code>jmp *Operand</code>(i.e. <code>jmp *%rax</code>使用寄存器rax中的值作为<strong>Label</strong>；或者<code>jmp *(%rax)</code>使用寄存器的值作为地址来访问存储器得到<strong>Label</strong>)。</li><li>个人认为<strong>直接跳转</strong>可以直接使用label，而<strong>间接跳转</strong>需要从存储器(e.g. 寄存器或者主存)中读取label; <strong>条件跳转只能是直接跳转</strong></li><li>x86中的<code>PC-relative</code>是通过<code>PC+4+符号位拓展的Offset</code>来计算跳转到的地址</li><li>原本不同目标文件的<code>虚拟地址</code>的<code>程序段</code>都是由<code>0</code>开始，<strong>链接</strong>后，<strong>重定位</strong>到<strong>可执行目标文件</strong>后原本程序段的<code>虚拟地址</code>就发生了变化</li><li><code>rep</code>指令后面跟<code>ret</code>的组合来避免使ret指令成为条件跳转指令的目标(e.g. <code>rep; ret</code>)</li><li><code>条件传送指令</code>的<code>tradeoff</code>，能够提高遇到分支时流水线的效率(e.g. 减少控制冲突的可能，可以通过插一个气泡的方式来解决)，但同时也会增加指令数。不过现代微处理器的<code>分支预测器</code>已经足够优秀，所以比如说<code>ARM</code>就没有添加条件传送指令; 由<strong>编译器</strong>来决定编译出条件分支指令还是条件控制转移指令，不过<code>GCC</code>还是更倾向于使用<code>条件控制转移</code></li><li>流水线预测错误处罚时间: $T_{MP}&#x3D;2(T_{ran} - T_{OK})$；执行代码的平均时间: $T_{ran} &#x3D; T_{avg} &#x3D; T_{OK}+0.5T_{MP}$；其中$T_{ran}$为分支随机预测时的执行时间，$T_{OK}$为分支非常可预测的执行时间</li><li><code>逆向工程</code>，简而言之就是由<code>汇编</code>到<code>高级语言程序</code></li><li>注意<code>编译器的优化</code>不会总能带来性能的提升</li><li>编译器对<code>while</code>循环的两种优化: <code>jump to middle</code>和<code>guarded-do</code>，通过量化的方式，第二种方式在<strong>流水线</strong>中相比第一种性能较好<ul><li>jump to middle:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">test:</span><br><span class="line">    t = test-expr;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop</span><br></pre></td></tr></table></figure></li><li>guarded-do:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></li></ul></li><li><code>switch</code>语句采用<code>跳转表(jump table)</code>，跳转表就是个数组，因此当值的范围跨度较大时，跳转表所占用的存储空间就会变大。当switch语句<code>case数量比较多(4个以上)</code>，并且<code>值的范围跨度比较小</code>时就会使用<strong>跳转表</strong>(<code>GCC</code>根据switch的case数量和值的范围来决定是否编译成生成<code>跳转表</code>)。</li><li>和<code>if-elseif</code>语句相比，使用跳转表的优点是执行switch语句的时间与case的数量无关(<code>用空间来换时间</code>)</li><li>GCC中前缀<code>&amp;</code>表示指向数据值的指针，<code>&amp;&amp;</code>表示指向代码的指针</li><li>switch语句先判断常量值是否在switch语句范围内(可能会和某个数值做差来生成保证由0开始的数组下标)，如果不在范围内或者在范围内情况在switch语句中不存在，则跳转到defualt情况对应的label。若存在重复的情况，则两种情况使用同一个label(e.g. case 104和106就会使用同一个label)，如：<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case <span class="number">104</span>:</span><br><span class="line">case <span class="number">106</span>:</span><br><span class="line">    val *= val<span class="comment">;</span></span><br><span class="line">    break<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><code>Case</code>的范围从100到106的跳转表，<code>.align</code>指令指定数组元素要保证8字节对齐，<code>.quad</code>指令用于定义64位数值，Overview:<br><img src="/2022/05/19/CSAPP-Ch3/05/19/CSAPP-Ch3/img-2022-05-25-09-10-38.png"></li><li>通用栈帧结构<br><img src="/2022/05/19/CSAPP-Ch3/05/19/CSAPP-Ch3/img-2022-06-04-11-03-23.png"></li><li>当x86-64<strong>过程</strong>需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间(这部分称为栈帧(stack frame))</li><li>x86-64最多可以使用寄存器来传递6个参数，超出部分需要在栈上传递(参数7~n，参数7位于<code>栈顶</code>)</li><li>叶子过程：所有的局部变量保存在寄存器中，而且该函数不会调用任何其他函数，即<code>不需要</code>栈帧</li><li>调用<code>call</code>指令时，会<strong>自动</strong>(i.e.不需要手动开辟栈帧)把返回地址(紧跟在call指令后的指令地址)压入栈中，<code>ret</code>指令会将压入的返回地址从栈中弹出并赋给<code>PC</code></li><li><code>Frame pointer</code>指向本函数的栈帧顶，每个函数的<code>fp</code>放在其后调用的函数的栈帧中；fp一般在backtrace或者是管理变长栈帧时要用到。</li><li>通过栈<strong>传递参数</strong>(注意不是局部变量)时，所有数据大小都向8的倍数对齐。</li><li>有的时候<code>局部数据</code><strong>必须</strong>存储在栈上:<ul><li>寄存器不足以存放所有本地数据</li><li>使用地址运算符<code>&amp;</code>(取地址)的局部变量，要为它产生一个地址(寄存器存储的局部变量取不到地址)，因此必须存储在栈上。</li><li>某些局部变量是数组或结构体，必须通过数组或结构体引用被访问到。</li></ul></li><li><code>callee save</code>寄存器(被调用函数能保证它们的值不变，要么不使用，要么压栈保存)：rbx, rbp, r12~r15；<code>caller save</code>寄存器(意味着任何被调用函数都能修改它们)：除了上述寄存器以及rsp外的寄存器。</li><li>T D[R][C]的数组元素D[i][j]的内存地址为：$&amp;D[i][j]&#x3D;x_D+L(C\cdot i + j)$，其中<code>L</code>是数据类型T以字节为单位的大小，$x_D$为数组D的起始地址。</li><li>C语言编译器能够优化<code>定长</code>多维数组(比如说减少寄存器的使用或者减少分支判断，具体可以参考书本3.8.4)</li><li>变长数组。<code>C99</code>引入了一种功能，允许数组的维度是<code>表达式</code>(原本只能是常量)，在遇到这个数组的时候计算出数组的维度(因此变量定义的值必须要数组使用之前)</li><li>动态的版本(i.e.变长数组)必须使用乘法指令来对i伸缩n倍，而不能用一系列的移位和加法(移位只针对于2的幂次)。在一些处理器中，乘法会导致严重的性能处罚(编器件通过优化来避免生成我们上面计算地址的表达式从而避免乘法指令，具体看书本P182)。</li><li>C语言结构体(struct)的所有组成部分都存放在内存中一段连续的区域内；<strong>编译器维护关于每个结构体类型的信息</strong>，指示每个字段(field)(i.e. 属性)的字节偏移</li><li>C语言联合体(union)是<strong>用不同的字段来引用相同的内存块</strong>(进而节约内存空间)。e.g.数据结构中的二叉树，因为内部结点中不存放数据，而叶子节点中存放数据，就可以考虑使用union来节省内存空间。如下面代码所示，union一共只需要16个字节的内存空间。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">node_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node_s</span>* <span class="title">left</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node_s</span>* <span class="title">right</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>计算机系统对数据对齐限制简化了形成处理器和内存系统之间接口的硬件设计。e.g.假设一个处理器总是从内存中取8个字节，则地址必须为8的倍数(这样就可以用一个内存操作来读或者写值了)，进而提高性能。</li><li>对齐原则是任何K字节的基本对象的地址必须是K的倍数。<br><img src="/2022/05/19/CSAPP-Ch3/05/19/CSAPP-Ch3/img-2022-06-11-18-24-09.png"></li><li>编译器再汇编代码中插入指令<code>.align</code>，指明<strong>全局数据</strong>所需的对齐。e.g.<code>.align 8</code>，这就保证了它<strong>后面</strong>的数据的起始地址是8的倍数。</li><li>编译器可能需要在字段的分配过程中插入<code>Gap</code>或者在末尾进行<code>Padding</code>。e.g.结构体数组<code>struct S2 d[4]</code>，结构体元素的可能会在末尾进行填充来保证接下来的结构体数组元素是对齐的。</li><li>void*类型代表通用指针，e.g.<code>malloc</code>函数返回<code>void*</code>类型，然后通过显示的强制类型转换或者赋值操作那样的隐式强制类型转换，来转换成有类型的指针</li><li>C语言表达式<code>p+i</code>，这里指针值为$p$，得到的地址计算为$p+L \cdot i$，$L$是与P相关的数据类型的大小</li><li>将指针从一种类型强制转换成另一种类型，只改变它的<strong>类型</strong>，而不改变它的<strong>值</strong></li><li>函数指针的声明<code>int (*f)(int*);</code>，*f两边的括号是必要的，否则就会声明成<code>int* f(int*)</code>，既返回类型为<code>int*</code>的函数f。函数指针也是个指针，可以将函数名作为函数的起始地址存放到函数指针中。</li><li>C语言对于数组引用不进行任何<strong>边界检查</strong>，因此可能会因为越界的数组元素的写操作来破坏存储在栈上的状态信息(e.g.参数，返回地址)，这可能会导致ret指令将PC返回到未知的地址。</li><li>来看一个**缓冲区溢出(Buffer Overflow)**的例子，主要是因为用户输入的字符串的长度超出了为数组分配的空间<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Implementation of library function gets() */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> *dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != ’\n’ &amp;&amp; c != EOF)</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">        <span class="comment">/* No characters read */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    *dest++ = ’\<span class="number">0</span>’; <span class="comment">/* Terminate string */</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Read input line and write it back */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">/* Way too small! */</span></span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/19/CSAPP-Ch3/05/19/CSAPP-Ch3/img-2022-06-11-19-40-24.png"></li><li>C语言中有一些库函数(e.g.fgets)是原始库函数的更安全的版本，它额外包括一个参数，限制待读入的最大字节数。</li><li>缓冲区溢出攻击的目的就是使执行的ret指令跳转到攻击代码(在缓冲区中)</li><li>病毒：用来指各种在系统间传播攻击代码的策略</li><li>对抗缓冲区溢出攻击常见的三种方式：栈随机化、栈破坏检测、限制可执行代码区域。</li><li>栈随机化使得栈的位置在程序每次运行时都有变化，通过在程序开始时在栈上分配一段0~n字节之间的随即大小的空间(程序不使用这段空间)。在Linux系统中，采用地址空间布局随机化(ASLR)，使得每次运行时程序中的程序代码、库代码、栈、全局变量和堆数据都被加载到内存的不同区域。</li><li>栈破坏检测能够检测到栈何时已经被破坏。因为在C语言中没有可靠的方法来防止对数组的写越界，最近的GCC版本在产生的代码中加入金丝雀(canary)来检测(在x86中为<code>%fs:40</code>使用fs数据段寄存器来进行段寻址，canary在段中标志为只读)。在恢复寄存状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了(使用xorq指令来进行比较)，如果改变了，程序就会异常中止。最近的GCC版本会自动插入这种溢出检测(canary)。可以通过对局部变量的重新排列来提供更好的安全性(见201页)</li><li>限制内存区域中哪些区域能够存放可执行代码。许多系统允许三种访问形式：R、W、X。最近AMD和Intel处理器的内存保护引进了”NX”(No-Execute)位，将读和执行访问模式分开。这样一来栈可以被标记为可读和可写，但是不可执行(检查页是否可执行由硬件来完成，效率上没有损失)</li><li>alloca函数申请的是栈上的内存空间(与malloc不同)，用完会在退出栈时自动释放，来支持<strong>变长栈帧</strong>。为了支持变长栈帧能方便进行栈的释放，需要支持帧指针(frame pointer)来保存上一个栈帧顶的地址。x86中帧指针存放在rbp寄存器中，而RISCV将帧指针压到栈上。</li></ul><blockquote><p>浮点指令与SIMD相关的这一部分内容因为ICS课内就没有讲，所以我准备等真正用到的时候再系统地去学习。同时我打算抽空完成<code>Attack Lab</code>，巩固所学知识。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记《CSAPP》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>书籍推荐</title>
      <link href="/2022/05/18/Recommended_books/"/>
      <url>/2022/05/18/Recommended_books/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一些好书推荐(强烈建议)，可以按照大类先后阅读。以下的书我绝大多数都看过，希望能在接下来有限的时间里都阅读完吧</p></blockquote><span id="more"></span><h4 id="说在前面-Preliminary"><a href="#说在前面-Preliminary" class="headerlink" title="说在前面(Preliminary)"></a>说在前面(Preliminary)</h4><ul><li><input disabled type="checkbox"> The C Programming Language (K&amp;R)</li><li><input checked disabled type="checkbox"> C++ Primer</li><li><input checked disabled type="checkbox"> Algorithm 4</li><li><input checked disabled type="checkbox"> Computer System: A Programmer’s Perspective(CSAPP)</li></ul><h4 id="Computer-Architecture"><a href="#Computer-Architecture" class="headerlink" title="Computer Architecture"></a>Computer Architecture</h4><ul><li><input checked disabled type="checkbox"> Introduction to Computing Systems: From Bits and Gates to C</li><li><input checked disabled type="checkbox"> Computer Organization and Design: The Hardware-Software Interface</li><li><input disabled type="checkbox"> Computer Architecture: A Quantitative Approach (6th Edition)</li></ul><h4 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h4><ul><li><input checked disabled type="checkbox"> Operating Systems: Three Easy Pieces(OSTEP)</li><li><input disabled type="checkbox"> Operating Systems Principles &amp; Practice (2nd Edition)</li><li><input disabled type="checkbox"> xv6 book</li><li><input checked disabled type="checkbox"> Advanced Programming Unix Environment</li></ul><h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><ul><li><input disabled type="checkbox"> Database System Concepts (Seventh Edition)</li></ul><h4 id="Computer-Networks"><a href="#Computer-Networks" class="headerlink" title="Computer Networks"></a>Computer Networks</h4><ul><li><input disabled type="checkbox"> Computer Networking: A Top Down Approach (8th Edition)</li></ul><h4 id="Distributed-Systems"><a href="#Distributed-Systems" class="headerlink" title="Distributed Systems"></a>Distributed Systems</h4><ul><li><input disabled type="checkbox"> Designing Data-Intensive Application</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Ch2 信息的表示和处理</title>
      <link href="/2022/05/18/CSAPP-Ch2/"/>
      <url>/2022/05/18/CSAPP-Ch2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第二章后面部分Yale patt讲的比较清楚，因此在读第二遍的时候就没有继续总结了</p></blockquote><span id="more"></span><h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a><strong>信息的表示和处理</strong></h1><ul><li>编译器维护着数据类型的信息，机器级程序不包含所谓的数据类型信息。</li><li>可以将2的幂次十进制数通过$n&#x3D;i+4*j$这个公式来直接转换成十六进制数。其中$0\leq i\leq3$， 1(i&#x3D;0), 2(i&#x3D;1), 4(i&#x3D;2), 8(i&#x3D;3)，可以把十六进制数写成高位是<code>i</code>对应的值，后面跟<code>j</code>个0。如：$2^{11}$转换成十六进制数，$n&#x3D;11&#x3D;3+4\times2$，<code>i</code>对应的值是8，后面跟2个0，得到的结果是<code>0x800</code></li><li><code>大端字节序/网络字节序</code>: 最高有效字节在最前面; <code>小端字节序/主机字节序</code>: 最低有效字节在最前面</li><li>考虑一个$w$位的整数，其位表示位$[x_{w-1}, x_{w-2}, …, x_1, x_0]$，其中$x_0$是最低有效位。假设$w$是8的倍数，这些位就能被分组成<strong>字节</strong>，其中低有效字节包含位$[x_7, x_6, …, x_0]$。某些机器选择再内存中按照从最低有效字节到最高有效字节的顺序存储对象(按字节编址寻址)。</li><li><code>ISA</code>可以同时拥有两种以上顺序模式，如：ARM。而具体决定使用什么字节顺序由操作系统来决定。</li><li>书中提到了<code>指针和数组</code>，想起来<code>P&amp;H</code>中提到过C语言中两者的性能差距。通过观察汇编代码可以发现，数组Loop判断越界下标需要在循环体内计算边界条件的地址，相比较于指针loop完成额外的乘法运算(花更多的指令)</li><li><code>强制转换(cast)</code>并不会改变指针的内容，只是告诉<code>编译器</code>以新的<code>数据类型</code>来看待转换后的数据。</li><li><strong>商用的Achitecture按字节编址寻址</strong></li><li><code>strlen()</code>不计算字符串末尾的空字符; <code>sizeof()</code>会计算末尾的空字符的大小</li><li><code>ASCII</code>和<code>UTF-8</code>编码只占用1个字节，而<code>Unicode</code>占用2~4字节</li><li>C语言中对结果为负数的除法(<code>\</code>)进行的是<strong>向上舍入</strong>，对结果为正数进行的是<strong>向下舍入</strong>，总的来说(<code>\</code>)是<strong>向零舍入</strong>；</li><li>在<strong>向上舍入</strong>时在<strong>移位操作</strong>之前需要加上$2^k-1$的**偏移量(bias)**，如果低位部分超过$2^k$的一半(i.e. $2^{k-1}$)，来达到除法移位操作后正数部分值加<code>1</code>的效果。根据<code>Value box</code>可以想到，相当于将最终的负数结果增大了1，因此也就达成了向上取整的效果(见 2.3.7节)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记《CSAPP》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Ch1 计算机系统漫游</title>
      <link href="/2022/05/18/CSAPP-Ch1/"/>
      <url>/2022/05/18/CSAPP-Ch1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>It is better to fail in originality than to succeed in imitation.</p></blockquote><span id="more"></span><h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a><strong>计算机系统漫游</strong></h1><ul><li>计算机系统是由<strong>硬件</strong>和<strong>系统软件</strong>组成的</li><li>源程序中由<code>ASCII</code>字符构成的文件称为<strong>文本文件</strong>, 所有其他文都称为<strong>二进制文件</strong></li><li>预处理阶段预处理器根据以字符<code>#</code>开头的命令，修改原始C程序，读取系统头文件的内容，并把它直接插入程序文本中，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">--</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><img src="/2022/05/18/CSAPP-Ch1/05/18/CSAPP-Ch1/img-2022-05-17-23-21-05.png"></li><li><code>字(word)</code>: 总线传送定长字节块的大小</li><li>磁盘驱动器(HDD)简单说其实就是磁盘</li><li>适配器: 插在主板插槽的卡(比如图形适配器，显示屏); 控制器：I&#x2F;O设备本身或系统主板上的芯片组</li><li>在键盘上读取<code>hello</code>命令。通过将数据读取到<code>KBDR</code>中(中间涉及到ASCII到Binary的转换)，再将<code>KBDR</code>中的数据存入主存中。整个过程需要CPU参与，引出了概念<code>可编程I/O</code><br><img src="/2022/05/18/CSAPP-Ch1/05/18/CSAPP-Ch1/img-2022-05-17-23-29-59.png"></li><li>因此也延伸出了优化的方案(使用<code>DMA</code>)<br><img src="/2022/05/18/CSAPP-Ch1/05/18/CSAPP-Ch1/img-2022-05-17-23-34-32.png"></li><li>将字符串显示到显示器上。通过将数据写入到<code>DDR</code>中(要将Binary转换为ASCII)，再将<code>DDR</code>中的数据显示到图形适配器上<br><img src="/2022/05/18/CSAPP-Ch1/05/18/CSAPP-Ch1/img-2022-05-17-23-35-01.png"></li><li><code>Cache</code>产生的原因：随着时间的推移<code>DRAM</code>的性能和<code>Disk</code>相差三个数量级; Cache充分利用了<strong>局部性原理</strong>。</li><li><code>Posix标准</code>：标准化<code>Unix</code>的开发</li><li><code>上下文切换</code>涉及到<code>PC</code>和<code>寄存器组</code>的Save和Restore<br><img src="/2022/05/18/CSAPP-Ch1/05/18/CSAPP-Ch1/img-2022-05-17-23-40-48.png" alt="存储器层次结构"></li><li>进程虚拟内存中的内容存储在磁盘上，而主存作为磁盘的缓存, 造成<code>容量又大速度又快</code>的假象。<br><img src="/2022/05/18/CSAPP-Ch1/05/18/CSAPP-Ch1/img-2022-05-17-23-44-21.png" alt="进程虚拟地址空间"></li><li>Unix I&#x2F;O的读写系统调用为<code>逻辑读写</code></li><li>通过<code>网络适配器</code>可以在不同主机之间在交换主存中的数据</li><li><code>Amdahl&#39;s law</code>: $S&#x3D;\frac{1}{(1-\alpha)+\alpha&#x2F;k}$, 其中$S$为加速比, $\alpha$为提高部分的执行时间占总时间的比例, $k$为该部分性能提升的比例; 其中<code>2.2倍</code>可以表示为<code>2.2x</code></li><li><code>TLP</code>, <code>ISP</code>, <code>SIMD</code></li><li><img src="/2022/05/18/CSAPP-Ch1/05/18/CSAPP-Ch1/img-2022-05-18-11-24-10.png" alt="Abstraction"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记《CSAPP》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Letex Note</title>
      <link href="/2022/05/18/Letex-Note/"/>
      <url>/2022/05/18/Letex-Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下记录一些本人常用的公式, 因为deploy之后对部分公式支持较差，因此有部分删减</p></blockquote><span id="more"></span><h4 id="1-数学模式"><a href="#1-数学模式" class="headerlink" title="1. 数学模式"></a><strong>1. 数学模式</strong></h4><ol><li>行内公式(inline math)<code>$...$</code>与文本融为一体。</li><li>独立公式(display math)<code>$$..$$</code>独立成段，复杂公式包括微积分方程等都是采用行间公式</li><li>LaTex注释符号为<code>%</code></li></ol><h4 id="2-输入上下标"><a href="#2-输入上下标" class="headerlink" title="2. 输入上下标"></a><strong>2. 输入上下标</strong></h4><p><code>^</code>表示上标，<code>_</code>表示下标</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>i<span class="built_in">^</span>na<span class="built_in">_</span>i<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><ul><li>显示:<br>$$\sum_i^na_i$$</li></ul><h4 id="3-输入分数"><a href="#3-输入分数" class="headerlink" title="3. 输入分数"></a><strong>3. 输入分数</strong></h4><p>分数的输入形式<code>\frac&#123;分子&#125;&#123;分母&#125;</code></p><ul><li>例子:<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p(v)=<span class="keyword">\frac</span>&#123;1&#125;&#123;1+exp(-v/t)&#125;</span><br></pre></td></tr></table></figure></li><li>显示:</li></ul><p>$$p(v)&#x3D;\frac{1}{1+exp(-v&#x2F;t)}$$  </p><h3 id="4-输入根号"><a href="#4-输入根号" class="headerlink" title="4. 输入根号"></a><strong>4. 输入根号</strong></h3><ul><li>例子:<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;12&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\sqrt</span>[n]&#123;12&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li><li>显示:<br>$$\sqrt{12} \<br>\sqrt[n]{12}$$</li></ul><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\langle</td><td>$\langle$</td><td>\rlangle</td><td>$\rangle$</td></tr><tr><td>\lceil</td><td>$\lceil$</td><td>\rceil</td><td>$\rceil$</td></tr><tr><td>\lfloor</td><td>$\lfloor$</td><td>\rfloor</td><td>$\rfloor$</td></tr><tr><td>\lbrace</td><td>$\lbrace$</td><td>\rbrace</td><td>$\rbrace$</td></tr><tr><td>\lvert</td><td>$\lvert$</td><td>\rvert</td><td>$\rvert$</td></tr><tr><td>\lVert</td><td>$\lVert$</td><td>\rVert</td><td>$\rVert$</td></tr></tbody></table><h4 id="7-积分"><a href="#7-积分" class="headerlink" title="7.积分"></a><strong>7.积分</strong></h4><ul><li>例子:<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>0<span class="built_in">^</span>1&#123;x+1&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li><li>显示:<br>$$ \int_0^1{x+1} $$</li></ul><h4 id="8-极限运算"><a href="#8-极限运算" class="headerlink" title="8. 极限运算"></a><strong>8. 极限运算</strong></h4><p>使用<code>\lim_&#123;变量 \to 表达式&#125;&#123;表达式&#125;</code>来输入一个极限。</p><ul><li>例子:<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> <span class="keyword">\infin</span>&#125;<span class="keyword">\frac</span>&#123;1&#125;&#123;n+1&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li><li>显示:<br>$$\lim_{x \to \infin}\frac{1}{n+1}$$</li></ul><h4 id="9-累加乘积运算"><a href="#9-累加乘积运算" class="headerlink" title="9. 累加乘积运算"></a><strong>9. 累加乘积运算</strong></h4><p>使用<code>\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125;</code>来输入一个累加。与之类似，使用 <code>\prod</code>, <code>\bigcup</code>, <code>\bigcap</code>来分别输入累乘、并集和交集。</p><ul><li>例子:<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n&#123;<span class="keyword">\frac</span>&#123;1&#125;&#123;i<span class="built_in">^</span>2&#125;&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li><li>显示:<br>$$\prod_{i&#x3D;1}^n{\frac{1}{i^2}}$$</li></ul><h4 id="10-希腊字符"><a href="#10-希腊字符" class="headerlink" title="10. 希腊字符"></a><strong>10. 希腊字符</strong></h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\alpha</td><td>$\alpha$</td><td>\xi</td><td>$\xi$</td></tr><tr><td>\gamma</td><td>$\gamma$</td><td>\sigma</td><td>$\sigma$</td></tr><tr><td>\epsilon</td><td>$\epsilon$</td><td>\Delta</td><td>$\Delta$</td></tr><tr><td>\lambda</td><td>$\lambda$</td><td>\rho</td><td>$\rho$</td></tr><tr><td>\delta</td><td>$\delta$</td><td>\theta</td><td>$\theta$</td></tr></tbody></table><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><p>[1] <a href="https://www.zybuluo.com/codeep/note/163962#9%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5%E6%9E%81%E9%99%90%E8%BF%90%E7%AE%97">Cmd Markdown 公式指导手册</a></p><p>[2] <a href="https://www.cnblogs.com/nowgood/p/latexstart.html">MarkDown 中使用 LaTeX 数学式</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61B Lec Note</title>
      <link href="/2022/05/18/CS61B-Lec-Note/"/>
      <url>/2022/05/18/CS61B-Lec-Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Data Structure in Java</p></blockquote><span id="more"></span><h1 id="CS61B-Data-Structure-Notes"><a href="#CS61B-Data-Structure-Notes" class="headerlink" title="CS61B Data Structure Notes"></a>CS61B Data Structure Notes</h1><h1 id="Java-Syntax"><a href="#Java-Syntax" class="headerlink" title="Java Syntax"></a><strong>Java Syntax</strong></h1><ul><li>Java除了8种基本类型(按值传递)<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>boolean</code>, <code>char</code>之外，其他一切，包括<code>数组</code>，不是原始类型，而是<code>Reference Type</code>(引用类型)，说白了就是指针。</li><li>声明任何引用类型(Reference Type)的变量，java会分配一个64-bit的box，这64-bit种不包含数据(如对象的属性等)，而是包含该数据的在内存中的地址。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;             </span><br><span class="line">b = a;                <span class="comment">// 将a在内存中的地址赋给b，使a和b指向同一内容。</span></span><br></pre></td></tr></table></figure></li><li>嵌套类(Nested Class)。经验法则：如果不使用外部类的任何实例成员，则将嵌套类定义为<code>static</code>。因为被声明为static的嵌套类不能访问外部类的实例成员, 同时也节约了内存。</li><li>文件名必须和类名相同，每个文件必须只包含一个外部类。</li><li>泛型(Generic Type)仅适用于引用类型，尖括号内不能放入原始类型比如:int, double, 但是可以放入原始类型的引用版本，如: <code>Integer</code>, <code>Double</code>, <code>Character</code>, <code>Boolean</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code>, <code>Float</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;genericTypeName&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> genericTypeName item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(IntNode _prev, genericTypeName _item, IntNode _next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = _prev;</span><br><span class="line">            <span class="built_in">this</span>.item = _item;</span><br><span class="line">            <span class="built_in">this</span>.next = _next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLList</span><span class="params">(genericTypeName x)</span> &#123;</span><br><span class="line">        prev = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        DDList&lt;String&gt; d1 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        DDList&lt;Integer&gt; d2 = <span class="keyword">new</span> <span class="title class_">DDList</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 上一行代码和这行是相等的实例化尖括号声明类型可以省略</span></span><br><span class="line">        DDList&lt;Integer&gt; d2 = <span class="keyword">new</span> <span class="title class_">DDList</span>&lt;Integer&gt;(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>创建数组的三种方法:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">y = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] z = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;   <span class="comment">// 类似第二种方法，但只能和声明结合时使用</span></span><br></pre></td></tr></table></figure></li><li>java数组仅在运行时执行边界检查。System.arraycopy()方法非常方便使用。</li><li><code>[]</code>允许我们在运行时指定想要的索引，而类中指定字段就不行。</li><li>创建泛型对象数组的方法(虽然java不允许，而且编译器会报错)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glorp[] items = (Glorp []) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure></li><li>判断两个字符串是否相等使用<code>equals</code>而不是<code>==</code>的原因是，<code>==</code>比较的是地址，而<code>equals</code>比较的是存储单元中的值。</li><li>java不允许使用<code>&gt;</code>运算符在字符串之间比较，而是用<code>str1.compareTo(str2)</code>来进行比较，如果相等则返回0，str1 &gt; str2则返回一个正数。</li><li><code>org.junit</code>库提供了很多方法来简化测试的编写, <a href="https://junit.org/junit4/javadoc/4.12/org/junit/Assert.html">Junit官方文档</a>; <code>import static org.junit.Assert.*</code> <code>import org.junit.Test</code>之后，就可以省略掉<code>org.junit.Assert</code>前缀，进而直接使用<code>assertEquals</code>方法; 需要在每个方法前加上<code>@org.junit.Test</code>来替代<code>@Test</code>, IDEA中Junit可视化测试是根据<code>@Test</code>标签在运行时自动检测的。</li><li>获取String的第i个字符的方法<code>str.charAt(i)</code>。</li><li>Java中字符使用单引号，字符串则使用双引号。</li><li><code>public class AList&lt;Item&gt; implements List61B&lt;Item&gt;&#123;...&#125;</code>, implements, 接口继承，子类可以使用父类的方法，也可以覆盖父类的方法; <code>AList</code>将保证拥有并定义<code>List61B</code>接口中指定的所有属性和方法; <code>AList</code> is a <code>List61B</code>, 他们之间是<code>is a</code>关系; 在<code>AList</code>中实现<code>List61B</code>的方法时，<code>@Override</code>是必要的, 这是为了提醒编译器通知你可能发生的错误。</li><li><code>List61B&lt;Item&gt; lst = new AList&lt;&gt;();</code>完成多态。</li><li><code>StdRandom</code>库生成随机数<a href="https://introcs.cs.princeton.edu/java/stdlib/javadoc/StdRandom.html">文档</a>。</li><li><code>assertEquals(message, expected, actual)</code>, JUnit测试失败时输出有用信息, 将预期值和实际值作为<code>message</code>。</li><li>Difference between <code>implement</code> and <code>extends</code>。</li><li>实现继承<code>extends</code>(is a关系, 继承…)关键字，子类继承父类的所有成员包括(构造函数不被继承)：<ul><li>所有实例和静态变量</li><li>所有方法</li><li>所有嵌套类</li></ul></li><li>在子类的构造函数中需要调用父类的构造函数，在子类的构造函数中使用<code>super()</code>关键字。原因: 比如<code>TA extends Human</code>(TA is a Human), 先需要创建一个人，接着创建TA才有意义; 当然如果我们不这样做，Java会<strong>自动</strong>调用super类的<code>无参构造函数</code>。</li><li>Java中的每个类都是<code>Object Class</code>或者是它的后代(descendant), 类没有<strong>显示地</strong>extends仍然会<strong>隐式地</strong>extends <code>Object Class</code>。</li><li>Java可以用<code>interface</code>(接口)类型来充当函数指针。</li><li>通过接口继承来定义一个比较接口<code>CompareTo</code>，解决<code>Object</code>对象之间不能比较的问题。</li><li>抽象数据类型(Abstract Data Type), 简称ADT, 指的是一种数据类型，只带有行为，没有任何具体的方式来实现展示这些行为(抽象的); <code>java.util</code>库中包含三个最重要的ADT: <ul><li><img src="https://pic4.zhimg.com/80/v2-a8b3d43d066476b5c6eafbcdc5071c5a.png" alt="白色框是接口, 蓝色框是具体的类"></li><li><code>List</code>, 比较流行的实现是(ArrayList)<code>List&lt;String&gt; lst = new ArrayList&lt;String&gt;();</code></li><li><code>Set</code>, 比较流行的实现是(HashSet)<code>Set&lt;String&gt; ss = new HashSet&lt;&gt;();</code></li><li><code>Map</code>。比较流行的实现是(HashMap)<code>Map&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;();</code></li></ul></li><li>接口(interface)的特性:<ul><li>所有方法都必须是<code>public</code></li><li>所有变量都必须是<code>public static final</code>，<code>final</code>类似于cpp的<code>const</code></li><li>无法实例化</li><li><strong>默认情况</strong>下，所有方法都是<code>abstract</code>的，除非指定为<code>defualt</code></li><li>每个类可以<code>Implements</code>多个<code>Interface</code>。</li></ul></li><li>抽象类(Abstract类似cpp), 介于<code>interface</code>和<code>concrete class</code>之间。<ul><li>方法可以是<code>public</code>也可以是<code>private</code>，或者<code>protected</code></li><li>可以有任何类型的变量</li><li>无法实例化</li><li><strong>默认情况</strong>下，方法是<code>concrete</code>的，除非指定为<code>abstract</code></li><li>每个类只能<code>Implements</code>一个<code>Abstract</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GraphicObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meveTo</span><span class="params">(<span class="type">int</span> newX, <span class="type">int</span> newY)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>wrapper class(包装类)，如int的包装类是Integer。Java可以在原始类型和包装类型(也成为引用类型)之间进行<strong>隐式转换</strong>。两个方向的转换成为装箱(box)(int-&gt;Integer), 拆箱(unbox)(Integer-&gt;int); 注意:<ul><li>数组永远不会自动装箱或自动拆箱</li><li>自动装箱和拆箱会对性能产生影响</li><li>包装类型比原始类型使用更多的内存, 关于内存使用信息的拓展<a href="http://www.javamex.com/tutorials/memory/object_memory_usage.shtml">此链接</a>或<a href="http://blog.kiyanpro.com/2016/10/07/system_design/memory-usage-estimation-in-java/">链接</a></li></ul></li><li>Java同如CPP这样的语言，会自动隐式向上类型转换，若占用字节较大的类型转换为较小的类型则需要手动去转换。</li><li>不可变数据类型，如String或加上<code>final</code>关键字修饰的基本类型。<ul><li>优点：防止错误并使调试更容易</li><li>缺点：需要创建一个新对象才能更改属性。</li></ul></li><li>在Java中异常是对象，抛出异常的格式<code>throw new IllegalArgumentException(&quot;can&#39;t add null&quot;);</code></li><li>在Java中可以定义一个迭代器接口, 如ADT需使用则<code>extend</code>或者Implement这个接口，需要有next, hasNext方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Java中创建<code>Package</code>(类似于cpp的namespace), 存储package的文件夹名称应该和包一致<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ug.joshh.animal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>JAR</code>文件就像zip文件一样，完全可以将文件解压缩并转换回.java文件。</li><li>public、protected、package-private、private的访问控制权限:<img src="https://pic4.zhimg.com/80/v2-6d77a6127e21f7f37c62dd23bf1df0b9.png" alt="Image"></li><li>Java中操作文件，查看<a href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html">File javadocs</a>和使用<code>Utils.java</code>类，该类具有许多有用的文件操作辅助函数。</li><li>序列化(seralize), 将java<strong>对象</strong>序列化为文件(持久性)，通过implements<code>Serializable</code>接口</li><li>使用<code>Utils</code>类(proj Gitlet提供的子集)中的辅助函数来序列化和反序列化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Model m;</span><br><span class="line"><span class="type">File</span> <span class="variable">outFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializing the Model object</span></span><br><span class="line">writeObject(outFile, m);</span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line">Model m;</span><br><span class="line"><span class="type">File</span> <span class="variable">inFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deserializing the Model object</span></span><br><span class="line">m = readObject(inFile, Model.class);</span><br></pre></td></tr></table></figure></li><li>可变参数形式<code>static void writeContents(File file, Object... contents)</code></li><li>常用ADT的操作<ul><li>Stacks<ul><li><code>push(int x)</code>: 将x放在栈顶</li><li><code>int pop()</code>: 获取栈顶元素</li></ul></li><li>Lists<ul><li><code>add(int i)</code>: 添加一个元素</li><li><code>int get(int i)</code>: 获取索引i处的元素</li></ul></li><li>Sets<ul><li><code>add(int i)</code>: 添加一个元素</li><li><code>contains(int i)</code>: 返回集合是否包含值得布尔值</li></ul></li><li>Maps<ul><li><code>put(K key, V value)</code>: 将键值放入哈希表中</li><li><code>V get(K key)</code>: 获取key对应得值</li></ul></li></ul></li><li>Java泛型<a href="https://docs.oracle.com/javase/tutorial/java/generics/bounded.html">bounded type parameter</a></li><li><code>Collection</code>可以由许多不同的数据结构实例化</li></ul><h1 id="IDEA-Skill"><a href="#IDEA-Skill" class="headerlink" title="IDEA Skill"></a><strong>IDEA Skill</strong></h1><ul><li>左键点击行号的右侧打断点</li><li>条件断点，在断点的基础上右键增加条件。进入Debug模式后，拖动console到右侧可以同时显示console和Debugger。</li><li>比较好用的Plugin: <code>Java visualizer</code>, <code>IdeaVim</code>, IDEA自带的<code>Sheck Style</code>。</li><li><code>Step into</code> vs. <code>Step over</code>, Step into进入函数，而Step over则不进入函数直接向下执行。<code>Step out</code>跳出函数。</li><li><code>Resuming</code>类似于continue，跳到条件断点的下一个条件，在step over的左下侧向右的绿色箭头</li><li><code>Destructive</code> vs. <code>Non-Destructive</code>, 非破坏性调用函数没有修改传入的数据结构，相反破坏性则修改了传入的数据结构。</li><li>创建JAR文件<ul><li>File -&gt; Project Structure -&gt; Artifacts -&gt; JAR -&gt; “From modules with dependencies</li></ul></li><li>IDEA将生成的<code>.class</code>文件存储在<code>out</code>或<code>target</code>文件夹中。</li></ul><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a><strong>Algorithm</strong></h1><h2 id="1-Big-Theta-Theta-来代替order-of-growth-增长级"><a href="#1-Big-Theta-Theta-来代替order-of-growth-增长级" class="headerlink" title="1.(Big-Theta$\Theta$来代替order of growth(增长级))"></a><strong>1.(Big-Theta$\Theta$来代替order of growth(增长级))</strong></h2><pre><code>- Only consider the worst case.- Pick a representative operation (aka: cost model)- Ignore lower order terms- Ignore multiplicative constants.</code></pre><h2 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2.并查集"></a><strong>2.并查集</strong></h2><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><pre><code>- Connect()- isConnect()- find()- parent[]</code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>路径压缩<br> $$lg^<em>n :&#x3D; \begin{cases}0, &amp; \text {if n $\leq$ 1}\ 1+lg^</em>(lgn), &amp; \text{if n $&gt;$ 1} \end{cases}$$  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">        id[p] = id[id[p]]; <span class="comment">// 路径压缩，使得下次查找更快</span></span><br><span class="line">        p = id[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>按秩合并</li></ol><ul><li>规则：将<code>height</code>较小的Set连接到<code>height</code>较大的Set<h2 id="3-渐近线分析"><a href="#3-渐近线分析" class="headerlink" title="3.渐近线分析"></a><strong>3.渐近线分析</strong></h2>并不是所有两层for循环的复杂度都为$\Theta(N^2)$, 比如下面这个for loop的复杂度为$C(N) &#x3D; 1 + 2 + 4 + … + N &#x3D; 2N-1$(如何N为2的幂)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printParty</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j += <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);   </span><br><span class="line">            <span class="type">int</span> <span class="variable">ZUG</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>递归, 复杂度为$C(N) &#x3D; 1 + 2 + 4 + 8 + … + 2^{N-1} &#x3D; 2(2^{N-1})-1 &#x3D; 2^N-1 &#x3D; \Theta(N)$<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> f3(n-<span class="number">1</span>) + f3(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>$O$(<code>Big O</code>)是$\Theta$(<code>Big Theta</code>)在不考虑最好情况和最坏情况下的表示, 在不同的输入，运行时间不同的情况下，它允许我们做出没有实例(case)限定的简单语句</li><li>$\Theta$形式表示增长级(Order of growth)为$F(N)$</li><li>$\Omega$表示增长级小于等于$F(N)$</li><li>$\Omicron$表示增长级大于等于$F(N)$<h2 id="4-归并排序-Merge-Sort"><a href="#4-归并排序-Merge-Sort" class="headerlink" title="4.归并排序(Merge Sort)"></a><strong>4.归并排序(Merge Sort)</strong></h2>结合选择排序来理解，在选择排序上进行优化$\Theta(nlogn)$, 额外开辟一个存储结果的空间，利用双指针获得最后的排序数组。</li></ul><h2 id="5-均摊-Amortized-分析"><a href="#5-均摊-Amortized-分析" class="headerlink" title="5.均摊(Amortized)分析"></a><strong>5.均摊(Amortized)分析</strong></h2><p>$\Phi_i &#x3D; \Phi_{i-1} + a_i - c_i$, 其中$c_i$是操作的真实开销，$a_i$是随机摊销操作的开销，在所有$i$中必须一致。假设$\Phi_0 &#x3D; 0$。</p><h2 id="6-二叉搜索树-BST-Binary-Search-Trees"><a href="#6-二叉搜索树-BST-Binary-Search-Trees" class="headerlink" title="6.二叉搜索树(BST Binary Search Trees)"></a><strong>6.二叉搜索树(BST Binary Search Trees)</strong></h2><p>除了含有二叉树的属性外，对于树中的每个节点X，要求左子树中的每个键都小于X的键，右子树中的每个键都大于X的键。需要成员为<code>root</code>, 具备的私有内嵌类有<code>BSTNode</code>，其中的成员为<code>key</code>, <code>value</code>, <code>left</code>, <code>right</code>, <code>node count</code>。</p><h3 id="插入put"><a href="#插入put" class="headerlink" title="插入put"></a>插入<code>put</code></h3><ul><li>总是在叶节点插入, 递归找到<code>null</code>节点后创建一个node count为1的<code>Node</code>。<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3></li><li>被删除节点没有子节点, 直接删除它的父指针</li><li>被删除节点有1个子节点，将父节点的子指针分配给被删除节点的子节点</li><li>被删除节点有2个子节点，由新的节点来替换，必须要大于左子树，且小于右子树, 即取右子树的<code>min</code>或者左子树的<code>max</code>两种解决方案。<strong>Hibbard deletion</strong>，维护好删除节点后后BST的平衡性, 要实现的方法有<code>ceiling</code>, <code>floor</code>, <code>deleteMin</code>, <code>deleteMax</code>。<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3></li><li><code>get</code>递归返回值，而<code>put</code>递归返回一个子树。<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3></li><li><code>depth</code>, <code>height</code>, <code>average depth</code>:<br>  <img src="https://pic4.zhimg.com/80/v2-e925732ad6e4f45795982fe471a6eed9.png" alt="BST"><br>  $$Average Depth &#x3D; \frac{\sum^D_{i&#x3D;0}d_in_i}{N}$$<br>  其中$d_i$为depth, $n_i$为当前层节点的数目<br>  <img src="https://pic4.zhimg.com/80/v2-ecdf853a69118f5400c7fa20e1986555.png" alt="BST"><h3 id="BST存在的问题"><a href="#BST存在的问题" class="headerlink" title="BST存在的问题"></a>BST存在的问题</h3>我们总是在叶子节点处插入，这是导致高度增加的原因。插入顺序不同会导致高度不同。</li><li>树的<strong>高度</strong>决定了最坏情况的运行时间，</li><li>树的<strong>平均深度</strong>决定了平均情况的运行时间。<br><img src="https://pic4.zhimg.com/80/v2-8010a66ab4fb46d6c67ecb5f5f433b84.png" alt="BST"><h2 id="7-B树-B-Trees"><a href="#7-B树-B-Trees" class="headerlink" title="7.B树(B-Trees)"></a><strong>7.B树(B-Trees)</strong></h2></li><li>B树很好地避免了BST存在的问题, 最糟糕搜索情况为$O(N)$——以链表的形式展开</li><li>BigO $\not &#x3D;$ Worst Case</li><li>L非常大的情况，在数据库和文件系统中会出现。</li><li><code>2-3树</code>, 通常指明<code>L</code>(每个节点中项(item)的最大数量)为2，而<code>2-3</code>指的是可以拥有的孩子节点的数量为2或3。</li><li><code>max-degree</code>指的是所能拥有最多孩子节点的个数, <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B树可视化模拟</a>。<h3 id="B树不变量-Invariant"><a href="#B树不变量-Invariant" class="headerlink" title="B树不变量(Invariant)"></a>B树不变量(Invariant)</h3>保证了B树的<code>bushy</code>。</li><li>所有叶子节点到根节点有着<strong>相同</strong>的距离</li><li>含有<code>k</code>项的节点一定含有<code>k+1</code>个子节点。<h3 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h3></li><li>向叶子节点中插入，沿着树向下遍历以及根据当前节点项的大小左右遍历</li><li>将节点添加到叶子节点后，如果项数&gt;L, 则弹出<strong>中左</strong>(middle left)项，加入到父节点中重新排列。</li><li>如果父节点的项数也大于L，则再次弹出<strong>中左</strong>项目</li><li>重复完成此过程，直到父节点可以容纳或到达根节点。<h3 id="搜索B树运行时最坏情况分析"><a href="#搜索B树运行时最坏情况分析" class="headerlink" title="搜索B树运行时最坏情况分析"></a>搜索B树运行时最坏情况分析</h3></li><li>总运行时间$O(LlogN)$, 搜索在树中最大的数，遍历到底部需要$O(logN)$, 向右遍历得到最大数需要$O(L)$, 因为当前节点有有L个项。<h3 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h3>分以下几种情况, 打算做到15445的proj2 B+Tree的时候再review B树删除操作的<a href="https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g508ece10b0_1_1305">slide</a></li><li>Case 1: Multi-Key Sibling</li><li>Case 2: Multi-Key Parent</li><li>Case 3: Single-Key Parent and Sibling<h3 id="B树的特性总结"><a href="#B树的特性总结" class="headerlink" title="B树的特性总结"></a>B树的特性总结</h3></li><li>Nodes may contain between<code>1</code>and<code>L</code>items.</li><li>contains works almost exactly like a normal BST.</li><li>add works by adding items to existing leaf nodes.</li><li>If nodes are too full, they split.</li><li>Resulting tree has perfect balance. Runtime for operations is $O(logN)$.</li><li>B-trees are more complex, but they can efficiently handle ANY insertion order.</li><li>B树实现起来比较复杂，相对来说比较慢<h2 id="8-红黑树-Red-Black-Trees"><a href="#8-红黑树-Red-Black-Trees" class="headerlink" title="8. 红黑树(Red-Black Trees)"></a><strong>8. 红黑树(Red-Black Trees)</strong></h2></li><li>left-Leaning Red Black Binary Search Tree (LLRB)<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3></li><li>不存在节点含有两个<code>red links</code>(意味着4个item一个节点，在2-3树中是不存在的)。</li><li>叶子节点到root的<code>black links</code>数一致。<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3></li><li>在2-3树，插入时总是使用<code>red links</code>。</li><li>通过旋转使得<code>red links</code>在左侧。右侧的<code>Red links</code>是不允许的, 除了<code>temporary 4 node</code>即含有两个red links的子节点</li><li>如果出现2个连续的左侧连接，则通过右旋转来调整为<code>temporary 4 node</code></li><li>含有<code>temporary 4 node</code>, 即含有两个red links的子节点, 则<code>color clip</code>来模拟BST的<code>split</code>. <code>Color Flip</code>指将当前节点的两个<code>red links</code>变黑，并将父节点的<code>black links</code>变红。如果当前节点为根节点则，则不存在将父节点变红这一步。<h3 id="红黑树总结"><a href="#红黑树总结" class="headerlink" title="红黑树总结"></a>红黑树总结</h3></li><li>61B的<a href="https://docs.google.com/presentation/d/1jgOgvx8tyu_LQ5Y21k4wYLffwp84putW8iD7_EerQmI/edit#slide=id.g463de7561_042">demo</a>通过insert来理解红黑树的特性。</li><li>红黑树和B树的复杂度一致</li><li>将BST转化为红黑树的代码实现<img src="https://pic4.zhimg.com/80/v2-7cd7df921c5da3080ef5c0d352e71b84.png" alt="Image"></li></ul><h2 id="9-哈希"><a href="#9-哈希" class="headerlink" title="9. 哈希"></a><strong>9. 哈希</strong></h2><ul><li>Properties of HashCode(哈希值)<ul><li>必须是整数</li><li><code>.hashCode()</code>在同一对象上运行两次，应该返回相同的数字</li><li>被考虑的两个对象<code>.equal()</code>必须具有相同的哈希码</li></ul></li><li>实际上哈希表key-value对，在Java中key在哈希表中的索引是由<code>hashCode()</code>成员函数生成的。</li><li>溢出会引起冲突(出现在哈希值过大的情况下)，比如最大的整型数加1会变成最小的整型数</li><li>避免冲突的方式，取模而不是无限地增大空间。</li><li>尝试用链表数组(ArrayList), 即数组元素为链表，来作为哈希的空间，处理碰撞的复杂度$\Theta(Q)$, 因为<code>add</code>和<code>contains</code>需要检查当前链表数组元素(即链表)的第<code>Q</code>项是否为存在。最坏的情况下为所有项目的hashCode都是相同的，因此需要$\Theta(N)$。</li><li>利用<strong>模运算</strong>来减少bucket的数量了。<h3 id="动态增长哈希表"><a href="#动态增长哈希表" class="headerlink" title="动态增长哈希表"></a>动态增长哈希表</h3></li><li>假设含有<code>M</code>个Bucket和<code>N</code>个items。Bucket相当于一个链表数组的一个元素。<img src="https://pic4.zhimg.com/80/v2-12a66211e25a00cd7ba604f07378324e.png" alt="Image"></li><li>每隔一段时间就<strong>Double</strong> M创建一个新的哈希表，来确保时间复杂度为$\Theta(N&#x2F;M)$即$\Theta(1)$。</li><li>遍历旧的哈希表，将元素一个个地添加到新的哈希表中。因为哈希表大小的改变，元素对哈希表大小的模数也会发生变化。</li><li><code>Load Factor</code>(即N&#x2F;M)等于上述最好情况(Best case)的运行时间。如果<code>N</code>在增加，Load Factor也将会持续增加</li><li><code>Load Factor Threshold</code>，当Load factor大于load factor threshold时就<code>resize</code>。 resize需要$\Theta(N)$的时间，因为需要将N个items添加到哈希表中，每个添加需要$\Theta(1)$的时间。</li><li>注意: 当resize时，不需要检查项目是否已经存在于Linkedlist中(因为知道没有重复项)，所以<code>Add</code>只需要$\Theta(1)$的时间<h3 id="经验法则"><a href="#经验法则" class="headerlink" title="经验法则"></a>经验法则</h3></li><li>使用<code>base</code>策略，即模数。</li><li>使用一个小的质数作为<code>base</code>。素数非偶特性有助于避免溢出问题，以及更容易计算等等。<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3></li><li>当一个目标变量改变，它的哈希值也改变。因此不要再哈希表中存储能够改变的Objects<h3 id="避免冲突的方法"><a href="#避免冲突的方法" class="headerlink" title="避免冲突的方法"></a>避免冲突的方法</h3></li><li>开放定址法(open addressing), 如果目标bucket已经存在，则选择不同的bucket<ul><li>linear Probing(线性探测法)，如果当前bucket已被占用，使用下一个bucket，一个接着一个扫描</li></ul></li></ul><h2 id="10-堆和优先队列"><a href="#10-堆和优先队列" class="headerlink" title="10. 堆和优先队列"></a><strong>10. 堆和优先队列</strong></h2><ul><li>涉及到搜索树的优先级?</li><li>堆的数据结构是<strong>二叉搜索树</strong></li></ul><h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><ul><li>属性<ul><li>每个节点都小于等于它的两个子节点。</li></ul></li><li>操作<ul><li>add: 临时添加到堆尾，<code>swimming</code>到合适的位置。</li><li>getSmallest: 返回堆的根。</li><li>removeSmallest: 将堆中的最后一项交换到根中，将层次结构下沉到适当的位置。<h3 id="Implementation-of-PQ"><a href="#Implementation-of-PQ" class="headerlink" title="Implementation of PQ"></a>Implementation of PQ</h3></li></ul></li><li>leftchild(k) &#x3D; k * 2;</li><li>rightchild(k) &#x3D; k * 2 - 1;</li><li>parent(k) &#x3D; k &#x2F; 2;</li><li>实现基于的数据结构: <code>数组</code>, <code>BST</code>, <code>哈希表</code>，<code>堆</code></li><li><img src="https://pic4.zhimg.com/80/v2-f23000dfd8f9db7487f066e4558fc55d.png" alt="Image"></li></ul><h2 id="树和图的遍历"><a href="#树和图的遍历" class="headerlink" title="树和图的遍历"></a><strong>树和图的遍历</strong></h2><ul><li>树也是图的一种实现方式, 无环。</li><li>先序遍历(preorder traversal)适合打印目录结构。</li><li>后序遍历(postorder traversal)同样适用计算出当前目录下的文件总大小。</li></ul><h3 id="简单图的定义"><a href="#简单图的定义" class="headerlink" title="简单图的定义"></a><strong>简单图的定义</strong></h3><ul><li>不存在一个顶点的边回到自身。</li><li>不存在两条边连着同样的顶点。</li></ul><h3 id="图的类型"><a href="#图的类型" class="headerlink" title="图的类型"></a><strong>图的类型</strong></h3><ul><li>Acyclic(非循环) vs. cyclic(循环), 循环指的是第一个顶点和最后一个顶点是同一个。</li><li>Directed(有向) vs. Indirected(无向)</li><li>With edge label(a.k.a. weight)(边权重).</li></ul><h3 id="图的问题"><a href="#图的问题" class="headerlink" title="图的问题"></a><strong>图的问题</strong></h3><ul><li>s-t Path? 由顶点s到t是否存在路径?</li><li>Connectivity? 每个顶点到其它顶点是否存在路径?</li><li>Biconnectivity? 如果将某两个顶点的边移除，图就不是连通的了。</li><li>Shortest s-t Path?</li><li>Cycle Detection?</li><li>Euler(欧拉) Tour? 是否存在一个cycle使得所有边只使用一次。</li><li>Hamilton Tour? 是否存在一个cycle使得所有顶点只使用一次。</li><li>Planarity(平面化)? 能否画一张图不出现交叉的边。</li><li>Isomorphism? 两个图是否为同构?</li></ul><h3 id="Depth-First-Traversal"><a href="#Depth-First-Traversal" class="headerlink" title="Depth-First Traversal"></a><strong>Depth-First Traversal</strong></h3><ul><li>marks, 可以避免connected(v, t)–(寻找neighborhood)的无限循环。</li><li>marked(), 判断是否被标记</li><li>edgeTo[w] &#x3D; v, 添加边</li></ul><h3 id="Graph-Traversal"><a href="#Graph-Traversal" class="headerlink" title="Graph Traversal"></a><strong>Graph Traversal</strong></h3><ul><li>Dfs postorder, 若当前顶点的邻居都被标记时才返回当前顶点的值。</li><li>Dfs preorder, 若遍历到当前顶点即打印值。</li><li>BFS</li></ul><h3 id="Graph-API"><a href="#Graph-API" class="headerlink" title="Graph API"></a><strong>Graph API</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span>:               Create empty graph with v vertices</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span>: add an edge v-w</span><br><span class="line">  Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>:      vertices adjacent to v</span><br><span class="line">  <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>:                           number of vertices</span><br><span class="line">  <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>:                           number of edges</span><br></pre></td></tr></table></figure><h3 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a><strong>图的实现</strong></h3><ul><li>邻接矩阵(无向图)</li><li>邻接链表(有向图)</li><li>边集合, 如<code>&#123;&#123;0, 2&#125;, &#123;0, 1&#125;&#125;</code>表示顶点0分别指向1和2。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS61B </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61C C Note</title>
      <link href="/2022/05/18/CS61C-C-Note/"/>
      <url>/2022/05/18/CS61C-C-Note/</url>
      
        <content type="html"><![CDATA[<!-- # CS61C C Part Notes. --><blockquote><p>揭示C语言的本质</p></blockquote><span id="more"></span><ol><li>Array在传递给函数时记得必须要一并传递Array的大小，因为在函数内使用<code>sizeof</code>会得到不正确的结果。</li><li>Array in C don’t know their size.</li><li>数组名不是一个变量。</li><li>Struct Alignment.</li><li>A String in C is just an array of characters. </li><li>String end. Last character is followed by a 0 byte(‘\0’)(a.k.a <code>null terminator</code>).</li><li><code>strlen()</code> return the length of string(not including null term).</li><li>Pointer Arithmetic, Pointer+1实际上是加指针指向的类型的大小<code>sizeof(*p)</code>. Pointer arithmetic moves the pointer by the<br>size of the thing it’s pointing to.</li><li>注意<code>postfixal</code>++的优先级要大于dereference(*), 注意这两种区别<code>*p++</code>，先将p和后置++捆绑，但是在解引用之后生效，即增以p&#x3D;p+1。<code>(*p)++</code>表示，先将p和<code>*</code>捆绑，再将解引用后的值++, 即(*p) &#x3D; (*p) + 1.</li><li>声明一个指针如果未初始化，则随机指向任何一个地址<code>garbage</code>，这在<code>dereference</code>时会发生ACV(如果地址为系统地址)。</li><li>dot notation &amp; arrow notationss</li><li>pointers to pointers, 还有一点需要注意。如果传的参数不是当前类型本身的地址，则在函数中改变的值不会对全局造成影响，比如：类型本身是指针就需要传递指针的指针才能改变本身的值。</li><li>Stack frame, which contains location of caller function(调用函数的入口地址)、function arguments(函数参数)、Space for local variables(局部变量所需的空间). Actually in xv6, it contains the additional part of previous stack frame pointer.</li><li>Stack pointer 为最低的(current)Stack frame.</li><li>注意从局部变量返回地址，这个地址在接下来主函数中解引用会出现错误的值，因为栈帧(stack frame)很可能会被覆盖(over write)。印象中Effective cpp书中只是提到这种情况是危险的但并未说清楚其中的原理。So never return pointers to local variable from function.</li><li>Static Data: place for variables that persist. 静态数据会在程序执行的整个过程中持续存在。</li><li><code>String literal</code>字符串字面量同样也是静态数据，比如: <code>char* str = &quot;hi&quot;</code>, 为一个字符指针指向用引号括起来的字符串。切记不要误用为<code>char str[] = &quot;hi&quot;</code>，它会将数据保存到栈(stack)中而不是<code>Static Data</code>区域。</li><li><code>String literal</code>是不能被更改的左值。</li><li><code>Static Data</code>由两种类型组成，一种是<code>Read-only</code>, 比如说<code>String literal</code>; 一种是<code>Read-Write</code>, 比如说<code>Global variable</code>.</li><li><code>Code</code>为<code>Read-only</code> Data，存放machine code.</li><li>地址大小即为指针的大小，取决于Architecture.</li><li><code>Endianness</code>, Big Endian or Little Endian, which just are used in Memory.</li><li><code>sizeof(type/var)</code>函数输出类型的字节大小。</li><li><code>malloc(n)</code>函数，分配n个bytes连续的未初始化的虚存，返回分配块的起始地址(void*类型)。搭配typecaset和sizeof使用，case: <code>int *p = (int *) malloc(n*sizeof(int));</code>, 注意如果为字符串(字符数组)分配空间size则需要+1，为null terminator分配一个location.</li><li><code>calloc(nmember, size)</code>和<code>malloc</code>一致, 只多了一步初始化为<code>0</code>. <code>nmember</code>为成员的数量，<code>size</code>为每个成员的大小。</li><li><code>realloc(ptr, size)</code>, <code>ptr</code>为<code>malloc</code>或<code>calloc</code>返回的指针，<code>size</code>为需要改变的所需要的大小(同malloc)，会复制起始地址为<code>ptr</code>的内容。且可能会移动地址，或者保持在<code>ptr</code>原来的地址不变。</li><li><code>free(p)</code>函数，p必须为最开始分配时的起始地址，否则会抛出异常，因此对<code>p++</code>操作是不明智的。注意<code>free</code>的释放顺序，应该最后释放<strong>源</strong>，否则可能会double free。</li><li>Memory Error: Segmentation Error、Bus Error.</li><li><code>strcpy()</code>的修订版本<code>strncpy</code>保证<code>dst</code>有足够的空间供<code>src</code>来copy.</li><li>Rule of Thumb(经验法则): Malloc的数量超过free意味着内存泄漏；潜在的内存泄漏：改变指针。</li><li><code>free()</code> adds block to the list, combines with adjacent free blocks; <code>malloc()</code> searches free list for block large enough to meet request</li><li>Choose block in malloc(): Best-fit, First-fit, Next-fit.</li></ol>]]></content>
      
      
      <categories>
          
          <category> CS61C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NJU OS Note</title>
      <link href="/2022/05/16/NJU-OS-Note/"/>
      <url>/2022/05/16/NJU-OS-Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直以来被忽略的本科教学</p></blockquote><span id="more"></span><ul><li><code>ld</code>, GNU Linker</li><li><code>gcc</code>支持对汇编代码的预编译(还会定义__ASSEMBLER__宏)。</li><li><code>wget url</code>下载URL的文件内容。</li><li><code>gcc -E foo.c</code>在预处理阶段后停止。</li><li><code>volatile</code>声明的变量不能优化。</li><li><code>asm</code>是<code>GNU</code>的拓展。可以从汇编程序中读取和写入C变量。</li><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html"><code>Extended asm</code></a>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asm asm-qualifiers ( AssemblerTemplate  </span><br><span class="line">               :OutputOperands  </span><br><span class="line">               [:InputOperands[: Clobbers]]) </span><br></pre></td></tr></table></figure><ul><li>Qualifier: volatile, inline, goto。</li><li>AssemblerTemplate: 包含汇编程序指令的文字字符串。</li><li>OutputOperands(允许使用空列表): <code>[[asmSymbolicName]] constraint(c_variablename)</code>，输出约束必须以<code>=</code>作为开头, 常见的约束<code>r</code> for register, <code>m</code> for memory。约束后还需要有个C的变量名，括号是语法的必须部分。</li><li>InputOperands(允许使用空列表)。</li><li>eample  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> src = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dst;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;mov %1, %0\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;add $1, %0&quot;</span></span><br><span class="line">    : <span class="string">&quot;=r&quot;</span> (dst) </span><br><span class="line">    : <span class="string">&quot;r&quot;</span> (src));</span><br></pre></td></tr></table></figure></li><li>Clobbers: <code>memory</code>( Further, the compiler does not assume that any values read from memory before an asm remain unchanged after that asm;), <code>Compiler barrier</code>.</li></ul></li><li><code>strace</code>追踪当前程序或者进程执行过的系统调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ICS Lab Note</title>
      <link href="/2022/05/16/ICS-Lab-Note/"/>
      <url>/2022/05/16/ICS-Lab-Note/</url>
      
        <content type="html"><![CDATA[<!-- # ICS Lab Note --><blockquote><p>本校的Lab体验总结</p></blockquote><span id="more"></span><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a><strong>lab1</strong></h2><ol><li>实际上通过编写发现，为了编写方便，我将ASCII模板0和存放文件起始地址的位置调换(即0x3013和0x3012)，并将文件的内容连续(consecutively)放在从0x3013处的开始；随之变动的也有将LDR R3, x3013改为LEA R3, x3013，最开始没有注意到这个问题debug发现其实x3013里我设的值为’H’即x0048，按照原来的执行，它会提取x0048处的内容，因此单步执行到这行机器代码直接halt掉了，且估计是因为ACV异常导致的结果。</li><li>编写bin文件转化为obj之后调试发现，bin文件第一行的内容并没有被显示在主存中。因此可以推断第一行为程序执行的起始地址(可能是因为我没有仔细看实验手册吧:)。</li><li>fgets执行成功文件指针自动后移; 格式化写入文件fprintf;</li><li>a+: 以追加、可读写的方式打开文件，允许读写。若进行读操作，则从头开始读；若进行写操作，则将内容添加在末尾。若文件不存在，则创建文件。打开成功后返回文件指针，位置指针指向文件头部。</li></ol><ul><li>完成时间3h</li></ul><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a><strong>lab2</strong></h2><ol><li>Bug: Loop的次数不是所期望的3，因此需要改变影响loop次数的BR，将BRzp改为BRp，即可达到所期望的3次，结果为30.</li><li>Bug: 应该把LDR改为LEA这样就可以提取存储单元的内容，而不是提取存储单元内容的内容(相当于间接寻址)，修改过后就为正确的了。</li><li>Bug: x300C和x300B行应该调换位置。因为实际上R3寄存器的设置是作为loop的次数，同时LDR同样也可以生成条件码，这会导致意想不到的错误(比如对应文件地址里存储的是负数或者0就会终止循环得到意想不到的结果)</li><li>Bug: 如果x3400地址单元内存的值为0，那么就会出现死循环的问题，单步调试之后发现在x3003处的BR指令并没有判断取数为0的情况，因此我做出了这样的调整。在x3003处将BRn改为BRnz</li></ol><ul><li>完成时间2h</li></ul><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a><strong>lab3</strong></h2><ol><li>将输入的 大写&#x2F;小写字母 转化为 小写&#x2F;大写字母 输出到显示屏上，如果是别的字符则输出error.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">       .ORIG  x3000           ; program start at x3000</span><br><span class="line">       LD     R2, TERM        ; Load negative of ASCII 7</span><br><span class="line">AGAIN  TRAP   x23             ; input syscall</span><br><span class="line">; judge the range of R0</span><br><span class="line">       LD     R5, UPMIN       </span><br><span class="line">       ADD    R5, R5, R0     </span><br><span class="line">       BRn    OTH             ; if input &lt; A, jump to OTH</span><br><span class="line">       LD     R5, UPMAX      </span><br><span class="line">       ADD    R5, R5, R0      </span><br><span class="line">       BRnz   U2L             ; if input &lt;= Z, jump to U2L</span><br><span class="line">       LD     R5, LOWMIN      </span><br><span class="line">       ADD    R5, R5, R0      </span><br><span class="line">       BRn    OTH             ; if input &lt; a, jump to OTH</span><br><span class="line">       LD     R5, LOWMAX      </span><br><span class="line">       ADD    R5, R5, R0</span><br><span class="line">       BRnz   L2U             ; if input &lt;= z, jump to L2U</span><br><span class="line">       BR     OTH             ; the rest range of input.</span><br><span class="line">U2L    LD     R3, ASCII       ; load difference value</span><br><span class="line">       BR     OUTPUT</span><br><span class="line">L2U    LD     R3, ASCII2</span><br><span class="line">;</span><br><span class="line">; handle alpha</span><br><span class="line">;</span><br><span class="line">OUTPUT ADD    R1, R2, R0      ; if input 7, jump to halt.</span><br><span class="line">       BRz    EXIT            ; exit</span><br><span class="line">       ADD    R0, R0, R3      ; trasforming u2l/l2u</span><br><span class="line">       TRAP   x21             ; output syscall</span><br><span class="line">       BR     AGAIN           ; unconditional loop</span><br><span class="line">;</span><br><span class="line">; if the character not an alpha, handle from there</span><br><span class="line">;</span><br><span class="line">OTH    ADD    R1, R2, R0</span><br><span class="line">       BRz    EXIT</span><br><span class="line">       LEA    R3, ERROR       ; load prompt pointer</span><br><span class="line">LOOP   LDR    R0, R3, #0      ; load character</span><br><span class="line">       BRz    AGAIN</span><br><span class="line">       TRAP   x21             ; it may change the value in R1</span><br><span class="line">       ADD    R3, R3, #1      ; load next character</span><br><span class="line">       BR     LOOP</span><br><span class="line">TERM   .FILL  xFFC9           ; xFFC9 is negative of ASCII 7(x0037)</span><br><span class="line">ASCII  .FILL  x0020           ; The difference value between upper case and lower case</span><br><span class="line">ASCII2 .FILL  xFFE0           ; xFFE0 is negative of -20</span><br><span class="line">UPMIN  .FILL  xFFBF           ; xFFBF is negative of ASCII A</span><br><span class="line">UPMAX  .FILL  xFFA6           ; xFFA6 is negative of ASCII Z</span><br><span class="line">LOWMIN .FILL  xFF9F           ; xFF9F is negative of ASCII a</span><br><span class="line">LOWMAX .FILL  xFF86           ; xFF86 is negative of ASCII z</span><br><span class="line">EXIT   TRAP   x25             ; halt</span><br><span class="line">ERROR  .STRINGZ &quot;Input character error!&quot;</span><br><span class="line">       .END</span><br></pre></td></tr></table></figure></li><li>gets函不包含换行符(<code>\n</code>)</li></ol><ul><li>完成时间2h</li></ul><h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a><strong>lab4</strong></h2><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>1.编写完程序之后发现有报错log, 于是配合上vscode+vim插件可以直接在代码中定位错误信息，将报错log(主要时label名字输入错误)全部修改正确。</p><p>2.汇编成功后，debug发现书上有两个小错误，最开始以为x-0A是0x0A但后面发现并不是，而是0x0A的取补数来判定值, 还有x-03和x-09也是一样的。后来ADD后面只能跟5个Bit的值，遂用#-10表示,因此改为:</p><p><img src="https://pic4.zhimg.com/80/v2-812c175efddbad0e4dc2b76e381e3064.png" alt="Image"></p><p>3.debug发现这一段条件码判断的有问题，应该是照着敲的时候敲错了太粗心了…!第一步和负的ASCII的0比较应该是判断BRn才为NOT A integer, 事实上我写成了BRp才造成了这样的错误，而且还漏写了大于9的边界判断，下面是Debug错误图:</p><p><img src="https://pic4.zhimg.com/80/v2-90401b2396aac9499e8c7c5c69eebe6a.png" alt="Image"><img src="https://pic4.zhimg.com/80/v2-790558c0ce2a716b2a8942c46c83b599.png" alt="Image"></p><p><strong>正确</strong>应该改为:</p><p><img src="https://pic4.zhimg.com/80/v2-3cd596729cfb00576d353da469fe8e5b.png" alt="Image"></p><p>4.输入+测试会crash，随后我设置断点缩小了BUG的范围，找到了对应的位置，最后确定是因为这一段代码输入错，可以能是因为重复恢复R5寄存器，也可能是以为忘记恢复R7寄存器的值。crash的图片:</p><p><img src="https://pic4.zhimg.com/80/v2-bae4d8bc8edf58837b97b96dcdd5430a.png" alt="Image"></p><p>错误代码的图片:</p><p><img src="https://pic4.zhimg.com/80/v2-dce739185fc63a23b13334f0a3f8b0b7.png" alt="Image"></p><p>改正了这部分代码, 恢复正常:</p><p><img src="https://pic4.zhimg.com/80/v2-e9bccf6f55cf7287a06b29ea514e85da.png" alt="Image"></p><p>5.debug排错技巧，先在某个特定的函数位置打好断点再看源代码是否有误，并屏感觉有不合理的地方对照课本，最后走一遍单步调试.</p><p>6.仔细查看这行代码并没有实际的意义，于是对照可课本发现确实是敲错了:</p><p><img src="https://pic4.zhimg.com/80/v2-24cbd8d35456387479b36ffc0ab9c213.png" alt="Image"></p><p>7.查看了Display的源代码发现显示的其实是栈顶元素(一个符号位三个数字)，也就是刚输入的ASCIIBUFF。衍生出了一个问题，如果上上次输入的是一个3位数字，且上次输入的是一个2位数字，那么ASCIIBUF的2位数字会和3位数字的百位一起显示吗？因为实际上在ASCIItoBinary函数中会覆盖掉之前的内容。</p><p>8.测试了一下栈内一共可以存10个元素，于是看了一下地址分布，又确认了一下确实是这样(1 stackbase location + 9 stackmax locations):</p><p><img src="https://pic4.zhimg.com/80/v2-c16ad818c2c0113c2c065f26ec96a56c.png" alt="Image"></p><p>9.实际上POP和PUSH操作在发生underflow&#x2F;overflow时是不会移动栈顶指针的，而是直接打印信息改变寄存器R5的值然后返回:</p><p><img src="https://pic4.zhimg.com/80/v2-e64de1d0088a29d4552ccaac0bf33758.png" alt="Image"></p><p>10.每一次ADD操作弹栈取两个操作后求和，会检查值是否超出范围([-999, 999]).</p><p>11.MULT操作专门有一个寄存器存放sign bit, 方便两个操作数进行累加来完成乘法。还有如果其中有一个操作数为0则直接将这个值压入栈中，退出乘法操作。而且乘法只需要将作为累加次数的乘数的值变为正数即可，最后根据符号位取结果的时候，可以发现四种结果都是正确的。</p><p>12.发现有个BUG，在console中输入一个数字之后又backtrace将它清除再输入一个数回车就会出现Not a integer的报错，看了一下它的VALUE_LOOP的实现发现确实是有这么一个缺陷。</p><p>13.PUSH和POP默认操作的都是R0寄存器</p><p>14.查看clear函数源码，发现仅仅是将栈顶指针初始化为空(即初始化为stackbase再-1)</p><p>15.又发现一个BUG：输入百位数Display显示乱码，进而导致相加的结果出错。有两个原因：1.push值到栈中出错(PUSH_VALUE)A2B。2.或者B2A的过程中出错。经过定位之后发现输入到ASCIIBUFF中的三个数字是完整的存在里面的，难道是转换出错？开始往Display函数上打断点，可以发现在单步执行通过Binary2ASCII前后ASCIIBUF的值发生了变化，经过之前:</p><p><img src="https://pic4.zhimg.com/80/v2-f8f064c63aee48c35230e6c2f40972f1.png" alt="Image"><br><img src="https://pic4.zhimg.com/80/v2-fc118d61d731129e1ba81f336f17015a.png" alt="Image"></p><p>经过之后，可以看出ASCIIBUFF中的值已经发生了变化：</p><p><img src="https://pic4.zhimg.com/80/v2-943b0e7832ae7bd4226d27f845a828d6.png" alt="Image"><br><img src="https://pic4.zhimg.com/80/v2-ac2006c2c1cf9c2b19d0dfb80e4e07ca.png" alt="Image"></p><p>接下来又试了一下两位数，经过这个函数后显示的结果是正确的，难道是课本代码出错？？？Not！又进一步精确了错误的位置，发现如果是两位数，在发现在栈中的值就是所输入的两位数的值，而三位数的时候就变成了随机的值，因此可以推断问题不是出在B2A而是处在A2B往栈中存的值不正确导致最后Display从栈中取二进制数时打印出错!(刚好就只剩A2B的源代码没看哈哈哈)。以下是输入123，栈中值错误：</p><p><img src="https://pic4.zhimg.com/80/v2-17b94c6024eebac989a7adaf9ec1b6e4.png" alt="Image"></p><p>仔细阅读了A2B的源代码定位到了错误(从十六进制转化为十进制时使用MASK的对象应该是R4,也就是刚LD过来的内容):</p><p><img src="https://pic4.zhimg.com/80/v2-c69df62813b011e7fb9b5c15daff2404.png" alt="Image"></p><p>修改过后，成功了！:</p><p><img src="https://pic4.zhimg.com/80/v2-634e98e287e5de31e3de86f7f7de08a7.png" alt="Image"></p><p>16.最后说一下A2B的设计，我本以为是数位的ASCII码来和’0’做减，没想到是和x000F的MASK取模也行，太妙了！</p><ul><li>完成时间5h</li></ul><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>1.难受了windows下是carriage return + linefeed, 我提取的字符是一位….我很难受。遂换一个策略</p><p>2.scanf后面接个getchar吸收换行符</p><ul><li>完成时间5h</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS186 Note</title>
      <link href="/2022/05/16/CS186-Note/"/>
      <url>/2022/05/16/CS186-Note/</url>
      
        <content type="html"><![CDATA[<!-- # **CS186 Note** --><blockquote><p>SQL真的这么难吗?</p></blockquote><span id="more"></span><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a><strong>SQL</strong></h2><ul><li><code>SELECT</code>后加<code>DISTINCT</code>可以将重复的tuple去掉。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tbl<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="NULL-value"><a href="#NULL-value" class="headerlink" title="NULL value"></a>NULL value</h3><ul><li>任何以<code>NULL</code>值作为操作数的算数运算操作结果都为<code>NULL</code>，所以通常需要<code>IS NULL</code>或<code>IS NOT NULL</code>来提前判断。</li><li><code>NULL</code> is <strong>falsey</strong>.</li></ul><h3 id="Aggregate-funtion"><a href="#Aggregate-funtion" class="headerlink" title="Aggregate funtion"></a>Aggregate funtion</h3><ul><li>SUM, AVG, MAX, MIN, COUNT。</li><li>输入是一个列，输出是一个值。</li><li>每个aggregate都忽略掉<code>NULL</code>, 除了<code>COUNT(*)</code>之外。注意<code>COUNT&lt;column&gt;</code>返回具体列非空值的数量。</li><li>注意分组后COUNT(*)计算的是当前组的行数。<br><img src="https://pic4.zhimg.com/80/v2-e51e235585811be04b61e04c12a2d1e0.png" alt="Image"></li></ul><h3 id="Groups-of-Data"><a href="#Groups-of-Data" class="headerlink" title="Groups of Data"></a>Groups of Data</h3><ul><li>GROUP BY</li><li>将当前列中属性值相同的行放入一个组中, 该组中的所有行要合并为一行。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tbl<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span> −− <span class="keyword">Filter</span> <span class="keyword">out</span> <span class="keyword">rows</span> (before <span class="keyword">grouping</span>) .</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>; −− <span class="keyword">Filter</span> <span class="keyword">out</span> <span class="keyword">groups</span> (after <span class="keyword">grouping</span>) .</span><br></pre></td></tr></table></figure></li><li>WHERE用于过滤行，而HAVING用来过滤组。</li></ul><h3 id="有问题的查询语句"><a href="#有问题的查询语句" class="headerlink" title="有问题的查询语句"></a>有问题的查询语句</h3><ul><li>投影的属性<code>AVG(num dogs)</code>是只有一个值，但是<code>age</code>属性中有很多值。因此形成的表中必须有同样数量的行，error。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, <span class="built_in">AVG</span>(num_dogs)</span><br><span class="line"><span class="keyword">FROM</span> Person;</span><br></pre></td></tr></table></figure></li><li>将age分为一个组之后，无法合并为一行(因为age在当前组中含单个数字，但num_dogs含多个数字)，error。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, num_dogs</span><br><span class="line"><span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Order-By"><a href="#Order-By" class="headerlink" title="Order By"></a>Order By</h3><ul><li>默认是升序排列的，要想降序排列需要具体列名(属性名)后加关键字DESC。下面语句列num_dogs按升序排列，但name按降序排列。我们先对num_dogs排序再对num_dogs中相同的行进行name降序排序。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, num_dogs</span><br><span class="line"><span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num_dogs ,name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><ul><li>限定返回的行数</li></ul><h3 id="语句编写顺序"><a href="#语句编写顺序" class="headerlink" title="语句编写顺序"></a>语句编写顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tbl<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line">LIMIT <span class="operator">&lt;</span>num<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><ul><li>cross join(笛卡尔积), filter在笛卡尔积过后的表中寻找对应的行。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li>inner join，和上述语句输出是一样的结果。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line">    <span class="keyword">ON</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 除了加上共有的属性值行...</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 加上左侧表中特有的属性值行，当前右侧表中对应的不存在的属性用<span class="keyword">NULL</span>代替。</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 加上右侧表中特有的属性值行。</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 加上两侧表中特有的属性值行。</span><br><span class="line"><span class="operator">-</span> <span class="keyword">natural</span> <span class="keyword">join</span>, <span class="operator">*</span><span class="operator">*</span>隐式地<span class="operator">*</span><span class="operator">*</span>将属性值一致的列<span class="keyword">inner</span> <span class="keyword">join</span>, 比如在当前例子中，将会自动包含<span class="keyword">join</span> <span class="keyword">condition</span>: courses.num <span class="operator">=</span> enrollment.num。</span><br><span class="line">    ``` <span class="keyword">sql</span></span><br><span class="line">    <span class="keyword">SELECT</span> ∗</span><br><span class="line">    <span class="keyword">FROM</span> courses <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> enrollment;</span><br></pre></td></tr></table></figure></li><li>ON后跟的是连接的predicate。</li></ul><h3 id="Name-conflict"><a href="#Name-conflict" class="headerlink" title="Name conflict"></a>Name conflict</h3><ul><li>通过<code>列名.属性</code>来避免命名冲突。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ∗</span><br><span class="line"><span class="keyword">FROM</span> courses <span class="keyword">INNER</span> <span class="keyword">JOIN</span> enrollment</span><br><span class="line"><span class="keyword">ON</span> courses.num <span class="operator">=</span> enrollment.num;</span><br></pre></td></tr></table></figure></li><li>通过AS来指定别名。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> courses <span class="keyword">AS</span> a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> enrollment <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> A.num <span class="operator">=</span> B.num;</span><br></pre></td></tr></table></figure><h3 id="Subqueries"><a href="#Subqueries" class="headerlink" title="Subqueries"></a>Subqueries</h3></li><li>Notes中举得例子是，需要找到课程的学生人数大于所有课程的平均学生人数的课程。如果单纯进行AVG处理，那么想要获取的行将会被过滤掉了，这时候就需要用到子查询了。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> num</span><br><span class="line"><span class="keyword">FROM</span> enrollment</span><br><span class="line"><span class="keyword">WHERE</span> students <span class="operator">&gt;=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(students)</span><br><span class="line">    <span class="keyword">FROM</span> enrollment;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Set-Operators"><a href="#Set-Operators" class="headerlink" title="Set Operators"></a>Set Operators</h3></li><li>ANY, ALL, UNION, INTERSECT, DIFFERENCE, IN.</li></ul><h3 id="Correlated-Subqueries"><a href="#Correlated-Subqueries" class="headerlink" title="Correlated Subqueries"></a>Correlated Subqueries</h3><ul><li>子查询可以嵌套在WHERE中，也可以嵌套在FROM中。</li></ul><h3 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h3><ul><li><code>%</code>可以匹配任何子串。</li><li><code>_</code>可以匹配任何单个字符。</li></ul><h3 id="Regular-expression"><a href="#Regular-expression" class="headerlink" title="Regular expression"></a>Regular expression</h3><ul><li>使用前需要加~。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> artist_name, first_yr_active</span><br><span class="line"><span class="keyword">FROM</span> Artists</span><br><span class="line"><span class="keyword">WHERE</span> artist_name <span class="operator">~</span><span class="string">&#x27;^B.*&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Relation-Algerbra"><a href="#Relation-Algerbra" class="headerlink" title="Relation Algerbra"></a><strong>Relation Algerbra</strong></h2><p>关系代数中返回结果不包含重复的tuple。</p><h3 id="Projection-pi"><a href="#Projection-pi" class="headerlink" title="Projection($\pi$)"></a>Projection($\pi$)</h3><ul><li>$\pi_{name}(dog)$选择对应的列，类似于SELECT name FROM dogs;</li><li>在关系代数中不存在操作符等价于FROM。</li></ul><h3 id="Selection-sigma"><a href="#Selection-sigma" class="headerlink" title="Selection($\sigma$)"></a>Selection($\sigma$)</h3><ul><li>根据给定的条件过滤出具体的行。如:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> dogs <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure>  对应关系代数的版本<br>  $\pi_{name, age}(\sigma_{age &#x3D; 12}(dogs))$<br>  或者$\sigma_{age &#x3D; 12}(\pi_{name, age}(dogs))$</li><li>Selection操作符同样支持<code>compound predicate</code>，比如<code>AND</code>可以用$\wedge$来表示<code>OR</code>可以用$\vee$来表示, 如:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age </span><br><span class="line"><span class="keyword">FROM</span> dogs </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;Timmy&#x27;</span>;</span><br></pre></td></tr></table></figure>  对应的关系代数版本<br>  $\sigma_{age&#x3D;12 \wedge name&#x3D;’Timmy’}(\pi_{name, age}(dogs))$</li></ul><h3 id="Union-cup"><a href="#Union-cup" class="headerlink" title="Union($\cup$)"></a>Union($\cup$)</h3><ul><li>Compatible: 要求union的两个操作数必须拥同样数量的attribute, 并且对应的attribute必须拥有同样的类型。</li></ul><h3 id="Set-Difference"><a href="#Set-Difference" class="headerlink" title="Set Difference($-$)"></a>Set Difference($-$)</h3><ul><li>和union一样要求Compatible</li><li>等价于SQL的EXCEPT语句, 比如$\pi_{name}(dogs) - \pi_{name}(cats)$只显示dogs表的行而不显示cats表的行。</li></ul><h3 id="Intersection-cap"><a href="#Intersection-cap" class="headerlink" title="Intersection($\cap$)"></a>Intersection($\cap$)</h3><ul><li>和union一样要求Compatible。</li><li>等价于SQL的INTERSECT语句。</li></ul><h3 id="CrossProduct-times"><a href="#CrossProduct-times" class="headerlink" title="CrossProduct($\times$)"></a>CrossProduct($\times$)</h3><ul><li>就像在SQL中执行笛卡尔积，输出两个表中行的所有组合。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ∗</span><br><span class="line"><span class="keyword">FROM</span> dogs, parks;</span><br></pre></td></tr></table></figure>  等价于$dogs \times parks$。</li><li>不必要求属性数量一致。</li></ul><h3 id="Join-Join"><a href="#Join-Join" class="headerlink" title="Join($\Join$)"></a>Join($\Join$)</h3><ul><li><code>inner join</code>: $dogs\Join_{dogs.name&#x3D;cats.name}cats$，subscript中表示join的条件，也称作Theta join, “$\Join(\theta)$”。</li><li><code>Natual join</code>: $dogs\Join cats$，上面SQL中提到过，自然连接将会把两个表中所有同样的列自动合并。</li><li>和selection操作符一样可以使用compound predicate。</li><li>join都可以由cross和selection生成。</li><li>$cats \Join_{\theta} dogs$和$\sigma_{\theta}(cats \times dogs)$是等价的。</li><li>$cats \Join dogs$和$\sigma_{cats.col1&#x3D;dogs.col1\wedge cats.col2&#x3D;dogs.col2\wedge…\wedge cats.colN&#x3D;dogs.colN}(cats \times dogs)$是等价的。</li></ul><h3 id="Rename-rho"><a href="#Rename-rho" class="headerlink" title="Rename($\rho$)"></a>Rename($\rho$)</h3><ul><li>等价于SQL中的Alias。</li><li>$cats\Join_{name&#x3D;dname} \rho_{name-&gt;dname}(dogs)$，将dog中的name属性重命名为dname, 避免冲突。</li></ul><h3 id="Group-By-x2F-Aggregation-gamma"><a href="#Group-By-x2F-Aggregation-gamma" class="headerlink" title="Group By&#x2F; Aggregation($\gamma$)"></a>Group By&#x2F; Aggregation($\gamma$)</h3><ul><li>exp1  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age</span><br><span class="line"><span class="keyword">FROM</span> dogs</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>  等价于$\gamma_{age, COUNT(*)&gt;5}(dogs)$</li><li>exp2  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, <span class="built_in">SUM</span>(weight)</span><br><span class="line"><span class="keyword">FROM</span> dogs</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">8</span>) <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>  等价于$\gamma_{age, SUM(weight), COUNT(*)&gt;5(dogs)}$</li></ul><h3 id="SQL-gt-Relation-Algebra"><a href="#SQL-gt-Relation-Algebra" class="headerlink" title="SQL -&gt; Relation Algebra"></a>SQL -&gt; Relation Algebra</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> teamid <span class="keyword">AS</span> tid</span><br><span class="line"><span class="keyword">FROM</span> players</span><br><span class="line"><span class="keyword">WHERE</span> players.teamid <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> teamid <span class="keyword">FROM</span> teams)</span><br><span class="line"><span class="keyword">AND</span> position<span class="operator">=</span><span class="string">&#x27;shootingGuard&#x27;</span>;</span><br></pre></td></tr></table></figure><p>等价于<br>$$\rho_{teamid-&gt;tid}(\pi_{teamid}(\sigma_{position&#x3D;’shootingGuard’}(players))-\pi_{players.teamid}(players\Join_{players.teamid&#x3D;teams.teamid}teams))$$</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 Project1: BUFFER POOL MANAGER</title>
      <link href="/2022/05/16/cmu15445-project1/"/>
      <url>/2022/05/16/cmu15445-project1/</url>
      
        <content type="html"><![CDATA[<!-- # CMU 15-445 Project1: BUFFER POOL MANAGER --><blockquote><p>OS vs. DB</p></blockquote><span id="more"></span><h2 id="TASK-1-LRU-REPLACEMENT-POLICY"><a href="#TASK-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="TASK #1 - LRU REPLACEMENT POLICY"></a><strong>TASK #1 - LRU REPLACEMENT POLICY</strong></h2><h3 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a><strong>1.1 问题描述</strong></h3><p>需要完成的函数</p><ul><li>Victim(frame_id_t*) : Remove the object that was accessed least recently compared to all the other elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False.</li><li>Pin(frame_id_t) : This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer.</li><li>Unpin(frame_id_t) : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer.</li><li>Size() : This method returns the number of frames that are currently in the LRUReplacer</li></ul><p>想到lc上有类似的实现可以参考一下，双链表+哈希表实现<a href="https://leetcode-cn.com/problems/lru-cache/">LRU</a>，大致思路和本题是一样的。pin时表示该页正在被使用，因此需要将该页从lru_replacer中移除，unpin反之。需要注意的是，不能多次unpin，这点与lc上有差别。</p><h3 id="1-2-部分实现"><a href="#1-2-部分实现" class="headerlink" title="1.2 部分实现"></a><strong>1.2 部分实现</strong></h3><p><strong>lru_replacer.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// TODO(student): implement me!</span></span><br><span class="line"> std::unordered_map&lt;<span class="type">frame_id_t</span>, ListNode*&gt; cache_;</span><br><span class="line"> std::mutex lru_latch_;</span><br><span class="line"> ListNode* head_;  <span class="comment">// dummy.</span></span><br><span class="line"> ListNode* tail_;</span><br><span class="line"> <span class="type">size_t</span> curr_size_;</span><br><span class="line"> <span class="type">size_t</span> capacity_;</span><br></pre></td></tr></table></figure><p><strong>lru_replacer.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;  <span class="comment">// evict the old frame.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(lru_latch_)</span></span>;  <span class="comment">// lock</span></span><br><span class="line">  <span class="keyword">if</span> (curr_size_ == <span class="number">0</span>) &#123;  <span class="comment">// lruReplacer empty.</span></span><br><span class="line">    frame_id = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode* delframe = tail_-&gt;prev;</span><br><span class="line">  <span class="type">frame_id_t</span> delframe_id= delframe-&gt;frame_id;</span><br><span class="line">  *frame_id = delframe_id;</span><br><span class="line">  cache_.<span class="built_in">erase</span>(delframe_id);  <span class="comment">// remove from frame.</span></span><br><span class="line">  curr_size_--;</span><br><span class="line">  <span class="comment">// Evict frame.</span></span><br><span class="line">  <span class="built_in">RemoveFrame</span>(delframe);</span><br><span class="line">  <span class="keyword">delete</span> delframe;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(lru_latch_)</span></span>;  <span class="comment">// lock</span></span><br><span class="line">  <span class="keyword">if</span> (cache_.<span class="built_in">find</span>(frame_id) != cache_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// decrease the attribute size.</span></span><br><span class="line">    curr_size_--;</span><br><span class="line">    ListNode* delframe = cache_[frame_id];</span><br><span class="line">    cache_.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">    <span class="built_in">RemoveFrame</span>(delframe);</span><br><span class="line">    <span class="comment">// release the source.</span></span><br><span class="line">    <span class="keyword">delete</span> delframe;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(lru_latch_)</span></span>;  <span class="comment">// lock</span></span><br><span class="line">  <span class="keyword">if</span> (cache_.<span class="built_in">find</span>(frame_id) == cache_.<span class="built_in">end</span>()) &#123;  <span class="comment">// didn&#x27;t find Unpin frame.</span></span><br><span class="line">    ListNode* frame = <span class="keyword">new</span> <span class="built_in">ListNode</span>(frame_id);</span><br><span class="line">    ++curr_size_;</span><br><span class="line">    <span class="keyword">if</span> (curr_size_ &gt; capacity_) &#123;</span><br><span class="line">      <span class="type">frame_id_t</span> fid;</span><br><span class="line">      <span class="built_in">Victim</span>(&amp;fid);</span><br><span class="line">      cache_[frame_id] = frame;</span><br><span class="line">      curr_size_--;</span><br><span class="line">      <span class="built_in">AddToHead</span>(frame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cache_[frame_id] = frame;</span><br><span class="line">      <span class="built_in">AddToHead</span>(frame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// couldn&#x27;t Unpin many times but once.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">LRUReplacer::Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> curr_size_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::AddToHead</span><span class="params">(ListNode* frame)</span> </span>&#123;</span><br><span class="line">  frame-&gt;next = head_-&gt;next;</span><br><span class="line">  head_-&gt;next-&gt;prev = frame;</span><br><span class="line">  head_-&gt;next = frame;</span><br><span class="line">  frame-&gt;prev = head_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::RemoveFrame</span><span class="params">(ListNode* frame)</span> </span>&#123;</span><br><span class="line">  frame-&gt;prev-&gt;next = frame-&gt;next;</span><br><span class="line">  frame-&gt;next-&gt;prev = frame-&gt;prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TASK-2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#TASK-2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="TASK #2 - BUFFER POOL MANAGER INSTANCE"></a><strong>TASK #2 - BUFFER POOL MANAGER INSTANCE</strong></h2><h3 id="2-1-问题描述"><a href="#2-1-问题描述" class="headerlink" title="2.1 问题描述"></a><strong>2.1 问题描述</strong></h3><p>可以联系课程给的slide了解对应的关系，需要理解的概念以及注意的点：</p><ol><li>free_list、lru_replacer、buffer_pool是独立存在的。</li><li>free_list中存放的是未被使用的frame，页表中不存在其frame的映射，即page_id为INVALID_PAGE_ID。</li><li>unpin_page，存放在lru_replacer中，页表中存在其frame的映射，但其在buffer pool中未被使用。</li><li>pin_page，存在于buffer pool中且正在被使用。</li><li>刷盘的时机，只需要在victim、deletePage时刷盘即可，不需要在每次unpinpage时刷盘，在unpinpage时保存其传入的dirty状就行。因此每次fetch或者new一个页，从free_list中返回的页都不是脏页，同时victim时刷盘也保证获取的页不是脏页。</li><li>从fetch、new获取lru_replace中的页时，需要在页表中删除原page与frame的映射。</li><li>避免加锁函数的嵌套，可能会出现死锁的情况。</li></ol><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a><strong>2.2 代码实现</strong></h3><p>可以进一步细化锁粒度，这里只给了未优化的实现。</p><p><strong>NewPgImp</strong></p><p>fetchpage和newpgImp都需要增加pin_count值，实现是差不多的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call AllocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span></span><br><span class="line">  <span class="comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span></span><br><span class="line">  <span class="comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span></span><br><span class="line">  <span class="comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// step 1</span></span><br><span class="line">  <span class="type">bool</span> all_pinned = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pages_[i].pin_count_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      all_pinned = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (all_pinned)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// allocate a page on disk.</span></span><br><span class="line">  *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line">  </span><br><span class="line">  Page* p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// pick a victim page P.</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid;</span><br><span class="line">  <span class="keyword">if</span> (free_list_.<span class="built_in">empty</span>()) &#123;  <span class="comment">// pick from free list first.</span></span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Victim</span>(&amp;fid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p = &amp;pages_[fid];</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;is_dirty_) &#123;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(p-&gt;page_id_, p-&gt;data_);</span><br><span class="line">        p-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_.<span class="built_in">erase</span>(p-&gt;page_id_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fid = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    p = &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// add P to the page table.</span></span><br><span class="line">  page_table_[*page_id] = fid;</span><br><span class="line">  <span class="comment">// updata P&#x27;s metadata.</span></span><br><span class="line">  p-&gt;page_id_ = *page_id;</span><br><span class="line">  p-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(fid);</span><br><span class="line">  <span class="comment">// zeroes out the data that is held within the page</span></span><br><span class="line">  p-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  <span class="comment">// step 4</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FetchPgImp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.     Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.1    If P exists, pin it and return it immediately.</span></span><br><span class="line">  <span class="comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span></span><br><span class="line">  <span class="comment">//        Note that pages are always found from the free list first.</span></span><br><span class="line">  <span class="comment">// 2.     If R is dirty, write it back to the disk.</span></span><br><span class="line">  <span class="comment">// 3.     Delete R from the page table and insert P.</span></span><br><span class="line">  <span class="comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// step 1</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid;</span><br><span class="line">  Page* p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">find</span>(page_id) != page_table_.<span class="built_in">end</span>()) &#123;  <span class="comment">// find.</span></span><br><span class="line">    fid = page_table_[page_id];</span><br><span class="line">    pages_[fid].pin_count_++;</span><br><span class="line">    <span class="comment">// pin it.</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(fid);</span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (free_list_.<span class="built_in">empty</span>()) &#123;  <span class="comment">// pick from free list first.</span></span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Victim</span>(&amp;fid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// the page placed in the lrureplacer need to be flushed.</span></span><br><span class="line">      p = &amp;pages_[fid];</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;is_dirty_) &#123;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(p-&gt;page_id_, p-&gt;data_);</span><br><span class="line">        p-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_.<span class="built_in">erase</span>(p-&gt;page_id_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fid = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    p = &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// step 3</span></span><br><span class="line">  <span class="comment">// insert p.</span></span><br><span class="line">  page_table_[page_id] = fid;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(fid);</span><br><span class="line">  <span class="comment">// update P&#x27;s metadata.</span></span><br><span class="line">  p-&gt;page_id_ = page_id;</span><br><span class="line">  p-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// read in the page content from disk.</span></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, p-&gt;data_);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DeletePgImp</strong></p><p>删除buffer pool中的页后需要将page的元数据还原到初始值，再放入free_list中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DeallocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.   If P does not exist, return true.</span></span><br><span class="line">  <span class="comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span></span><br><span class="line">  <span class="comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// P does not exist.</span></span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">find</span>(page_id) == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// P does exist.</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid = page_table_[page_id];</span><br><span class="line">  Page* deletepage = &amp;pages_[fid];</span><br><span class="line">  <span class="keyword">if</span> (deletepage-&gt;pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// flush the page before deallocate it.</span></span><br><span class="line">  <span class="keyword">if</span> (deletepage-&gt;is_dirty_) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, deletepage-&gt;data_);</span><br><span class="line">    deletepage-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="comment">// remove P from the page table.</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page_id);</span><br><span class="line">  <span class="comment">// reset its metadata.</span></span><br><span class="line">  <span class="comment">// the page returned to freelist does not stores any page.</span></span><br><span class="line">  deletepage-&gt;page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  deletepage-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  deletepage-&gt;pin_count_ = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// return it to free_list_.</span></span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(fid);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UnpinPgImp</strong></p><p>保留传入的dirty状态，在Victim时刷盘。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="type">frame_id_t</span> fid = page_table_[page_id];</span><br><span class="line">  Page* p = &amp;pages_[fid];</span><br><span class="line">  p-&gt;is_dirty_ = is_dirty;  <span class="comment">// hold the state until victim.</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pin_count_ &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  --p-&gt;pin_count_;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Unpin</span>(fid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FlushPgImp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure you call DiskManager::WritePage!</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">find</span>(page_id) == page_table_.<span class="built_in">end</span>() || page_id == INVALID_PAGE_ID)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[page_table_[page_id]].data_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TASK-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#TASK-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="TASK #3 - PARALLEL BUFFER POOL MANAGER"></a><strong>TASK #3 - PARALLEL BUFFER POOL MANAGER</strong></h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a><strong>3.1 问题描述</strong></h3><p>问题是从task2进一步延出来的，单个缓冲池管理器可能会照成大量的锁争用，因为在这种情况下每个线程和缓冲池交互都争着用单个锁存器，因此需要实现一个并行管理器来管理多个缓冲池管理器，进而实现每个缓冲池都有自己的latch。在这里只需要复用上一个task所实现的缓冲器实例即可，再实现一些基本的逻辑即可通过。</p><h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a><strong>3.2 代码实现</strong></h3><p><strong>parallel_buffer_pool_manager.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ParallelBufferPoolManager::<span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager,</span><br><span class="line">                                                     LogManager *log_manager) &#123;</span><br><span class="line">  <span class="comment">// Allocate and create individual BufferPoolManagerInstances</span></span><br><span class="line">  num_instances_ = num_instances;</span><br><span class="line">  pool_size_ = pool_size;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances; ++i) &#123;</span><br><span class="line">    parallel_.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">BufferPoolManagerInstance</span>(pool_size, num_instances, i, disk_manager, log_manager));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update constructor to destruct all BufferPoolManagerInstances and deallocate any associated memory</span></span><br><span class="line">ParallelBufferPoolManager::~<span class="built_in">ParallelBufferPoolManager</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> bpm : parallel_) &#123;</span><br><span class="line">    <span class="keyword">delete</span> bpm;</span><br><span class="line">  &#125;</span><br><span class="line">  parallel_.<span class="built_in">clear</span>();</span><br><span class="line">  std::<span class="built_in">vector</span>&lt;BufferPoolManager*&gt;().<span class="built_in">swap</span>(parallel_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>parallel_buffer_pool_manager.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;BufferPoolManager*&gt; parallel_;</span><br><span class="line">  <span class="type">uint32_t</span> num_instances_;</span><br><span class="line">  <span class="type">size_t</span> pool_size_;</span><br><span class="line">  <span class="type">int</span> start_ = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>通过完成lab1，让我站在DBMS的角度去理解了操作系统的工作原理，以及对页表，缓存，刷盘时机，页面调度算法LRU有了更深刻的理解。</p>]]></content>
      
      
      <categories>
          
          <category> CMU15-445 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61C Lab2</title>
      <link href="/2022/05/16/cs61c-lab2/"/>
      <url>/2022/05/16/cs61c-lab2/</url>
      
        <content type="html"><![CDATA[<!-- # CS61C Lab2 --><blockquote><p>覆盖广的一个lab</p></blockquote><span id="more"></span><h2 id="Exercise-0-Makefiles"><a href="#Exercise-0-Makefiles" class="headerlink" title="Exercise 0: Makefiles"></a><strong>Exercise 0: Makefiles</strong></h2><ol><li>Which target is part of a rule that deletes all the compiled programs?</li><li>Which target is part of a rule that makes all the compiled programs?</li><li>Which compiler is currently being used?</li><li>What C standard are we currently using?</li><li>How would we reference a variable FOO in a makefile?</li><li>What operating system does the term “Darwin” represent?</li><li>What line creates the lfsr program from its object files? (Give its line number.)</li></ol><p>我的答案:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.clean</span><br><span class="line">2.all</span><br><span class="line">3.gcc</span><br><span class="line">4.c99</span><br><span class="line">5.$(Foo)</span><br><span class="line">6.macos</span><br><span class="line">7.31</span><br></pre></td></tr></table></figure><h2 id="Exercise-1-Bit-Operations"><a href="#Exercise-1-Bit-Operations" class="headerlink" title="Exercise 1: Bit Operations"></a><strong>Exercise 1: Bit Operations</strong></h2><p><code>get_bit</code>很简单，<code>set_bit</code>中需要将<code>v</code>的<code>0</code>和<code>1</code>减去1构造一下变成全0和全1来判断条件, 做过csapp的datalab之后一下就有思路了。若<code>v</code>为<code>1</code>则只需要移动<code>n</code>个bit到对应的bit或一下就行了，置为0则需要考虑一下除了移动到的bit之外的bit都置为1，可以在移位前做加上一个<code>1</code>的处理，随后移动到相应位置之后再取反，与一下即可。<code>flip_bit</code>只需要稍加处理在应用<code>set_bit</code>的模式即可，先取到即将要翻转的bit，随后与<code>1</code>做异或运算，使得0变为1，1变为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bit_ops.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the nth bit of x.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">get_bit</span><span class="params">(<span class="type">unsigned</span> x,</span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">    <span class="comment">// Returning -1 is a placeholder (it makes</span></span><br><span class="line">    <span class="comment">// no sense, because get_bit only returns</span></span><br><span class="line">    <span class="comment">// 0 or 1)</span></span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; n) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set the nth bit of the value of x to v.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(<span class="type">unsigned</span> * x,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> n,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line"><span class="type">int</span> flag = v<span class="number">-1</span>;</span><br><span class="line">(*x) = (((*x) | (v &lt;&lt; n)) &amp; (~flag)) | ((*x) &amp; (~((v+<span class="number">1</span>) &lt;&lt; n)) &amp; flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Flip the nth bit of the value of x.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flip_bit</span><span class="params">(<span class="type">unsigned</span> * x,</span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line"><span class="type">int</span> v = ((*x) &gt;&gt; n) &amp; <span class="number">0x1</span>;</span><br><span class="line">v ^= <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> flag = v<span class="number">-1</span>;</span><br><span class="line">(*x) = (((*x) | (v &lt;&lt; n)) &amp; (~flag)) | ((*x) &amp; (~((v+<span class="number">1</span>) &lt;&lt; n)) &amp; flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-2-Linear-Feedback-Shift-Register"><a href="#Exercise-2-Linear-Feedback-Shift-Register" class="headerlink" title="Exercise 2: Linear Feedback Shift Register"></a><strong>Exercise 2: Linear Feedback Shift Register</strong></h2><p><img src="https://pic4.zhimg.com/80/v2-704f48aad6446d5640cac655e77e7a19.gif" alt="Linear Feedback Shift Register"></p><p>根据图中信息构造门级电路即可，<code>test</code>中循环已经写好不需要再构建循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lfsr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lfsr_calculate</span><span class="params">(<span class="type">uint16_t</span> *reg)</span> &#123;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line"><span class="type">uint16_t</span> regs =*reg; </span><br><span class="line"><span class="type">uint16_t</span> msb = ((regs&amp;<span class="number">0x1</span>)^((regs&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x1</span>)^((regs&gt;&gt;<span class="number">3</span>)&amp;<span class="number">0x1</span>)^((regs&gt;&gt;<span class="number">5</span>)&amp;<span class="number">0x1</span>))&lt;&lt;<span class="number">15</span>;</span><br><span class="line">(*reg) &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">(*reg) |= msb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-3-Linked-Lists"><a href="#Exercise-3-Linked-Lists" class="headerlink" title="Exercise 3: Linked Lists"></a><strong>Exercise 3: Linked Lists</strong></h2><p>面试常考的翻转链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a node to the end of the linked list. Assume head_ptr is non-null. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">append_node</span> <span class="params">(node** head_ptr, <span class="type">int</span> new_data)</span> &#123;</span><br><span class="line"><span class="comment">/* First lets allocate memory for the new node and initialize its attributes */</span></span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">node* new_node = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">new_node-&gt;val = new_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the list is empty, set the new node to be the head and return */</span></span><br><span class="line"><span class="keyword">if</span> (*head_ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">*head_ptr = new_node;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node* curr = *head_ptr;</span><br><span class="line"><span class="keyword">while</span> (curr-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">curr = curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Insert node at the end of the list */</span></span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">curr-&gt;next = new_node;</span><br><span class="line">new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reverse a linked list in place (in other words, without creating a new list).</span></span><br><span class="line"><span class="comment">   Assume that head_ptr is non-null. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_list</span> <span class="params">(node** head_ptr)</span> &#123;</span><br><span class="line">node* prev = <span class="literal">NULL</span>;</span><br><span class="line">node* curr = *head_ptr;</span><br><span class="line">node* next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/* INSERT CODE HERE */</span></span><br><span class="line">next = curr-&gt;next;</span><br><span class="line">curr-&gt;next = prev;</span><br><span class="line">prev = curr;</span><br><span class="line">curr = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Set the new head to be what originally was the last node in the list */</span></span><br><span class="line">*head_ptr = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-4-Memory-Management"><a href="#Exercise-4-Memory-Management" class="headerlink" title="Exercise 4: Memory Management"></a><strong>Exercise 4: Memory Management</strong></h2><p>为<code>vector</code>在<code>Makefile</code>中指定目标, 将下列语句添加到<code>Makefile</code>中。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(VECTOR_PROG)</span>: <span class="variable">$(VECTOR_OBJS)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -g -o <span class="variable">$(VECTOR_PROG)</span> <span class="variable">$(VECTOR_OBJS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure><p>分析一下: <code>bad_vector_new</code>。声明的指针变量v未被使用，且没有为结构体<code>vector_t</code>动态开辟堆空间，而是使用野指针，这样很危险; <code>also_bad_vector_new</code>。声明栈上的结构体数据，最后返回之后拷贝的开销非常大，因此也不够合理, 且如果未及时对返回值进行保存，栈帧会有被覆盖的可能，会丢失返回的数据。</p><blockquote><p>$ valgrind –tool&#x3D;memcheck –leak-check&#x3D;full –track-origins&#x3D;yes [OS SPECIFIC ARGS] <code>./&lt;executable&gt;</code></p></blockquote><ul><li><code>Valgrind</code>默认使用<code>memcheck</code>工具。还有其它工具包括: <code>Callgrind</code>, <code>Cachegrind</code>, <code>Helgrind</code>, <code>Massif</code>。</li><li><code>--leak-check=full</code>: 详细地显示每个单独的内存泄露。</li><li><code>--track-origins=yes</code>: 这会跟踪初始化值的来源。着重于有用的输出而不是速度。</li></ul><p>注意在函数<code>vector_set</code>的题意，超出访问的loc超出堆内存的范围需要重新再申请空间<code>realloc</code>，而不是简单地提示错误信息，若重新申请为空则提示错误信息<code>allocation_failed</code>。用<code>cgdb</code>慢慢调就行了。在<code>make vector_test</code>通过后，使用工具<code>Valgrind</code>检测到内存泄露，查看了一下<code>vector_test</code>函数，发现存在使用未初始化元素的行为，随后便可以将问题可以定位到<code>vector_set</code>函数中，在其中加入for循环初始化即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new vector with a size (length) of 1</span></span><br><span class="line"><span class="comment">   and set its single component to zero... the</span></span><br><span class="line"><span class="comment">   RIGHT WAY */</span></span><br><span class="line"><span class="type">vector_t</span> *<span class="title function_">vector_new</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* Declare what this function will return */</span></span><br><span class="line">    <span class="type">vector_t</span> *retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First, we need to allocate memory on the heap for the struct */</span></span><br><span class="line">    retval = (<span class="type">vector_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">vector_t</span>));<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check our return value to make sure we got memory */</span></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="literal">NULL</span><span class="comment">/* YOUR CODE HERE */</span>) &#123;</span><br><span class="line">        allocation_failed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we need to initialize our data.</span></span><br><span class="line"><span class="comment">       Since retval-&gt;data should be able to dynamically grow,</span></span><br><span class="line"><span class="comment">       what do you need to do? */</span></span><br><span class="line">    retval-&gt;size = <span class="number">1</span>;<span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line">    retval-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*retval-&gt;size);<span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the data attribute of our vector to make sure we got memory */</span></span><br><span class="line">    <span class="keyword">if</span> (retval-&gt;data == <span class="literal">NULL</span><span class="comment">/* YOUR CODE HERE */</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(retval);<span class="comment">//Why is this line necessary? Because it allocate the memory of vector but not allocate the data that will cause memory leak.</span></span><br><span class="line">        allocation_failed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Complete the initialization by setting the single component to zero */</span></span><br><span class="line">    <span class="comment">/* YOUR CODE HERE */</span> </span><br><span class="line">*(retval-&gt;data) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* and return... */</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at the specified location/component &quot;loc&quot; of the vector */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vector_get</span><span class="params">(<span class="type">vector_t</span> *v, <span class="type">size_t</span> loc)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are passed a NULL pointer for our vector, complain about it and exit. */</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;vector_get: passed a NULL vector.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the requested location is higher than we have allocated, return 0.</span></span><br><span class="line"><span class="comment">     * Otherwise, return what is in the passed location.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (loc &lt; v-&gt;size<span class="comment">/* YOUR CODE HERE */</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> v-&gt;data[loc];<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free up the memory allocated for the passed vector.</span></span><br><span class="line"><span class="comment">   Remember, you need to free up ALL the memory that was allocated. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_delete</span><span class="params">(<span class="type">vector_t</span> *v)</span> &#123;</span><br><span class="line">    <span class="comment">/* YOUR SOLUTION HERE */</span></span><br><span class="line"><span class="built_in">free</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set a value in the vector. If the extra memory allocation fails, call</span></span><br><span class="line"><span class="comment">   allocation_failed(). */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_set</span><span class="params">(<span class="type">vector_t</span> *v, <span class="type">size_t</span> loc, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">/* What do you need to do if the location is greater than the size we have</span></span><br><span class="line"><span class="comment">     * allocated?  Remember that unset locations should contain a value of 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* YOUR SOLUTION HERE */</span></span><br><span class="line"><span class="keyword">if</span> (loc &gt;= v-&gt;size) &#123;</span><br><span class="line">v-&gt;data = (<span class="type">int</span>*)<span class="built_in">realloc</span>(v-&gt;data, <span class="keyword">sizeof</span>(<span class="type">int</span>)*(loc+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            allocation_failed();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = v-&gt;size; i &lt; loc+<span class="number">1</span>; ++i)</span><br><span class="line">v-&gt;data[i] = <span class="number">0</span>;</span><br><span class="line">v-&gt;size = loc+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">v-&gt;data[loc] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS61C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stanford CS144 Lab0: Networking Warmup</title>
      <link href="/2022/05/16/cs144-lab0/"/>
      <url>/2022/05/16/cs144-lab0/</url>
      
        <content type="html"><![CDATA[<!-- # Stanford CS144 Lab0: Networking Warmup --><blockquote><p>应用层Overview</p></blockquote><span id="more"></span><h2 id="1-Fetch-a-Web-page"><a href="#1-Fetch-a-Web-page" class="headerlink" title="1. Fetch a Web page"></a><strong>1. Fetch a Web page</strong></h2><p>使用<code>telnet</code>通过<code>http</code>协议访问远端服务器<br><img src="https://pic4.zhimg.com/80/v2-0f3f73376b27537497d7778b962aa839.png" alt="Image"></p><h2 id="2-Writing-webget"><a href="#2-Writing-webget" class="headerlink" title="2. Writing webget"></a><strong>2. Writing webget</strong></h2><h3 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a><strong>2.1 描述</strong></h3><p>实现<code>webget</code>来通过Internet获取网页，使用TCP协议和套接字抽象。实现简单的Web客户端，使用上述<code>HTTP</code>的形式。读数据时遇到<code>EOF</code>则结束，使用轮询的方式读取数据。</p><blockquote><p>Please note that in HTTP, each line must be ended with “\r\n” (it’s not sufficient<br>to use just “\n” or endl).<br>• Don’t forget to include the “Connection: close” line in your client’s request. This<br>tells the server that it shouldn’t wait around for your client to send any more<br>requests after this one. Instead, the server will send one reply and then will<br>immediately end its outgoing bytestream (the one from the server’s socket to your<br>socket). You’ll discover that your incoming byte stream has ended because your<br>socket will reach “EOF” (end of file) when you have read the entire byte stream<br>coming from the server. That’s how your client will know that the server has<br>finished its reply.<br>• Make sure to read and print all the output from the server until the socket reaches<br>“EOF” (end of file)—a single call to read is not enough.<br>• We expect you’ll need to write about ten lines of code.</p></blockquote><h3 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a><strong>2.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\n&quot;;</span></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;</span></span><br><span class="line">    TCPSocket client;</span><br><span class="line">    client.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    string message = <span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span> + </span><br><span class="line">                    host + <span class="string">&quot; \r\nConnection: close\r\n\r\n&quot;</span>;</span><br><span class="line">    client.<span class="built_in">write</span>(message);</span><br><span class="line">    client.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!client.<span class="built_in">eof</span>()) &#123;  <span class="comment">// polling</span></span><br><span class="line">        cout &lt;&lt; client.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    client.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-An-in-memory-reliable-byte-stream"><a href="#3-An-in-memory-reliable-byte-stream" class="headerlink" title="3. An in-memory reliable byte stream"></a><strong>3. An in-memory reliable byte stream</strong></h2><h3 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a><strong>3.1 描述</strong></h3><ol><li><code>ByteStream</code>字节流是有限的, 容量为<code>capacity</code>，允许在内存中存在的最大数量的字节，确保写字节数不超过<code>capacity</code>。</li><li>需要实现一个缓冲区<code>buffer</code>来模拟当前字节流相应的功能。考虑到读端(Output End)队头和写端(Input End)队尾，因此使用<code>stl</code>中的双端队列<code>deque</code>来实现。</li><li><code>eof()</code>返回<code>true</code>, 读端无数据可读有两种情况, 一次读到<code>eof</code>、或者buffer为空。</li><li>从写端取数据分为两种操作, <code>peek</code>和<code>pop</code></li></ol><h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a><strong>3.2 实现</strong></h3><p>byte_stream.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : <span class="built_in">buffer_</span>(std::<span class="built_in">move</span>(<span class="built_in">deque</span>&lt;<span class="type">char</span>&gt;(<span class="number">0</span>))), <span class="built_in">capacity_</span>(capacity), <span class="built_in">end_write_</span>(<span class="literal">false</span>),</span><br><span class="line">                    <span class="built_in">read_num_</span>(<span class="number">0</span>), <span class="built_in">write_num_</span>(<span class="number">0</span>) &#123; <span class="built_in">DUMMY_CODE</span>(capacity); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(data);</span><br><span class="line">    <span class="type">size_t</span> can_write = <span class="built_in">min</span>(data.<span class="built_in">size</span>(), <span class="built_in">remaining_capacity</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; can_write; ++i) &#123;</span><br><span class="line">        buffer_.<span class="built_in">push_back</span>(data[i]);    <span class="comment">// push from the input side.</span></span><br><span class="line">    &#125;</span><br><span class="line">    write_num_ += can_write;</span><br><span class="line">    <span class="keyword">return</span> can_write;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(len);</span><br><span class="line">    <span class="type">size_t</span> can_peek = <span class="built_in">min</span>(len, buffer_.<span class="built_in">size</span>());</span><br><span class="line">    string peek_data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; can_peek; ++i) &#123;</span><br><span class="line">        peek_data += buffer_[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> peek_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; buffer_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">set_error</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        buffer_.<span class="built_in">pop_front</span>();           <span class="comment">// removed from the output side.</span></span><br><span class="line">    &#125;</span><br><span class="line">    read_num_ += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(len);</span><br><span class="line">    string message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> can_read = <span class="built_in">min</span>(len, buffer_.<span class="built_in">size</span>());  <span class="comment">// next &quot;len&quot; bytes.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; can_read; ++i) &#123;</span><br><span class="line">        message += buffer_.<span class="built_in">front</span>();</span><br><span class="line">        buffer_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    read_num_ += can_read;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; end_write_ = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end_write_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">buffer_empty</span>() &amp;&amp; end_write_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> write_num_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> read_num_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> capacity_ - buffer_.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>byte_stream.hh</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that&#x27;s a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; buffer_;</span><br><span class="line">    <span class="type">size_t</span> capacity_;     <span class="comment">// capacity in memory.</span></span><br><span class="line">    <span class="type">bool</span> end_write_;</span><br><span class="line">    <span class="type">size_t</span> read_num_;</span><br><span class="line">    <span class="type">size_t</span> write_num_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> _error&#123;&#125;;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab5: xv6 lazy page allocation</title>
      <link href="/2022/05/16/s081-lab5/"/>
      <url>/2022/05/16/s081-lab5/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab5: xv6 lazy page allocation --><p>很多情况都用到了Lazy allocation, 比如:</p><ul><li>paging from disk</li><li>COW fork</li><li>automatically extending stack</li><li>memory-mapped files<span id="more"></span></li></ul><p>xv6使用<code>sbrk()</code>申请<strong>物理地址空间</strong>并将其映射到进程的虚拟地址空间(向内核请求堆内存)。这个lab视频上也给了很多提示，重要的是理解并掌握原理。</p><p>实际上复杂的内核会在分配栈空间时做这样的处理, <code>sbrk</code>没有分配物理地址空间，只是记住分配了哪些用户地址，并在用户地址将这些地址标记为无效(invalid)。当进程尝试第一次使用任何给定Lazy Allocation的页面时，CPU会产生Page Fault的异常，该异常错误的类型会存放到<code>scause</code>寄存器，而<code>stval</code>寄存器中从存放着不能被translate的虚拟地址。<br><img src="https://pic4.zhimg.com/80/v2-998ad453d6ec0eed41edd98ca61aa644.png" alt="scause"></p><p>Page Fault的类型:</p><ul><li>load page faults, load指令不能translate地址</li><li>store page faults，store指令不能translate地址</li><li>instruction page faults，指令地址未能被tanslate<h2 id="1-Eliminate-allocation-from-sbrk"><a href="#1-Eliminate-allocation-from-sbrk" class="headerlink" title="1. Eliminate allocation from sbrk()"></a><strong>1. Eliminate allocation from sbrk()</strong></h2><h3 id="1-1-Description"><a href="#1-1-Description" class="headerlink" title="1.1 Description"></a><strong>1.1 Description</strong></h3>将<code>growproc</code>函数注释掉，不分配物理地址空间，只增加进程内存的大小。<h3 id="1-2-Implementation"><a href="#1-2-Implementation" class="headerlink" title="1.2 Implementation"></a><strong>1.2 Implementation</strong></h3><code>kernel/sysproc.c</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line"></span><br><span class="line">  myproc()-&gt;sz += n;</span><br><span class="line">  <span class="comment">// if(growproc(n) &lt; 0)  // Not need to allocate pysical memory.</span></span><br><span class="line">  <span class="comment">//   return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;  <span class="comment">// return the old size of process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Lazy-allocation"><a href="#2-Lazy-allocation" class="headerlink" title="2. Lazy allocation"></a><strong>2. Lazy allocation</strong></h2><h3 id="2-1-Description"><a href="#2-1-Description" class="headerlink" title="2.1 Description"></a><strong>2.1 Description</strong></h3>比如说要实现<code>Lazy allocation</code>, 在<code>sbrk()</code>系统调用时<code>page fault</code>异常发生，<code>sepc</code>寄存器保证在修补完页表之后到跳转回异常发生时执行指令的位置重新执行指令(原本的疑虑是在<code>usertrapret()</code>中sepc会+4即跳转到当前指令的下一条指令，实际上在lab3中才有自增4这条语句&#x3D; &#x3D;)。若没有空闲的物理内存，则返回错误，并且kill进程。如果<code>sbrk()</code>缩减堆内存，<code>page fault</code>就不会发生。</li></ul><p><code>uvmunmap</code>产生panic的原因是因为<code>sbrk()</code>已经分配物理内存但该物理内存未被使用。</p><p>在<code>printf</code>之前修改代码，使得<code>echo hi</code>正确执行。<br>Some hint:</p><ul><li>You can check whether a fault is a page fault by seeing if r_scause() is 13 or 15 in usertrap().</li><li>r_stval() returns the RISC-V stval register, which contains the virtual address that caused the page fault.</li><li>Steal code from uvmalloc() in vm.c, which is what sbrk() calls (via growproc()). You’ll need to call kalloc() and mappages().</li><li>Use PGROUNDDOWN(va) to round the faulting virtual address down to a page boundary.</li><li>uvmunmap() will panic; modify it to not panic if some pages aren’t mapped.</li><li>If the kernel crashes, look up sepc in kernel&#x2F;kernel.asm</li><li>Use your vmprint function from pgtbl lab to print the content of a page table.</li><li>If you see the error “incomplete type proc”, include “spinlock.h” then “proc.h”.<h3 id="2-2-Implementation"><a href="#2-2-Implementation" class="headerlink" title="2.2 Implementation"></a><strong>2.2 Implementation</strong></h3><code>kernel/trap:usertrap</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    <span class="comment">// check whether a fault is a page fault</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page fault: %p\n&quot;</span>, va);</span><br><span class="line">    <span class="comment">// lazy allocation before printf information.</span></span><br><span class="line">    <span class="type">char</span>* mem = kalloc();  <span class="comment">// allocate one page of physical memory. </span></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);  <span class="comment">// set all zeros.</span></span><br><span class="line">      <span class="keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><code>kernel/vm.c:uvmunmap</code>, 如果这一部分不用<strong>continue</strong>来处理，在接下来的code，刚分配的物理内存就会被释放掉。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Lazytests-and-Usertests"><a href="#3-Lazytests-and-Usertests" class="headerlink" title="3. Lazytests and Usertests"></a><strong>3. Lazytests and Usertests</strong></h2><h3 id="3-1-Description"><a href="#3-1-Description" class="headerlink" title="3.1 Description"></a><strong>3.1 Description</strong></h3>如果<code>sbrk()</code>缩减堆空间大小而不是扩大，注意<code>proc.sz</code>为无符号整型数，和一个int型数相加，有符号数会向无符号数发生隐式地转换。还需要注意<code>uvmunmap</code>的<code>walk panic</code>，已经改变sz但未分配物理地址，在释放就会出现<code>panic</code>，只需要执行<code>continue</code>即可。<code>out of memory</code>测试。同时xv6book中第三章有说<code>guard page</code>的<code>PTE_V</code>未设置，注意参考第三章给出的用户地址空间的布局。xv6中为用户栈分配了一个页</li></ul><p>Some hints:</p><ul><li>Handle negative sbrk() arguments.</li><li>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</li><li>Handle the parent-to-child memory copy in fork() correctly.</li><li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li><li>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</li><li>Handle faults on the invalid page below the user stack.<h3 id="3-2-Implementation"><a href="#3-2-Implementation" class="headerlink" title="3.2 Implementation"></a><strong>3.2 Implementation</strong></h3></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab4: Traps</title>
      <link href="/2022/05/16/s081-lab4/"/>
      <url>/2022/05/16/s081-lab4/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab4: Traps --><ul><li>跟着视频走一遍系统调用<code>gdb</code>的流程。<code>tmux</code>分割两个窗口，一个窗口作为服务器<code>make CPUS=1 qemu-gdb</code>，另一个窗口作为<code>gdb</code>调试窗口<code>gdb-multiarch</code>。将断点打在<code>ecall指令处</code>, <code>continue</code>执行，随后再将第二个断点打到<code>print/x $stvec</code>处也就是，<code>TRAPFRAME</code>的起始地址。<code>ecall</code>指令完成三件事，将用户模式切换到管理员模式、将PC保存到sepc寄存器中、将stvec寄存器的值赋给PC跳转到stvec保存的地址处执行。<span id="more"></span></li><li>进入<code>trampoline.s</code>后，<code>csrrw a0, sscratch, a0</code>首先将非体系结构寄存器<code>sscratch</code>与<code>a0</code>的值交换，<code>sscratch</code>寄存器中保存的时<code>TRAPFRAME</code>的起始地址。</li><li>然后将当前的现场(即寄存器)保存到<code>TRAPFRAME</code>中，再将<code>TRAPFRAME</code>中保存的内核栈指针，<code>hartid</code>，<code>usertrap()</code>的地址，以及内核页表所在的<code>stap</code>寄存器的值加载到当前通用寄存器中。</li><li>随后将寄存器<code>t1</code>保存的内核页目录的地址写入当前<code>satp</code>寄存器中，再刷新<code>TLB</code>，将用户页表切换为内核页表  <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csrw satp, <span class="built_in">t1</span></span><br><span class="line">sfence.vma <span class="built_in">zero</span>, <span class="built_in">zero</span></span><br></pre></td></tr></table></figure></li><li>将用户模式完全切换为内核模式之后，最后跳到<code>t0</code>中保存的<code>usertrap()</code>的入口地址，<code>jr t0</code>跳入<code>usertrap</code>函数。</li><li>进入函数后，首先判断<code>sstatus</code>寄存器的<code>SSP</code>位是否为<code>0</code>(即是否为用户模式下发生的trap)。将<code>stvec</code>赋值为<code>kernelvec</code>的入口地址，即在当前<code>usertrap</code>发生的中断或异常则跳转到<code>stvec</code>处执行。再保存中断返回的地址到<code>sepc</code>。</li><li>中断将会改变<code>sstatus</code>寄存器，因此在修改结束之后才将中断打开<code>intr_on()</code>。</li><li>之后进入系统调用<code>syscall()</code>，根据<code>p-&gt;trapframe-&gt;a7</code>中保存的系统调用号来决定调用哪个系统调用(专门通过一个静态数组查找<code>syscalls[num]</code>), 随后将系统调用的返回值保存到<code>p-&gt;trapframe-&gt;a0</code>中。</li><li>完成系统调用之后，随后计算<code>uservec</code>的虚拟地址并赋值给<code>stvec</code>，以便发生异常或中断的时候处理。接下来将相应的内容restore到<code>trapframe</code>中方便进行下一次<code>trap</code>。随后更新<code>sstatus</code>状态寄存器的值，清空<code>SSP</code>、设置<code>SPIE</code>位。</li><li>更新<code>sepc</code>的值以及将<code>satp</code>的值设为内核页表的地址，将在<code>userret</code>中切换页表。计算<code>userret</code>在<code>trampoline.s</code>中的虚拟地址，跳转到<code>userret</code>，跳转之前传参有个小细节，即将<code>TRAMPOLINE</code>作为第一个参数，这样在<code>a0</code>与<code>sscratch</code>交换后，<code>sscratch</code>就得到<code>TRAMPOLINE</code>的起始地址了。</li><li>进入到收尾阶段，将恢复到<code>trap</code>之前的状态。将<code>TRAMPOLINE</code>中的内容load到通用寄存器中，先将<code>a0</code>寄存器的值写入<code>sscratch</code>寄存器中，这样最后<code>csrrw a0, sscratch, a0</code>即可将这两个寄存器复位为各自的值。最后<code>sret</code>将<code>sepc</code>赋给<code>pc</code>完成系统调用恢复正常执行。</li></ul><h4 id="比较重要的非体系结构寄存器"><a href="#比较重要的非体系结构寄存器" class="headerlink" title="比较重要的非体系结构寄存器"></a><strong>比较重要的非体系结构寄存器</strong></h4><ul><li>stvec, 存放系统调用处理程序的地址</li><li>sepc, 当系统调用发生时PC存放到此处，以便系统调用返回时能从下一条指令开始执行<code>sret</code>: sepc -&gt; pc。</li><li>scause, ISA通过它来分析系统调用的种类</li><li>sscratch, 内核将一个值放到这里，方便系统调用的开始(通用寄存器和sscratch寄存器通过csrrw来交换值<code>csrrw a0, sscratch, a0</code>)。</li><li>sstatus, 状态寄存器，类似LC-3来决定是否发生中断，或者决定是用户模式还是系统模式，若存在条件码则存放条件码。</li></ul><h4 id="Debug相关"><a href="#Debug相关" class="headerlink" title="Debug相关"></a><strong>Debug相关</strong></h4><ul><li><code>add-symbol-file</code>或<code>file</code>命令从文件<code>filename</code>中读取附加的符号表信息存放在<code>ELF</code>文件(可重定向目标文件)中的<code>.symtab</code> Entry中。当文件名（通过其他方式）动态加载到正在运行的程序中时，将使用此命令。</li><li>解决调试alarmtest时<code>usertrap</code> C源代码不显示的, 函数和变量信息不够全，需要<code>add-symbol-file kernel/kernel</code>即可。</li></ul><h2 id="1-RISC-V-assembly"><a href="#1-RISC-V-assembly" class="headerlink" title="1. RISC-V assembly"></a><strong>1. RISC-V assembly</strong></h2><h3 id="1-1-Description"><a href="#1-1-Description" class="headerlink" title="1.1 Description"></a><strong>1.1 Description</strong></h3><blockquote><p>It will be important to understand a bit of RISC-V assembly, which you were exposed to in 6.004. There is a file user&#x2F;call.c in your xv6 repo. make fs.img compiles it and also produces a readable assembly version of the program in user&#x2F;call.asm.</p></blockquote><p>可以在<code>gdb</code>中使用<code>file</code>来对<code>call.o</code>文件调试，并将断点打到<code>main</code>函数上。解释调试时<code>RISCV</code>汇编出现的一些指令, <code>x</code>表示寄存器, <code>M</code>表示存储器:</p><ul><li><code>auipc</code>, Add Upper Immediate to PC. 将指令编码格式中的<code>Imm[31:12]</code>左移12位后的结果<code>sign-extened</code>后再加上PC。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auipc rd, Imm  <span class="comment">; x[rd] = PC + sext(Imm[31:12] &lt;&lt; 12)</span></span><br></pre></td></tr></table></figure></li><li><code>li</code>(pseudoinstruction), Load Immediate.<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li rd, Imm  <span class="comment">; x[rd] = Imm</span></span><br></pre></td></tr></table></figure></li><li><code>mv</code>(pseudoinstruction), Move. 注意与<code>x86 ISA</code>的<code>mov</code>传递方向不同。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv rd, rs1  <span class="comment">; x[rd] = x[rs1]</span></span><br></pre></td></tr></table></figure></li><li><code>jalr</code>, Jump And Link Register. <a href="https://stackoverflow.com/questions/40453719/risc-v-why-set-least-significant-bit-to-zero-in-jalr">为什么要将最低有效位置为0?</a>字节对齐。将当前pc+4赋给ra作为返回地址并跳转到offset(rs1), 随后返回到当前指令的下一条指令继续执行。注意如果rd省略了，那么rd就默认为x1(即<code>ra</code>保存返回地址的寄存器)。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jalr </span>rd, offset(rs1)  <span class="comment">; t=pc+4; pc=(x[rs1]+sext(offset)) &amp; ~1; x[rd] = t;</span></span><br></pre></td></tr></table></figure></li><li><code>lbu</code>, Load Byte Unsigned. 取完一个字节后，紧接着零拓展, <code>lb</code>为符号位拓展。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lbu </span>rd, offset(rs1)  <span class="comment">; x[rd] M[x[rs1] + sext(offset)] [7:0]</span></span><br></pre></td></tr></table></figure></li><li><code>seqz</code>(pseudoinstruction), Set if Equal to Zero.<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seqz rd, rs1  <span class="comment">; x[rd] = (x[rs1] == 0)</span></span><br></pre></td></tr></table></figure></li><li><code>csrrw</code>, Control and Status Register Read and Write. 状态寄存器和通用寄存器之间的读写操作。将状态寄存器中的内容放入rd寄存器，将rs1的内容放入状态寄存器。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrrw rd, csr, rs1  <span class="comment">; t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t</span></span><br></pre></td></tr></table></figure></li><li><code>csrw</code><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrw csr, rs1</span><br></pre></td></tr></table></figure></li><li><code>csrr</code><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrr rd, csr</span><br></pre></td></tr></table></figure><h3 id="1-2-Implementation"><a href="#1-2-Implementation" class="headerlink" title="1.2 Implementation"></a><strong>1.2 Implementation</strong></h3></li><li>不了解RISCV指令集的建议可以把<a href="https://inst.eecs.berkeley.edu/~cs61c/su20/">CS61C</a>的Week2专门讲RISCV的slide或者视频看完，直到把调试过程中遇到的每条指令弄明白再来做这一个task。</li></ul><p>分析<code>user/call.asm</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  <span class="number">1</span>c:<span class="number">1141</span>                <span class="keyword">addi</span><span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">16</span></span><br><span class="line">  <span class="number">1</span>e:e406                sd<span class="built_in">ra</span>,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="symbol">  20:</span>e022                sd<span class="built_in">s0</span>,<span class="number">0</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="symbol">  22:</span><span class="number">0800</span>                <span class="keyword">addi</span><span class="built_in">s0</span>,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">  printf(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line"><span class="symbol">  24:</span><span class="number">4635</span>                li<span class="built_in">a2</span>,<span class="number">13</span></span><br><span class="line"><span class="symbol">  26:</span><span class="number">45</span>b1                li<span class="built_in">a1</span>,<span class="number">12</span></span><br><span class="line"><span class="symbol">  28:</span><span class="number">00000517</span>          auipc<span class="built_in">a0</span>,<span class="number">0x0</span></span><br><span class="line">  <span class="number">2</span>c:<span class="number">7</span>c050513          <span class="keyword">addi</span><span class="built_in">a0</span>,<span class="built_in">a0</span>,<span class="number">1984</span> <span class="comment"># 7e8 &lt;malloc+0xea&gt;</span></span><br><span class="line"><span class="symbol">  30:</span><span class="number">00000097</span>          auipc<span class="built_in">ra</span>,<span class="number">0x0</span></span><br><span class="line"><span class="symbol">  34:</span><span class="number">610080</span>e7          <span class="keyword">jalr</span><span class="number">1552</span>(<span class="built_in">ra</span>) <span class="comment"># 640 &lt;printf&gt;</span></span><br><span class="line">  exit(<span class="number">0</span>);</span><br><span class="line"><span class="symbol">  38:</span><span class="number">4501</span>                li<span class="built_in">a0</span>,<span class="number">0</span></span><br><span class="line">  <span class="number">3</span>a:<span class="number">00000097</span>          auipc<span class="built_in">ra</span>,<span class="number">0x0</span></span><br><span class="line">  <span class="number">3</span>e:<span class="number">27</span>e080e7          <span class="keyword">jalr</span><span class="number">638</span>(<span class="built_in">ra</span>) <span class="comment"># 2b8 &lt;exit&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2</span><br></pre></td></tr></table></figure></li><li>Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline funtions.)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译器优化: g被inline到了f中，f又进一步被内联到了main中 </span><br></pre></td></tr></table></figure></li><li>At what address is the function printf located?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auipc ra, 0x0指令将0x30赋给ra中, 而jalr 1552(ra)跳转到的地址为0x640</span><br></pre></td></tr></table></figure></li><li>What value is in the register ra just after the jalr to printf in main?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果jalr没有第一个操作数，那么返回地址默认存放到ra寄存器中。ra=pc+4即0x38</span><br></pre></td></tr></table></figure></li><li>Run the following code.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line"> ```     </span><br><span class="line"> What is the output? </span><br></pre></td></tr></table></figure>57616&#x3D;0xe110, RISCV是little-endian, 因此i在内存中存储的形式为0x726c6400对应的ASCII值为0x72 &#x3D; ‘r’, 0x6c &#x3D; ‘l’, 0x64 &#x3D; ‘d’, 0x00 &#x3D; ‘\0’。因此最后printf输出的结果为”He110, World\0”。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If the RISC-V were instead big-endian what would you set i to in order to yield the same output?</span><br></pre></td></tr></table></figure>如果是大端字节序，为保持相同的输出结果，将i的值反过来即可i &#x3D; 0x726c6400<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- In the following code, what is going to be printed after &#x27;y=&#x27;? (note: the answer is not a specific value.) Why does this happen?</span><br><span class="line">  ``` c</span><br><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阅读call.asm, 将3存放到a1寄存器后，在调用printf之前并未对a2寄存器进行修改(本应该有第二个参数的), 第二个参数传入的值是a2寄存器中原有的随机值。</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-Backtrace"><a href="#2-Backtrace" class="headerlink" title="2. Backtrace"></a><strong>2. Backtrace</strong></h2><h3 id="2-1-Description"><a href="#2-1-Description" class="headerlink" title="2.1 Description"></a><strong>2.1 Description</strong></h3><p>在<code>kernel/printf.c</code>中实现<code>backtrace()</code>函数。阅读源码时会有<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">内联汇编</a>的相关知识。实现backtrace函数还需要了解<a href="https://pdos.csail.mit.edu/6.828/2020/lec/l-riscv-slides.pdf">RISCV栈帧</a>布局。当前的<code>stack frame</code>含有对前一个<code>stack frame</code>的指针。高地址往低地址以此为<code>Return Address</code>, <code>To Prev. Frame Pointer</code>, <code>Saved Registers</code>, <code>Local Variables</code>…其中frame pointer指向栈帧第一个entry的顶部。<br>Some hints</p><ul><li>Add the prototype for backtrace to kernel&#x2F;defs.h so that you can invoke backtrace in sys_sleep.</li><li>The GCC compiler stores the frame pointer of the currently executing function in the register s0. Add the following function to kernel&#x2F;riscv.h:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>and call this function in backtrace to read the current frame pointer. This function uses in-line assembly to read s0.</li><li>These lecture notes have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</li><li>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using PGROUNDDOWN(fp) and PGROUNDUP(fp) (see kernel&#x2F;riscv.h. These number are helpful for backtrace to terminate its loop.<h3 id="2-2-Implementation"><a href="#2-2-Implementation" class="headerlink" title="2.2 Implementation"></a><strong>2.2 Implementation</strong></h3>要利用好当前栈帧所在页的边界，来通过每个栈帧的prev(类似于链表)，来遍历并打印当前栈帧的返回地址。要注意栈是由高地址向低地址方向增长的，因此需要获取页的Top作为边界, 要理解<strong>回溯</strong>这个词。注意更新fp的时候上一个栈帧的fp是存放在地址单元为当前栈帧的fp-8中的, 因此需要解引用(*)取地址。在xv6中，内核为进程分配一个页大小的栈。<br><code>kernel/printf.c</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 fp = r_fp();  <span class="comment">// r_fp() return the fp of current execute function</span></span><br><span class="line">  uint64 ftop = PGROUNDUP(fp);  <span class="comment">// get the top addr of stack frame page.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (fp &lt; ftop) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(fp<span class="number">-8</span>));  <span class="comment">// print return address stored in (fp-8).</span></span><br><span class="line">    fp = *(uint64*)(fp<span class="number">-16</span>);   <span class="comment">//  update fp to previous frame fp.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Alarm"><a href="#3-Alarm" class="headerlink" title="3. Alarm"></a><strong>3. Alarm</strong></h2><h3 id="3-1-Description"><a href="#3-1-Description" class="headerlink" title="3.1 Description"></a><strong>3.1 Description</strong></h3><blockquote><p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example</p></blockquote><p>sigalarm(n, fn)表示，在每个n ticks之后将会调用应用程序函数fn, 当fn函数调用结束之后，应用程序将会在它调用fn的地址处恢复执行。</p><h3 id="3-2-1-test0-invoke-handler"><a href="#3-2-1-test0-invoke-handler" class="headerlink" title="3.2.1 test0: invoke handler"></a><strong>3.2.1 test0: invoke handler</strong></h3><p>Some hints:</p><ul><li>You’ll need to modify the Makefile to cause alarmtest.c to be compiled as an xv6 user program.</li><li>The right declarations to put in user&#x2F;user.h are:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>Update user&#x2F;usys.pl (which generates user&#x2F;usys.S), kernel&#x2F;syscall.h, and kernel&#x2F;syscall.c to allow alarmtest to invoke the sigalarm and sigreturn system calls.</li><li>For now, your sys_sigreturn should just return zero.</li><li>Your sys_sigalarm() should store the alarm interval and the pointer to the handler function in new fields in the proc structure (in kernel&#x2F;proc.h).</li><li>You’ll need to keep track of how many ticks have passed since the last call (or are left until the next call) to a process’s alarm handler; you’ll need a new field in struct proc for this too. You can initialize proc fields in allocproc() in proc.c.</li><li>Every tick, the hardware clock forces an interrupt, which is handled in usertrap() in kernel&#x2F;trap.c.</li><li>You only want to manipulate a process’s alarm ticks if there’s a timer interrupt; you want something like  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) ...</span><br></pre></td></tr></table></figure></li><li>Only invoke the alarm function if the process has a timer outstanding. Note that the address of the user’s alarm function might be 0 (e.g., in user&#x2F;alarmtest.asm, periodic is at address 0).</li><li>You’ll need to modify usertrap() so that when a process’s alarm interval expires, the user process executes the handler function. When a trap on the RISC-V returns to user space, what determines the instruction address at which user-space code resumes execution?</li><li>It will be easier to look at traps with gdb if you tell qemu to use only one CPU, which you can do by running  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure></li><li>You’ve succeeded if alarmtest prints “alarm!”.<h3 id="3-2-2-test0-implementation"><a href="#3-2-2-test0-implementation" class="headerlink" title="3.2.2 test0 implementation"></a><strong>3.2.2 test0 implementation</strong></h3></li><li><code>kernel/proc.h</code>，在proc结构体中加入结构体成员<code>tick</code>, <code>handler</code>, <code>intervel</code>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint64 tick;</span><br><span class="line">uint64 handler;</span><br><span class="line">uint64 intervel;</span><br></pre></td></tr></table></figure></li><li><code>kernel/proc.c</code>，在<code>allocproc</code>函数中初始化<code>tick</code>成员为0。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;tick = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><code>kernel/trap.c</code>, 当trap返回时，sret指令将sepc寄存器中的地址赋给pc执行，也就是说在下述代码中，trap返回时将执行alarm的中断处理程序。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;intervel == p-&gt;tick) &#123;  <span class="comment">// expire</span></span><br><span class="line">    p-&gt;tick = <span class="number">0</span>;  <span class="comment">// reset tick</span></span><br><span class="line">    <span class="comment">// save all the needed registers</span></span><br><span class="line">    <span class="comment">// epc store the user program counter(PC).</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;handler;  <span class="comment">// when returned, jump to execute handler.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p-&gt;tick++;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>kernel/sysproc.c</code>, <code>argint</code>和<code>argaddr</code>获取系统调用的第n个参数值, 然后初始化进程中对应的属性。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">int</span> interval;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="comment">// fetch syscall nth argument.</span></span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;interval) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// initialize p&#x27;s attribute.</span></span><br><span class="line">  p-&gt;intervel = interval;</span><br><span class="line">  p-&gt;handler = handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-test1-x2F-test2-resume-interrupted-code"><a href="#3-3-1-test1-x2F-test2-resume-interrupted-code" class="headerlink" title="3.3.1 test1&#x2F;test2: resume interrupted code"></a><strong>3.3.1 test1&#x2F;test2: resume interrupted code</strong></h3>需要添加一些操作，确保在alarm处理程序完成后，控制权返回到用户程序最初被时钟中断的指令。必须得确保寄存器内容恢复到中断前的值，以及中断前的位置，所以需要在alarm的handler覆盖掉sepc之前保存好存放返回地址的sepc寄存器。<br>Some hints:</li><li>Your solution will require you to save and restore registers—what registers do you need to save and restore to resume the interrupted code correctly? (Hint: it will be many).</li><li>Have usertrap save enough state in struct proc when the timer goes off that sigreturn can correctly return to the interrupted user code.</li><li>Prevent re-entrant calls to the handler—-if a handler hasn’t returned yet, the kernel shouldn’t call it again. test2 tests this.</li></ul><h3 id="3-3-2-test1-x2F-test2-Implementation"><a href="#3-3-2-test1-x2F-test2-Implementation" class="headerlink" title="3.3.2 test1&#x2F;test2 Implementation"></a><strong>3.3.2 test1&#x2F;test2 Implementation</strong></h3><p>考虑一下第一个提示，是不是可以选择性地<code>save</code>寄存器? 看一下alarmtest.asm中的handler的汇编程序找一找。</p><ul><li>在<code>kernel/proc.h</code>中加入<code>is_alarm_working</code>属性，防止当前还在执行handler而导致的重入。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> is_alarm_working = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><code>kernel/trap.c</code>, 因为为用户级别的中断，因此不涉及到trapframe中保存的有关内核寄存器的修改。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!p-&gt;is_alarm_working &amp;&amp; p-&gt;intervel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;intervel == p-&gt;tick) &#123;  <span class="comment">// expire</span></span><br><span class="line">      p-&gt;tick = <span class="number">0</span>;  <span class="comment">// reset tick</span></span><br><span class="line">      p-&gt;is_alarm_working = <span class="number">1</span>;  <span class="comment">// reprensent executed handler is not terminate.</span></span><br><span class="line">      <span class="comment">// save all the needed registers.</span></span><br><span class="line">      p-&gt;saved_epc = p-&gt;trapframe-&gt;epc; <span class="comment">// save return address.</span></span><br><span class="line">      p-&gt;saved_ra = p-&gt;trapframe-&gt;ra;</span><br><span class="line">      p-&gt;saved_sp = p-&gt;trapframe-&gt;sp;</span><br><span class="line">      p-&gt;saved_gp = p-&gt;trapframe-&gt;gp;</span><br><span class="line">      p-&gt;saved_tp = p-&gt;trapframe-&gt;tp;</span><br><span class="line">      p-&gt;saved_t0 = p-&gt;trapframe-&gt;t0;</span><br><span class="line">      p-&gt;saved_t1 = p-&gt;trapframe-&gt;t1;</span><br><span class="line">      p-&gt;saved_t2 = p-&gt;trapframe-&gt;t2;</span><br><span class="line">      p-&gt;saved_t3 = p-&gt;trapframe-&gt;t3;</span><br><span class="line">      p-&gt;saved_t4 = p-&gt;trapframe-&gt;t4;</span><br><span class="line">      p-&gt;saved_t5 = p-&gt;trapframe-&gt;t5;</span><br><span class="line">      p-&gt;saved_t6 = p-&gt;trapframe-&gt;t6;</span><br><span class="line">      p-&gt;saved_a0 = p-&gt;trapframe-&gt;a0;</span><br><span class="line">      p-&gt;saved_a1 = p-&gt;trapframe-&gt;a1;</span><br><span class="line">      p-&gt;saved_a2 = p-&gt;trapframe-&gt;a2;</span><br><span class="line">      p-&gt;saved_a3 = p-&gt;trapframe-&gt;a3;</span><br><span class="line">      p-&gt;saved_a4 = p-&gt;trapframe-&gt;a4;</span><br><span class="line">      p-&gt;saved_a5 = p-&gt;trapframe-&gt;a5;</span><br><span class="line">      p-&gt;saved_a6 = p-&gt;trapframe-&gt;a6;</span><br><span class="line">      p-&gt;saved_a7 = p-&gt;trapframe-&gt;a7;</span><br><span class="line">      p-&gt;saved_s0 = p-&gt;trapframe-&gt;s0;</span><br><span class="line">      p-&gt;saved_s1 = p-&gt;trapframe-&gt;s1;</span><br><span class="line">      p-&gt;saved_s2 = p-&gt;trapframe-&gt;s2;</span><br><span class="line">      p-&gt;saved_s3 = p-&gt;trapframe-&gt;s3;</span><br><span class="line">      p-&gt;saved_s4 = p-&gt;trapframe-&gt;s4;</span><br><span class="line">      p-&gt;saved_s5 = p-&gt;trapframe-&gt;s5;</span><br><span class="line">      p-&gt;saved_s6 = p-&gt;trapframe-&gt;s6;</span><br><span class="line">      p-&gt;saved_s7 = p-&gt;trapframe-&gt;s7;</span><br><span class="line">      p-&gt;saved_s8 = p-&gt;trapframe-&gt;s8;</span><br><span class="line">      p-&gt;saved_s9 = p-&gt;trapframe-&gt;s9;</span><br><span class="line">      p-&gt;saved_s10 = p-&gt;trapframe-&gt;s10;</span><br><span class="line">      p-&gt;saved_s11 = p-&gt;trapframe-&gt;s11;</span><br><span class="line">      <span class="comment">// epc register store the user program counter(PC).</span></span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;handler;  <span class="comment">// when returned, jump to execute handler.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p-&gt;tick++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>kernel/sysproc.c</code>, <code>sigreturn</code>系统调用在alarm的handler结束之后完成<code>sigalarm</code>发生前现场的保护，即对寄存器的<code>restore</code>和防止重入变量的<code>reset</code>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;trapframe-&gt;epc = p-&gt;saved_epc; </span><br><span class="line">  p-&gt;trapframe-&gt;ra = p-&gt;saved_ra; </span><br><span class="line">  p-&gt;trapframe-&gt;sp = p-&gt;saved_sp; </span><br><span class="line">  p-&gt;trapframe-&gt;gp = p-&gt;saved_gp; </span><br><span class="line">  p-&gt;trapframe-&gt;tp = p-&gt;saved_tp; </span><br><span class="line">  p-&gt;trapframe-&gt;a0 = p-&gt;saved_a0; </span><br><span class="line">  p-&gt;trapframe-&gt;a1 = p-&gt;saved_a1; </span><br><span class="line">  p-&gt;trapframe-&gt;a2 = p-&gt;saved_a2; </span><br><span class="line">  p-&gt;trapframe-&gt;a3 = p-&gt;saved_a3; </span><br><span class="line">  p-&gt;trapframe-&gt;a4 = p-&gt;saved_a4; </span><br><span class="line">  p-&gt;trapframe-&gt;a5 = p-&gt;saved_a5; </span><br><span class="line">  p-&gt;trapframe-&gt;a6 = p-&gt;saved_a6; </span><br><span class="line">  p-&gt;trapframe-&gt;a7 = p-&gt;saved_a7; </span><br><span class="line">  p-&gt;trapframe-&gt;t0 = p-&gt;saved_t0; </span><br><span class="line">  p-&gt;trapframe-&gt;t1 = p-&gt;saved_t1; </span><br><span class="line">  p-&gt;trapframe-&gt;t2 = p-&gt;saved_t2; </span><br><span class="line">  p-&gt;trapframe-&gt;t3 = p-&gt;saved_t3; </span><br><span class="line">  p-&gt;trapframe-&gt;t4 = p-&gt;saved_t4; </span><br><span class="line">  p-&gt;trapframe-&gt;t5 = p-&gt;saved_t5; </span><br><span class="line">  p-&gt;trapframe-&gt;t6 = p-&gt;saved_t6;</span><br><span class="line">  p-&gt;trapframe-&gt;s0 = p-&gt;saved_s0;</span><br><span class="line">  p-&gt;trapframe-&gt;s1 = p-&gt;saved_s1;</span><br><span class="line">  p-&gt;trapframe-&gt;s2 = p-&gt;saved_s2;</span><br><span class="line">  p-&gt;trapframe-&gt;s3 = p-&gt;saved_s3;</span><br><span class="line">  p-&gt;trapframe-&gt;s4 = p-&gt;saved_s4;</span><br><span class="line">  p-&gt;trapframe-&gt;s5 = p-&gt;saved_s5;</span><br><span class="line">  p-&gt;trapframe-&gt;s6 = p-&gt;saved_s6;</span><br><span class="line">  p-&gt;trapframe-&gt;s7 = p-&gt;saved_s7;</span><br><span class="line">  p-&gt;trapframe-&gt;s8 = p-&gt;saved_s8;</span><br><span class="line">  p-&gt;trapframe-&gt;s9 = p-&gt;saved_s9;</span><br><span class="line">  p-&gt;trapframe-&gt;s10 = p-&gt;saved_s10;</span><br><span class="line">  p-&gt;trapframe-&gt;s11 = p-&gt;saved_s11;</span><br><span class="line">  p-&gt;is_alarm_working = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="最后的疑问"><a href="#最后的疑问" class="headerlink" title="最后的疑问"></a><strong>最后的疑问</strong></h3><p>用户级别的时钟中断是在系统调用<code>sigalarm</code>时对硬件进行操作使得其周期性地发生中断?</p><h3 id="All-Test-Passed"><a href="#All-Test-Passed" class="headerlink" title="All Test Passed"></a><strong>All Test Passed</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-a5ba7b96aa580477641e72690d8b2044.png" alt="Test"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>终于结束lab4了，呼~, gdb调的真舒服，基本的syscall逻辑大致都搞明白了。Backtrace按照hint写入一些函数，实际上就是要理解上一节video讲的frame point的一些概念，当前stack frame的第1个entry会指向前一个frame同时也给出了stack frame的分布图，间接地实现了gdb的查看栈帧的backtrace命令; 系统调用alarm会在进程使用CPU时间定期发出警报，手把手实现一个<strong>用户级别</strong>的中断。通过trap中根据devintr()的返回值判断中断的类型，1为设备中断，2为时钟中断，0为未识别。进而tick控制在指定intervel内调用中断处理程序handler。同时还需要在proc.h中加入字段，防止中断发生时的重入。涉及到部分寄存器的store&#x2F;restore。另外<code>ecall</code>指令完成三件事：1.将用户模式切换到管理员模式; 2.将PC保存到sepc寄存器中; 3.将跳转到stvec寄存器中存储的地址处执行，即将stvec赋给PC。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab3: Page tables</title>
      <link href="/2022/05/16/s081-lab3/"/>
      <url>/2022/05/16/s081-lab3/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab3: Page tables --><h2 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a><strong>1. Print a page table</strong></h2><span id="more"></span><h3 id="1-1-Description"><a href="#1-1-Description" class="headerlink" title="1.1 Description"></a><strong>1.1 Description</strong></h3><blockquote><p>Define a function called vmprint(). It should take a pagetable_t argument, and print that pagetable in the format described below. Insert if(p-&gt;pid&#x3D;&#x3D;1) vmprint(p-&gt;pagetable) in exec.c just before the return argc, to print the first process’s page table. You receive full credit for this assignment if you pass the pte printout test of make grade.</p></blockquote><h3 id="1-2-Implementation"><a href="#1-2-Implementation" class="headerlink" title="1.2 Implementation"></a><strong>1.2 Implementation</strong></h3><ul><li>将<code>vmprint</code>函数添加到<code>kernel/vm.c</code>文件中并在<code>kernel/defs.h</code>文件中添加该函数的声明。使用格式符<code>%p</code>打印16进制数，使用<code>kernel/riscv.h</code>文件中定义的宏, 参考<code>freewalk</code>函数以递归的形式完成。实现该函数方便接下来的调试, 可以在gdb中测试其正确性。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">3</span>)  <span class="comment">// terminate condition.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      uint64 pa = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; depth; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, pa);</span><br><span class="line">      vmprint((<span class="type">pagetable_t</span>)pa, ++depth);  <span class="comment">// recursive.</span></span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2. A kernel page table per process"></a><strong>2. A kernel page table per process</strong></h2><h3 id="2-1-Description"><a href="#2-1-Description" class="headerlink" title="2.1 Description"></a><strong>2.1 Description</strong></h3><blockquote><p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify struct proc to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if usertests runs correctly.</p></blockquote><ul><li><p>Add a field to struct proc for the process’s kernel page table.</p></li><li><p>A reasonable way to produce a kernel page table for a new process is to implement a modified version of kvminit that makes a new page table instead of modifying kernel_pagetable. You’ll want to call this function from allocproc.</p></li><li><p>Make sure that each process’s kernel page table has a mapping for that process’s kernel stack. In unmodified xv6, all the kernel stacks are set up in procinit. You will need to move some or all of this functionality to allocproc.</p></li><li><p>Modify scheduler() to load the process’s kernel page table into the core’s satp register (see kvminithart for inspiration). Don’t forget to call sfence_vma() after calling w_satp().</p></li><li><p>scheduler() should use kernel_pagetable when no process is running.</p></li><li><p>Free a process’s kernel page table in freeproc.</p></li><li><p>You’ll need a way to free a page table without also freeing the leaf physical memory pages.</p></li><li><p>vmprint may come in handy to debug page tables.</p></li><li><p>It’s OK to modify xv6 functions or add new functions; you’ll probably need to do this in at least kernel&#x2F;vm.c and kernel&#x2F;proc.c. (But, don’t modify kernel&#x2F;vmcopyin.c, kernel&#x2F;stats.c, user&#x2F;usertests.c, and user&#x2F;stats.c.)</p></li><li><p>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes sepc&#x3D;0x00000000XXXXXXXX. You can find out where the fault occurred by searching for XXXXXXXX in kernel&#x2F;kernel.asm.</p><h3 id="2-2-Implementation"><a href="#2-2-Implementation" class="headerlink" title="2.2 Implementation"></a><strong>2.2 Implementation</strong></h3></li><li><p>在<code>proc.h</code>进程的结构体中加入内核页表的属性<code>pkpagetable</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="type">pagetable_t</span> pkpagetable;     <span class="comment">// process&#x27;s kernel page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>kvminit</code>函数的另一个版本来初始化进程的内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create processes&#x27;s kernel table</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">ukvmcreate</span><span class="params">()</span>  </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  uvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  uvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> kpagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以及专门将映射加入进程的内核页表的函数<code>uvmmap</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to processes&#x27;s kernel</span></span><br><span class="line"><span class="comment">// page table</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确保每个进程的内核页表中包含该进程所使用到的内核栈的映射。可以将原来在<code>boot time</code>进程初始化<code>procinit</code>函数中全局内核页表映射内核栈的代码<strong>注释</strong>掉。应题目要求在<code>allocproc</code>函数中实现映射当前进程所对应的内核栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="type">char</span> *pa = kalloc();   <span class="comment">// allocate physical memory per page.</span></span><br><span class="line"><span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="type">int</span>) (p - proc));  <span class="comment">// virtual address.</span></span><br><span class="line"><span class="comment">// make sure each process&#x27;s kernel page table has a mapping</span></span><br><span class="line"><span class="comment">// for that process&#x27;s kernel stack.</span></span><br><span class="line">uvmmap(p-&gt;pkpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure></li><li><p>在<code>scheduler</code>函数内实现，模仿<code>kvminithart</code>函数在调度时切换页表，即将进程的内核页表的地址放入<code>satp</code>寄存器，相应地刷新<code>TLB</code>，当进程没有在运行时，调度器切换回全局内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  load the process&#x27;s kernel page table into the core&#x27;s satp register.</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;pkpagetable));</span><br><span class="line">        sfence_vma();   <span class="comment">// flush the TLB.</span></span><br><span class="line">        </span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">        <span class="comment">// use kernel_pagetable when no process is running</span></span><br><span class="line">        kvminithart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;   <span class="comment">// wait for interrupt.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>freeproc</code>函数中完成释放进程的内核页表操作, 同时实现函数<code>freeukpagetable</code>, 在释放页表时不释放掉<code>leaf</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;pkpagetable) &#123;</span><br><span class="line">  freeukpagetable(p-&gt;pkpagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freeukpagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;  <span class="comment">// not leaf.</span></span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        freeukpagetable((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Simplify"><a href="#3-Simplify" class="headerlink" title="3. Simplify"></a><strong>3. Simplify</strong></h2><h3 id="3-1-Description"><a href="#3-1-Description" class="headerlink" title="3.1 Description"></a><strong>3.1 Description</strong></h3><blockquote><p>Your job in this part of the lab is to add user mappings to each process’s kernel page table (created in the previous section) that allow copyin (and the related string function copyinstr) to directly dereference user pointers. Replace the body of copyin in kernel&#x2F;vm.c with a call to copyin_new (defined in kernel&#x2F;vmcopyin.c); do the same for copyinstr and copyinstr_new. Add mappings for user addresses to each process’s kernel page table so that copyin_new and copyinstr_new work. You pass this assignment if usertests runs correctly and all the make grade tests pass.</p></blockquote></li><li><p>Replace copyin() with a call to copyin_new first, and make it work, before moving on to copyinstr.</p></li><li><p>At each point where the kernel changes a process’s user mappings, change the process’s kernel page table in the same way. Such points include fork(), exec(), and sbrk().</p></li><li><p>Don’t forget that to include the first process’s user page table in its kernel page table in userinit.</p></li><li><p>What permissions do the PTEs for user addresses need in a process’s kernel page table? (A page with PTE_U set cannot be accessed in kernel mode.)<br>Don’t forget about the above-mentioned PLIC limit.</p><h3 id="3-2-Implementation"><a href="#3-2-Implementation" class="headerlink" title="3.2 Implementation"></a><strong>3.2 Implementation</strong></h3></li><li><p>用<code>copy_new</code>函数替代<code>copyin</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>copyinstr_new</code>函数替代<code>copyinstr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>fork()</code>中针对用户页表映射修改，相应进程的内核页表做出的改动。并实现将用户页表copy到内核页表并清空相应<code>PTE_U</code>标志的函数<code>copyupttokpt</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line"><span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line"><span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(np);</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">copyupttokpt(np-&gt;pkpagetable, np-&gt;pagetable, <span class="number">0</span>, np-&gt;sz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy saved user registers.</span></span><br><span class="line">*(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">copyupttokpt</span><span class="params">(<span class="type">pagetable_t</span> ker, <span class="type">pagetable_t</span> user, uint64 old_size, uint64 new_size)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte_from, *pte_to;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  old_size = PGROUNDUP(old_size);</span><br><span class="line">  <span class="keyword">for</span>(i = old_size; i &lt; new_size; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte_from = walk(user, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;copyupttokpt: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((pte_to = walk(ker, i, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;copyupttokpt: walk&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte_from);</span><br><span class="line">    <span class="comment">// clear PTE_U bit because of kernel page table.</span></span><br><span class="line">    flags = PTE_FLAGS(*pte_from) &amp; (~PTE_U);</span><br><span class="line">    *pte_to = PA2PTE(pa) | flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数<code>exec()</code>中，替换当前进程的用户页表时，内核页表也随之释放，并<code>copy</code>新用户页表的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line"><span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">  <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    last = s+<span class="number">1</span>;</span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br><span class="line">p-&gt;sz = sz;</span><br><span class="line"></span><br><span class="line">uvmunmap(p-&gt;pkpagetable, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line"></span><br><span class="line">p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure></li><li><p>函数<code>sbrk()</code>，相应的增加和减少内存时变更用户页表，需要同时更新进程的内核页表。需要判断用户分配地址空间的限制。如果增加的内存大于<code>PLIC</code>则返回<code>-1</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((sz + n) &gt;= PLIC) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// test overflow.</span></span><br><span class="line">    <span class="comment">// mapping the n bytes in process&#x27;s kernel table.</span></span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, sz-n, sz);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// ummaping the n bytes in process&#x27;s kernel table.</span></span><br><span class="line">    uvmunmap(p-&gt;pkpagetable, PGROUNDUP(sz), (PGROUNDUP(p-&gt;sz) - PGROUNDUP(sz))/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>userinit</code>，初始化第一个<code>process</code>时也需要更新进程的内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>简单的写一下lab 3的总结吧，做之前最好把概念理清楚，确实蛮有难度的。</p><p>打印三级也页表页表项的虚拟地址以及物理地址，利用递归就可以完成，leaf pte的判断的判断条件即递归结束条件，可以参考vm.c中部分函数的源代码。leaf pte可以通过pte中的flag进行判断，事实上，也就只有leaf pte才含有PTE_W，PTE_X，PTE_R。</p><p>由于历史原因部分os将内核和用户进程独立分为两个page table，本lab的初衷是为了利用好进程之间的isolation，为每个用户进程分配一个内核页表(初始时的映射和全局内核页表相同, <strong>其中此内核页表中含有用户页表的映射</strong>)，释放进程的同时也要将进程的内核页表释放，注意不将叶子pte的物理内存释放，初始化时也是同样的。注意到procinit函数里已经为每个用户进程通过全局内核页表分配好了内核栈，hint中要求把该部分迁移到分配用户进程是时分配栈，另外kvmpa函数中也有个坑，需要将全局内核页表替换为当前用户进程的内核页表。</p><p>将用户进程页表载入到用户的内核页表后，系统调用传参时所用到的copyin或者copyinstr就不需要再间接的将该参数的虚拟地址通过用户页表转换为物理地址之后再处理了，简化了一步walk的操作，直接dereference即可。copy页表映射时可以参考vmcopy函数，fork中有相关页表复制的内容，但不是全部参考，可能会出现remap的情况，因此考虑不使用mappages函数即可。注意sbrk时相关函数growproc的overflow检测，以及虚拟地址空间减少时要从用户内核页表中unmap掉相关内容，增加时正常复制即可。exec函数中copy前需要将用户内核页表的映射清空。其他都按hint去做就行了，The devil is in the details.</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><p>强调一下<code>walk</code>函数的实现，在xv6中即为遍历三级页表, 很清晰地刻画了真实的页表实现。<code>PTE2PA</code>宏将当前PTE的地址(物理地址)右移10位将10个有效位置0，左移12位加上偏移量(因为页大小为<code>4kb</code>, $2^{12}&#x3D;4096&#x3D;4k$, 所以偏移量为12, <code>byte</code>为寻址能力大小), 最后转化为物理地址。<br>记住页目录存在于物理地址空间中。虚拟地址空间中的<code>L2</code>, <code>L1</code>, <code>L0</code>字段确定每一级页目录中的<code>Entry</code>。<strong>非叶子节点</strong>的<code>PPN</code>(Physical page number)连结上全0的Offset为下一级页目录的<strong>物理地址</strong>。<br><img src="https://pic4.zhimg.com/80/v2-78092855fd01e077d1d69fda55a6f1b2.png" alt="Page table"></p><ul><li><strong>walk</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];  <span class="comment">// 根据虚拟地址的L字段获取页目录中的Entry</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// 解引用获取当前Entry的地址, 将PPN(物理页号)和Offset(全0)连接后更下一级页目录的物理地址</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];  <span class="comment">// 叶子节点处PPN+虚拟地址的Offset为最终转换的物理地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>宏</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab2: System Calls</title>
      <link href="/2022/05/16/s081-lab2/"/>
      <url>/2022/05/16/s081-lab2/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab2: System Calls --><h2 id="1-System-call-tracing"><a href="#1-System-call-tracing" class="headerlink" title="1. System call tracing"></a><strong>1. System call tracing</strong></h2><span id="more"></span><h3 id="1-1-描述"><a href="#1-1-描述" class="headerlink" title="1.1 描述"></a><strong>1.1 描述</strong></h3><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel&#x2F;syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><ul><li>将相应的文件添加到<em>user&#x2F;user.h</em>和<em>user&#x2F;usys.pl</em>中，向<em>kernel&#x2F;syscall.h</em>文件中添加本实验所需要添加的系统调用号。</li><li>向<em>kernel&#x2F;sysproc.c</em>中添加系统调用函数<em>sys_trace</em>(这是内核系统调用的实现)，以及需要在进程的结构体中，新建一个变量Mask(掩码)由低位开始偏移系统调用号个bit的值(通过观察<em>syscall.h</em>文件以及题目中给的case可以发现系统调用号对应二进制的bit)。</li><li>还需要再<em>kernel&#x2F;proc.c&#x2F;fork</em>函数中使得子进程继承父进程的Mask属性。</li><li>参照<em>kernel&#x2F;syscall.c</em>中别的系统调用，通过阅读<em>user&#x2F;trace.c</em>代码，使用<code>argint</code>函数来提取trace函数中的第一个参数(a0寄存器)作为掩码赋给进程的属性Mask(这个赋值不会影响其他系统调用的掩码)，还需要定义系统调用号对应的系统调用名数组。</li><li>需要注意的点，a0作为返回值且a7作为系统调用号，在<em>trace</em>调用后打印信息时需要用到</li><li>trace的参数只能是(1&lt;&lt;系统调用号)每次只能检测一种系统调用(就是这么设计的)，通过掩码的方式</li><li>argint等用于提取用户地址空间的参数到内核(比如通过寄存器)</li></ul><h3 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a><strong>1.2 实现</strong></h3><p>这里贴出部分代码</p><p>kernel&#x2F;syscall.c&#x2F;syscall</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">    num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="comment">// reap return value.</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;mask)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">                p-&gt;pid, p-&gt;name, num);</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kernel&#x2F;sysproc.c&#x2F;sys_trace</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argint</span>(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)  <span class="comment">// 将a0寄存器中的值(也就是trace的第一个参数)赋给mask，argint获取的类型为int</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">myproc</span>()-&gt;mask = mask;     <span class="comment">// 每个进程都要有一个mask属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trace.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> *nargv[MAXARG];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span> || (argv[<span class="number">1</span>][<span class="number">0</span>] &lt; <span class="string">&#x27;0&#x27;</span> || argv[<span class="number">1</span>][<span class="number">0</span>] &gt; <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trace(atoi(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>) &#123;  <span class="comment">// 命令行参数是字符串形式</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123; </span><br><span class="line">    nargv[i<span class="number">-2</span>] = argv[i];</span><br><span class="line">  &#125;</span><br><span class="line">  exec(nargv[<span class="number">0</span>], nargv);  <span class="comment">// 从当前进程的上下文中加载一个程序并运行</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用样例<br>$ trace 32 grep hello README<br>3: syscall read -&gt; 1023<br>3: syscall read -&gt; 966<br>3: syscall read -&gt; 70<br>3: syscall read -&gt; 0</p></li><li><p>kernel&#x2F;proc.c&#x2F;fork。每个进程都要有一个mask属性，保证在fork子进程时也能追踪到子进程的syscall</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;mask = p-&gt;mask;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-Sysinfo"><a href="#2-Sysinfo" class="headerlink" title="2. Sysinfo"></a><strong>2. Sysinfo</strong></h2><h3 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a><strong>2.1 描述</strong></h3><blockquote><p>In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel&#x2F;sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.</p></blockquote><ul><li>类似trace系统调用将函数添加到相应文件中。</li><li>.需要参考函数<em>kernel&#x2F;sysfile.c&#x2F;sys_fstat</em>以及kernel&#x2F;file.c&#x2F;filestat中<em>copyout</em>函数的实现，即将内核数据复制到用户的虚拟地址空间。</li><li>需要在<em>kernel&#x2F;kalloc.c</em>以及<em>kernel&#x2F;proc.c</em>中添加函数，获取空闲内存的数量(字节为单位)，并获取状态为UNUSED状态的进程数，将两个函数的返回值分别赋给定义在<em>kernel&#x2F;sysinfo.h</em>中sysinfo结构体的两个属性 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sysinfo</span> &#123;</span><br><span class="line">  uint64 freemem;   <span class="comment">// amount of free memory (bytes)</span></span><br><span class="line">  uint64 nproc;     <span class="comment">// number of process</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>需要注意的是，在获取空闲内存的数量时，空闲链表的一个节点的大小为一个页的大小，遍历空闲链表即可获得结果。</li><li>该lab出现了比较少见的数组初始化方式Designated Initializers，详见<a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">此处</a></li><li><code>sysinfo(struct sysinfo*);  // 传出参数为sysinfo结构体，里面保存系统记录的信息</code></li></ul><h3 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a><strong>2.2 实现</strong></h3><p>kernel&#x2F;sysproc.c&#x2F;sys_sysinfo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint64 useraddr;               <span class="comment">// 用于保存用户sysinfo参数的虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;useraddr) &lt; <span class="number">0</span>)  <span class="comment">// argaddr获取的类型为指针(64-bit)，获取到内核</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sysinfo</span> sys;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span>* p = <span class="built_in">myproc</span>();</span><br><span class="line">    sys.nproc = <span class="built_in">procnum</span>();</span><br><span class="line">    sys.freemem = <span class="built_in">freemem</span>();</span><br><span class="line">    <span class="comment">// 将sys结构体从内核空间拷贝到用户空间useraddr，即参数sysinfo中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copyout</span>(p-&gt;pagetable, useraddr, (<span class="type">char</span>*)&amp;sys, <span class="built_in">sizeof</span>(sys)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kernel&#x2F;kalloc.c&#x2F;freemem</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">freemem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line">    uint64 n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// every node of the freelist represent a page.</span></span><br><span class="line">    <span class="keyword">for</span> (r = kmem.freelist; r; r = r-&gt;next) &#123;  <span class="comment">// 遍历空闲空间链表</span></span><br><span class="line">        n += PGSIZE;          <span class="comment">// 记录未使用的物理地址空间大小(字节)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;  <span class="comment">// 返回未使用的物理地址空间的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理内存的结构</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span>* freelist;    <span class="comment">// 空闲空间的链表</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">run</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>kernel&#x2F;proc&#x2F;procnum</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">procnum</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">    uint64 num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历PCB(进程控制块)</span></span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;  <span class="comment">// NPROC为最大进程数量，xv6中为64</span></span><br><span class="line">        <span class="comment">// xv6中有6种状态：未使用，使用，阻塞，就绪，运行，僵尸</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">        num++;     <span class="comment">// 记录除了未使用状态(i.e.没有分配内存)进程的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对lab2的学习，阅读了<em>kernel&#x2F;proc.c</em>以及<em>kernel&#x2F;proc.h</em>。通过熟悉进程的结构，从本质上理解了进程调度，进程上下文，并阅读了fork、exec等系统调用的源代码。lab2以动手实现系统调用形式，让我明白了其通过系统调用号进行索引，也了解了Designated Initializers的数组初始化形式。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab1: Xv6 and Unix utilities</title>
      <link href="/2022/05/16/s081-lab1/"/>
      <url>/2022/05/16/s081-lab1/</url>
      
        <content type="html"><![CDATA[<!-- # MIT 6.S081 Lab1: Xv6 and Unix utilities --><h2 id="1-sleep"><a href="#1-sleep" class="headerlink" title="1. sleep"></a><strong>1. sleep</strong></h2><span id="more"></span><h3 id="1-1-描述"><a href="#1-1-描述" class="headerlink" title="1.1 描述"></a><strong>1.1 描述</strong></h3><blockquote><p>Implement the UNIX program <em><strong>sleep</strong></em> for xv6; your <em><strong>sleep</strong></em> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <em><strong>user&#x2F;sleep.c</strong></em>.</p></blockquote><p>可以了解一下atoi的简单实现，参考一下user文件中的其他命令的实现。</p><h3 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a><strong>1.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep second\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">sleep</span>(i);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-pingpong"><a href="#2-pingpong" class="headerlink" title="2. pingpong"></a><strong>2. pingpong</strong></h2><h3 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a><strong>2.1 描述</strong></h3><blockquote><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file user&#x2F;pingpong.c.</pid></pid></pid></p></blockquote><p>需要熟悉fork、write、read、pipe等系统调用的使用，来实现父进程与子进程之间的通过管道的数据传输，应用在xv6中的实现的一组库函数(在user&#x2F;user.h中)来实现本例。</p><h3 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a><strong>2.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">pipe</span>(p);</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;  <span class="comment">// parent</span></span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(p[<span class="number">1</span>], buf, <span class="built_in">sizeof</span>(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// child</span></span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(p[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// error</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-primes"><a href="#3-primes" class="headerlink" title="3. primes"></a><strong>3. primes</strong></h2><h3 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a><strong>3.1 描述</strong></h3><blockquote><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user&#x2F;primes.c.</p></blockquote><p>应用埃氏筛法实现对素数的筛选，下面给出的是迭代实现，注意利用该条件终止迭代*Hint: read returns zero when the write-side of a pipe is closed.*。每次迭代创建一个管道，父进程通过将原始数据写管道，子进程在读阶段将数据中非素数筛出并保留筛出数据到缓冲区供下次传递使用，并打印数据</p><h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a><strong>3.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> buf[<span class="number">36</span>];</span><br><span class="line">  <span class="type">int</span> pid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// initialize.</span></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; ++i) &#123;</span><br><span class="line">    buf[index++] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// use the sieve function 埃氏筛法</span></span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">pipe</span>(p);  <span class="comment">// Create pipe every valid loop.</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;     <span class="comment">// child</span></span><br><span class="line">      <span class="comment">// sieve operation.</span></span><br><span class="line">      <span class="type">int</span> prime = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">      <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">read</span>(p[<span class="number">0</span>], &amp;temp, <span class="built_in">sizeof</span>(temp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// handle to sieve prime numbers.</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          prime = temp;</span><br><span class="line">          index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (temp % prime != <span class="number">0</span>) buf[index++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">      <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;  <span class="comment">// parent</span></span><br><span class="line">      <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">        <span class="built_in">write</span>(p[<span class="number">1</span>], &amp;buf[i], <span class="built_in">sizeof</span>(buf[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">wait</span>(<span class="number">0</span>);   <span class="comment">// main process is waiting all child processes to quit.</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork failure.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-find"><a href="#4-find" class="headerlink" title="4. find"></a><strong>4. find</strong></h2><h3 id="4-1-描述"><a href="#4-1-描述" class="headerlink" title="4.1 描述"></a><strong>4.1 描述</strong></h3><blockquote><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user&#x2F;find.c.</p></blockquote><p>参考<em>user&#x2F;ls.c</em>文件了解如何读取目录，其实实现是类似的，只不过find命令需要实现递归。</p><h3 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a><strong>4.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief transmit the complete filename path to the filename eradicated dir.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param path complete filename path.</span></span><br><span class="line"><span class="comment"> * @return return the filename eradicated part behind the last slash &quot;/&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">char</span>*</span></span><br><span class="line"><span class="function"><span class="title">fmtname</span><span class="params">(<span class="type">char</span>* path)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];  <span class="comment">// +1表示buf最后一个字符为字符串结束符</span></span><br><span class="line">  <span class="type">char</span>* p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从后向前遍历找到最底层的文件/目录名</span></span><br><span class="line">  <span class="keyword">for</span> (p = path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--);</span><br><span class="line">  p++;  <span class="comment">// 跳过slash指向最底层文件/目录名称的第一个字符</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对这个名称进行处理，如果大于最大的目录名称则直接返回该名称；小于则进行空字符的填充</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  <span class="comment">// 将改名称写入buf中</span></span><br><span class="line">  <span class="built_in">memmove</span>(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="comment">/* fill the white space into the rest of the DIRSIZ that</span></span><br><span class="line"><span class="comment">   * guarantee the correctness of strcmp func.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// DIRSIZ为目录名称的最大长度(14个字符)，目录名称的长度小于14那么就填充对应的&#x27; &#x27;字符，</span></span><br><span class="line">  <span class="comment">// 来保证在能够在strcmp中两个比较的目录名称都是14个字符</span></span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  buf[<span class="built_in">strlen</span>(p)] = <span class="number">0</span>;   <span class="comment">// 字符串结束符，数组下标由0开始，也就是在该名称后面加上字符串结束符</span></span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">(<span class="type">char</span>* path, <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> st;  <span class="comment">// 文件状态结构体</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;  <span class="comment">// open系统调用通过文件路径获取文件描述符</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>) &#123;   <span class="comment">// 将文件描述符对应的stat结构返回到st参数中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (st.type)  <span class="comment">// 记录文件的类型，st.type的类型为short。xv6用分别用三个宏表示文件类型，依次从1开始(T_DIR, T_FILE, T_DEVICE)</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> T_FILE:</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="built_in">fmtname</span>(path)))  <span class="comment">// 如果相等strcmp返回0</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">case</span> T_DIR: </span><br><span class="line">    <span class="comment">// 个人感觉两个+1都指的是slash占位符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path)+<span class="number">1</span>+DIRSIZ+<span class="number">1</span> &gt; <span class="built_in">sizeof</span>(buf)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* buf store the complete path and hold the buf pointer in front of it that</span></span><br><span class="line"><span class="comment">     * is convenient to print the complete path which we expect to output.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);  <span class="comment">// 将p指向buf的最后一个字符</span></span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;   <span class="comment">// i.e. *(p++) = &#x27;/&#x27;(优先级从右向左).</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de)) &#123;  <span class="comment">// 读取文件的目录结构到de结构体(实际上fstat也大概是这么实现的，注意到这两个结构体都是满足字节对齐的)</span></span><br><span class="line">      <span class="keyword">if</span> (de.inum == <span class="number">0</span>)             <span class="comment">// inum为当前目录下子目录的个数，如果为0就没必要往下找了</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">memmove</span>(p, de.name, DIRSIZ);  <span class="comment">// 将目录名称移动到p指向的区域</span></span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;                <span class="comment">// 字符串结束符</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>)) &#123;  <span class="comment">// 如果是上一级目录或者是当前目录则continue</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">find</span>(buf, name);  <span class="comment">// recursive.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find path name...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], argv[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-xargs"><a href="#5-xargs" class="headerlink" title="5. xargs"></a><strong>5. xargs</strong></h2><h3 id="5-1-描述"><a href="#5-1-描述" class="headerlink" title="5.1 描述"></a><strong>5.1 描述</strong></h3><blockquote><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user&#x2F;xargs.c.</p></blockquote><p>需要去了解linux中<a href="https://man7.org/linux/man-pages/man1/xargs.1.html">xargs</a>命令的实现，需要注意的是argv提取的是由xargs之后的参数(运行的是xargs程序)，从管道中提取数据作为xargs后面命令的参数。通过read从标准输入读数据，将其中的’\n’和’ ‘参数分隔符用字符串结束符替代，并添加在参数列表的后面，由exec系统调用执行。xargs - build and execute command lines from standard input，完成了用标准输入的内容作为xargs的参数</p><h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a><strong>5.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; MAXARG) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: arg is too much\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span>* param[MAXARG];</span><br><span class="line">  <span class="type">char</span> line[MAXLINE];  <span class="comment">// 读缓冲区</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> arg_param = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span>* cmd = argv[<span class="number">1</span>];  <span class="comment">// xargs后面跟的命令</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">    param[arg_param++] = argv[i];  <span class="comment">// xargs后的参数放在参数列表的前面随后跟着管道前的标准输入提取的参数</span></span><br><span class="line">  <span class="keyword">if</span> ((pid=fork()) &gt; <span class="number">0</span>) &#123;   <span class="comment">// parent.</span></span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;    <span class="comment">// child.</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;  <span class="comment">// 读缓冲区的索引</span></span><br><span class="line">    <span class="type">char</span>* arg = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>));  <span class="comment">// 暂存读到的参数</span></span><br><span class="line">    <span class="comment">// 从标准输入(fd为0)中(管道前执行的命令)提取行，并为每一行运行一个命令，将&quot;该行作为参数&quot;提供给xargs后的命令</span></span><br><span class="line">    <span class="keyword">while</span>((n = <span class="built_in">read</span>(<span class="number">0</span>, line, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line[i] == <span class="string">&#x27; &#x27;</span> || line[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">          arg[index] = <span class="number">0</span>;  <span class="comment">// &#x27;\0&#x27; 换为字符串结束符，方便提取</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arg);</span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          param[arg_param++] = arg;  <span class="comment">// 放入参数列表中</span></span><br><span class="line">          arg = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>));  <span class="comment">// 再初始化暂存的参数或者命令的区域</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          arg[index++] = line[i];  <span class="comment">// 继续遍历读缓冲区的护具</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">exec</span>(cmd, param);  <span class="comment">// 将每一个标准输入行中的参数提供给xargs后的命令作为参数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>通过完成lab1中xv6相应的命令函数的实现，以及相关代码的阅读，加深了了我对linux部分命令实现原理的理解，同时也熟悉了基本的系统调用函数。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.S081 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61B GITLET PROJECT</title>
      <link href="/2022/05/16/CS61B-GITLET-PROJECT/"/>
      <url>/2022/05/16/CS61B-GITLET-PROJECT/</url>
      
        <content type="html"><![CDATA[<!-- # CS61B Gitlet --><blockquote><p>简化版Git，深入探索Git的底层结构</p></blockquote><span id="more"></span><h2 id="Project-2-Getting-Started-Lab6"><a href="#Project-2-Getting-Started-Lab6" class="headerlink" title="Project 2 Getting Started(Lab6)"></a><strong>Project 2 Getting Started(Lab6)</strong></h2><h3 id="Preperation"><a href="#Preperation" class="headerlink" title="Preperation"></a><strong>Preperation</strong></h3><p>首先使用<code>git submodule update --init --recursive</code>命令将21sp的library更新，再一并复制过来。记得再当前操作系统中设置<code>REPO_DIR</code>环境变量为所有projA、HW的根目录。切记要注意看文档, 以及其中给出的设置来实现相应的功能, 最后才发现FAQ也给了非常好的提示，另外比如说在我的机器上使用<code>python</code>而不是<code>python3</code>，<code>make check</code>是跑不通的，需要找到<code>Makefile</code>的第25行, 修改为<code>PYTHON = python</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main story <span class="string">&quot;Once upon a time, there was a beautiful dog.&quot;</span></span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main story <span class="string">&quot;That dog was named Fjerf.&quot;</span></span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main story <span class="string">&quot;Fjerf loved to run and jump.&quot;</span></span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line">Fjerf loved to run and jump.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main dog Mammoth <span class="string">&quot;German Spitz&quot;</span> 10</span></span><br><span class="line">Woof! My name is Mammoth and I am a German Spitz! I am 10 years old! Woof!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main dog Qitmir Saluki 3</span> </span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 3 years old! Woof!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main birthday Qitmir</span></span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 4 years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main birthday Qitmir</span></span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 5 years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br></pre></td></tr></table></figure><p>准备开始Gitlet:</p><h2 id="Gitlet"><a href="#Gitlet" class="headerlink" title="Gitlet"></a><strong>Gitlet</strong></h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><ul><li>Git pro book</li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a><strong>Note</strong></h3><ul><li>往年课程的<a href="https://cdn-uploads.piazza.com/attach/k5eevxebzpj25b/jqr7jm9igtc7l5/k97ipfmgmb3n/Gitlet_Slides.pdf">Slide</a>很好地以图片的形式介绍了<code>Gitlet</code>中的各个命令的实现。</li><li><a href="https://paper.dropbox.com/doc/Gitlet-Persistence-zEnTGJhtUMtGr8ILYhoab">Gitlet Persistence</a></li><li><a href="https://chinese.freecodecamp.org/news/git-internals-objects-branches-create-repo/#:~:text=%E5%9C%A8%20git%20%E4%B8%AD%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84,%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E3%80%82">这里</a>有Git比较详细的图解。</li><li>仔细阅读<code>gitlet.Utils</code>中封装好的方法。</li><li>编写设计文档，<a href="https://sp21.datastructur.es/materials/proj/proj2/design.html">规格</a>和<a href="https://sp21.datastructur.es/materials/proj/proj2/capers-example">示例</a></li><li>Git的内部结构<ul><li>blob(Binary Large Object): 文件的保存内容。一个文件可能对应多个blob：每个blob在不同的<code>Commit</code>中被跟踪。</li><li>Tree: 映射文件名称(name)到blob的reference，或者是映射文件名称到其他tree(子目录)的引用。</li><li>commits: 日志消息，其他元数据(提交日期、作者等), 对树的引用和对Parent Commit的引用。<code>repository</code>还维护了分支头到提交引用的映射(以便某些重要的提交具有符号名称)</li></ul></li><li>Gitlet简化的部分<ul><li>将树合并到Commit中而不处理子目录</li><li>只能两个父级合并</li><li>元数据仅包含时间戳和日志消息，因此Commit将由<code>日志消息</code>, <code>时间戳</code>, <code>文件名</code>到<code>Blob</code>引用的映射，<code>父引用</code>, (用于Merge的)<code>第二个父引用</code>来组成。</li></ul></li><li>每个blob和每个commit都有一个唯一的整数id，用作该对象的<strong>引用</strong>。</li><li>当使用SHA-1哈希一个Commit时，会包括所有的数据和引用。</li><li>区分<code>Commit</code>和<code>Blob</code>的哈希值，一种方法是可以在两个类中各自定义一个属性字段来实现。</li><li>不应该在Main中做完所有事情，而是将需要实现的内容封装成一个函数到<code>Repository</code>类中去。</li><li>序列化最好使用<code>TreeMap</code>而不是<code>HashMap</code>。</li><li><code>Gitlet</code>不会出现<code>deteched head</code>(分离头部)的状态。指的是当前<code>HEAD</code>指向的Commit不表示任何一个分支。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul><li>在<code>terminal</code>下出现了<code>Esc</code>无法退出<code>insert mode</code>而且还进入了<code>Itellij</code>的编辑界面。解决方案看<a href="https://www.jianshu.com/p/f1ae155cda6e">此处</a></li><li>暂存区包含两个区域, <code>stage for addition</code>和<code>stage for removal</code>。</li><li><code>gitlet</code>中一条命令对应运行一次程序，因此需要将用到的数据结构序列化为字节流后保存到文件中。</li><li>在实验一开始给的<code>Utils</code>类中， 不需要使用<code>createNewFile()</code>来创建文件, 因为<code>writeObject()</code>中会调用<code>WriteContent()</code>，若文件不存在则会自动创建，或者文件存在则覆盖掉它。</li><li>注意要在当前目录下执行<code>make check</code>，测试文件可能跑通(可能需要操作src&#x2F;目录中的文件)。</li><li>注意每次更新数据时都需要序列化对象和反序列化文件, 保证更新的数据能够及时存储到文件中。</li><li>也需要将<code>blobs</code>的映射集合序列化存储起来(同样用TreeMap)，<code>checkout</code>命令要使用(用SHA-ID(文件名+文件内容)来作为文件名)。在<code>add</code>命令将blob和文件名映射放入<code>stage for addition</code>的同时，将blob和文件内容的映射放入<code>blobs</code>集合。</li><li><code>blob</code>生成<code>blobId</code>(sha-1 id)的时候，需要通过<code>文件名+文件内容(字节流)</code>生成。若只用文件内容生成<code>blobId</code>，不同名的两个文件内容都为空时，生成的<code>blobId</code>是一致的, 使用<code>文件名+文件对象</code>生成的sha-1哈希也是同样的结果。</li><li><code>mkdirs()</code>方法可以一同创建之前未存在的父目录。</li><li>注意写文件内容时用<code>writeContent()</code>而不是<code>writeObject()</code>。注意到<code>writeObject</code>会在调用<code>writeContent</code>前将第二个参数先序列化, 若将字节数组再序列化，可能会在内容中写入额外的信息。</li><li><code>Untracked file</code>，既没有被当前<code>commit</code>跟踪，也没有被放到<code>stage area</code>里。或者是已经被<code>stage for removal</code>但是又重新创建了。(考虑到我这里rm情况下没有将其从暂存区删除，仅仅是将它从<code>stage for removal</code>删除了而已)。</li><li>保证分支头只有一个, <code>get(0)</code>可以直接取(这里我将分支做所处的位置做成了一个目录，目录中是用分支名来命名的文件, 方便直接取头Commit)。</li><li>暂存区使用<code>blobId</code>映射<code>文件对象</code>不可取(序列化后提取的文件内容还是的却决于当前工作目录下的内容，不符合预期)，试试映射文件内容(字符串readContentsAsString)。经过调试发现必须得映射字节流，因为前面生成blobId中需要<code>文件名+文件内容(字节流)</code>。</li><li>注意<code>Utils</code>中的<code>restrictedDelete()</code>方法，是如果文件存在则删除, 如果文件对象不存在则删除未成功返回false, 给我们实现<code>rm</code>指令来删除当前工作目录中的文件提供了一个很好的帮助。</li><li>需要在每次<code>commit</code>命令执行时都更新分支头目录中的数据以及其对应<code>branches</code>目录中的数据。</li><li>除了<code>init</code>之外剩下的命令在处理之前都需要检测当前<code>.gitlet</code>目录是否存在, 若不存在则输出报错信息。</li><li>在开始项目任何一个功能前一定要有一个<code>Big picture</code>和整体思路，确保在实现过程中能够顺利进行。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h3><ul><li>查看<code>tester.py</code>文档中一些相应的操作来对应测试文件。测试文件可以从<code>AG</code>中获取。</li></ul><h3 id="init"><a href="#init" class="headerlink" title="init"></a><strong>init</strong></h3><ul><li>创建<code>.gitlet</code>目录，并在其中新建一些文件来存储序列化信息。</li><li><code>init</code>会自动创建一个包含initial commit信息的<code>Commit</code>开始</li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a><strong>add</strong></h3><ul><li>暂存已经暂存过的文件，会用新内容来覆盖先前的内容。</li><li>若当前需要暂存的文件与Commit跟踪的文件版本一致(包括其修改之后又还原内容的文件，blobId都是一致的)，则不对它进行处理。</li><li>若当前添加文件在<code>Stage for removal</code>中，则将它从里面删除。</li><li>gitlet一次只能添加一个文件。</li><li>维护一个<code>TreeMap</code>来存放<code>stage for addition</code>文件。</li></ul><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a><strong>commit</strong></h3><ul><li>需要考虑在当前跟踪的文件可能在新的Commit中未被跟踪，与rm指令将文件<code>Stage for removal</code>相关。</li><li>当前Commit跟踪的blob需要加上其父Commit跟踪的blob(前提是父Commit中跟踪的blob未被当前Commit跟踪的文件覆盖过)。</li><li><code>commmit</code>后将<code>stage area</code>清空，也就是<code>stage for add</code>和<code>stage for removal</code>。</li><li>若没有文件被暂存，或没有提交信息则中止。</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><strong>rm</strong></h3><ul><li>若当前文件正在<code>stage for addition</code>，则将它从里面移除。</li><li>若文件在当前<code>Commit</code>中被跟踪，则将其放入<code>stage for removal</code>暂存区中, 同时将本地目录文件删除。</li><li>只考虑被当前Commit跟踪的情况下</li><li>维护一个<code>TreeMap</code>来存放<code>stage for removal</code>文件。</li></ul><h3 id="log"><a href="#log" class="headerlink" title="log"></a><strong>log</strong></h3><ul><li>注意显示的是太平洋标准时间而不是UTC。</li><li>当前操作系统显示时间得调成英文显示，否则打印log会出现中文字样</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a><strong>find</strong></h3><ul><li>通过<code>Utils</code>类中给的方法<code>plainFilenamesIn</code>, 直接遍历<code>commit Id</code>所处的目录，若出现<code>commit</code>对象不同但提交信息一致的打印情况，分行打印各自的<code>commit id</code>。</li></ul><h3 id="status"><a href="#status" class="headerlink" title="status"></a><strong>status</strong></h3><ul><li><code>TreeMap</code>数据结构会按照字典序来排序。</li><li><code>Untrack file</code>，既未跟踪也未暂存。未跟踪将当前目录下的文件名和当前最新Commit中track的文件名做对比。若未包含则说明未跟踪。同样包括已经准备删除但又重新创建的文件(说明其还在<code>stage for removal</code>里，因为<code>stage area</code>只在commit时删除)。思考该该怎么标记? rm之后add的文件?</li><li><code>modified</code>, 同样与Commit中track对比，若文件名相同，但BlobId不同则说明被修改过。</li><li>遍历当前跟踪的文件，使用<code>exist</code>判断文件对象是否存在以及是否存在于<code>stage for removal</code>，就能判断文件是否被<code>delete</code>。</li></ul><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a><strong>checkout</strong></h3><ul><li>有三类<code>checkuout</code>:<ul><li>java gitlet.Main checkout – [file name]</li><li>java gitlet.Main checkout [commit id] – [file name]</li><li>java gitlet.Main checkout [branch name]</li></ul></li><li>若<code>checkout</code>切换分支，且当前目录下文件有文件未被跟踪，则打印提示信息并退出。</li><li>注意切换完成，将新分支放入<code>heads</code>目录的同时，从<code>heads</code>目录中删除先前的分支。</li><li><code>checkout filename</code>将当前文件从<code>head commit</code>中拿到当前工作目录。</li><li>切换到另一个分支要将暂存区清空。要将当前commit中跟踪了但切换到的分支commit中没有跟踪的文件删除(如果有则覆盖)。</li><li>考虑两种情况:<ul><li><code>checkout</code>的目标分支跟踪的文件比当前目录的文件多，直接写就行了</li><li><code>checkout</code>的目标分支跟踪的文件比当前目录的文件少，需要删除本地目录中多余的文件</li><li>这两中情况都需要遍历当前目录中的所有文件名来确定。</li></ul></li><li>一个<strong>错误的策略</strong>是切换之前先将当前当前文件下所有的都删除，然后再将切换到的分支commit跟踪的文件写进CWD当前工作目录, 在后续将跟踪文件写入当前工作目录时，取不到文件对象了。</li><li><code>checkout branchName</code>时需要将暂存区清空。</li><li>后面还有一个<code>checkout shortid</code>的测试，需要包括通过commitid的前8就能切换到不同的分支。和commitId一样序列化到磁盘上的文件就行。</li><li>gitlet<strong>不允许</strong>删除提交。</li></ul><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a><strong>reset</strong></h3><ul><li>神似<code>checkout branchName</code>, 只是最后是将<code>当前branch</code>回退而不是切换分支。</li></ul><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a><strong>branch</strong></h3><ul><li>只新建一个分支(即在branches目录中新建一个序列化的分支Commit文件), 但是并未切换到新建的分支。</li></ul><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a><strong>merge</strong></h3><ul><li>将给定分支名为branchName的文件合并到当前分支中。</li><li>如何找到<code>split point</code>? 考虑到gitlet只支持两个分支合并，因此可以把新建分支的commit作为split point?! hhh笑死ucb学生视频里第一个提问和我想得一模一样。我感觉这种方法在gitlet中可行，但在多分支合并时就不行了。还是得去过一遍图的遍历这一节的slide。</li><li><strong>Latest common ancestor</strong>其实指的也就是<code>split point</code>。</li><li>如果给定分支是<code>split point</code>则不做任何处理。</li><li>无论是否发生冲突，<code>merge</code>结束后新建一个<code>Commit</code>。</li><li>如果当前分支是<code>split point</code>, 则<strong>切换</strong>到给定分支。</li><li>发生冲突且修改的内容不同只写当前分支的冲突文件。</li><li>需要复用<code>add</code>和<code>rm</code>以及<code>commit</code>命令。</li><li>git提交后的分布可以看作是个<code>direct graph</code>。</li><li>可以通过将从<code>init commit</code>到当前分支经过的commit放到一个list中，同时将要给定分支的路径也放到一个set中，再通过按指定顺序遍历(由当前分支开始)当前分支的list，使用<code>contains</code>方法来确定遍历经过的commit是否在分支路径的set中。需要使用BFS来遍历。</li><li>之前的策略是在切换分支(checkout, reset)时才将branches目录中的当前分支信息更新，这在这一步中获取当前分支对象是危险的，因此需要调整策略，在每一次commit更新HEAD目录时和reset时，都更新Branches中当前分支信息。这样就能保证当前分支在Head目录和Branches目录中的信息是同步一致的了。</li><li>注意Java中<code>null</code>在字符串比较时不能用<code>equals()</code>来比较。</li><li>别忘了改写冲突文件时需要生成新的<code>blobId</code>放入暂存区中在新的合并Commit中加入当前目录。</li></ul><h4 id="处理case"><a href="#处理case" class="headerlink" title="处理case"></a><strong>处理case</strong></h4><ul><li><img src="https://pic4.zhimg.com/80/v2-5b2470a6def367603e617ea9c709c231.png" alt="Image"></li><li>想到了一个比较情况的好方法，将当前分支，给定分支以及split point三个集合中含有的文件名的并集放到集合里。比较时需要各个集合的BlobId和文件名的映射，以及BlobId和content的映射。</li><li>由两个值来区分所有情况分别是<code>isPresent</code>和<code>IsModified</code>。</li><li><code>Modifed</code>只需要通过当前分支分支或给定分支， 与<code>split point blobId</code>比较来区分就行了, 程序里我将不存在的文件的blobId赋值为空串。</li><li>当前分支和给定分支都modifed也就是case3还需要细分发生冲突，还是不发生冲突。直接通过比较当前分支和给定分支<code>commit Id</code>即可。</li><li><code>git pro</code>中的原话, 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。这点与Gitlet还是不同的。</li><li>发生冲突的内容差异会自动写入冲突文件(按合理性来说只需要写入当前分支头即可)如, 需要解决冲突后，需要打印提示信息，合并的提交跟踪冲突文件:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">contents of file in current branch</span><br><span class="line">=======</span><br><span class="line">contents of file in given branch</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li>处理好每个情况后将每个文件对应的result添加到暂存区等待新的Commit。result的内容为当前分支的内容也需要<code>stage for addition</code>, 但不需要放入<code>blobs</code>集合中。</li><li><code>getBytes</code>方法可以将字符串转化为字节数组(byte[])。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-de14f3c3a0f560d423afde1fdd05300b.png" alt="Image"></p>]]></content>
      
      
      <categories>
          
          <category> CS61B </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61C CPU PROJECT</title>
      <link href="/2022/05/16/CS61C-CPU-PROJECT/"/>
      <url>/2022/05/16/CS61C-CPU-PROJECT/</url>
      
        <content type="html"><![CDATA[<!-- # **CS61C CPU PROJECT** --><blockquote><p>用时4天，体验CPU设计</p></blockquote><span id="more"></span><h2 id="关于如何Debug"><a href="#关于如何Debug" class="headerlink" title="关于如何Debug"></a><strong>关于如何Debug</strong></h2><p>相信前面的<code>lab5</code>和<code>lab6</code>已经奠定好了使用<code>logisim</code>的基础，前面相关内容同样奠定好了RISC-V ISA的知识基础。接下来Project中的一系列的task可以通过参考:</p><ul><li><code>61C Reference card</code></li><li><code>ROM</code>表</li><li>对应测试文件中的汇编代码和测试电路</li><li>通过<code>change value</code>来对电路中的bit位进行赋值，查看输入输出的值</li></ul><p>需要将所有这些结合起来构建完整的<code>big picture</code>。</p><h2 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a><strong>ALU</strong></h2><p>根据文档中给的功能类别通过门级电路来构造基本的ALU原件，个别功能的实现所用到的元器件还需要查看手册。<br><img src="https://pic4.zhimg.com/80/v2-014bf51c0d29af49c1b904c3cb4a28e2.png" alt="ALU"></p><h2 id="RegFile"><a href="#RegFile" class="headerlink" title="RegFile"></a><strong>RegFile</strong></h2><p>需要用到<code>Multiplexer</code>和<code>Demultiplexer</code>，以及一些基本的逻辑，比较废鼠标…<br><img src="https://pic4.zhimg.com/80/v2-2bc53f743fb481fc3a22f8c141f95071.png" alt="Regfile"></p><h2 id="Immediate-Generator"><a href="#Immediate-Generator" class="headerlink" title="Immediate Generator"></a><strong>Immediate Generator</strong></h2><p>这一部分跟着61C绿卡里的指令编码表。以下显示的是所有含有imm部分的指令的实现。<br><img src="https://pic4.zhimg.com/80/v2-f46d246882abfdf6f28e13266e41c363.png" alt="Imm-gen"></p><h2 id="Control-Store-Implemented-by-ROM"><a href="#Control-Store-Implemented-by-ROM" class="headerlink" title="Control Store(Implemented by ROM)"></a><strong>Control Store(Implemented by ROM)</strong></h2><p>通过分析绿卡上或者是文档里给的指令的功能，来初始化每条指令对应的微指令，需要结合数据通路中每个部分的实现以及PartA中我们已经构建好的ALU。Immsel以及个别控制信号可以自行设计(后面会有介绍修改<code>.csv</code>文件即可, 我这边是修改过后的)，建议PartB部分一开始就完善ROM表。<br>下面给出我的数据:<br><img src="https://pic4.zhimg.com/80/v2-3ffb5bc0653de42a33fba13bf38a868d.png" alt="ROM"></p><p>完善ROM表后，将<code>ROM Output</code>复制到控制逻辑的ROM中。需要在控制逻辑电路中根据指令编码中的<code>opcode</code>, <code>fun3</code>, <code>fun7</code>字段来区分每个类型，甚至每条指令，再通过优先级别编码器来索引控存中的微指令, 产生对应的控制信号。<br><img src="https://pic4.zhimg.com/80/v2-00828871fd39660bf6ddaf8a32ab38fa.png" alt="Control"><br><img src="https://pic4.zhimg.com/80/v2-ee25b2c060400847e6cf55d220704422.png" alt="Control"><br>因为优先级别编码器最多只能支持32bit, 但我们的指令有36条, 需拆拆分成两部分输入。剩下四条指令可以通过指令编码格式来各自区分，然后再找到指令编码格式中与前32条指令相异的bit作为控制信号来控制二选一MUX。<img src="https://pic4.zhimg.com/80/v2-4c10eb6557e75cdd3866bd188e5868ff.png" alt="Control"></p><h2 id="Branch-and-Jump-Instruction"><a href="#Branch-and-Jump-Instruction" class="headerlink" title="Branch and Jump Instruction"></a><strong>Branch and Jump Instruction</strong></h2><p>通过<code>BrUn</code>信号来实现分支比较器产生对应<code>BrEq</code>和<code>BrLt</code>的控制信号决定分支是否发生跳转。<br><img src="https://pic4.zhimg.com/80/v2-b4917e6611d7a6b8aa66d86f9d1362b5.png" alt="Branch Comp"></p><p>B类指令和J类指令产生<code>PCsel</code>控制信号来决定是否修改<code>PC</code>, 同样也通过指令编码格式中的bit来区分jump发生还是branch发生<br><img src="https://pic4.zhimg.com/80/v2-941f7fe17956fab75c7e74b1afa5fb17.png" alt="Control"></p><h2 id="Loading-and-Storing"><a href="#Loading-and-Storing" class="headerlink" title="Loading and Storing"></a><strong>Loading and Storing</strong></h2><p>这部分需要细心一些，部分load和部分store无论是字节还是半字都要<strong>符号位拓展</strong>成字的大小。部分load相对部分store来说比较简单，因为部分load只需要考虑从存储器中读出来的数据位置不同即可，而部分store不仅需要将从寄存器中读来的数据分割，还需要将分割的数据存到对应存储器中字的偏移位置(这部分是由Mask来确定写入的位置的)。需要通过低两位来判断具体load的是当前字的哪一个部分。</p><h3 id="Partial-Load"><a href="#Partial-Load" class="headerlink" title="Partial Load"></a><strong>Partial Load</strong></h3><p>如果不是取一个字的数据，则要根据当前指令lw来访问存储器的地址字段的低两位来产生控制信号，决定取当前数据字的哪一个部分的数据到寄存器中(通过splitter来划分)。由指令编码中的bit来作为控制信号区分，选择具体是<code>lw</code>还是<code>lh</code>, <code>lb</code>。<br><img src="https://pic4.zhimg.com/80/v2-723ccb2b6671606fe4a6ac5b0cbf58c9.png"></p><h3 id="Partial-Store"><a href="#Partial-Store" class="headerlink" title="Partial Store"></a><strong>Partial Store</strong></h3><p>同样有指令编码格式来区分三种类型的store指令决定store到存储器中的数据。MemWriteMask有四个二进制bit组成，分别表示store到存储器中数据的位置, 实验中并未提到mask实现的细节。但是需要完成有指令编码和访问存储器的地址来生成mask。生成的mask需要通过指令编码格式中的bit和地址字段的低两位来区分, 额外在利用上优先级别编码器来索引。 生成的mask有<code>lb</code>的0001, 0010, 0100, 1000, 和<code>lh</code>的0011, 1100以及<code>lw</code>的1111, 七种组合。<br><img src="https://pic4.zhimg.com/80/v2-1b3b6bfa9c35647d8b7df3225a1e2a6f.png"></p><h2 id="Datapath"><a href="#Datapath" class="headerlink" title="Datapath"></a><strong>Datapath</strong></h2><p>下面是流水过后的数据通路, 两级流水线挺好实现的，看了一下不需要考虑<code>Structure Hazards</code>以及<code>Data Hazards</code>，省去了很多数据通路上的麻烦。需要考虑的只有<code>Control Hazards</code>。当Branch或者Jump发生时，紧随其后进入流水线的只有一条指令，实验文档里解决的方案是插入一条NOP指令来防止冲突。什么时候插入NOP指令根据<code>PCsel</code>控制信号来决定即可。同时注意两个不同stage之间的差异(导致后面利用到PC的指令执行结果不正确)，需要通过在两个stage之间加流水线寄存器来存储一个时钟周期之内的信息(包括指令和PC值)。<br><img src="https://pic4.zhimg.com/80/v2-55adeda8be6c453ab203579651619b65.png" alt="Datapath"></p><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a><strong>参考书目</strong></h2><ul><li>Introduction to Computing Systems: From Bits &amp; Gates to C &amp; Beyond [3ed.]</li><li>P&amp;H [RISC-V 2ed.]</li><li>CAAQA [6ed.]</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS61C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP: Bomb Lab</title>
      <link href="/2022/05/16/CSAPP-Lab2-Bomb-Lab/"/>
      <url>/2022/05/16/CSAPP-Lab2-Bomb-Lab/</url>
      
        <content type="html"><![CDATA[<!-- # CSAPP: Bomb Lab --><blockquote><p>熟悉GDB</p></blockquote><span id="more"></span><h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a><strong>Preparation</strong></h2><p>建议在实验大致看一下lab相关的<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f20/www/recitations/f20New/recitation02-bomblab.pdf">pdf</a>。使用<code>man</code>手册来查看库函数，<code>callq … &lt;_exit@plt&gt;</code>类型为C的库函数。注意商用的architecture是以字节为单位编址寻址。</p><p>参考CS61C所了解到的Tool, 做足了准备工作。安装<code>CGDB</code>, 相比较于<code>GDB</code>的<code>tui</code>在调试lab时显示不会出现乱码的情况。从<code>ubuntu</code>中<code>apt-get</code>下载到的版本较低，一些功能不适用。参考<a href="https://cgdb.github.io/">CGDB官网</a>下载最新版本的<code>CGDB</code>, 简单浏览了一下<a href="https://cgdb.github.io/docs/cgdb.pdf">CGDB官方手册</a>, 以及对应<code>CGDB</code>在<code>~/.cgdb/cgdbrc</code>文件中做了如下的配置足以满足调试需求:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set disasm</span><br><span class="line">:set hls</span><br><span class="line">:set syn=style</span><br></pre></td></tr></table></figure><p>另外gdb相关内容再推荐这两本书籍<br><code>Debugs Hacks</code>和<code>Debugging with GDB</code>。</p><p>需要用<code>chmod</code>命令修改一下<code>bomb</code>二进制文件的可执行权限</p><p>接下来可以愉快地开始<code>bomb lab</code>了~</p><p>运行<code>cgdb</code>且在对应phase打上断点后可以用一个放入输入信息的文本文件标准输入重定向到传递给主函数的参数中，这样就可以避免卡死在读取输入的systemcall上。更多关于<a href="https://stackoverflow.com/questions/19467865/how-to-use-redirection-in-c-for-file-input">重定向</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)run &lt; in</span><br></pre></td></tr></table></figure><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a><strong>Phase_1</strong></h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp                   # 开辟栈帧保存返回地址和写在文件中的字符串函数参数<span class="built_in">edi</span></span><br><span class="line">  400ee4:be <span class="number">00</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x402400,%esi</span><br><span class="line">  400ee9:e8 4a <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">401338</span> &lt;strings_not_equal&gt;  # <span class="built_in">edi</span>接着传给strings_not_equal</span><br><span class="line">  400eee:<span class="number">85</span> c0                <span class="keyword">test</span>   %eax,%eax                   # 若字符串相等，即函数返回<span class="number">0</span>，则Defuse炸弹</span><br><span class="line">  400ef0:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     400ef7 &lt;phase_1+<span class="number">0x17</span>&gt;</span><br><span class="line">  400ef2:e8 <span class="number">43</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          <span class="keyword">add</span>    <span class="number">$0</span>x8,%rsp                   # 函数调用结束栈顶指针复原</span><br><span class="line">  400efb:c3                   retq </span><br></pre></td></tr></table></figure><p>分析一下<code>strings_not_equal</code>，判断两个字符串是否相等。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000401338</span> &lt;strings_not_equal&gt;:</span><br><span class="line">  <span class="number">401338</span>:<span class="number">41</span> <span class="number">54</span>                <span class="keyword">push</span>   %r12                             # callee save</span><br><span class="line">  40133a:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp</span><br><span class="line">  40133b:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line">  40133c:<span class="number">48</span> <span class="number">89</span> fb             <span class="keyword">mov</span>    %rdi,%rbx                        # 将两个参数放入local中, 防止后续操作被覆盖</span><br><span class="line">  40133f:<span class="number">48</span> <span class="number">89</span> f5             <span class="keyword">mov</span>    %rsi,%rbp</span><br><span class="line">  <span class="number">401342</span>:e8 d4 ff ff ff       callq  40131b &lt;string_length&gt;           # 第一个参数<span class="built_in">rdi</span>传递给函数返回第一个字符串长度到<span class="built_in">eax</span>中</span><br><span class="line">  <span class="number">401347</span>:<span class="number">41</span> <span class="number">89</span> c4             <span class="keyword">mov</span>    %eax,%r12d</span><br><span class="line">  40134a:<span class="number">48</span> <span class="number">89</span> ef             <span class="keyword">mov</span>    %rbp,%rdi                        # 将当前函数的第二个参数传递给<span class="built_in">rdi</span></span><br><span class="line">  <span class="number">40134d</span>:e8 c9 ff ff ff       callq  40131b &lt;string_length&gt;           # 返回第二个字符串参数的长度</span><br><span class="line">  <span class="number">401352</span>:ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%edx</span><br><span class="line">  <span class="number">401357</span>:<span class="number">41</span> <span class="number">39</span> c4             <span class="keyword">cmp</span>    %eax,%r12d                       # 两个参数的长度比较</span><br><span class="line">  40135a:<span class="number">75</span> 3f                <span class="keyword">jne</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;  # 字符串不相等则到转到restore并返回<span class="built_in">edx</span>中保存的<span class="number">1</span></span><br><span class="line">  40135c:0f b6 <span class="number">03</span>             movzbl (%rbx),%eax                      # 零拓展避免<span class="built_in">eax</span>高位出现杂乱数据, 字符为8bit，将其高位清<span class="number">0</span></span><br><span class="line">  40135f:<span class="number">84</span> c0                <span class="keyword">test</span>   %al,%al                          # 检测第一个参数是否遍历到terminator, 这种形式让<span class="built_in">al</span>与<span class="number">0</span>比较</span><br><span class="line">  <span class="number">401361</span>:<span class="number">74</span> <span class="number">25</span>                <span class="keyword">je</span>     <span class="number">401388</span> &lt;strings_not_equal+<span class="number">0x50</span>&gt;</span><br><span class="line">  <span class="number">401363</span>:3a <span class="number">45</span> <span class="number">00</span>             <span class="keyword">cmp</span>    <span class="number">0x0</span>(%rbp),%al</span><br><span class="line">  <span class="number">401366</span>:<span class="number">74</span> 0a                <span class="keyword">je</span>     <span class="number">401372</span> &lt;strings_not_equal+<span class="number">0x3a</span>&gt;</span><br><span class="line">  <span class="number">401368</span>:eb <span class="number">25</span>                <span class="keyword">jmp</span>    40138f &lt;strings_not_equal+<span class="number">0x57</span>&gt;</span><br><span class="line">  40136a:3a <span class="number">45</span> <span class="number">00</span>             <span class="keyword">cmp</span>    <span class="number">0x0</span>(%rbp),%al</span><br><span class="line">  <span class="number">40136d</span>:0f 1f <span class="number">00</span>             nopl   (%rax)</span><br><span class="line">  <span class="number">401370</span>:<span class="number">75</span> <span class="number">24</span>                <span class="keyword">jne</span>    <span class="number">401396</span> &lt;strings_not_equal+<span class="number">0x5e</span>&gt;</span><br><span class="line">  <span class="number">401372</span>:<span class="number">48</span> <span class="number">83</span> c3 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%rbx                        # 移动读取两个字符串参数中的字符</span><br><span class="line">  <span class="number">401376</span>:<span class="number">48</span> <span class="number">83</span> c5 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%rbp</span><br><span class="line">  40137a:0f b6 <span class="number">03</span>             movzbl (%rbx),%eax</span><br><span class="line">  <span class="number">40137d</span>:<span class="number">84</span> c0                <span class="keyword">test</span>   %al,%al                          # 检测第二个参数是否遍历到terminator</span><br><span class="line">  40137f:<span class="number">75</span> e9                <span class="keyword">jne</span>    40136a &lt;strings_not_equal+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">401381</span>:ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%edx                        # 两参数字符串相等，返回<span class="number">0</span></span><br><span class="line">  <span class="number">401386</span>:eb <span class="number">13</span>                <span class="keyword">jmp</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">401388</span>:ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%edx</span><br><span class="line">  <span class="number">40138d</span>:eb 0c                <span class="keyword">jmp</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  40138f:ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%edx</span><br><span class="line">  <span class="number">401394</span>:eb <span class="number">05</span>                <span class="keyword">jmp</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">401396</span>:ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%edx</span><br><span class="line">  40139b:<span class="number">89</span> d0                <span class="keyword">mov</span>    %edx,%eax                        # <span class="built_in">eax</span>作为返回值</span><br><span class="line">  <span class="number">40139d</span>:5b                   <span class="keyword">pop</span>    %rbx                             # restore</span><br><span class="line">  40139e:<span class="number">5d</span>                   <span class="keyword">pop</span>    %rbp</span><br><span class="line">  40139f:<span class="number">41</span> 5c                <span class="keyword">pop</span>    %r12</span><br><span class="line">  4013a1:c3                   retq </span><br></pre></td></tr></table></figure><p>观察<code>phase_1</code>函数，需要进入函数<code>string_not_equal</code>，并通过该函数的返回结果来决定是否引爆炸弹。进入该函数后，可以发现在函数中比较的是<code>rdi</code>和<code>rsi</code>两个字符串参数。<code>rdi</code>是标准输入中输入的字符串。<code>string_length</code>的返回值保存在寄存器<code>eax</code>中为两字符串的长度。长度不相等即表示字符串肯定不相等，则返回寄存器<code>edx</code>中的1。初步可以判断<code>phase_1</code>要求比较的两个字符串要相等才能<code>defuse</code>。再仔细观察<code>phase_1</code>函数中<code>test %eax, %eax</code>测试寄存器<code>eax</code><strong>非0</strong>则跳转到<code>bomb</code>。因此要想不爆炸必须得保证存在于<code>($rdi)</code>, <code>($rsi)</code>中的两个字符串相等，即<code>strings_not_equal</code>的返回值为<strong>0</strong>。</p><p>用<code>x/s</code>查看对应<code>memory</code>中地址单元的的字符串内容, 使标准输入参数<code>rdi</code>等于下述字符串即可<code>defuse</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure><p>经分析答案为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a><strong>Phase_2</strong></h2><p><code>x86</code>ISA规定，当参数超过6个的时候就会使用栈来保存参数。<code>print (char*) 0x4025c3</code>打印由地址0x4025c3起始的字符串，显示的结果可以发现字符串为<code>&quot;%d %d %d %d %d %d&quot;</code>格式串。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp                       # callee save</span><br><span class="line">  400efd:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line">  400efe:<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x28,%rsp                 # <span class="built_in">rdi</span>为标准输入字符串的地址</span><br><span class="line">  400f02:<span class="number">48</span> <span class="number">89</span> e6             <span class="keyword">mov</span>    %rsp,%rsi                  # <span class="built_in">rsp</span>作为函数read_six_numbers的第二个参数, caller save</span><br><span class="line">  400f05:e8 <span class="number">52</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40145c &lt;read_six_numbers&gt;  # 函数读取六个数字到栈空间上。</span><br><span class="line">  400f0a:<span class="number">83</span> 3c <span class="number">24</span> <span class="number">01</span>          cmpl   <span class="number">$0</span>x1,(%rsp)                # 取第一个数字</span><br><span class="line">  400f0e:<span class="number">74</span> <span class="number">20</span>                <span class="keyword">je</span>     400f30 &lt;phase_2+<span class="number">0x34</span>&gt;</span><br><span class="line">  400f10:e8 <span class="number">25</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:eb <span class="number">19</span>                <span class="keyword">jmp</span>    400f30 &lt;phase_2+<span class="number">0x34</span>&gt;</span><br><span class="line">  400f17:8b <span class="number">43</span> fc             <span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbx),%eax           # 取接下来的数字</span><br><span class="line">  400f1a:<span class="number">01</span> c0                <span class="keyword">add</span>    %eax,%eax                 # double</span><br><span class="line">  400f1c:<span class="number">39</span> <span class="number">03</span>                <span class="keyword">cmp</span>    %eax,(%rbx)</span><br><span class="line">  400f1e:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     400f25 &lt;phase_2+<span class="number">0x29</span>&gt;     # 下一个参数的值需要为上一个参数值的两倍才能确保不发生爆炸</span><br><span class="line">  400f20:e8 <span class="number">15</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:<span class="number">48</span> <span class="number">83</span> c3 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%rbx</span><br><span class="line">  400f29:<span class="number">48</span> <span class="number">39</span> eb             <span class="keyword">cmp</span>    %rbp,%rbx                 # 若读到第六个数字，则将局部变量所使用的寄存器restore到原来的值, <span class="keyword">pop</span>栈指针复原到调用前的位置, 否则继续<span class="keyword">loop</span></span><br><span class="line">  400f2c:<span class="number">75</span> e9                <span class="keyword">jne</span>    400f17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line">  400f2e:eb 0c                <span class="keyword">jmp</span>    400f3c &lt;phase_2+<span class="number">0x40</span>&gt;</span><br><span class="line">  400f30:<span class="number">48</span> <span class="number">8d</span> 5c <span class="number">24</span> <span class="number">04</span>       <span class="keyword">lea</span>    <span class="number">0x4</span>(%rsp),%rbx</span><br><span class="line">  400f35:<span class="number">48</span> <span class="number">8d</span> 6c <span class="number">24</span> <span class="number">18</span>       <span class="keyword">lea</span>    <span class="number">0x18</span>(%rsp),%rbp           # <span class="built_in">rsp</span>~<span class="built_in">rsp</span>-<span class="number">0x10</span>这部分为函数的返回地址和局部变量以及所用的栈空间</span><br><span class="line">  400f3a:eb <span class="built_in">db</span>                <span class="keyword">jmp</span>    400f17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line">  400f3c:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          <span class="keyword">add</span>    <span class="number">$0</span>x28,%rsp</span><br><span class="line">  400f40:5b                   <span class="keyword">pop</span>    %rbx</span><br><span class="line">  400f41:<span class="number">5d</span>                   <span class="keyword">pop</span>    %rbp</span><br><span class="line">  400f42:c3                   retq   </span><br></pre></td></tr></table></figure><p><code>read_six_numbers</code>中会调用C库函数<code>sscanf</code>，<code>man</code>手册中返回值的描述，返回输入数字匹配的个数。</p><blockquote><p>On success, these functions return the number of input items  success‐<br>fully  matched  and  assigned; this can be fewer than provided for, or<br>even zero, in the event of an early matching failure.</p></blockquote><p>注意<code>x86</code>栈帧由低地址到高地址，先是返回地址，再到局部变量，再到save register。第1个参数在栈帧低地址 立即数为<code>32bit</code>, 按字节变址寻址, 函数参数为<code>caller save</code>。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp                    # 开辟栈帧, <span class="built_in">rdi</span>为第一个参数</span><br><span class="line">  <span class="number">401460</span>:<span class="number">48</span> <span class="number">89</span> f2             <span class="keyword">mov</span>    %rsi,%rdx                     # 第<span class="number">3</span>个参数</span><br><span class="line">  <span class="number">401463</span>:<span class="number">48</span> <span class="number">8d</span> 4e <span class="number">04</span>          <span class="keyword">lea</span>    <span class="number">0x4</span>(%rsi),%rcx                # 第<span class="number">4</span>个参数</span><br><span class="line">  <span class="number">401467</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">46</span> <span class="number">14</span>          <span class="keyword">lea</span>    <span class="number">0x14</span>(%rsi),%rax               # 第<span class="number">8</span>个参数</span><br><span class="line">  40146b:<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>       <span class="keyword">mov</span>    %rax,<span class="number">0x8</span>(%rsp)</span><br><span class="line">  <span class="number">401470</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">46</span> <span class="number">10</span>          <span class="keyword">lea</span>    <span class="number">0x10</span>(%rsi),%rax               # 第<span class="number">7</span>个参数</span><br><span class="line">  <span class="number">401474</span>:<span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>          <span class="keyword">mov</span>    %rax,(%rsp)</span><br><span class="line">  <span class="number">401478</span>:4c <span class="number">8d</span> 4e 0c          <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsi),%r9                 # 第<span class="number">6</span>个参数</span><br><span class="line">  40147c:4c <span class="number">8d</span> <span class="number">46</span> <span class="number">08</span>          <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsi),%r8                 # 第<span class="number">5</span>个参数</span><br><span class="line">  <span class="number">401480</span>:be c3 <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x4025c3,%esi                # 第<span class="number">2</span>个参数，格式串</span><br><span class="line">  <span class="number">401485</span>:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax                     # 初始化返回值</span><br><span class="line">  40148a:e8 <span class="number">61</span> f7 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:<span class="number">83</span> f8 <span class="number">05</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x5,%eax                     # 要求输入数字要大于<span class="number">5</span>个才不会引爆炸弹</span><br><span class="line">  <span class="number">401492</span>:7f <span class="number">05</span>                <span class="keyword">jg</span>     <span class="number">401499</span> &lt;read_six_numbers+<span class="number">0x3d</span>&gt;</span><br><span class="line">  <span class="number">401494</span>:e8 a1 ff ff ff       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401499</span>:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">40149d</span>:c3                   retq  </span><br></pre></td></tr></table></figure><p>查看<code>0x4025c3</code>地址单元中的内容为格式串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4025c3</span><br><span class="line">0x4025c3:       &quot;%d %d %d %d %d %d&quot;</span><br></pre></td></tr></table></figure><p>经分析答案为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure><h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a><strong>Phase_3</strong></h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  400f47:<span class="number">48</span> <span class="number">8d</span> 4c <span class="number">24</span> 0c       <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line">  400f4c:<span class="number">48</span> <span class="number">8d</span> <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line">  400f51:be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x4025cf,%esi         # <span class="string">&quot;%d %d&quot;</span>需要两个无符号十进制数, 少于<span class="number">2</span>个会引爆炸弹</span><br><span class="line">  400f56:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  400f5b:e8 <span class="number">90</span> fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:<span class="number">83</span> f8 <span class="number">01</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">  400f63:7f <span class="number">05</span>                <span class="keyword">jg</span>     400f6a &lt;phase_3+<span class="number">0x27</span>&gt;</span><br><span class="line">  400f65:e8 d0 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:<span class="number">83</span> 7c <span class="number">24</span> <span class="number">08</span> <span class="number">07</span>       cmpl   <span class="number">$0</span>x7,<span class="number">0x8</span>(%rsp)         # 第一个标准输入中的参数大于<span class="number">7</span>则会跳转发生爆炸</span><br><span class="line">  400f6f:<span class="number">77</span> 3c                <span class="keyword">ja</span>     400fad &lt;phase_3+<span class="number">0x6a</span>&gt;</span><br><span class="line">  400f71:8b <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rsp),%eax</span><br><span class="line">  400f75:ff <span class="number">24</span> c5 <span class="number">70</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span> jmpq   *<span class="number">0x402470</span>(,%rax,<span class="number">8</span>)     # indirect jump, 跳转到<span class="number">0x402470</span>+<span class="built_in">rax</span>*<span class="number">8</span>的存储单元中存放的地址即<span class="number">0x400f83</span></span><br><span class="line">  400f7c:b8 cf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>xcf,%eax</span><br><span class="line">  400f81:eb 3b                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f83:b8 c3 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x2c3,%eax</span><br><span class="line">  400f88:eb <span class="number">34</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f8a:b8 <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x100,%eax</span><br><span class="line">  400f8f:eb <span class="number">2d</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f91:b8 <span class="number">85</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x185,%eax</span><br><span class="line">  400f96:eb <span class="number">26</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f98:b8 ce <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>xce,%eax</span><br><span class="line">  400f9d:eb 1f                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f9f:b8 aa <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x2aa,%eax</span><br><span class="line">  400fa4:eb <span class="number">18</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400fa6:b8 <span class="number">47</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x147,%eax</span><br><span class="line">  400fab:eb <span class="number">11</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400fad:e8 <span class="number">88</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  400fb7:eb <span class="number">05</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400fb9:b8 <span class="number">37</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x137,%eax</span><br><span class="line">  400fbe:3b <span class="number">44</span> <span class="number">24</span> 0c          <span class="keyword">cmp</span>    <span class="number">0xc</span>(%rsp),%eax         # 第二个参数和覆写后的<span class="built_in">eax</span>相等才能跳过bomb</span><br><span class="line">  400fc2:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     400fc9 &lt;phase_3+<span class="number">0x86</span>&gt;</span><br><span class="line">  400fc4:e8 <span class="number">71</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  400fcd:c3                   retq   </span><br></pre></td></tr></table></figure><p><code>jmp *Operand</code>为Indirect Jump, 跳转的target存放在寄存器中或者内存中。查看内存中存放的target:<br><img src="https://pic4.zhimg.com/80/v2-bd761cefa9fec00f19cf892677e0e12d.png" alt="Image"><br>再结合上面的汇编代码，可以得出8个答案:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 207</span><br><span class="line">1 311</span><br><span class="line">2 707</span><br><span class="line">3 256</span><br><span class="line">4 389</span><br><span class="line">5 206</span><br><span class="line">6 682</span><br><span class="line">7 327</span><br></pre></td></tr></table></figure><h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a><strong>Phase_4</strong></h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">401010</span>:<span class="number">48</span> <span class="number">8d</span> 4c <span class="number">24</span> 0c       <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsp),%rcx  # callee save</span><br><span class="line">  <span class="number">401015</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsp),%rdx  # callee save</span><br><span class="line">  40101a:be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x4025cf,%esi  # 格式串, 需要两个十进制数, 因此可以断定标准输入为两个数</span><br><span class="line">  40101f:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  <span class="number">401024</span>:e8 c7 fb ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  <span class="number">401029</span>:<span class="number">83</span> f8 <span class="number">02</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x2,%eax             # 需要在标准输入中传递两个参数(sscanf系统调用的返回值)，否则会引爆炸弹</span><br><span class="line">  40102c:<span class="number">75</span> <span class="number">07</span>                <span class="keyword">jne</span>    <span class="number">401035</span> &lt;phase_4+<span class="number">0x29</span>&gt;</span><br><span class="line">  40102e:<span class="number">83</span> 7c <span class="number">24</span> <span class="number">08</span> 0e       cmpl   <span class="number">$0</span>xe,<span class="number">0x8</span>(%rsp)        # 第一个参数若大于<span class="number">14</span>，则bomb</span><br><span class="line">  <span class="number">401033</span>:<span class="number">76</span> <span class="number">05</span>                <span class="keyword">jbe</span>    40103a &lt;phase_4+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">401035</span>:e8 <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:ba 0e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>xe,%edx             # <span class="number">14</span>作为func4的第三个参数</span><br><span class="line">  40103f:be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%esi             # <span class="number">0</span>作为func4的第二个参数</span><br><span class="line">  <span class="number">401044</span>:8b 7c <span class="number">24</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rsp),%edi        # phase_4的第一个参数作为func4的第一个参数</span><br><span class="line">  <span class="number">401048</span>:e8 <span class="number">81</span> ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  <span class="number">40104d</span>:<span class="number">85</span> c0                <span class="keyword">test</span>   %eax,%eax             # 若返回值<span class="built_in">eax</span>不为<span class="number">0</span>则bomb</span><br><span class="line">  40104f:<span class="number">75</span> <span class="number">07</span>                <span class="keyword">jne</span>    <span class="number">401058</span> &lt;phase_4+<span class="number">0x4c</span>&gt;</span><br><span class="line">  <span class="number">401051</span>:<span class="number">83</span> 7c <span class="number">24</span> 0c <span class="number">00</span>       cmpl   <span class="number">$0</span>x0,<span class="number">0xc</span>(%rsp)        # 若第二个标准输入参数不为<span class="number">0</span>则bomb, 因此可以确定第二个标准输入参数必须为<span class="number">0</span></span><br><span class="line">  <span class="number">401056</span>:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     <span class="number">40105d</span> &lt;phase_4+<span class="number">0x51</span>&gt;</span><br><span class="line">  <span class="number">401058</span>:e8 <span class="built_in">dd</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">40105d</span>:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">401061</span>:c3                   retq   </span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp              # stack frame</span><br><span class="line">  400fd2:<span class="number">89</span> d0                <span class="keyword">mov</span>    %edx,%eax</span><br><span class="line">  400fd4:<span class="number">29</span> f0                <span class="keyword">sub</span>    %esi,%eax</span><br><span class="line">  400fd6:<span class="number">89</span> c1                <span class="keyword">mov</span>    %eax,%ecx</span><br><span class="line">  400fd8:c1 e9 1f             <span class="keyword">shr</span>    <span class="number">$0</span>x1f,%ecx             # 取符号位</span><br><span class="line">  400fdb:<span class="number">01</span> c8                <span class="keyword">add</span>    %ecx,%eax</span><br><span class="line">  400fdd:d1 f8                <span class="keyword">sar</span>    %eax                   # <span class="built_in">eax</span>  除以<span class="number">2</span>向下取整, 最后的答案与之相关</span><br><span class="line">  400fdf:<span class="number">8d</span> 0c <span class="number">30</span>             <span class="keyword">lea</span>    (%rax,%rsi,<span class="number">1</span>),%ecx</span><br><span class="line">  400fe2:<span class="number">39</span> f9                <span class="keyword">cmp</span>    %edi,%ecx              # 直到<span class="built_in">ecx</span>小于等于第一个标准输入的参数<span class="built_in">edi</span>, 则跳转到<span class="number">0x400ff2</span></span><br><span class="line">  400fe4:7e 0c                <span class="keyword">jle</span>    400ff2 &lt;func4+<span class="number">0x24</span>&gt;</span><br><span class="line">  400fe6:<span class="number">8d</span> <span class="number">51</span> ff             <span class="keyword">lea</span>    -<span class="number">0x1</span>(%rcx),%edx</span><br><span class="line">  400fe9:e8 e0 ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:<span class="number">01</span> c0                <span class="keyword">add</span>    %eax,%eax</span><br><span class="line">  400ff0:eb <span class="number">15</span>                <span class="keyword">jmp</span>    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;</span><br><span class="line">  400ff2:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax              # 此处很关键，要保证不bomb必须返回<span class="number">0</span></span><br><span class="line">  400ff7:<span class="number">39</span> f9                <span class="keyword">cmp</span>    %edi,%ecx  </span><br><span class="line">  400ff9:<span class="number">7d</span> 0c                <span class="keyword">jge</span>    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;    # 跳转到此处之后，要想此处跳转，条件必须是<span class="built_in">ecx</span>==<span class="built_in">edi</span></span><br><span class="line">  400ffb:<span class="number">8d</span> <span class="number">71</span> <span class="number">01</span>             <span class="keyword">lea</span>    <span class="number">0x1</span>(%rcx),%esi</span><br><span class="line">  400ffe:e8 cb ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  <span class="number">401003</span>:<span class="number">8d</span> <span class="number">44</span> <span class="number">00</span> <span class="number">01</span>          <span class="keyword">lea</span>    <span class="number">0x1</span>(%rax,%rax,<span class="number">1</span>),%eax  # 执行到这一步无论<span class="built_in">rax</span>的值为什么都不可能为<span class="number">0</span></span><br><span class="line">  <span class="number">401007</span>:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          <span class="keyword">add</span>    <span class="number">$0</span>x8,%rsp</span><br><span class="line">  40100b:c3                   retq   </span><br></pre></td></tr></table></figure><p>经过调试分析, 可得出四个答案, 除此之外可能还有其他答案就不另行分析了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7 0</span><br><span class="line">3 0</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a><strong>Phase_5</strong></h2><p>ASCII转化为十六进制时(因为所取数字的下标大于10)需要查看ASCII编码表。关于stack canary的解释可以参考<a href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value/10325915#10325915">文章</a>和<a href="https://qastack.cn/unix/453749/what-sets-fs0x28-stack-canary">文章</a>使用rax寄存器作为间接传递的原因是因为x86中不存在内存到内存的mov指令。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000401062</span> &lt;phase_5&gt;:</span><br><span class="line">  <span class="number">401062</span>:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx                     # callee save</span><br><span class="line">  <span class="number">401063</span>:<span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x20,%rsp</span><br><span class="line">  <span class="number">401067</span>:<span class="number">48</span> <span class="number">89</span> fb             <span class="keyword">mov</span>    %rdi,%rbx                # 标准输入字符串参数</span><br><span class="line">  40106a:<span class="number">64</span> <span class="number">48</span> 8b <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> <span class="keyword">mov</span>    %fs:<span class="number">0x28</span>,%rax            # stack-canary</span><br><span class="line">  <span class="number">401071</span>:<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">401073</span>:<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>       <span class="keyword">mov</span>    %rax,<span class="number">0x18</span>(%rsp)</span><br><span class="line">  <span class="number">401078</span>:<span class="number">31</span> c0                <span class="keyword">xor</span>    %eax,%eax                # 对<span class="built_in">eax</span>清<span class="number">0</span></span><br><span class="line">  40107a:e8 9c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  40131b &lt;string_length&gt;   # <span class="built_in">rdi</span>作为参数, 返回<span class="built_in">rdi</span>字符串的长度</span><br><span class="line">  40107f:<span class="number">83</span> f8 <span class="number">06</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x6,%eax                # 如果标准输入的字符串不为<span class="number">6</span>个字符，则bomb</span><br><span class="line">  <span class="number">401082</span>:<span class="number">74</span> 4e                <span class="keyword">je</span>     4010d2 &lt;phase_5+<span class="number">0x70</span>&gt;</span><br><span class="line">  <span class="number">401084</span>:e8 b1 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401089</span>:eb <span class="number">47</span>                <span class="keyword">jmp</span>    4010d2 &lt;phase_5+<span class="number">0x70</span>&gt;</span><br><span class="line">  40108b:0f b6 0c <span class="number">03</span>          movzbl (%rbx,%rax,<span class="number">1</span>),%ecx       # 取字符</span><br><span class="line">  40108f:<span class="number">88</span> 0c <span class="number">24</span>             <span class="keyword">mov</span>    %cl,(%rsp)               # 取最低字节大小的字符</span><br><span class="line">  <span class="number">401092</span>:<span class="number">48</span> 8b <span class="number">14</span> <span class="number">24</span>          <span class="keyword">mov</span>    (%rsp),%rdx</span><br><span class="line">  <span class="number">401096</span>:<span class="number">83</span> e2 0f             <span class="keyword">and</span>    <span class="number">$0</span>xf,%edx                # 将ASCII转化为对应的十六进制数作为索引</span><br><span class="line">  <span class="number">401099</span>:0f b6 <span class="number">92</span> b0 <span class="number">24</span> <span class="number">40</span> <span class="number">00</span> movzbl <span class="number">0x4024b0</span>(%rdx),%edx      # <span class="number">0x4024b0</span>中存放了一串字符, 通过分析可以发现<span class="built_in">rdx</span>作为取字符串字符的索引</span><br><span class="line">  4010a0:<span class="number">88</span> <span class="number">54</span> <span class="number">04</span> <span class="number">10</span>          <span class="keyword">mov</span>    %dl,<span class="number">0x10</span>(%rsp,%rax,<span class="number">1</span>)    # 将取到的字符存入由<span class="built_in">rsp</span>+<span class="number">0x10</span>处的开始向高地址方向增长</span><br><span class="line">  4010a4:<span class="number">48</span> <span class="number">83</span> c0 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%rax                # 减少迭代次数</span><br><span class="line">  4010a8:<span class="number">48</span> <span class="number">83</span> f8 <span class="number">06</span>          <span class="keyword">cmp</span>    <span class="number">$0</span>x6,%rax                # 迭代<span class="number">6</span>次</span><br><span class="line">  4010ac:<span class="number">75</span> <span class="built_in">dd</span>                <span class="keyword">jne</span>    40108b &lt;phase_5+<span class="number">0x29</span>&gt;</span><br><span class="line">  4010ae:c6 <span class="number">44</span> <span class="number">24</span> <span class="number">16</span> <span class="number">00</span>       movb   <span class="number">$0</span>x0,<span class="number">0x16</span>(%rsp)          # 在字符串后添加termimator, 作为字符串比较结束的标志</span><br><span class="line">  4010b3:be 5e <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x40245e,%esi           # <span class="string">&quot;flyers&quot;</span></span><br><span class="line">  4010b8:<span class="number">48</span> <span class="number">8d</span> 7c <span class="number">24</span> <span class="number">10</span>       <span class="keyword">lea</span>    <span class="number">0x10</span>(%rsp),%rdi</span><br><span class="line">  4010bd:e8 <span class="number">76</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">401338</span> &lt;strings_not_equal&gt;    # 比较存放在<span class="number">0x40245e</span>中的字符串和标准输入转化后的字符串</span><br><span class="line">  4010c2:<span class="number">85</span> c0                <span class="keyword">test</span>   %eax,%eax</span><br><span class="line">  4010c4:<span class="number">74</span> <span class="number">13</span>                <span class="keyword">je</span>     4010d9 &lt;phase_5+<span class="number">0x77</span>&gt;</span><br><span class="line">  4010c6:e8 6f <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:0f 1f <span class="number">44</span> <span class="number">00</span> <span class="number">00</span>       nopl   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line">  4010d0:eb <span class="number">07</span>                <span class="keyword">jmp</span>    4010d9 &lt;phase_5+<span class="number">0x77</span>&gt;</span><br><span class="line">  4010d2:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  4010d7:eb b2                <span class="keyword">jmp</span>    40108b &lt;phase_5+<span class="number">0x29</span>&gt;</span><br><span class="line">  4010d9:<span class="number">48</span> 8b <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>       <span class="keyword">mov</span>    <span class="number">0x18</span>(%rsp),%rax  </span><br><span class="line">  4010de:<span class="number">64</span> <span class="number">48</span> <span class="number">33</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> <span class="keyword">xor</span>    %fs:<span class="number">0x28</span>,%rax                 # 若stack canary未被破坏则跳过__stack_chk_fail</span><br><span class="line">  4010e5:<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  4010e7:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     4010ee &lt;phase_5+<span class="number">0x8c</span>&gt;</span><br><span class="line">  4010e9:e8 <span class="number">42</span> fa ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">20</span>          <span class="keyword">add</span>    <span class="number">$0</span>x20,%rsp                    # restore</span><br><span class="line">  4010f2:5b                   <span class="keyword">pop</span>    %rbx</span><br><span class="line">  4010f3:c3                   retq </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;:  &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:       &quot;flyers&quot;</span><br></pre></td></tr></table></figure><p>输入正确结果后内存中存放的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s $rsp+0x10</span><br><span class="line">0x7fffffffdfc0: &quot;flyers&quot;</span><br></pre></td></tr></table></figure><p>最后的答案为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9?&gt;567</span><br></pre></td></tr></table></figure><h2 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a><strong>Phase_6</strong></h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:<span class="number">41</span> <span class="number">56</span>                <span class="keyword">push</span>   %r14                         # callee save</span><br><span class="line">  4010f6:<span class="number">41</span> <span class="number">55</span>                <span class="keyword">push</span>   %r13</span><br><span class="line">  4010f8:<span class="number">41</span> <span class="number">54</span>                <span class="keyword">push</span>   %r12</span><br><span class="line">  4010fa:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp</span><br><span class="line">  4010fb:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line">  4010fc:<span class="number">48</span> <span class="number">83</span> ec <span class="number">50</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x50,%rsp                   # stack frame</span><br><span class="line">  <span class="number">401100</span>:<span class="number">49</span> <span class="number">89</span> e5             <span class="keyword">mov</span>    %rsp,%r13</span><br><span class="line">  <span class="number">401103</span>:<span class="number">48</span> <span class="number">89</span> e6             <span class="keyword">mov</span>    %rsp,%rsi</span><br><span class="line">  <span class="number">401106</span>:e8 <span class="number">51</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  40110b:<span class="number">49</span> <span class="number">89</span> e6             <span class="keyword">mov</span>    %rsp,%r14</span><br><span class="line">  40110e:<span class="number">41</span> bc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x0,%r12d                   # 迭代器</span><br><span class="line">  <span class="number">401114</span>:4c <span class="number">89</span> ed             <span class="keyword">mov</span>    %r13,%rbp</span><br><span class="line">  <span class="number">401117</span>:<span class="number">41</span> 8b <span class="number">45</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">0x0</span>(%r13),%eax               # <span class="built_in">r13</span>中存放的数字放入<span class="built_in">eax</span>中</span><br><span class="line">  40111b:<span class="number">83</span> e8 <span class="number">01</span>             <span class="keyword">sub</span>    <span class="number">$0</span>x1,%eax                    # <span class="built_in">eax</span>大于<span class="number">5</span>则bomb, 一轮<span class="keyword">loop</span>之后观察可以推出六个数字的范围是<span class="number">1</span>到<span class="number">6</span>, 且相邻数字不能相同</span><br><span class="line">  40111e:<span class="number">83</span> f8 <span class="number">05</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x5,%eax</span><br><span class="line">  <span class="number">401121</span>:<span class="number">76</span> <span class="number">05</span>                <span class="keyword">jbe</span>    <span class="number">401128</span> &lt;phase_6+<span class="number">0x34</span>&gt;        # be无符号比较, 若参数数减去<span class="number">1</span>小于<span class="number">0</span>则会bomb，进而可以推出参数不能小于<span class="number">1</span></span><br><span class="line">  <span class="number">401123</span>:e8 <span class="number">12</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401128</span>:<span class="number">41</span> <span class="number">83</span> c4 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%r12d </span><br><span class="line">  40112c:<span class="number">41</span> <span class="number">83</span> fc <span class="number">06</span>          <span class="keyword">cmp</span>    <span class="number">$0</span>x6,%r12d</span><br><span class="line">  <span class="number">401130</span>:<span class="number">74</span> <span class="number">21</span>                <span class="keyword">je</span>     <span class="number">401153</span> &lt;phase_6+<span class="number">0x5f</span>&gt;        # 外循环迭代次数到<span class="number">6</span>次则终止<span class="keyword">loop</span></span><br><span class="line">  <span class="number">401132</span>:<span class="number">44</span> <span class="number">89</span> e3             <span class="keyword">mov</span>    %r12d,%ebx</span><br><span class="line">  <span class="number">401135</span>:<span class="number">48</span> <span class="number">63</span> c3             movslq %ebx,%rax</span><br><span class="line">  <span class="number">401138</span>:8b <span class="number">04</span> <span class="number">84</span>             <span class="keyword">mov</span>    (%rsp,%rax,<span class="number">4</span>),%eax           # 取下一个数字放入<span class="built_in">eax</span></span><br><span class="line">  40113b:<span class="number">39</span> <span class="number">45</span> <span class="number">00</span>             <span class="keyword">cmp</span>    %eax,<span class="number">0x0</span>(%rbp)               # 若当前数字与下一个数字相等，则bomb</span><br><span class="line">  40113e:<span class="number">75</span> <span class="number">05</span>                <span class="keyword">jne</span>    <span class="number">401145</span> &lt;phase_6+<span class="number">0x51</span>&gt;</span><br><span class="line">  <span class="number">401140</span>:e8 f5 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;        # 六个数字出现连续相同的数字则发生bomb</span><br><span class="line">  <span class="number">401145</span>:<span class="number">83</span> c3 <span class="number">01</span>             <span class="keyword">add</span>    <span class="number">$0</span>x1,%ebx</span><br><span class="line">  <span class="number">401148</span>:<span class="number">83</span> fb <span class="number">05</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x5,%ebx                    # 若没遍历完六个数字中剩余的数字则<span class="keyword">loop</span></span><br><span class="line">  40114b:7e e8                <span class="keyword">jle</span>    <span class="number">401135</span> &lt;phase_6+<span class="number">0x41</span>&gt;</span><br><span class="line">  <span class="number">40114d</span>:<span class="number">49</span> <span class="number">83</span> c5 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%r13                    # 取下一个数字</span><br><span class="line">  <span class="number">401151</span>:eb c1                <span class="keyword">jmp</span>    <span class="number">401114</span> &lt;phase_6+<span class="number">0x20</span>&gt;</span><br><span class="line">  <span class="number">401153</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">74</span> <span class="number">24</span> <span class="number">18</span>       <span class="keyword">lea</span>    <span class="number">0x18</span>(%rsp),%rsi              # null terminator, 第六个参数后面的字</span><br><span class="line">  <span class="number">401158</span>:4c <span class="number">89</span> f0             <span class="keyword">mov</span>    %r14,%rax</span><br><span class="line">  40115b:b9 <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x7,%ecx</span><br><span class="line">  <span class="number">401160</span>:<span class="number">89</span> ca                <span class="keyword">mov</span>    %ecx,%edx</span><br><span class="line">  <span class="number">401162</span>:2b <span class="number">10</span>                <span class="keyword">sub</span>    (%rax),%edx                  # 将<span class="number">7</span>减去当前位置的参数数字的结果放回到当前位置, 即将六个数字结果都改为<span class="number">7</span>-当前数字</span><br><span class="line">  <span class="number">401164</span>:<span class="number">89</span> <span class="number">10</span>                <span class="keyword">mov</span>    %edx,(%rax)</span><br><span class="line">  <span class="number">401166</span>:<span class="number">48</span> <span class="number">83</span> c0 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%rax                    # 往下移动一个数字的位置</span><br><span class="line">  40116a:<span class="number">48</span> <span class="number">39</span> f0             <span class="keyword">cmp</span>    %rsi,%rax                    # 若未移动到最后一个数字结束则继续<span class="keyword">loop</span></span><br><span class="line">  <span class="number">40116d</span>:<span class="number">75</span> f1                <span class="keyword">jne</span>    <span class="number">401160</span> &lt;phase_6+<span class="number">0x6c</span>&gt;</span><br><span class="line">  40116f:be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%esi</span><br><span class="line">  <span class="number">401174</span>:eb <span class="number">21</span>                <span class="keyword">jmp</span>    <span class="number">401197</span> &lt;phase_6+<span class="number">0xa3</span>&gt;        </span><br><span class="line">  <span class="number">401176</span>:<span class="number">48</span> 8b <span class="number">52</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rdx),%rdx               # 将当前<span class="built_in">rdx</span>中存放地址的下一个<span class="number">8</span>字节中存放地址的内容存放到<span class="built_in">rdx</span>中, 即遍历链表，取到对应的节点</span><br><span class="line">  40117a:<span class="number">83</span> c0 <span class="number">01</span>             <span class="keyword">add</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">  <span class="number">40117d</span>:<span class="number">39</span> c8                <span class="keyword">cmp</span>    %ecx,%eax                    </span><br><span class="line">  40117f:<span class="number">75</span> f5                <span class="keyword">jne</span>    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;        # 若<span class="built_in">eax</span>与做出变更的数字不相等则继续<span class="keyword">loop</span>, 实际上变更的数字为node号</span><br><span class="line">  <span class="number">401181</span>:eb <span class="number">05</span>                <span class="keyword">jmp</span>    <span class="number">401188</span> &lt;phase_6+<span class="number">0x94</span>&gt;</span><br><span class="line">  <span class="number">401183</span>:ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x6032d0,%edx               # <span class="number">0x6032d0</span>为node1</span><br><span class="line">  <span class="number">401188</span>:<span class="number">48</span> <span class="number">89</span> <span class="number">54</span> <span class="number">74</span> <span class="number">20</span>       <span class="keyword">mov</span>    %rdx,<span class="number">0x20</span>(%rsp,%rsi,<span class="number">2</span>)       # 将当前node的地址存放到$<span class="built_in">rsp</span>+<span class="number">0x20</span>开始，以<span class="number">8</span>字节为间隔的连续地址</span><br><span class="line">  <span class="number">40118d</span>:<span class="number">48</span> <span class="number">83</span> c6 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%rsi                    # 移动到下一个变更后的参数</span><br><span class="line">  <span class="number">401191</span>:<span class="number">48</span> <span class="number">83</span> fe <span class="number">18</span>          <span class="keyword">cmp</span>    <span class="number">$0</span>x18,%rsi                   </span><br><span class="line">  <span class="number">401195</span>:<span class="number">74</span> <span class="number">14</span>                <span class="keyword">je</span>     4011ab &lt;phase_6+<span class="number">0xb7</span>&gt;        # 遍历完六个参数则跳转到target, 即取对应参数变更后的node号的地址放入内存中</span><br><span class="line">  <span class="number">401197</span>:8b 0c <span class="number">34</span>             <span class="keyword">mov</span>    (%rsp,%rsi,<span class="number">1</span>),%ecx           # 按顺序取做出变更后的参数</span><br><span class="line">  40119a:<span class="number">83</span> f9 <span class="number">01</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x1,%ecx                    # 若当前数字小于等于<span class="number">1</span>则，直接存放当前节点不需要遍历链表</span><br><span class="line">  <span class="number">40119d</span>:7e e4                <span class="keyword">jle</span>    <span class="number">401183</span> &lt;phase_6+<span class="number">0x8f</span>&gt;</span><br><span class="line">  40119f:b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">  4011a4:ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x6032d0,%edx               # 传递的是地址, gdb调试可以发现存在一个链表, 比如<span class="number">0x6032d8</span>存储单元中存放着的是<span class="number">0x6032e0</span></span><br><span class="line">  4011a9:eb cb                <span class="keyword">jmp</span>    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;</span><br><span class="line">  4011ab:<span class="number">48</span> 8b 5c <span class="number">24</span> <span class="number">20</span>       <span class="keyword">mov</span>    <span class="number">0x20</span>(%rsp),%rbx              # node6的地址</span><br><span class="line">  4011b0:<span class="number">48</span> <span class="number">8d</span> <span class="number">44</span> <span class="number">24</span> <span class="number">28</span>       <span class="keyword">lea</span>    <span class="number">0x28</span>(%rsp),%rax               </span><br><span class="line">  4011b5:<span class="number">48</span> <span class="number">8d</span> <span class="number">74</span> <span class="number">24</span> <span class="number">50</span>       <span class="keyword">lea</span>    <span class="number">0x50</span>(%rsp),%rsi               </span><br><span class="line">  4011ba:<span class="number">48</span> <span class="number">89</span> d9             <span class="keyword">mov</span>    %rbx,%rcx                    </span><br><span class="line">  4011bd:<span class="number">48</span> 8b <span class="number">10</span>             <span class="keyword">mov</span>    (%rax),%rdx                  # node5的地址, 即指针</span><br><span class="line">  4011c0:<span class="number">48</span> <span class="number">89</span> <span class="number">51</span> <span class="number">08</span>          <span class="keyword">mov</span>    %rdx,<span class="number">0x8</span>(%rcx)               # 将node5的指针作为node6的next</span><br><span class="line">  4011c4:<span class="number">48</span> <span class="number">83</span> c0 <span class="number">08</span>          <span class="keyword">add</span>    <span class="number">$0</span>x8,%rax                    # node4指针的地址</span><br><span class="line">  4011c8:<span class="number">48</span> <span class="number">39</span> f0             <span class="keyword">cmp</span>    %rsi,%rax                    # 看一下是否遍历结束</span><br><span class="line">  4011cb:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     4011d2 &lt;phase_6+<span class="number">0xde</span>&gt;        </span><br><span class="line">  4011cd:<span class="number">48</span> <span class="number">89</span> d1             <span class="keyword">mov</span>    %rdx,%rcx</span><br><span class="line">  4011d0:eb eb                <span class="keyword">jmp</span>    4011bd &lt;phase_6+<span class="number">0xc9</span>&gt;        # <span class="keyword">loop</span></span><br><span class="line">  4011d2:<span class="number">48</span> c7 <span class="number">42</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="keyword">movq</span>   <span class="number">$0</span>x0,<span class="number">0x8</span>(%rdx)               # 将尾节点node1的next指向空</span><br><span class="line">  4011d9:<span class="number">00</span>                                                        # 应该是涉及pipeline优化的bubble </span><br><span class="line">  4011da:bd <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x5,%ebp                    # 迭代器</span><br><span class="line">  4011df:<span class="number">48</span> 8b <span class="number">43</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rbx),%rax               # 将下一个node的地址赋给<span class="built_in">rax</span></span><br><span class="line">  4011e3:8b <span class="number">00</span>                <span class="keyword">mov</span>    (%rax),%eax                  # 取下一个node的值(即低32bit)赋给<span class="built_in">eax</span></span><br><span class="line">  4011e5:<span class="number">39</span> <span class="number">03</span>                <span class="keyword">cmp</span>    %eax,(%rbx)                  # 当前node的值若小于(&lt;)下一个node的值，则bomb，到这里可以猜测要将链表要按node值来构造递减序列</span><br><span class="line">  4011e7:<span class="number">7d</span> <span class="number">05</span>                <span class="keyword">jge</span>    4011ee &lt;phase_6+<span class="number">0xfa</span>&gt;        # 初步可以判断需要用<span class="number">7</span>-当前参数值来取node号</span><br><span class="line">  4011e9:e8 4c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:<span class="number">48</span> 8b 5b <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rbx),%rbx               # 将当前node的next赋给<span class="built_in">rbx</span>, 即移动指针遍历到下一个node</span><br><span class="line">  4011f2:<span class="number">83</span> ed <span class="number">01</span>             <span class="keyword">sub</span>    <span class="number">$0</span>x1,%ebp                    # 减少迭代次数</span><br><span class="line">  4011f5:<span class="number">75</span> e8                <span class="keyword">jne</span>    4011df &lt;phase_6+<span class="number">0xeb</span>&gt;</span><br><span class="line">  4011f7:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">50</span>          <span class="keyword">add</span>    <span class="number">$0</span>x50,%rsp</span><br><span class="line">  4011fb:5b                   <span class="keyword">pop</span>    %rbx</span><br><span class="line">  4011fc:<span class="number">5d</span>                   <span class="keyword">pop</span>    %rbp</span><br><span class="line">  4011fd:<span class="number">41</span> 5c                <span class="keyword">pop</span>    %r12</span><br><span class="line">  4011ff:<span class="number">41</span> <span class="number">5d</span>                <span class="keyword">pop</span>    %r13</span><br><span class="line">  <span class="number">401201</span>:<span class="number">41</span> 5e                <span class="keyword">pop</span>    %r14</span><br><span class="line">  <span class="number">401203</span>:c3                   retq   </span><br></pre></td></tr></table></figure><p>查看0x6032d0处地址内容(gdb中的字默认为4字节， 而x86的字默认为2字节), 可以猜测出第一个8字节中高4字节为node号，低4字节为值域，第二个8字节为next指针域，下述示例传递的参数为<code>1 2 3 4 5 6</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/12xg 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x000000010000014c      0x0000000000000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x00000002000000a8      0x00000000006032d0</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x000000030000039c      0x00000000006032e0</span><br><span class="line">0x603300 &lt;node4&gt;:       0x00000004000002b3      0x00000000006032f0</span><br><span class="line">0x603310 &lt;node5&gt;:       0x00000005000001dd      0x0000000000603300</span><br><span class="line">0x603320 &lt;node6&gt;:       0x00000006000001bb      0x0000000000603310</span><br></pre></td></tr></table></figure><p>6个node的值, 再将其由大到小排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node1: 0x14c</span><br><span class="line">node2: 0x0a8</span><br><span class="line">node3: 0x39c</span><br><span class="line">node4: 0x2b3</span><br><span class="line">node5: 0x1dd</span><br><span class="line">node6: 0x1bb</span><br><span class="line">node3 &gt; node4 &gt; node5 &gt; node6 &gt; node1 &gt; node2</span><br></pre></td></tr></table></figure><p>由7-nodeNumber得到答案为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-77b2f6513b85ca11bed6e27cf04ea16d.png" alt="Defused"></p>]]></content>
      
      
      <categories>
          
          <category> CMU15-213 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP: Data Lab</title>
      <link href="/2022/05/16/CSAPP-Lab1-Data-Lab/"/>
      <url>/2022/05/16/CSAPP-Lab1-Data-Lab/</url>
      
        <content type="html"><![CDATA[<h2 id="Some-Restriction"><a href="#Some-Restriction" class="headerlink" title="Some Restriction"></a><strong>Some Restriction</strong></h2><!-- # CSAPP: Data Lab --><blockquote><p>又复习了一次位级表示</p></blockquote><span id="more"></span><h4 id="Integer-Coding-Rules"><a href="#Integer-Coding-Rules" class="headerlink" title="Integer Coding Rules"></a><strong>Integer Coding Rules</strong></h4><ol><li>Expr<ol><li>整型操作数的值被限制在范围[0, 255]。</li><li>不能使用全局变量</li><li>只能使用的一元操作<code>!</code>, <code>~</code></li><li>只能使用的二元操作<code>&amp;</code>, <code>^</code>, <code>|</code>, <code>+</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li><li>一个表达式不会被限制拥有多个操作符</li></ol></li><li>Fobidden<ol><li>使用控制语句如<code>if</code>, <code>do</code>, <code>while</code>, <code>for</code>, <code>switch</code>等等</li><li>定义或使用任何宏</li><li>在当前文件中定义任何额外的函数</li><li>调用任何函数</li><li>使用其他操作</li><li>使用类型转换</li><li>使用除<code>int</code>之外的任何数据类型，使用<code>arrays</code>, <code>structs</code>, <code>unions</code></li></ol></li><li>假设机器的配置<ol><li>使用2的补码，<code>int</code>的表示为32-bit</li><li>执行算术右移</li><li>如果左移的位数小于0或者大于31则会出现未预测的行为。</li></ol></li></ol><h4 id="Floating-Point-Coding-Rules"><a href="#Floating-Point-Coding-Rules" class="headerlink" title="Floating Point Coding Rules"></a><strong>Floating Point Coding Rules</strong></h4><ol><li>Forbidden<ol><li>定义或使用任何宏</li><li>定义任何额外的函数</li><li>调用任何函数</li><li>使用任何形式的类型转换</li><li>使用<code>arrays</code>, <code>structs</code>, <code>unions</code></li></ol></li></ol><h4 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a><strong>Notes</strong></h4><ol><li>使用<code>dlc</code>(data tab checker)编译器来检查解决方案的合理性</li><li>使用<code>btest</code>来检查你的函数的正确性</li><li>使用<code>BDD checker</code>来正式地证实你的函数</li></ol><h4 id="lab-Note"><a href="#lab-Note" class="headerlink" title="lab Note"></a><strong>lab Note</strong></h4><ol><li>64位机器上编译32位程序会出现错误<code>fatal error: bits/libc-header-start.h: 没有那个文件或目录</code>，是因为gcc没有安装<code>multilib</code>库，这个库可以在64位的机器上产生32位的程序<code>sudo apt install gcc-multilib</code></li></ol><h3 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1. bitXor"></a><strong>1. bitXor</strong></h3><p>通过图中所给的与、非和或门构造的异或逻辑电路，再利用德摩根定律将所有的或门转化为与门可得。<br><img src="https://pic4.zhimg.com/80/v2-3e52fb0d69b1220a809e2982919296bf.png" alt="XOR gate"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> ~((~(x&amp;(~y))) &amp; (~((~x)&amp;y)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2. tmin"></a><strong>2. tmin</strong></h3><p>32位整型数<code>2&#39;s complement</code>的范围为<code>[-2^(n-1), 2^(n-1)-1</code>, 很容易得出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3. isTmax"></a><strong>3. isTmax</strong></h3><p>摸索了小一段时间，解法很多，<code>-1</code>可以通过取反<code>+1</code>来构造。假设x为<code>Tmax</code>, 对<code>Tmax</code>取反得到<code>Tmin</code>，再减1则会发生<code>underflow</code>会得到<code>Tmax</code>, 通过逻辑运算的结果与<code>x</code>本身异或，看结果是否为<code>0</code>来判断<code>Tmax</code>。这种情况下<code>-1</code>是需要排除的, 因为对<code>-1</code>的<code>2&#39;s Complement</code>取反得到<code>0</code>，减1之后会得到<code>-1</code>本身，因此异或结果还是<code>0</code>，需要排除(利用好<code>!!</code>,保证与的操作数要么是<code>0</code>或<code>1</code>)。排除直接让<code>x+1</code>判断即可，否则操作数会超出10个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (!(((~x)+(~<span class="number">1</span>+<span class="number">1</span>))^x)) &amp; (!!(x+<span class="number">1</span>));</span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure><h3 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4. allOddBits"></a><strong>4. allOddBits</strong></h3><p>根据题目给定的操作符数的限制，以及操作数值的限定，即可确定需要利用好<code>0xAA</code>。同样也花了一些时间去斟酌，很多细节需要把握住，得到最终的答案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !((((x&amp;<span class="number">0xAA</span>)&amp;((x&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xAA</span>))&amp;(((x&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xAA</span>)&amp;((x&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xAA</span>)))^<span class="number">0xAA</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-negate"><a href="#5-negate" class="headerlink" title="5. negate"></a><strong>5. negate</strong></h3><p>很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6. isAsciiDigit"></a><strong>6. isAsciiDigit</strong></h3><p>可以先将操作数限定在<code>0x3X</code>的范围内，再通过对<code>0x0A</code>取补得到<code>-10</code>，取低4位进行加法运算，得到的结果通过符号位，若符号位为<code>1</code>则为ASCII数字，否则不满足条件。可以通过提取从低位数起第五个bit即<code>0x10</code>来确定符号位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> neg_A = ~<span class="number">0x0A</span>+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((!((x&gt;&gt;<span class="number">4</span>)^<span class="number">0x3</span>)) &amp; (!!(((x&amp;<span class="number">0xF</span>)+neg_A)&amp;(<span class="number">0x10</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7. conditional"></a><strong>7. conditional</strong></h3><p>保证<code>x</code>非<code>0</code>即<code>1</code>，再利用<code>0</code>和<code>1</code>补码的特点, 构造全<code>1</code>和全<code>0</code>, 分别和<code>y</code>, <code>z</code>完成与运算来进行排除，这道题还是非常巧妙的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123; </span><br><span class="line">  <span class="type">int</span> mask = ~(!!(x^<span class="number">0x0</span>))+<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> (y&amp;mask) + (z&amp;(~mask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8. isLessOrEqual"></a><strong>8. isLessOrEqual</strong></h3><p>根据两个参数<code>x</code>, <code>y</code>的符号位先分几种情况</p><ol><li>满足小于等于<ol><li>两数相等</li><li><code>x&lt;0, y&gt;0</code>, 避免符号位相等时的溢出情况</li><li>符号位相等比较。通过第一个操作数加上第二个操作数的取补的形式, 若结果小于0，则<code>x&lt;y</code><ul><li>负负比较, 可能会出现对<code>Tmin</code>取补发生下溢出的特殊情况，因此需要排除第二个操作数为<code>Tmin</code>的情况，恰好该情况要么<strong>相等</strong>(已经判断过了), 要么就是<code>x&gt;y</code>(也判断了)。</li><li>正正比较</li></ul></li></ol></li><li>不满足小于等于,即大于等于(<code>x&gt;0, y&lt;0</code>)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_sign_bit = ((x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x01</span>);</span><br><span class="line">  <span class="type">int</span> y_sign_bit = ((y&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x01</span>);</span><br><span class="line">  <span class="type">int</span> Tmin = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (!((~x_sign_bit)&amp;y_sign_bit)) &amp; ((!(x^y)) | (x_sign_bit&amp;(~y_sign_bit)) | ((((x+(~y+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>)&amp;(!!(y^Tmin))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9. logicalNeg"></a><strong>9. logicalNeg</strong></h3><p>首先要将想一个办法将0和正数，负数区分开来。因为0和正数的符号位都是0，要区分开来恰好利用到了0的补码还是其本身的特性，正数取反加一后符号位由0变1，可以直接区分开来。再利用算数右移的特性，将0构造成全0，负数和正数构造成全1, 最后<code>+1</code>得到返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((x&gt;&gt;<span class="number">31</span>)|((~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10. howManyBits"></a><strong>10. howManyBits</strong></h3><p>坦白说这一题真的是卡了我好久，即便找到了最高bit位要想返回正确的结果几乎是很繁琐的，但肯定会超出操作符的限制。这道题参考了一下各路佬的思想，可以用二分法来实现。还需要注意负数需要按位取反(排除符号位的影响)，正数保持不变即可，可以通过<code>sign_bit</code>减<code>1</code>来构造全<code>0</code>和全<code>1</code>。可以通过右移<code>16</code>、<code>8</code>、<code>4</code>、<code>2</code>、<code>1</code>bit来找到最高的<code>bit 1</code>，这道题还是非常巧妙的。<br>判断右移<code>n bit</code>后是否为0</p><ul><li>如果为0，说明需要的位在高<code>n-bit</code>(左半侧)，数则保持不变，故不记录<code>n</code>，继续进行二分搜索。</li><li>如果不为0，说明需要的位在低<code>n-bit</code>(右半侧), 数向右移动<code>n-bit</code>继续进行搜索，且记录<code>n</code>。<br>最后将所有移位得到的<code>n</code>都累加起来得到最后的结果<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits  - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> sign_bit = (x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">int</span> flag = sign_bit+(~<span class="number">1</span>+<span class="number">1</span>);   <span class="comment">// neg -&gt; all 0,  not_neg -&gt; all 1</span></span><br><span class="line">  x = ((~flag)&amp;(~x))|(flag&amp;x);  <span class="comment">// if neg, reverse.</span></span><br><span class="line">  b16 = (!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  x &gt;&gt;= b16;</span><br><span class="line">  b8 = (!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">  x &gt;&gt;= b8;</span><br><span class="line">  b4 = (!!(x&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">  x &gt;&gt;= b4;</span><br><span class="line">  b2 = (!!(x&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x &gt;&gt;= b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x &gt;&gt;= b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-floatScale2"><a href="#11-floatScale2" class="headerlink" title="11. floatScale2"></a><strong>11. floatScale2</strong></h3><p>描述里没有给<code>Infinity</code>的case，通过测试发现，与<code>Nan</code>返回值一致合并一起判断。需要判断几种情况: <code>NaN</code>, <code>Subnormal</code>, <code>+0</code>, <code>-0</code>, <code>Normalize</code>。<code>Normalize</code>的情况只需要对<code>Exponent</code>的最低位增加一个<code>bit</code>即可。注意<code>Subnormal</code>情况<code>Fraction</code>为全<code>1</code>时左移的结果不需要将<code>Exponent</code>清零，按测试用例应该是将<code>Subnormal</code>转化为<code>Normalize</code>了。强调一下移码的意义为<code>IEEE 754</code> Normalize表示部分2的指数部分。<br>$$Bias &#x3D; 2^{Exponent-1}-1$$<br>$$Normalize &#x3D; 1.Fraction \times 2^{Exponent + Bias} (1 \leq Exponent \leq 2^{Exponent} - 2)$$<br>$$Subnormal &#x3D; 0.Fraction \times 2^{1-Bias}$$<br>$$Biased &#x3D; Unsigned - Bias$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> exp_mask = <span class="number">0x7F800000</span>;          <span class="comment">// the eight bits of exponent is all 1.</span></span><br><span class="line">  <span class="type">int</span> Neg_zero = <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="type">int</span> sign_mask = Neg_zero;</span><br><span class="line">  <span class="type">int</span> fraction_mask = <span class="number">0x007FFFFF</span>;</span><br><span class="line">  <span class="keyword">if</span> (!((uf &amp; exp_mask)^exp_mask)) &#123;       <span class="comment">// eliminate the case of NaN.</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!uf) &#123;                     <span class="comment">// eliminate the case of +0.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(Neg_zero^uf)) &#123;          <span class="comment">// eliminate the case of -0.</span></span><br><span class="line">    <span class="keyword">return</span> Neg_zero;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(uf &amp; exp_mask)) &#123;              <span class="comment">// elinimate the case of subnormal.</span></span><br><span class="line">    <span class="keyword">return</span> (uf&amp;sign_mask) + (((uf&amp;fraction_mask)&lt;&lt;<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  uf += (<span class="number">0x1</span>&lt;&lt;<span class="number">23</span>);               <span class="comment">// Normalize.</span></span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-floatFloat2Int"><a href="#12-floatFloat2Int" class="headerlink" title="12. floatFloat2Int"></a><strong>12. floatFloat2Int</strong></h3><p>实现到<code>IEEE754</code>单精度浮点数到定点整数的转换。题目中首先要考虑溢出的情况，早在最开始实验就假设机器左移的位数小于0或者大于31都会出现未知的行为，因此需要将这两种情况包含进去。由于<code>Normalize</code>的<code>M</code>部分是$1.Fraction$因此需要将小数点前面的<code>1</code>提前加入<code>fraction</code>部分。实际上<code>fraction</code>右移<code>23位</code>可以和$2^{Biased}$的指数部分进行相减$2^{Biased-23}$，进行对应的移位操作完成$2^n$幂次运算，最后得到对应的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> bias = <span class="number">1</span>-(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">  <span class="type">int</span> exp_mask = <span class="number">0x7F800000</span>;</span><br><span class="line">  <span class="type">int</span> fraction_mask = <span class="number">0x007FFFFF</span>;</span><br><span class="line">  <span class="type">int</span> fraction = (uf &amp; fraction_mask);</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &amp; exp_mask) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">int</span> sign_bit = (uf&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">int</span> biased = <span class="built_in">exp</span> + bias;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">exp</span>^exp_mask) || biased &gt; <span class="number">31</span>) &#123;  <span class="comment">// NaN and infinity</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!uf || !(uf^<span class="number">0x80000000</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (biased &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">  &#125;</span><br><span class="line">  fraction |= (<span class="number">1</span>&lt;&lt;<span class="number">23</span>);  <span class="comment">// 1.F</span></span><br><span class="line">  <span class="keyword">if</span> (biased &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">    fraction &lt;&lt;= (biased<span class="number">-23</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fraction &gt;&gt;= (<span class="number">23</span>-biased);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sign_bit)</span><br><span class="line">    <span class="keyword">return</span> -fraction;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> fraction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-floatPower2"><a href="#13-floatPower2" class="headerlink" title="13. floatPower2"></a><strong>13. floatPower2</strong></h3><p>给定argument为<code>Biased</code>，求出其对应无符号<code>IEEE 754</code>单精度浮点数的表示即可。求出exp的值之后，左移23到IEEE754规格的exponent域中。认真读题后还是蛮简单的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bias = <span class="number">127</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span> = (x + bias)&lt;&lt;<span class="number">23</span>;  <span class="comment">// x = exp - bias</span></span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-127</span>) &#123;              <span class="comment">// too small(exp are all 0s that is Subnormal)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; (<span class="number">255</span><span class="number">-127</span>)) &#123;  <span class="comment">// too large(the floating point number is larger than INF that exp are all 1s)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x7f800000</span>;         <span class="comment">// +INF</span></span><br><span class="line">    &#125;</span><br><span class="line">    f |= <span class="built_in">exp</span>;    <span class="comment">// normalize</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://pic4.zhimg.com/80/v2-21774eab522096e708d883dc09a4aa25.png" alt="./btest"><br><img src="https://pic4.zhimg.com/80/v2-96d0c54113a6951eed5fe3cbfbba5b5a.png" alt="./dlc"></p>]]></content>
      
      
      <categories>
          
          <category> CMU15-213 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.NULL Video Note</title>
      <link href="/2022/05/16/6-NULL-Video-Note/"/>
      <url>/2022/05/16/6-NULL-Video-Note/</url>
      
        <content type="html"><![CDATA[<!-- # 6.NULL Video Note --><blockquote><p>好的工具总是能带来高的效率</p></blockquote><span id="more"></span><h2 id="VIDEO-1-The-Shell"><a href="#VIDEO-1-The-Shell" class="headerlink" title="VIDEO 1 The Shell"></a><strong>VIDEO 1</strong> The Shell</h2><ol><li><code>cd -</code>将会在和上一次cd的目录来回切换</li><li><code>rm</code>命令默认非递归的删除，因此删除目录时需要加上-r参数(recursive)，才能完整地将目录下的文件删除;而rmdir只能删除空目录</li><li>解释一下常用命令的含义<code>pwd</code>(print work directory), <code>cd</code>(change directory)</li><li>-表示当前没有允许的权限。d表示目录，注意目录的x位表示当前能够访问该目录的内容，且需要保证当前目录的父目录都含有x位才能访问。</li><li>redirect, &lt; 表示重定向输入, &gt; 表示重定向输出. Some example:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> hello &gt; hello.txt</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><code>&gt;&gt;</code>表示追加(append)</li><li><code>ctrl+L</code>清空终端的命令，返回到顶部。</li><li><code>tail -n</code>将数据中的末尾n行显示出来。</li><li>pipe，将两个不相关联的程序连接起来通过input&#x2F;output连接起来,管道的左边作为一个input, 管道的右边作为一个output。</li><li><code>$</code>表示当前运行在用户模式下; <code>#</code>表示当前运行在系统模式下,可以通过命令<code>sudo su</code>来打开root下的terminal.</li><li>xdg-open命令可以打开文件对应的格式</li><li>double quotes: backslash, <code>\</code>前面加个<code>!</code>就不会被默认移除</li><li>shebang是由脚本开头的字符数字符号和感叹号<code>#!</code>组成的字符序列。当带有shebang的文本文件被用作类Unix操作系统的”可执行文件”时，程序加载器机制将文件初始行的其余部分解析为”解释器指令”。它告诉内核用什么来运行此脚本(比如说python or shell?)</li></ol><h2 id="VIDEO-2-Shell-Tools-and-Scripting"><a href="#VIDEO-2-Shell-Tools-and-Scripting" class="headerlink" title="VIDEO 2 Shell Tools and Scripting"></a><strong>VIDEO 2</strong> Shell Tools and Scripting</h2><ol><li>different from the single quote<code>(&#39;)</code> and double quote<code>(&quot;)</code>. echo “”中解析出变量放变量(用<code>$</code>符号来表示)。而单引号不会解析变量。</li><li><ul><li><code>$1</code>到<code>$9</code>表示argv中第一个到第九个参数</li><li><code>$0</code>表示脚本的名字</li><li><code>$_</code>(undersocre)表示上一个command的最后一个参数</li><li><code>$?</code>(question mark)获取上一个command的error code(一般值为<code>0</code>表示ok, <code>1</code>表示执行出错)。</li><li><code>$#</code>(hash)表示参数的个数</li><li><code>$$</code>表示当前进程的ID</li><li><code>$@</code>表示所有参数。</li></ul></li><li><code>!!</code>(bang)代替上一次执行过的command，比如说创建一个目录<code>mkdir ..</code>没有权限，这时候只需要<code>sudo !!</code>, 就会默认表示<code>sudo mkdir ..</code>从而减少了一些重复性的工作。</li><li>;(semicolon)分号可以连接任何命令行。<code>false ; echo &quot;haha&quot;</code></li><li>脚本中变量用双引号引起来<code>&quot;$1&quot;</code>.</li><li>执行脚本<code>source ..</code></li><li>globbing, *(asterisk), {}(curly braces)</li><li><code>tldr</code>(too long, don’t read), 精简版带example的man</li><li><code>test</code>, 查看man手册</li><li><strong>查找文件</strong>:</li></ol><ul><li><code>find</code>查看man手册 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -<span class="built_in">type</span> d</span><br><span class="line"><span class="comment"># 查找所有文件夹路径中包含test的python文件</span></span><br><span class="line">find . -path <span class="string">&#x27;*/test/*.py&#x27;</span> -<span class="built_in">type</span> f</span><br><span class="line"><span class="comment"># 查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="comment"># 查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name <span class="string">&#x27;*.tar.gz&#x27;</span></span><br><span class="line"><span class="comment"># 删除全部扩展名为.tmp 的文件</span></span><br><span class="line">find . -name <span class="string">&#x27;*.tmp&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line"><span class="comment"># 查找全部的 PNG 文件并将其转换为 JPG</span></span><br><span class="line">find . -name <span class="string">&#x27;*.png&#x27;</span> -<span class="built_in">exec</span> convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure></li><li><a href="https://github.com/sharkdp/fd">fd</a>, find的替代物</li><li><code>locate</code>, 只能通过文件名，但速度很快。locate(1)当您只是尝试按名称查找特定文件时会更好，该文件您知道存在，但您只是不记得它的确切位置。find(1)当您有一个重点领域需要检查时，或者当您需要其众多优势中的任何一个时，效果会更好</li></ul><ol start="11"><li><code>shellcheck</code>检查shell脚本的语法。</li><li><strong>查找代码</strong>:<ul><li><code>grep</code></li><li><a href="https://beyondgrep.com/">awk</a></li><li><a href="https://github.com/BurntSushi/ripgrep">rg</a>(ripgrep)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py <span class="string">&#x27;import requests&#x27;</span></span><br><span class="line"><span class="comment"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match <span class="string">&quot;^#!&quot;</span></span><br><span class="line"><span class="comment"># 查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="comment"># 打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>查找shell命令</strong>:</li></ol><ul><li><code>history</code></li><li><code>Ctrl+R</code>, backward search. 搭配<a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a></li></ul><ol start="14"><li><strong>文件夹导航</strong>:<ul><li><code>tree</code></li><li><code>broot</code></li><li><a href="https://github.com/jarun/nnn">nnn</a>, 需要接下来去学习</li></ul></li><li>shell中使用变量需要加<code>&quot;&quot;</code>(double quote), 当变量中含有命令时需要加括号比如<code>&quot;$(pwd)&quot;</code></li><li>进行比较时需要加<code>[[]]</code>双括号，比如说<code>if [[ n -eq 12 ]]; then</code>, <strong>注意</strong>括号左右要有空格否则出错。</li><li><a href="https://linuxhint.com/bash_globbing_tutorial/">globbing</a></li></ol><h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a><strong>Exercise2</strong></h2><ol><li><p>ls</p><ol><li>所有文件（包括隐藏文件<code>ls -a</code></li><li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954) <code>ls -hl</code></li><li>文件以最近访问顺序排序<code>ls -clt</code></li><li>以彩色文本显示输出结果<code>ls --color=always</code></li></ol></li><li><p>设计一个自动化shell。marco函数保存当前工作目录pwd到home目录的一个log文件中，polo函数通过打开log文件中的路径cd跳到之前所保存的目录中。</p><p>方法一:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$HOME</span>/marco_history.log&quot;</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;save pwd <span class="subst">$(pwd)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">   <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(cat $HOME/marco_history.log)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>export</code>可以增加、修改或删除环境变量，仅效力于该次登陆的操作，和第一种方法的时效类似。</p><p>方法二:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">   <span class="built_in">export</span> MARCO=$(<span class="built_in">pwd</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">   <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$MARCO</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>shell表达式计算的格式为两个<code>(())</code>以及一些逻辑表达式的规范见<a href="https://ss64.com/bash/syntax-brackets.html">此处</a>。关于给的test中的语句中<code>&gt;&amp;2</code>以及一些重定向的问题<a href="https://askubuntu.com/questions/959066/what-does-mean-exactly-in-output-redirection">此处</a>给出了答案。<code>&gt;&amp;2</code>表示<code>2</code>是个文件描述符，不是<code>文件名</code>, 因为重定向的对象是文件名; <code>&amp;&gt;</code>则表示同时发送，比如<code>1&amp;&gt;2</code>表示标准输出和标准错误同时输出。</p><p>for循环的格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> u=rwx ./test.sh</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ./test.sh 2&gt; out.log</span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;failed after <span class="variable">$count</span> times&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> out.log</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">   ((count++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>shellcheck建议增加一行<code>mycmd=$?</code>, 用<code>mycmd</code>来代替<code>$?</code></p></li><li><p>利用xargs命令完成一些操作。xargs命令将标准输入的内容作为参数。<a href="https://unix.stackexchange.com/questions/368753/what-does-this-command-with-a-backslash-at-the-end-do">此处</a>有关于<code>find</code>后的<code>/</code>的作用，目的是方便为了遇到换行符<code>\n</code>停止解析?? <code>tar</code>命令，压缩文件<code>tar -czvf</code>, 解压文件<code>tar -xzvf</code>, <code>-c</code>表示创建备份文件，<code>-x</code>表示从备份文件中还原文件。<code>-f</code>表示指定备份文件, <code>-v</code>表示显示verbose, <code>-z</code>表示<code>--gzip</code>或<code>--ungzip</code> 通过<code>gzip</code>指令处理备份文件。<code>xargs</code>的<code>-d</code>参数后面跟字符表示修改xargs的分隔符(默认为空白字符tab、空格、换行符)。</p><p>方法一, <code>xargs -d &#39;\n&#39;</code>指定输入遇到换行符结束:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&#x27;*.html&#x27;</span> -<span class="built_in">type</span> f | xargs -d <span class="string">&#x27;\n&#x27;</span> tar -cxzf html.zip</span><br></pre></td></tr></table></figure><p>方法二, <code>find -print0</code>打印文件名到标准输出后后面自动跟个<code>null</code>; <code>xargs -0</code>输入遇到<code>null</code>则终止代替空格:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&#x27;*.html&#x27;</span> -<span class="built_in">type</span> f -print0 | xargs -0 tar -cxzf html.zip</span><br></pre></td></tr></table></figure></li><li><p>找出当前文件夹下最近使用的文件, 并按照最近使用的时间列出文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="built_in">type</span> -f | xargs <span class="built_in">ls</span> -tl | head-1 </span><br></pre></td></tr></table></figure></li></ol><h2 id="VIDEO-3-Editors-Vim"><a href="#VIDEO-3-Editors-Vim" class="headerlink" title="VIDEO 3 Editors(Vim)"></a><strong>VIDEO 3</strong> Editors(Vim)</h2><ol><li><code>v</code>进入可视化模式; <code>V</code>进入可视化<strong>行模式</strong>; <code>^v</code>(<code>Ctrl + v</code>)进入可视化<strong>块模式</strong></li><li>Vim大量使用<code>Esc键</code>，因此建议将<code>大小写锁定键</code>设置为<code>Esc键</code>, 可以在ubuntu下使用<a href="https://medium.com/@ahmaddynugroho/swap-caps-lock-and-escape-in-ubuntu-19-10-and-use-esc-easily-in-vim-vs-code-1d3d68f18764">gnome-tweaks</a>来配置交换修改大小写和Esc, 这里面同样介绍了VScode下的配置</li><li>Vim 会维护一系列打开的文件，称为“缓存<code>buffer</code>”。一个 Vim 会话包含一系列标签<code>tab</code>页，每个标签页包含 一系列窗口（分隔面板）。每个窗口显示一个缓存。</li><li><code>:qa</code>全部退出, <code>:wq</code>等价于<code>:x</code></li><li><code>:tabnew</code>;</li><li><code>:e &lt;文件名&gt;</code>打开要编辑的文件</li><li><ul><li><code>w</code>移动一个单词</li><li><code>b</code>回退一个单词</li><li><code>e</code>移动到单词末尾, 可以搭配<code>a</code>在光标之后插入文本。</li><li><code>^</code>移动到行首字符</li><li><code>$</code>移动到行尾字符</li><li><code>0</code>移动到行首字符前</li><li><code>^U</code>上翻页</li><li><code>^D</code>下翻页</li><li><code>gg</code>移动到最后一行</li><li>输入<code>number</code>+<code>G</code>则直接跳转到文件中的某一指定行。若不输入<code>number</code>则直接跳到文件第最后一行。</li><li><code>H</code>屏幕首行</li><li><code>M</code>屏幕中间</li><li><code>L</code>屏尾巴行</li></ul></li><li>[<code>f</code>|<code>F</code>|<code>t</code>|<code>T</code>][alpha], find和to功能来找到相应的字母</li><li><code>^g</code>显示当前编辑文件中当前光标所在行位置以及文件状态信息。</li><li><code>u</code>undo, <code>U</code>撤销在一行中做出的所有改动 ;<code>^r</code> redo</li><li><code>d</code>操作会将删除的内容放入vim中的寄存器中, 以便<code>p</code>操作时粘贴。<ul><li><code>de</code>删除从光标处到单词尾</li><li><code>dw</code>删除一个单词</li><li><code>d</code>+上<code>hjkl</code>方向可以删除需要的内容</li></ul></li><li><code>c</code>change，功能类似于<code>d</code>，只是操作<code>c</code>会进入<code>insert</code>模式</li><li>在词尾插入<code>e</code>移动到词尾，随后<code>a</code>在当前词尾插入</li><li><code>x</code>删除当前光标所处的字符, 如果在可视模式下就删除选中部分</li><li><code>r</code>replace, 如<code>ra</code>将当前字符替换为a; <code>R</code>则可以连续替换多个字符。</li><li><code>y</code>yank, <code>p</code>paste, <code>yw</code> copy one word, 都可以搭配可视化<code>v</code>来使用。</li><li><code>~</code>改变字母的大小写</li><li><code>[num[h|j|k|l]</code>, 如<code>4j</code>向下移动四次</li><li>modifier, <code>i</code>指的是<code>inner</code>, <code>a</code>指的是<code>around</code><ul><li><code>ci(</code> 改变当前括号内的内容</li><li><code>ci[</code> 改变当前方括号内的内容</li><li><code>da&#39;</code> 删除一个单引号字符串，包括周围的单引号</li></ul></li><li><code>%</code>在配对的括号(parenthese)如:<code>), ], &#125;</code>之间来回切换。在程序调试时用来找不配对的括号是很有用的。</li><li><code>/</code>后紧随一个字符串是在当前所编辑的文档中<code>正向查找</code>改字符串; <code>?</code>则与<code>/</code>相反，是反向查找。<code>:set ic</code>可以忽略大小写(<code>Ignore Case</code>)会在接下来的查找中持续, <code>:set noic</code>则忽略大小写; <code>:set hls</code>搜索时设置高亮显示, 移除匹配项的高亮显示<code>nohlsearch</code>; <code>:set is</code>(incsearch)查找短语时显示部分匹配, <code>:set noic</code>。</li><li><a href="https://vimways.org/2019/">每日一个vim小技巧</a></li><li>安装并配置插件</li><li>Windows下映射CapsLock到ESC需要用到<code>autohotkey</code>脚本工具，添加语句<code>Capslock::Esc</code>即可</li><li><code>^o</code>回退到光标之前的位置，<code>^i</code>跳转到较新的位置。</li><li><code>s</code> is substitution. The first argument is search string, the second is replacement string.<ul><li>输入<code>:s/old/new</code>则只将光标所在行的第一个串<code>old</code>修改为<code>new</code>-</li><li>输入<code>:s/old/new/g</code>则将全行的匹配串<code>old</code>修改为<code>new</code>。</li><li><code>:%s/old/new/g</code>则替换整个文件中的每个匹配串。</li><li><code>:%s/old/new/gc</code>则会在替换时询问。</li><li><code>:#,#s/old/new/g</code>其中<code>#, #</code>代表的是替换操作的若干行中首尾两行的行号</li></ul></li><li>在vim内执行外部命令的方法，输入<code>:!</code>然后紧接着输入外部的<code>shell</code>命令，如:<code>:!ls</code>，回车结束显示。</li><li>可以搭配可视模式将部分内容<code>:w &lt;filename&gt;</code>写到文件名中。</li><li>将磁盘文件内容提取到当前光标行<code>:r &lt;filename&gt;</code>.</li><li><code>:sp</code>分割窗口，<code>^w ^w</code>(double w)在窗口之间来回切换.</li><li><code>F1</code>或者<code>:help</code>打开帮助文档。下面这些参数可以得到该主题的帮助<ul><li><code>:help w</code></li><li><code>:help c_CTRL-D</code></li><li><code>:help insert-index</code></li><li><code>:help user-manual</code>，阅读Vim的用户手册。</li></ul></li><li><code>.</code>(period)会完成重复性的工作。</li><li>vim命令的补全功能，例如输入<code>:e</code>, 然后按下<code>^D</code>键, Vim会显示以e开始的命令的列表, 接着按下<code>&lt;tab&gt;键</code>会自动自动补全命令。</li><li><code>q:</code> | <code>q?</code>查看vim中的历史命令</li><li>从vim8.0版本开始安装插件只需要将插件<code>git clone</code>到<code>~/.vim/pack/vendor/start/</code>文件里就行。</li></ol><h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a><strong>Exercise3</strong></h2><ol><li><p><code>vimtutor</code></p></li><li><ul><li>创建文件<code>~/.vimrc</code>能够获得更多的特性。了解更多信息可以输入<code>:help vimrc-intro</code></li><li>文件中注释使用<code>&quot;</code></li><li><code>set nocompatible</code>从默认的<code>Vi</code>兼容模式切换到激活<code>Vim</code>的功能。如果<code>vimrc</code>文件存在它就会默认设置<code>nocompatible</code>, 包含这一条语句是为了以防以一些别的方式加载配置文件。</li><li><code>syntax on</code>打开语法高亮</li><li><code>set shortmess+=I</code>禁止Vim默认的启动信息<code>:intro</code>，也就是解释vim的版本，以及该如何使用。</li><li><code>set number</code>在vim中显示行数</li><li><code>set relativenumber</code>显示与当前行的行号和与其相对的行号，其实<code>set number</code>也可以不用加了</li><li><code>set laststatus=2</code>在vim底部显示当前状态。<code>2</code>表示不管存在几个窗口总是显示状态栏。</li><li><code>set backspace=indent,eol,start</code>。设置backspace的属性，感觉好像vim兼容了对默认情况，经过测试这一行语句似乎没有什么实质性的作用。</li><li><code>set hidden</code>可以告诉Vim你拥有未显示在屏幕上未保存的工作,  多一条提示信息。</li><li><code>set ignorecase</code>不区分大小写</li><li><code>set smartcase</code>只能在<code>ignorecase</code>，它会使得区分大小写更智能。</li><li><code>incsearch</code>使用<code>/</code>搜索时会实时搜索，而不是等到Enter键按下时才进行搜索。</li><li><code>nmap Q &lt;Nop&gt;</code>对按键Q的解绑操作，按键Q会进入Ex mode, <code>&lt;Nop&gt;</code>意为无操作, 且<code>nmap</code>和<code>nnoremap</code>是等价的。<code>nmap</code>是在Normal模式下使用，详情可见<code>:h map-modes</code>。</li><li><code>set noerrorbells visualbell t_vb=</code>, disable Vim的bell beeping。</li><li><code>set mouse+=a</code>鼠标支持, 方便进入可视化选择。<code>a</code>表示all previous modes。应用在vim中的所有五个模式。</li><li><code>nmap &lt;Left&gt; :echoe &quot;Use h&quot;&lt;CR&gt;</code>来使用户养成在Normal模式下使用h来左移的习惯。</li><li><code>imap &lt;Left&gt; &lt;ESC&gt;:echoe &quot;Use h&quot;&lt;CR&gt;</code>来使用户养成在Insert模式下使用h来左移的习惯，若在Insert模式下使用方向键Left，则回到Normal模式并提示信息”Use h”。因为Vim中的命令行换行是以<code>CR</code>来结尾的(也就是敲完命令需要敲回车换行)才能执行该echo命令回显信息, <code>echoe</code>回显的是错误信息，会加上红色高亮。</li></ul></li><li><p>如果创建多级目录的路径不存在则自动创建<code>mkdir -p</code>使用参数<code>p</code>。安装和配置插件内含帮助文档<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md"> ctrlp.vim</a></p><ul><li><code>^P</code>打开模糊搜索</li><li><code>c-d</code>切换搜索路径和文件的模式</li><li><code>c-t</code>打开该文件作为新的tab; <code>c-v</code>打开该文件分割列; <code>c-x</code>打开该文件分割行; 个人认为这些tmux都可以替代。</li><li><code>c-n</code>和<code>c-p</code>选择next&#x2F;previous在ctrlp中的搜索记录</li><li>在ctrlp中输入<code>:help ctrlp-mappings</code>查看更多映射的帮助</li><li>查找到文件后加<code>:25</code>即可跳到该文件的25行</li></ul></li><li><p>使用Chrome上的<code>vimium</code>有关Vim的插件。</p><ul><li><code>j</code>和<code>k</code>上下移动网页, <code>d</code>和<code>u</code>以翻页的形式上下移动网页, <code>h</code>和<code>l</code>左右移动网页</li><li>同样可以像vim一样前缀加上数字，比如<code>4j</code>等。也可以<code>gg</code>跳至网页头和<code>G</code>跳至网页尾</li><li><code>f</code>通过标签打开当前网页超链接到当前的tab上，<code>F</code>则打开到新的tab上。</li><li>当前tab历史的前进<code>L</code>和回退<code>H</code></li><li>在打开的网页tab之间切换，上一个<code>J</code>, 下一个<code>K</code></li><li>关闭当前标签页<code>x</code>, <code>X</code>恢复关闭的tab</li><li>在历史标签中搜索<code>o</code>，<code>ESC</code>退出</li><li>若标签页太多,可以使用<code>T</code>在已有的标签之中搜索，<code>ESC</code>退出</li><li><code>?</code>打开<code>Vimium</code>的帮助文档。</li><li><code>r</code>(Reload)刷新当前网页</li><li><code>yy</code>将当前的URL复制到剪切板，<code>p</code>将剪切板上的URL在当前tab中打开，<code>P</code>则在新的tab中打开</li><li><code>gi</code>将光标焦距到当前网页的第一个输入栏(即搜索栏)</li><li><code>b</code>搜索书签打开到当前tab，<code>B</code>打开到新的tab中</li><li><code>/</code>在当前网页中使用匹配， 搭配<code>n</code>和<code>N</code></li><li><code>t</code>创建新的tab</li><li><code>alt+p</code>，pin和unpin当前tab</li><li><code>alt+m</code>, 静音和解除静音当前tab</li></ul></li><li><p>(待做)<code>XML</code>转<code>JSON</code><br>, <code>:wq</code>等价于<code>:x</code></p><h2 id="VIDEO-4-Data-Wangling-TODO"><a href="#VIDEO-4-Data-Wangling-TODO" class="headerlink" title="VIDEO 4 Data Wangling (TODO)"></a><strong>VIDEO 4</strong> Data Wangling (TODO)</h2></li><li><p>正则表达式通常以<code>/</code>开始和结束。正则表达式在线调试工具<a href="https://regex101.com/r/qqbZqh/2">regex debugger</a></p><ul><li><code>.</code>除换行符之外的”任意单个字符”</li><li><code>*</code>匹配前面字符零次或多次</li><li><code>+</code>匹配前面字符一次或多次</li><li><code>[abc]</code>匹配<code>a</code>,<code>b</code>和<code>c</code>中任意一个, 在括号中使用<code>^</code>即为非</li><li><code>(RX1|RX2)</code>任何能够匹配<code>RX1</code>或<code>RX2</code>的结果</li><li><code>^</code>行首</li><li><code>$</code>行尾</li></ul></li><li><p><code>sed</code>命令</p><ul><li><code>-E</code>参数支持对正则表达式的拓展</li></ul></li><li><p><code>uniq</code>命令去除重复行</p><ul><li><code>-c</code>参数输出过滤后的行数</li></ul></li><li><p><code>sort</code>命令按照数字顺序对输入进行排序(默认情况下是按照字序列排序)</p><ul><li><code>-r</code>参数进行倒序排序</li><li><code>-n</code>参数表示仅排序到第<code>n</code>个部分</li></ul></li><li><p><code>awk</code>编辑器, <code>awk</code>其实是一种编程语言具体可以查看<code>man awk</code>和<code>tldr awk</code></p></li><li><p>学习一下<a href="https://regexone.com/lesson/introduction_abcs">交互式正则表达式教程</a></p></li></ol><h2 id="VIDEO-6-Version-Control-Git"><a href="#VIDEO-6-Version-Control-Git" class="headerlink" title="VIDEO 6 Version Control(Git)"></a><strong>VIDEO 6</strong> Version Control(Git)</h2><ol><li>Git中的对象可以是blob(数据对象)、Tree或Commit</li><li>所有的snapshot都可以用<a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1哈希</a>(40位的十六进制字符)来标记，但显然<code>Reference</code>更方便。</li><li><code>HEAD</code>引用可以通过两种方式查看, <code>cat .git/HEAD</code>; <code>git symbolic-ref HEAD</code>。</li><li><strong>基础</strong><ul><li><code>git help &lt;command&gt;</code>:获取git命令的帮助信息</li><li><code>git init</code>:创建一个新的git仓库，其数据会存放在一个名为<code>.git</code>的目录下</li><li><code>git status</code>:显示当前仓库的状态</li><li><code>git add &lt;filename&gt;</code>:添加文件到暂存区(staging Area)</li><li><code>git commit</code>:创建一个新的提交; 如何编写<a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>, 为什么要<a href="https://cbea.ms/git-commit/">编写良好的提交信息</a></li><li><code>git</code>的提交信息<ol><li>用空行将主体与主体分开</li><li>将主题行限制为50个字符</li><li>将主题行大写</li><li>不要以句点结束主题行</li><li>在主题行中使祈使句语句</li><li>将正文包裹在72个字符处</li><li>用正文来解释<code>what</code> <code>why</code> vs. <code>how</code></li></ol></li><li><code>git log</code>:显示日志历史</li><li><code>git log --all --graph --decorate</code>:可视化历史记录(有向无环图)</li><li><code>git diff &lt;filename&gt;</code>:显示与暂存区文件的差异</li><li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>:显示某个文件两个版本之间的差异</li><li><code>git checkout &lt;revision&gt;</code>:更新HEAD和目前的分支</li></ul></li><li><strong>分支和合并</strong><ul><li><code>git branch</code>:显示分支</li><li><code>git branch &lt;name&gt;</code>:创建分支</li><li><code>git checkout -b &lt;name&gt;</code>:创建分支并切换到该分支, 相当于<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li><li><code>git merge &lt;revision&gt;</code>:合并到当前分支</li><li><code>git mergetool</code>:使用工具来处理合并冲突</li><li><code>git rebase &lt;name&gt;</code>:创建更线性的提交历史</li></ul></li><li><strong>远端操作</strong><ul><li><code>git remote</code>:列出远端</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>:添加一个远端</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>:将对象传送至远端并更新远端引用</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>:创建本地和远端分支关联关系</li><li><code>git fetch</code>:从远端获取对象</li><li><code>git pull</code>:相当于<code>git fetch; git merge</code></li><li><code>git clone &lt;url&gt; &lt;name&gt;</code>:从远端下载仓库并命名为name</li></ul></li><li><strong>撤销</strong><ul><li><code>git commit --amend</code>:编辑提交的内容或信息</li><li><code>git reset HEAD &lt;file&gt;</code>:恢复暂存的文件</li><li>&#96;git checkout – <file>:丢弃修改</file></li></ul></li><li><strong>Git高级操作</strong><ul><li><code>git config</code>:Git是一个<a href="https://git-scm.com/docs/git-config">高度可定制</a>的工具</li><li><code>git clone --depth=1</code>:浅克隆(shallow clone), 不包括完整的版本历史信息</li><li><code>git add -p</code>:交互式暂存</li><li><code>git blame</code>:查看最后修改某行的人</li><li><code>git stash</code>:暂时移除工作目录下的修改内容</li><li><code>git stash pop</code>:恢复工作目录下的修改内容</li><li><code>git bisect</code>:通过二分查找搜索历史记录</li><li><code>.gitignore</code>:<a href="https://git-scm.com/docs/gitignore">指定</a>故意不追踪的文件</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 6.NULL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile Note</title>
      <link href="/2022/05/16/Makefile-Note/"/>
      <url>/2022/05/16/Makefile-Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux工程构建必备工具</p></blockquote><span id="more"></span><p>参考<a href="https://seisman.github.io/how-to-write-makefile/introduction.html">跟我一起写Makefile</a>做点笔记。</p><ul><li><p>第一个<code>target</code>为<code>make</code>的默认目标</p></li><li><p><code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>command</code>所定义的命令就会被执行。<strong>且会在执行命令之前先看依赖是否存在，若不存在则会在makefile文件中向下查找(其他规则为第一条规则服务)</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command(shell命令)</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>最开始的实例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure></li><li><p>为了复用可以在<code>Makefile</code>中使用<code>shell</code>的变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></li><li><p><code>make</code>会自动推导命令，只要<code>Make</code>看到一个<code>.o</code>文件，它就会自动地把<code>.c</code>文件加在依赖关系中。并且command <code>cc -c xxx.c</code>也会被自动推导出来</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></li><li><p>更稳健的<code>clean</code>写法: </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean <span class="comment"># `.PHONY`表示`clean`是个伪目标文件</span></span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></li><li><p><code>Makefile</code>中主要包含的五部分:</p><ul><li>显示规则, 显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</li><li>隐晦规则, 由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。</li><li>变量的定义</li><li>文件指示, 即<code>Makefile</code>可以使用<code>include</code>将其他makefile包含进来。<code>filename</code>可以用一个或多个空格隔开。如: <code>include foo.make a.mk b.mk c.mk e.mk f.mk</code>。</li><li>注释，和shell一样使用<code>#</code>。</li></ul></li><li><p><code>make</code>命令开始时，会寻找<code>include</code>所指出的其它<code>Makefile</code>，并把其内容安置在当前的位置。如果还没找到则在当前目录找。如果还是没找到则在以下几个目录找:</p><ul><li>make命令开始时，会找寻 include 所指出的其它Makefile，并把其内容安置在当前的位置</li><li>如果目录 <prefix>&#x2F;include （一般是： &#x2F;usr&#x2F;local&#x2F;bin 或 &#x2F;usr&#x2F;include ）存在的话，make也会去找。</prefix></li></ul><p>如果还没找到则会生成警告信息，随后报错。可以在前面加个减号<code>-include &lt;filename&gt;</code>来告诉make无论出现什么错误，都不要报错，继续执行。</p></li><li><p>GNU的make工作时的执行步骤:</p><ol><li>读入所有的Makefile。</li><li>读入被include的其它Makefile。</li><li>初始化文件中的变量。</li><li>推导隐晦规则，并分析所有规则。</li><li>为所有的目标文件创建依赖关系链。</li><li>根据依赖关系，决定哪些目标要重新生成。</li><li>执行生成命令。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim+vscode+tmux+gdb</title>
      <link href="/2022/05/16/vim-vscode-tmux-gdb/"/>
      <url>/2022/05/16/vim-vscode-tmux-gdb/</url>
      
        <content type="html"><![CDATA[<!-- # vim+vscode+tmux+gdb+git --><blockquote><p>个人的一些认为比较常用以及不经常用到的的快捷操作</p></blockquote><span id="more"></span><h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a><strong>vscode</strong></h2><ol><li>查找文件ctrl+p， esc退出</li><li>分割屏幕ctrl+\，通过ctrl+1&#x2F;2&#x2F;3来切换分割屏幕的焦点</li><li>ctrl+&#96; 打开&#x2F;关闭终端</li><li>ctrl+tab, 在tab之间切换</li><li>模糊查找当前工作目录下的所有文件ctrl+p, #</li><li>Ctrl + Shift + Tab 导航tab</li><li>alt + &lt;-&#x2F;-&gt;切换tab</li></ol><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a><strong>vim</strong></h2><ol><li>跳转到指定行号n, ngg</li><li>复制整行 yy, 复制包括当前行接下来n行， nyy</li><li>复制指定行v模式下指定复制内容，然后y键复制。</li><li>粘贴<br> 如复制内容不是一整行：p粘贴到当前光标处，P粘贴到当前行首。<br> 如复制内容是一整行：p粘贴到当前行的下一行，P粘贴到当前行的上一行</li><li>剪切dd</li><li>在当前文件查找指定内容，&#x2F;+内容</li><li>ctrl+] 跳转到函数的定义处，ctrl+t返回上一次光标处</li><li>u撤销，ctrl+r恢复</li><li><code>^y</code>向上移动一行, <code>^e</code>向下移动一行</li><li><code>^b</code>向上移动一页，<code>^f</code>向下移动一页</li><li>number + shift + G, 跳到第number行 </li><li>在<code>tab</code>之间切换, <code>Alt</code>+<code>number</code>.</li><li>可视条件下选中后<code>&lt;</code>或<code>&gt;</code>完成缩进。</li><li>要想跳转到函数定义处，需要在项目目录中输入<code>ctags -R</code>命令。<code>ctrl+]</code>跳转, <code>ctrl+o</code>返回。</li><li>可视模式下注释+<code>d</code>。</li><li>替换变量名<code>:%s/foo/bar/g</code>将整个文件中的<code>foo</code>替换为<code>bar</code></li><li>在vim文件内使用shell命令<code>:! command</code></li><li>在当前文件中打开另一个文件<code>:e file</code></li><li>在Vim中编译代码<code>:!gcc %</code>, 编译并运行代码<code>:!gcc % || ./a.out</code></li><li><code>dw</code>删除一个词</li><li><code>I</code>将光标跳转到行首并进入<code>Insert</code>模式</li></ol><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a><strong>tmux</strong></h2><ol><li>任何命令都需要加ctrl+b前缀</li><li>c创建窗口；n, p切换窗口</li><li>%垂直分屏, “水平分屏</li><li>x关闭窗口(等同于^d)</li><li>o在窗口之间切换</li><li>PgUp开启tmux终端界面的翻页，q退出。</li></ol><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a><strong>gdb</strong></h2><ol><li>delete 删除所有断点</li><li>layout src&#x2F;reg&#x2F;asm 显示c源代码、寄存器和汇编，但未分屏；focus src&#x2F;reg&#x2F;asm在src、reg和asm的tui中来回切换</li><li>layout split获得c和asm的分屏。</li><li>info&#x2F;i frame 查看栈帧, info&#x2F;i args查看传递给main的参数, i locals显示当前的本地变量。</li><li>通过backtrace查看栈帧，frame n(n为bt结果的栈帧号)，然后i frame查看当前栈帧号的详细内容</li><li>print&#x2F;p查看argv数据;print&#x2F;p *argv(默认打印一个参数);可以通过print&#x2F;p *argv@n 来选择argv数组中的n个元素即参数; p *argv@argc打印所有参数</li><li><code>print</code>是打印值，<code>x</code>是访问主存。</li><li><code>Ctrl + x</code>，再按1：单窗口模式，显示一个窗口</li><li><code>Ctrl + x</code>，再按2：双窗口模式，显示两个窗口</li><li><code>Ctrl + x</code>，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。</li><li><code>^x+a</code>关闭可视化</li><li><code>wa</code>跟踪某个变量(watch point)</li></ol><h2 id="lt-gt-gdb续"><a href="#lt-gt-gdb续" class="headerlink" title="&lt;&gt;(gdb续)"></a><strong>&lt;<Debug hacks>&gt;(gdb续)</Debug></strong></h2><ol><li><code>break/b</code><ul><li><code>break 函数名</code></li><li><code>break 行号</code></li><li><code>break 文件名:行号</code></li><li><code>break 文件名:函数名</code></li><li><code>break +偏移量</code></li><li><code>break -偏移量</code></li><li><code>break *地址</code></li><li><code>break 断点 if 条件</code></li><li>若不指定位置就默认在下一行代码上设置断点</li><li><code>info break</code>显示断点信息</li></ul></li><li><code>run/r</code>, 如果不加参数，执行到断点位置后暂停运行(和start命令一样的效果)</li><li><code>print/p</code><ul><li><code>p $eax</code>，显示寄存器(寄存器名前加$)</li></ul></li><li><code>p/格式 变量</code>, 显示寄存器可用的格式:<ul><li>x, 显示为十六进制数</li><li>d, 显示为十进制数</li><li>u, 显示无符号十进制数</li><li>o, 显示八进制数</li><li>t, 显示二进制数(two)</li><li>a, 显示地址</li><li>c, 显示为字符</li><li>f, 浮点小数</li><li>s, 显示为字符串</li><li>i, 显示为机器语言</li></ul></li><li><code>x/NFU ADDR</code>, 显示内存的内容(eXamining):<ul><li><code>N</code>为重复次数</li><li><code>F</code>为上述的P格式</li><li><code>U</code>代表的单位：<ul><li>b, 字节</li><li>h, 半字</li><li>w, 字(4字节默认)</li><li>g, 双字</li></ul></li></ul></li></ol><h2 id="cgdb"><a href="#cgdb" class="headerlink" title="cgdb"></a><strong>cgdb</strong></h2><ol><li>使用<code>i</code>切换到<code>GDB command</code>，<code>esc</code>切换到<code>source window</code>。</li><li>在<code>source window</code>下，可以像<code>vim</code>一样用<code>\</code>匹配内容， 且移动到指定行按下<code>space</code>可以可视化打断点。</li><li><code>q</code>或者<code>^c+d</code>退出<code>gdb</code></li><li>调整<code>source window</code>的大小, <code>-</code>缩小一行，<code>=</code>增加一行。</li><li>在<code>source window</code>下<code>^w</code>窗口水平竖直分割切换。</li><li><code>F5</code> &#x3D; <code>run</code>, <code>F6</code> &#x3D; <code>continue</code>, <code>F7</code> &#x3D; <code>finish</code>, <code>F8</code> &#x3D; <code>next</code>, <code>F10</code> &#x3D; <code>step</code>。</li><li><code>CGDB</code>的配置, 在<code>~/.cgdb/</code>目录下创建<code>cgdbrc</code>文件并编辑。如果<code>cgdbrc</code>文件存在，<code>CGDB</code>就会执行该文件中的每一行。<ul><li><code>:set disasm</code>，以汇编语言的形式显示。</li><li><code>:set hls</code>，高亮显示匹配到的字符串</li><li><code>:set syn=style</code>设置当前文件对应语法风格的高亮。</li></ul></li></ol><h2 id="git"><a href="#git" class="headerlink" title="git"></a><strong>git</strong></h2><ul><li><code>git clone -b branch XXX</code>克隆指定分支的代码</li><li><code>git reset --hard 1a703e</code>回滚到某个历史commit</li><li><code>git branch -m &lt;branchName&gt;</code>将当前分支名更改为branchName</li><li><code>git checkout -b &lt;newbranch&gt;</code>创建新分支并切换到新分支</li><li><code>git diff</code>查看修改的差异</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Cpp Note</title>
      <link href="/2022/05/16/cpp%20Note/"/>
      <url>/2022/05/16/cpp%20Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工业级的Cpp语法</p></blockquote><span id="more"></span><h2 id="一、std-function和bind绑定器"><a href="#一、std-function和bind绑定器" class="headerlink" title="一、std::function和bind绑定器"></a>一、std::function和bind绑定器</h2><h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><ul><li>是一个函数指针</li><li>是一个具有<code>operator()</code>成员函数的类对象（仿函数）</li><li>是一个可被转换为函数指针的类对象</li><li>是一个类成员（函数）指针</li></ul><h3 id="可调用对象包装器std-funtion"><a href="#可调用对象包装器std-funtion" class="headerlink" title="可调用对象包装器std::funtion"></a>可调用对象包装器std::funtion</h3><ul><li>头文件<code>&lt;functional&gt;</code></li><li>可以容纳除了类成员（函数）指针之外的所有可调用对象</li><li>可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们</li><li><code>function</code>比普通函数指针更灵活和便利</li></ul><h3 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h3><ul><li>头文件<code>&lt;functional&gt;</code></li><li>接受一个可调用对象，生成一个新的可调用对象</li><li><code>std::bind</code>用来将可调用对象与其参数一起进行绑定，绑定后的结果可以使用<code>std::function</code>进行保存，并延迟调用到任何我们需要的时候</li><li>作用<ul><li>将可调用对象与其参数一起绑定成一个仿函数(functor)</li><li>将多元（参数个数为n）可调用对象转成一元或者（n-1）元可调用对象，却只绑定部分参数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();  <span class="comment">// 输出：1 2</span></span><br><span class="line">std::<span class="built_in">bind</span>(output, std::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);  <span class="comment">// 输出 ：1 2</span></span><br><span class="line">std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_1)(<span class="number">1</span>);  <span class="comment">// 输出 ：2 1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><code>std::bind</code>的返回类型是一个stl内部定义的仿函数类型</li><li><code>std::placeholders::_1</code>是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代</li><li>组合bind函数<ul><li><code>std::bind(std::greater&lt;int&gt;(), std::placeholders::_1, 5);</code><ul><li>判断是否大于5的功能闭包</li></ul></li></ul></li></ul><h3 id="C-11通过提供std-function和std-bind统一了可调用对象的各种操作"><a href="#C-11通过提供std-function和std-bind统一了可调用对象的各种操作" class="headerlink" title="C++11通过提供std::function和std::bind统一了可调用对象的各种操作"></a>C++11通过提供std::function和std::bind统一了可调用对象的各种操作</h3><h2 id="二、lambda表达式"><a href="#二、lambda表达式" class="headerlink" title="二、lambda表达式"></a>二、lambda表达式</h2><h3 id="语法形式"><a href="#语法形式" class="headerlink" title="语法形式"></a>语法形式</h3><ul><li><code>[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</code></li><li>C++11允许省略lambda表达式返回值定义，这样编译器就会根据<code>return</code>语句自动推导出返回类型<ul><li>初始化列表不能用于返回值的自动推导</li></ul></li><li>lambda表达式在没有参数列表时，参数列表是可以省略的</li></ul><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><ul><li><code>[]</code>不捕获任何变量</li><li><code>[&amp;]</code>捕获外部作用域中所有变量，并作为引用在函数体中使用（引用捕获）</li><li><code>[=]</code>捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）</li><li><code>[=, &amp;foo]</code>按值捕获外部作用域中所有变量，并按引用捕获foo变量</li><li><code>[bar]</code>按值捕获bar变量，同时不捕获其他变量</li><li><code>[this]</code>捕获当前类中的指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了<code>&amp;</code>或者<code>=</code>，就默认添加此选项</li><li>如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为<code>mutable</code>，如：<code>auto f2 = [=]() mutable &#123;return a++; &#125;</code></li></ul><h3 id="可以认为它是个带有operator-的类，即仿函数"><a href="#可以认为它是个带有operator-的类，即仿函数" class="headerlink" title="可以认为它是个带有operator()的类，即仿函数"></a>可以认为它是个带有operator()的类，即仿函数</h3><ul><li>可以使用<code>std::function</code>和<code>std::bind</code>来存储和操作lambda表达式  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f1 = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">void</span>)&gt; f2 = std::<span class="built_in">bind</span>([](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;, <span class="number">123</span>);</span><br></pre></td></tr></table></figure></li><li>对于没有捕获任何变量的lambda表达式，还可以被转换成一个普通的函数指针  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">int</span> (*)(<span class="type">int</span>);</span><br><span class="line"><span class="type">func_t</span> f = [](<span class="type">int</span>  a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></li><li>捕获变量的lambda表达式则不能转化为普通指针，若转换，lambda表达式本身的this指针就丢失掉了</li><li>lambda和<code>std::function</code>的效果是一样的，一般情况下可直接用lambda来代替<code>function</code></li></ul><h2 id="三、tuple元组"><a href="#三、tuple元组" class="headerlink" title="三、tuple元组"></a>三、tuple元组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>可以把它当作一个通用的结构体来用，不需要创建结构体又获取结构体的特征</li><li>在某些情况下可以取代结构体，使程序更简洁、直观</li><li>如果用tuple来替代3个以上字段的结构体时就不太合适了，不直观，易读性降低（建议）</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>创建元组<ul><li><code>tuple&lt;const char*, int&gt; tp = make_tuple(sendPack, nSendSize);</code></li><li><code>auto tp = return std::tie(1, &quot;aa&quot;, 2);</code>  &#x2F;&#x2F; tp的实际类型是：std::tuple&lt;int&amp;, string&amp;, int&amp;&gt;</li></ul></li><li>获取元组的值  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* data = tp.<span class="built_in">get</span>&lt;<span class="number">0</span>&gt; ();  <span class="comment">// 获取第一个值</span></span><br><span class="line"><span class="type">int</span> len = tp.<span class="built_in">get</span>&lt;<span class="number">1</span>&gt; ();  <span class="comment">// 获取第二个值</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>std::tie</code>解包tuple  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">string a;</span><br><span class="line">std::<span class="built_in">tie</span>(x, a, y) = tp;</span><br></pre></td></tr></table></figure><ul><li>如果只想了解某个位置的值时，可以用<code>std::ignore</code>占位符来表示不解某个位置的值<br>  <code>std::tie(std::ignore, std::ignore, y) = tp;</code>  &#x2F;&#x2F; 只解第3个值</li></ul></li></ul></li><li>创建右值引用元组<ul><li><code>forward_as_tuple</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">m.<span class="built_in">emplace</span>(std::forward_as_tuple(<span class="number">10</span>, std::<span class="built_in">string</span>(<span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>)));</span><br></pre></td></tr></table></figure><ul><li>创建了类似于<code>std::tuple&lt;int&amp;&amp;, std::string&amp;&amp;&gt;</code>类型的tuple</li></ul></li></ul></li><li>连接多个tuple<ul><li><code>tuple_cat</code></li></ul></li></ul><h2 id="四、shared-ptr共享的智能指针"><a href="#四、shared-ptr共享的智能指针" class="headerlink" title="四、shared_ptr共享的智能指针"></a>四、shared_ptr共享的智能指针</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>希望多个智能指针管理同一个资源就用shared_ptr</li><li><code>std::shared_ptr</code>使用引用计数，每一个shared_ptr的拷贝都指向相同的内存</li><li>在最后一个shared_ptr析构的时候，内存才会被释放</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>初始化<ul><li>可以通过使用构造函数、<code>std::make_shared&lt;int&gt;</code>辅助函数和<code>reset</code>方法来初始化shared_ptr  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;  <span class="comment">// 使用动态初始化，后加一个括号为值初始化</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr;</span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li>不能将一个原始指针直接赋值给智能指针</li><li>当智能指针中有值的时候，调用reset会使引用计数减1</li></ul></li><li>获取原始指针<ul><li>可以通过<code>get</code>方法来返回原始指针  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="type">int</span>* p = ptr.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li>指定删除器<ul><li>智能指针初始化可以指定删除器</li><li>当p的<code>引用计数</code>为0时，自动调用删除器DeleteIntPtr来释放对象的内存  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, DeleteIntPtr)</span></span>;</span><br></pre></td></tr></table></figure></li><li>也可以用lambda表达式指定删除器<ul><li><code>std::shared_ptr&lt;int&gt; p(new int, [](int* p) &#123; delete p; &#125;);</code></li></ul></li><li>当我们用<code>shared_ptr</code>管理动态数组时，需要指定删除器，因为<code>std::shared_ptr</code>的默认删除器不支持数组对象</li><li>也可以将<code>std::default_delete</code>作为删除器</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>1）不要用一个原始指针初始化多个shared_ptr</li><li>2）不要在函数实参中创建shared_ptr<ul><li>可能会因为发生异常而泄露内存</li></ul></li><li>3）通过<code>shared_from_this()</code>返回this指针<ul><li>因为this指针本质上是一个<code>裸指针</code>，因此这样可能会导致重复析构</li><li>解决方法<ul><li>让目标类通过派生<code>std::enable_shared_from_this&lt;T&gt;</code>类，然后使用基类的成员函数<code>shared_from_this</code>来返回this的shared_ptr</li></ul></li></ul></li><li>4）要避免循环引用<ul><li>智能指针最大的一个陷阱就是循环引用，循环引用会导致内存泄露</li><li>导致意外延长对象的生命期</li><li>解决方法<ul><li>使用weak_ptr</li></ul></li></ul></li></ul><h2 id="五、unique-ptr独占的智能指针"><a href="#五、unique-ptr独占的智能指针" class="headerlink" title="五、unique_ptr独占的智能指针"></a>五、unique_ptr独占的智能指针</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>希望只有一个智能指针管理资源或者管理数组就用unique_ptr</li><li>unique_ptr是一个独占型的智能指针</li><li>它不允许其他的智能指针共享其内部的指针</li><li>不允许通过赋值将一个unique_ptr赋值给另外一个unique_ptr</li><li>可以通过<code>std::move</code>来转移到其他的unique_ptr  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br><span class="line">unique_ptr&lt;T&gt; myOtherPtr = std:: <span class="built_in">move</span>(myptr);</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>如果是数组，则判断是否是定长数组<ul><li>若为定长数组则编译不通过（不能这样调用<code>make_unique&lt;T[10]&gt;(10) </code>)</li><li>若为非定长数组，则获取数组中的元素类型，再根据参数size创建动态数组的unique_ptr<ul><li><code>unique_ptr&lt;int[]&gt; ptr5 = make_unique&lt;int[]&gt;(10);</code></li></ul></li></ul></li><li>unique_ptr可以指向数组（而shared_ptr这么做不合法）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span> []&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function">ptr[9] </span>= <span class="number">9</span>;         <span class="comment">// 设置最后一个元素值为9</span></span><br></pre></td></tr></table></figure></li><li>unique_ptr指定删除器的时候需要确定删除器的类型<ul><li><code>std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int (1), [](int* p) &#123; delete p; &#125;);</code></li><li>lambda表达式在没有捕获变量的情况下是可以直接转换为函数指针的，一旦捕获了就无法转换了<ul><li><code>std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int (1), [&amp;](int* p) &#123; delete p; &#125;);</code>  &#x2F;&#x2F; 错误，捕获了变量</li></ul></li><li>如果希望unique_ptr删除器支持lambda可以这么写<ul><li><code>std::unique_ptr&lt;int, std::function&lt;void(int*)&gt;&gt; ptr(new int(1), [&amp;](int* p) &#123; delete p; &#125;</code></li></ul></li></ul></li></ul><h2 id="六、weak-ptr弱引用的智能指针"><a href="#六、weak-ptr弱引用的智能指针" class="headerlink" title="六、weak_ptr弱引用的智能指针"></a>六、weak_ptr弱引用的智能指针</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>weak_ptr是用来监视shared_ptr的，不会使引用计数加1</li><li>它不管理shared_ptr内部的指针，主要是为了监视shared_ptr的生命周期</li><li>它的构造不会增加引用计数，它的析构也不会减少引用计数</li></ul><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>1）通过<code>use_count()</code>方法来获得当前观测资源的引用计数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 结果将输出1</span></span><br></pre></td></tr></table></figure></li><li>2）通过<code>expired()</code>方法来判断所观测的资源是否已经释放（true为无效）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wp.<span class="built_in">expired</span>())</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weak_ptr无效，所监视的智能指针已经被释放&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weak_ptr有效&quot;</span>;</span><br></pre></td></tr></table></figure></li><li>3）通过<code>lock()</code>方法来获取所监视的shared_ptr  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; gw = sp;</span><br><span class="line"><span class="keyword">auto</span> spt = gw.<span class="built_in">lock</span>();  <span class="comment">// 获取所监视的shared_ptr</span></span><br><span class="line">cout &lt;&lt; *spt &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul><h3 id="weak-ptr返回this指针"><a href="#weak-ptr返回this指针" class="headerlink" title="weak_ptr返回this指针"></a>weak_ptr返回this指针</h3><ul><li><code>std::enable_shared_from_this</code>类中有一个weak_ptr，这个weak_ptr用来观测this智能指针</li><li>调用<code>shared_from_this()</code>方法时，会调用内部这个weak_ptr的<code>lock()</code>方法，将所观测的shared_ptr返回</li><li>获取自身智能指针的函数仅在<code>shared_ptr&lt;T&gt;</code>的构造函数被调用之后才能使用，因为<code>enable_shared_from_this</code>内部的weak_ptr只有通过shared_ptr才能构造</li></ul><h3 id="可以通过weak-ptr解决循环引用问题"><a href="#可以通过weak-ptr解决循环引用问题" class="headerlink" title="可以通过weak_ptr解决循环引用问题"></a>可以通过weak_ptr解决循环引用问题</h3>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 403. 青蛙过河</title>
      <link href="/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
      <url>/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>给定石子位置的列表stones（升序），青蛙可以跳上石子，但不能跳入水中。<br>如果青蛙一步跳跃了k个单位，那么它接下来跳跃的距离只能为k-1、k或k+1个单位。<br>青蛙只能向前方跳跃。</p><span id="more"></span><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stones = [0,1,3,5,6,8,12,17]</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">青蛙可以成功过河，按照如下方案跳跃：</span><br><span class="line">跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, </span><br><span class="line">然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><p>思路：本题为二维动态规划，使用动态规划的方法，令<code>dp[i][k]</code>为跳跃k个单位能否到达第i个石子，初始化<code>dp[0][0] = true;</code>，得出状态转移方程<code>dp[i][k] = dp[j][k-1] | dp[j][k] | dp[j][k+1];</code>，其中j为上一次所在石子的编号。</p><h3 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;  <span class="comment">// 优化：跳跃距离k必定满足k &lt;= i（可推），此时为青蛙无路可跳</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;  <span class="comment">// 反向枚举</span></span><br><span class="line">                <span class="type">int</span> k = stones[i] - stones[j];  <span class="comment">// 跳跃的距离k，j为上一次所在石子的编号</span></span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;  <span class="comment">// 在第j个石子上至多跳跃j+1的单位</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n^2^)，n为石子的个数，第i个石子后方只有i-1个石子，因此在任意位置，青蛙的上一次跳跃距离至多只有n种，状态总数为 n^2^ </li><li><strong>空间复杂度</strong>：O(n^2^)，需要二维动态数组的空间，其中n是石子的数量</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP Note</title>
      <link href="/2021/04/28/tcp%20note/"/>
      <url>/2021/04/28/tcp%20note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《TCP&#x2F;IP详解》读书笔记</p></blockquote><span id="more"></span><h2 id="一、TCP超时与重传"><a href="#一、TCP超时与重传" class="headerlink" title="一、TCP超时与重传"></a>一、TCP超时与重传</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li>计时器超时称为重传超时（RTO）</li><li>若TCP累计确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文段时，快速重传会推断出现丢包</li><li>由下层网络（IP）可能出现丢失重复或失序包，TCP重传其认为已经丢失的包</li></ul><h3 id="简单的超时与重传举例"><a href="#简单的超时与重传举例" class="headerlink" title="简单的超时与重传举例"></a>简单的超时与重传举例</h3><ul><li>二进制指数退避<ul><li>每次重传间隔时间加倍</li></ul></li><li>TCP拥有两个阈值来决定如何重传同一个报文段<ul><li>R1表示TCP在向IP层传递“消极建议”（如重新评估当前路径）前，愿意尝试重传的次数</li><li>R2（大于R1）指示TCP应放弃当前连接的时机</li></ul></li></ul><h3 id="设置重传超时"><a href="#设置重传超时" class="headerlink" title="设置重传超时"></a>设置重传超时</h3><ul><li>TCP超时和重传的基础根据给定连接的RTT（往返时间）设置RTO<ul><li>若TCP先于RTT开始重传，可能会在网络中引入不必要的重复数据</li><li>若延迟远大于RTT的间隔发送重传数据，整体网络利用率（及单个连接吞吐量）会随之下降</li></ul></li><li>RTO设置得当是保证TCP性能的关键</li><li>当分组失序（或丢失）时，RTT会被过高估算。较大的RTT估计值使得RTO也更大</li><li>时间戳选项（TSOPT）使得发送端即使在丢包、延时、失序的情况下也能测量RTT</li></ul><h3 id="基于计时器的重传"><a href="#基于计时器的重传" class="headerlink" title="基于计时器的重传"></a>基于计时器的重传</h3><ul><li>对于TCP来说，计时器需要有效地实现被设置、重新设置或取消的功能</li><li>RTO的设置通常大于RTT（两倍或更大）<ul><li>因此基于计时器的重传会导致网络利用率的下降</li></ul></li><li>快速重传不需要计时器超时来触发且比超时重传更高效</li></ul><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><ul><li>快速重传机制基于接收端的反馈信息来引发重传</li><li>快速重传是根据收到重复ACK来推断出现丢包并启动重传，而不必等待重传计时器超时</li><li>快读重传仅在达到重复阈值后才被触发，而不是一旦收到重复ACK就出发，减少了大量不必要的重传发生</li></ul><h3 id="带选择确认（SACK）的重传"><a href="#带选择确认（SACK）的重传" class="headerlink" title="带选择确认（SACK）的重传"></a>带选择确认（SACK）的重传</h3><ul><li>空缺<ul><li>ACK号与接收端缓存中的其他数据之间的间隔</li></ul></li><li>失序数据<ul><li>序列号高于空缺的数据</li></ul></li><li>在很多情况下，合理采用SACK信息能更快地实现空缺填补，且能减少不必要的重传</li><li>SACK接收端行为<ul><li>SACK选项的空间有限，应尽可能确保向TCP发送端提供最新信息，其余的SACK块包含的内容也按照接收的先后依次排序</li></ul></li><li>SACK发送端行为<ul><li>SACK发送端记录接收到的累计ACK信息，还需要记录接收到的SACK信息</li><li>当SACK发送端执行重传时，通常是由于其收到了SACK或重复SACK（D-SACK）</li></ul></li><li>为提高对ACK丢失的鲁棒性，第一个SACK块中需要包含之前的重复SACK信息</li></ul><h3 id="伪超时与重传"><a href="#伪超时与重传" class="headerlink" title="伪超时与重传"></a>伪超时与重传</h3><ul><li><p>伪重传</p><ul><li>即使没有出现数据丢失也可能引发的重传</li><li>主要原因是伪超时</li></ul></li><li><p>DSACK</p><ul><li>主要目的是判断何时重传是不必要的</li><li>因此发送端至少可以判断是否发生了包失序、ACK丢失、包重复</li></ul></li></ul><h3 id="包失序与重复"><a href="#包失序与重复" class="headerlink" title="包失序与重复"></a>包失序与重复</h3><ul><li>失序<ul><li>IP层不能保证包传输是有序进行的</li><li>如果失序发生在正向链路上，TCP可能无法正确识别失序和丢包</li></ul></li><li>重复<ul><li>采用DSACK避免</li></ul></li></ul><h3 id="重新组包"><a href="#重新组包" class="headerlink" title="重新组包"></a>重新组包</h3><ul><li>定义：发送一个更大的报文段来提高性能（不能超过接收端通告的MSS，也不能大于路径MTU）</li><li>当TCP超时重传，它并不需要完全重传相同的报文段</li><li>解决了重传二义性问题</li></ul><h2 id="二、TCP数据流与窗口管理"><a href="#二、TCP数据流与窗口管理" class="headerlink" title="二、TCP数据流与窗口管理"></a>二、TCP数据流与窗口管理</h2><h3 id="交互式通信"><a href="#交互式通信" class="headerlink" title="交互式通信"></a>交互式通信</h3><ul><li>TCP流量中通常90%或者更多的TCP报文段都包含大批量数据（如Web、文件共享、电子邮件、备份），其余部分则包含交互式数据（如远程登陆、网络游戏），批量数据通常较大，而交互式数据段则会比较小</li><li>对于一个ssh连接，客户端对其传输数据加密，意味着用户输入的信息在通过连接传送前已经进行了加密</li><li>每一个交互按键通常都会生成一个单独的数据包，每个按键是独立传输的（每次一个字符而非每次一行）</li><li>每个输入字符会生成4个TCP数据段：客户端的交互击键输入、服务器对击键的确认、服务器端生成的回显、客户端对该回显的确认<ul><li>通常第二段和第三段可以合并，可将对击键的确认与回显一并传送，这种方法称为（捎带延时确认）</li></ul></li></ul><h3 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h3><ul><li>TCP并不对每个到来的数据包都返回ACK<ul><li>利用TCP的累计ACK字段就能实现该功能</li></ul></li><li>捎带传输：<ul><li>累计确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传输的数据结合发送</li></ul></li><li>TCP不能任意时长地延迟ACK，否则对方会误认以为数据丢失而出现不必要的重传</li><li>RFC指出：TCP实现ACK延迟的时延应小于500ms，实践中时延最大取200ms</li></ul><h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><ul><li>当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据），小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送</li><li>ACK返回越快，数据传输越快</li><li>传输包数目更少而长度更大，但同时传输时延也更长</li><li>Nagle算法结合ACK可能会导致某种程度的死锁（这种死锁不是永久的）</li><li>要求延时尽量小的应用，建议禁用Nagle算法<ul><li>TCP_NODELAY选项可以禁用Nagle算法</li></ul></li></ul><h3 id="流量控制与窗口管理"><a href="#流量控制与窗口管理" class="headerlink" title="流量控制与窗口管理"></a>流量控制与窗口管理</h3><ul><li>每一个TCP报文段（除了建立之初的包交换）都包含一个有效的序列号字段、一个ACK号或确认字段以及一个窗口大小字段（包含窗口通告信息）</li><li>窗口通告：表示发送该窗口信息的通信方为即将到来的新数据预留的存储空间</li><li>窗口大小：表明接收端可用缓存空间的大小</li><li>滑动窗口<ul><li>每个TCP活动连接的两端都维护一个发送窗口结构和接收窗口结构</li><li>TCP以字节（而非包）为单位维护其窗口结构</li><li>窗口左右边界的运动<ul><li>1.关闭<ul><li>即窗口左边界右移。当已发送数据得到ACK确认时，窗口会减小</li></ul></li><li>2.打开<ul><li>即窗口右边界右移。使得可发送数据量增大。当已确认数据得到处理，接收端可用缓存变大，窗口也随之变大</li></ul></li><li>3.收缩<ul><li>即窗口右边界左移</li></ul></li></ul></li></ul></li><li>零窗口与TCP持续计时器<ul><li>零窗口：左右边界相等</li><li>当接收端的通告窗口值为0时，可以有效阻止发送端继续发送，直至窗口大小恢复为非零值</li><li>当接收端重新获得可用空间时，会给发送端传输一个”窗口更新“告知其可以继续发送数据<ul><li>该窗口更新通常不包含数据（纯ACK），不能保证其传输的可靠性，容易丢包，造成死锁的发生（发送方等待收到窗口更新告知其可继续发送，接收方等待接收数据）<ul><li>解决方案：发送端会采用一个持续计时器间歇性地查询接收端，看其窗口是否已增长</li></ul></li></ul></li><li>TCP持续计时器会触发”窗口探测“的传输，强制要求接收端返回ACK（其中包含了窗口大小字段）</li><li>窗口探测包含一个字节的数据，采用TCP可靠传输（丢失重传），因此可以避免由窗口更新丢失导致的死锁<ul><li>该一个字节的数据能否被接收，取决于接收端的可用缓存空间大小</li></ul></li><li>当TCP持续计时器超时，就会触发窗口探测的发送</li><li>窗口探测的响应条件：<ul><li>至少为一个MSS</li><li>超过总接收缓存的四分之一</li></ul></li><li>可以采用指数时间退避来计算持续计时器的超时</li></ul></li><li>糊涂窗口综合征（SWS）<ul><li>基于窗口的流量控制机制，尤其是不使用大小固定的报文段情况（如TCP），可能会出现SWS</li><li>当出现该问题时，交换数据段不是全长的而是一些较小的数据段，由于每个报文段中有用数据相对头部信息的比例较小，因此耗费的资源也更多，相应的传输效率也更低</li><li>避免SWS问题<ul><li>1.对于接收端来说，不应通告小的窗口值</li><li>2.对于发送端来说，不应发送小的报文段</li><li>为了避免SWS问题，至少满足以下条件之一时才能传输报文段（发送窗口更新）<ul><li>（a）全长（发送MSS字节）的报文段可以发送</li><li>（b）数据段长度 &gt;&#x3D; 接收端通告过的最大窗口的一半的，可以发送</li><li>（c）满足以下任一条件的都可以发送：<ul><li>（i）某一ACK不是目前期盼的（即没有未经确认的在传数据）</li><li>（ii）该连接禁用Nagle算法</li></ul></li></ul></li></ul></li><li>TCP需要避免窗口收缩</li><li>优先级：避免窗口收缩 &gt; 避免SWS</li></ul></li><li>大容量缓存与自动调优<ul><li>使用较小接收缓存的TCP应用的吞吐性能更差</li><li>自动调优<ul><li>高效地自动分配缓存大小</li><li>窗口值随着接收数据的增多而增大</li></ul></li></ul></li><li>紧急机制<ul><li>紧急指针字段被设置后，发送端生成的每个TCP头部都包含该字段</li><li>所有序列号大于紧急指针的数据都经接收端确认</li></ul></li></ul><h2 id="三、TCP拥塞控制"><a href="#三、TCP拥塞控制" class="headerlink" title="三、TCP拥塞控制"></a>三、TCP拥塞控制</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><ul><li>TCP拥塞控制的难点在于怎样准确地判断何时需要减缓且如何减缓TCP传输，以及何时恢复其原有速度</li><li>当网络中大量的发送方和接收方被要求承担超负荷的通信任务时，可以考虑采取(降低发送速率)或者(最终丢弃部分数据)的方法</li><li>拥塞<ul><li>路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象</li></ul></li></ul><h3 id="TCP拥塞检测"><a href="#TCP拥塞检测" class="headerlink" title="TCP拥塞检测"></a>TCP拥塞检测</h3><ul><li>针对丢包情况，TCP采取的首要机制是重传<ul><li>超时重传</li><li>快速重传</li></ul></li><li>丢包被用作判断拥塞发生与否的值标</li><li>在有线网络中，出现在路由器或交换机中的拥塞是造成丢包的主要原因</li><li>在无线网络中，传输和接收错误是导致丢包的重要因素</li></ul><h3 id="减缓TCP发送"><a href="#减缓TCP发送" class="headerlink" title="减缓TCP发送"></a>减缓TCP发送</h3><ul><li>TCP头部设置的通知窗口大小字段，是TCP发送方调节发送速率的依据</li><li>TCP发送端发送速率 &#x3D; min{接收速率，传输速率}</li><li>拥塞窗口（cwnd）<ul><li>反映网络传输能力的变量</li></ul></li><li>发送端实际可用窗口W &#x3D; min{cwnd，通知窗口(awnd)}</li><li>在外数据值<ul><li>已经发出但还未经确认的数据量大小</li><li>当TCP不使用选择确认机制时，W的限制作用体现为发送方发送的报文段序列号不能大于ACK号的最大值与W之和</li><li>当TCP使用选择确认机制时，W用来限制在外数据值</li></ul></li><li>带宽延迟积（BDP）也称作最佳窗口大小<ul><li>若在传输数据值远高于BDP时，会引入不必要的延时</li></ul></li></ul><h3 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h3><ul><li>TCP通过与接收端交换一个数据包来获得awnd的值</li><li>获得cwnd最佳值的唯一方法是以越来越快的速率不断发送数据，直到出现数据包丢失（或网络拥塞）为止</li><li>拥塞控制操作是由ACK的接收来驱动或“控制”的</li><li>接收到ACK回复表明发送的数据包已被成功接收，因此可以继续发送操作</li><li>自同步<ul><li>由一个ACK到达（称作ACK时钟）触发一个新数据包传输的关系</li></ul></li><li>在稳定传输状态下，整个系统可“自同步”控制</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ul><li>当一个新的TCP连接建立或检测到由重传超时（RTO）导致的丢包时，需执行慢启动</li><li>TCP发送端长时间处于空闲状态也可能调用慢启动算法<ul><li>在这种情况下cwnd初始值将被设置为重启窗口（RW），RW &#x3D; min（IW，cwnd）</li></ul></li><li>慢启动的目的<ul><li>使TCP在用拥塞避免探寻更多可用宽带之前得到cwnd值，以帮助TCP建立ACK时钟</li></ul></li><li>慢启动算法防止短时间内大量数据注入导致拥塞</li><li>TCP以发送一定数目的数据段开始慢启动（在SYN交换之后），称为初始窗口（IW）</li><li>SMSS &#x3D; min（接收方MSS，MTU）</li><li>慢启动算法会以min（N，SMSS）来增加cwnd值，N是指在未经确认的传输数据中能通过这一”新接收的ACK号大于之前收到的ACK号“确认的字节数</li><li>快速ACK模式<ul><li>TCP操作只在慢启动阶段完成后才返回ACK</li></ul></li></ul><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul><li>在慢启动阶段，cwnd会快速增长，帮助确立一个慢启动阈值，一旦达到阈值，就意味着可能有更多可用的传输资源。如果立即全部占用这些资源，将会使共享路由器队列的其他连接出现严重的丢包和重传情况，从而导致整个网络性能不稳定</li><li>一旦确立慢启动阈值，TCP会进入拥塞避免阶段</li><li>拥塞避免阶段窗口随时间线性增长，而慢启动阶段呈指数增长<ul><li>cwnd1 &#x3D; cwnd0+（1&#x2F;k）*SMSS</li></ul></li></ul><h3 id="慢启动和拥塞避免的选择"><a href="#慢启动和拥塞避免的选择" class="headerlink" title="慢启动和拥塞避免的选择"></a>慢启动和拥塞避免的选择</h3><ul><li>某个TCP连接总是选择运行慢启动和拥塞避免中的一个，不会出现两者同时运行的情况</li><li>当cwnd&lt;ssthresh，使用慢启动算法</li><li>当cwnd&gt;ssthresh，使用拥塞避免</li><li>当cwnd&#x3D;ssthresh，任何一种算法都可以使用</li><li>慢启动阈值ssthresh不是固定的，是随时间改变的</li><li>慢启动阈值的主要目的是，在没有丢包发生的情况下，记住上一次”最好的“操作窗口估计值</li><li>ssthresh &#x3D; max（在外数据值&#x2F;2，2*SMSS）</li><li>如果出现重传情况，慢启动阈值减小至当前窗口大小的一般（但不小于2*SMSS）</li></ul><h3 id="标准TCP"><a href="#标准TCP" class="headerlink" title="标准TCP"></a>标准TCP</h3><ul><li>当接收到一个好的ACK（表明新的数据传输成功）cwnd会相应更新<ul><li>cwnd +&#x3D; SMSS 慢启动</li><li>cwnd +&#x3D; SMSS*SMSS&#x2F;cwnd 拥塞避免</li></ul></li><li>当收到三次重复ACK（或其他表明需要快速重传的信号）时，会执行以下行为<ul><li>1.ssthresh更新为大于等式ssthresh &#x3D; min（在外数据值&#x2F;2，2*SMSS）的值</li><li>2.启用快速重传算法，将cwnd设为（ssthresh+3*SMSS）</li><li>3.每接收一个重复ACK，cwnd值暂时增加1 SMSS</li><li>4.当接收到一个好的ACK，将cwnd重设为ssthresh</li></ul></li></ul><h3 id="转发确认（FACK）和速率减半"><a href="#转发确认（FACK）和速率减半" class="headerlink" title="转发确认（FACK）和速率减半"></a>转发确认（FACK）和速率减半</h3><ul><li>为避免出现等待空闲而又不违背将拥塞窗口减半的做法，提出了转发确认（FACK）策略</li><li>带界定参数的速率减半（RHBP）<ul><li>基本操作：在一个RTT时间内，每接收两个重复ACK，TCP发送方可发送一个新的数据包</li><li>RHBP中区分了调整间隔（cwnd的修正阶段）和恢复间隔（数据重传阶段）</li></ul></li><li>速率减半是调节发送操作或避免集中发送的方法</li></ul><h3 id="限制传输"><a href="#限制传输" class="headerlink" title="限制传输"></a>限制传输</h3><ul><li>TCP发送方每接收两个连续的重复ACK，就能发送一个新数据包</li><li>TCP因此可以避免长时间等待RTO而导致吞吐性能下降</li><li>速率减半也是限制传输的一种形式<h3 id="拥塞窗口校验（CWV）"><a href="#拥塞窗口校验（CWV）" class="headerlink" title="拥塞窗口校验（CWV）"></a>拥塞窗口校验（CWV）</h3></li><li>在发送长时间暂停的情况下，由ssthresh维护cwnd保存的”记忆”，之后cwnd值会衰减。</li><li>需要区分空闲发送端和应用受限发送端</li><li>CWV算法原理：当需要发送新数据时，首先看距离上次发送操作是否超过一个RTO，如果超过则<ul><li>更新ssthresh值，设为max（ssthresh，（3&#x2F;4）*cwnd）</li><li>每经一个空闲RTT时间，cwnd值就减半，但不小于1 SMSS</li><li>对应用受限阶段<ul><li>已使用的窗口大小为W_used</li><li>更新ssthresh的值，设为max（ssthresh，（3&#x2F;4）*cwnd）</li><li>cwnd设置为cwnd和W_used的平均值</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C# Note</title>
      <link href="/2021/04/28/c#%20Note/"/>
      <url>/2021/04/28/c#%20Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>初衷是Unity</p></blockquote><span id="more"></span><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li>表达式主体方法<ul><li>&#x3D;&gt;操作符引用构成方法主体的表达式，而且没有return语句。表达式的值自动作为返回值；如果表达式不返回值，则方法自动为void方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResult</span>(<span class="params"><span class="built_in">int</span> answer</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>差值表达式<ul><li>$符号表明这是个差值字符串，{和}之间的任何表达式都需求值并置换，字符串差值比+操作符高效得多  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>只有<code>float</code>和<code>double</code>除以0得到<code>Infinity</code>（不会出错）</li><li><code>int</code>的最大最小值<code>int.MaxValue</code>和<code>int.MinValue</code></li><li>隐式类型变量<code>var</code>,作用类似于C++的<code>auto</code></li></ul><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><ul><li>与C++不一致<br>  -<code>if</code>语句中表达式必须是布尔值, 如：<code>if (1)</code> &#x2F;&#x2F; 错误</li><li><code>switch</code>语句的控制表达式不能用<code>float</code>和<code>double</code>类型</li><li><code>case</code>标签必须是常量表达式，且必须唯一</li><li>C#语句的直通规则<ul><li>直通，标签之间不能有额外语句（即不加<code>break</code>，不允许拥有语句）</li><li>每个<code>case</code>都加上<code>break</code></li></ul></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>C#所有方法都必须在类的内部声明</li><li>默认参数中如果参数匹配则不会出现歧义</li><li>默认参数（可选参数）必须放在后面</li><li>具名参数<ul><li><code>optMethod(first: 99, third: &quot;Word&quot;);</code>  &#x2F;&#x2F; 传递具名参数（参数名:传递的值），实参可以按任意顺序传递，second参数使用<code>默认值</code></li></ul></li></ul><h2 id="结构（结构体）"><a href="#结构（结构体）" class="headerlink" title="结构（结构体）"></a>结构（结构体）</h2><ul><li>与C++不一致，结构主体后不加<code>;</code></li><li>值类型<ul><li>对于简单的、比较小的数据值，复制值的效率等同于或基本等同于复制地址的效率，但较复杂的数据就考虑使用类，这样就可选择只复制数据的地址，从而提高代码的执行效率</li></ul></li><li>不能为结构声明默认构造器（无参构造器），否则无法编译，因为编译器始终会自动生成默认构造器（不同于类）</li><li>类的实例字段可在声明时初始化，但结构不允许  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> hours = <span class="number">0</span>;  <span class="comment">// 编译时错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译器不会自动初始化结构中的字段（与类不一致）</li><li>复制结构变量的前提时<code>=</code>操作符右侧的结构变量已完全初始化，否则编译错误</li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li>与C++不一致，枚举主体后不加<code>;</code></li><li>值类型</li><li>声明枚举时字面值默认是int类型，可以选择枚举的基础类型<ul><li><code>enum Season : short &#123; Spring, Summer &#125;</code></li></ul></li><li>为枚举的字面值显式指定常量整数值<ul><li><code>enum Season &#123; Spring = 1, Summer &#125;</code></li></ul></li><li>编译器自动为它指定比前一个枚举字面值大1的值</li><li>多个枚举字面值可以具有相同的基础值<ul><li><code>enum Season &#123; Spring, Summer, Fall, Autumn = Fall &#125;</code></li></ul></li><li>每个枚举定义的字面值名称都只有这个枚举类型的作用域，因此要加枚举类型限定，否则编译错误，如：Season.Fall</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p>与c++不一致，类主体、结构主体后不加分号</p></li><li><p>每个字段和方法声明都要重复<code>public</code>或<code>private</code>关键字</p></li><li><p>省略控制可访问性，默认为<code>private</code></p></li><li><p>类被拆分到多个文件中之后，要在每个文件中使用<code>partial</code>（分部）关键字定义类的不同部分</p></li><li><p>如果把方法或字段声明为<code>static</code>，就可使用类名调用方法或访问字段，而不用先创建对象</p></li><li><p>静态方法只能访问标记为<code>static</code>的其他方法和字段</p></li><li><p>类外访问类中的<code>static</code>字段要以，类名作为前缀，<code>class.function</code></p></li><li><p>静态方法也称为类方法</p></li><li><p>静态字段称为静态字段或静态变量</p></li><li><p>只有数值类型、字符串类型和枚举类型的字段才能声明为const字段</p></li><li><p>静态类</p><ul><li>只能包含静态成员</li><li><code>public static class Math</code></li></ul></li><li><p>using语句允许将类引入作用域，以便在访问静态成员时省略类名</p><ul><li><code>using static System.Math;</code></li></ul></li><li><p>匿名类</p><ul><li>匿名类就是没有名字的类</li><li>不知道类的名称可以使用隐式类型变量来创建正确类型的对象  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAnonymousObject = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">47</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>值类型</p><ul><li>基元类型</li></ul></li><li><p>引用类型</p><ul><li><code>string</code>在运行时动态分配内存</li><li>声明类变量时，编译器分配一小块内存，其中刚好可以容纳一个地址。以后类实际占用内存块的地址会填充到这里。该地址成为对内存块的引用</li><li>实际占用的内存<ul><li>使用<code>new</code>关键字创建对象时分配的内存</li></ul></li></ul></li><li><p>引用类型的变量包含的是引用，引用本身存储在栈上，但该引用指向堆上的对象</p></li><li><p>类可以提供clone方法来返回自己的新实例，并填充相同数据</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Circle <span class="title">Clone</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Circle clone = <span class="keyword">new</span> Circle();</span><br><span class="line">    clone.radius = <span class="keyword">this</span>.radius;</span><br><span class="line">    <span class="comment">// 返回包含克隆数据的新Circle对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果包含任何引用类型的字段，这种引用类型也需要提供Clone方法，否则只是“浅拷贝”，如果提供了Clone方法，能够复制引用的对象，就成为“深拷贝”</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle(<span class="number">42</span>);</span><br><span class="line">Circle copy = <span class="keyword">new</span> Circle(<span class="number">99</span>);</span><br><span class="line">copy = c;</span><br></pre></td></tr></table></figure></li><li><p>这时候copy原来的引用被回收了（垃圾回收机制）</p></li></ul></li><li><p>空条件操作符（问号加在变量名称之后）</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(c?.Area());</span><br></pre></td></tr></table></figure><ul><li>空条件操作符告诉”运行时“在操作符所应用的变量为null的前提下忽略当前语句</li></ul></li><li><p>可空类型</p><ul><li><code>null</code>本身就是引用，不能把它赋值给值类型</li><li>可将变量声明为可空值类型<ul><li><code>int? i = null;</code></li></ul></li><li>可将恰当值的表达式直接赋给可空变量<ul><li><code>i = j;</code></li></ul></li><li>不可将可空的值赋给普通的值类型变量<ul><li><code>j = i;</code></li></ul></li><li>可空类型的两个属性<ul><li><code>HasValue</code><ul><li>判断可空类型是包含一个值，还是包含null</li></ul></li><li><code>Value</code><ul><li>只读的属性</li><li>读取变量的值，但不能修改</li></ul></li></ul></li></ul></li><li><p>引用传参</p><ul><li><code>ref</code>参数<ul><li>要求实参和形参前都加上<code>ref</code>关键字<ul><li><code>DoWork(ref i)</code>;</li></ul></li><li>要求在传参之前必须初始化</li></ul></li><li><code>out</code>参数<ul><li>要求实参和形参前都加上<code>out</code>关键字</li><li>要求在方法中必须初始化，传参前不要求</li></ul></li></ul></li><li><p><code>object</code>类型</p><ul><li><code>object</code>类型的变量能引用任何引用类型的任何对象</li></ul></li><li><p><code>装箱</code></p><ul><li>将值类型赋给<code>object</code>类型的变量<ul><li><code>object o = 42;</code></li></ul></li><li>数据项从栈自动复制到堆的行为</li><li>与泛型异曲同工</li></ul></li><li><p><code>拆箱</code></p><ul><li>将引用了已装箱的值的object引用强制转换成值类型<ul><li><code>int a = (int)o;</code></li></ul></li><li>必须强制转换</li></ul></li><li><p>装箱和拆箱会产生较大的开销</p><ul><li>它们设计不少检查工作，且需要分配额外的堆内存</li></ul></li><li><p>数据的安全转型</p><ul><li>左操作数为对象，右操作数为类型<ul><li>is操作符<ul><li>if (o is WrappedInt)</li><li>如果is表达式正确，结果为true，反之为false</li></ul></li><li>as操作符<ul><li>WrappedInt temp &#x3D; o as WrappedInt;</li><li>若转换成功，就返回转换成功的结果，失败则为null</li></ul></li></ul></li></ul></li><li><p>在c#中使用c指针必须将代码标记为<code>unsafe</code></p><ul><li><code>unsafe</code>关键字可标记代码块或整个方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">swap</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>命名规范</p></li><li><p>公共标识符以大写字母开头</p></li><li><p>非公共标识符（包括局部变量）以小写字母开头</p></li><li><p>类名以大写字母开头</p></li><li><p>均采用驼峰命名法</p></li><li><p><code>TODO:</code>注释通常用于标注以后将进行加工的代码</p></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><code>checked</code>语句是<code>checked</code>关键字开头的代码块<ul><li>只有直接在checked块中的整数运算才会检查</li><li>溢出则抛出<code>OverflowException</code></li><li><code>checked</code>和<code>unchecked</code>关键字只适合整型运算</li><li>浮点运算永不抛出异常</li></ul></li><li><code>catch</code>省略名称默认捕获<code>Exception</code><ul><li>异常发生后将运行由”运行时“发现的第一个匹配的异常处理程序<code>catch</code>，其他处理程序会被忽略</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link href="/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>打印出二叉树中节点值的和为输入整数的所有路径（从根节点一直到叶子节点的路径）</p><span id="more"></span><p><strong>输入</strong>：<br>给定如下二叉树，以及目标和 target &#x3D; 22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><p>由根节点出发，首先想到先序遍历的思路</p><h3 id="2-1-回溯"><a href="#2-1-回溯" class="headerlink" title="2.1 回溯"></a>2.1 回溯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">      vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">      <span class="type">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">FindPath</span>(root, target, path, currentSum, ans);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; path, <span class="type">int</span> currentSum, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先序遍历</span></span><br><span class="line">      currentSum += root-&gt;val;  <span class="comment">// 更新当前路径</span></span><br><span class="line">      path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">      <span class="comment">// 如果是叶子节点，并且路径上的节点的和等于输入的值，则打印这条路径</span></span><br><span class="line">      <span class="type">bool</span> isLeaf = root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (currentSum == target &amp;&amp; isLeaf) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若不是叶子节点，则遍历它的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在返回父节点之前，在路径上删除当前节点</span></span><br><span class="line">      path.<span class="built_in">pop_back</span>();  <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(N)，N为二叉树的节点数，需要遍历所有节点</li><li><strong>空间复杂度</strong>：O(N)，最差情况下即树退化成链表，path存储所有树节点，使用O(N)额外空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 684. 冗余连接</title>
      <link href="/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
      <url>/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>找出无向图中的冗余连接，即将无向图还原成二叉树</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><h3 id="2-1-并查集"><a href="#2-1-并查集" class="headerlink" title="2.1 并查集"></a>2.1 并查集</h3><p>思路：通过并查集寻找附加的边，初始时每个节点都属于不同的连通分量，遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量</p><ul><li>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</li><li>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[index]]); </span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      parent[<span class="built_in">Find</span>(parent, x)] = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(klogk)，其中k是图中的节点个数</li><li>空间复杂度：O(n)</li></ul><h3 id="2-2-使用-x3D-x3D-按秩合并-路径压缩-x3D-x3D-的并查集"><a href="#2-2-使用-x3D-x3D-按秩合并-路径压缩-x3D-x3D-的并查集" class="headerlink" title="2.2 使用&#x3D;&#x3D;按秩合并+路径压缩&#x3D;&#x3D;的并查集"></a>2.2 使用&#x3D;&#x3D;按秩合并+路径压缩&#x3D;&#x3D;的并查集</h3><p>优化了空间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[parent[index]]);  <span class="comment">// 路径压缩，使树的层数更少</span></span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      <span class="type">int</span> i = <span class="built_in">Find</span>(parent, x), j = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">      <span class="comment">// 按秩合并</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">// 如果i的秩大于j的秩</span></span><br><span class="line">        parent[j] = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[i] = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(klogk)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql Note</title>
      <link href="/2021/04/28/mysql%20note/"/>
      <url>/2021/04/28/mysql%20note/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><span id="more"></span><ul><li>表名是唯一的</li><li>表中的数据是按行存储的</li><li>行（别名 记录）</li><li>主键：一列，其值能够区分表中每个行<ul><li>每个行都必须有一个主键值（不允许为NULL）</li><li>任意两行都不具有相同的主键值</li><li>不更新主键列中的值</li><li>不在主键列中使用可能会更改的值</li></ul></li><li>命令用分号；结束</li><li>连接到mysql需要以下信息<ul><li>主机名：本地服务器为localhost</li><li>端口：默认为3036</li><li>一个合法的用户名</li><li>用户口令（如果需要的话）</li></ul></li><li><code>use&lt;数据库名字&gt;</code>来选择数据库</li><li><code>show databases</code>返回可用数据库的一个列表</li><li><code>show tables</code>返回该数据库内的可用表的一个列表</li><li><code>show columns from &lt;表名&gt;</code> &#x3D; <code>describe &lt;表名&gt;</code>来显示表中的所有列</li><li>自动增量：Mysql可以自动地为每个行分配下一个可用的编号，需要create语句</li><li><code>show status</code>显示广泛的服务器状态信息</li><li><code>show create databases/table</code>分别用来显示创建特定数据库或表的语句</li><li><code>show grants</code>显示授予用户的安全权限</li><li><code>show errors</code>和<code>show warnings</code>显示服务器错误或警告信息</li></ul><h2 id="二、SELECT语句"><a href="#二、SELECT语句" class="headerlink" title="二、SELECT语句"></a>二、SELECT语句</h2><ul><li><code>SELECT &lt;列名&gt; FROM &lt;表名&gt;</code>在表中检索单个列<blockquote><p>SELECT检索多个列，列名用逗号分隔<br>检索所有列，用<code>*</code>通配符</p></blockquote></li><li>sql语句不区分大小写</li><li>SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写</li><li>处理SQL语句空格会被忽略</li><li><code>SELECT DISTINCT ... FROM</code>返回不重复的行（distinct要放在列名前面）</li><li>使用完全限定的表名<code>SELECT db.host FROM mysql.db</code></li><li><code>FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT</code>是<code>SELECT</code>的子句，其出现次序必须为上述顺序，次序不对将产生错误信息</li><li><code>ORDER BY</code>子句取一个或多个列的名字对输出进行排序<blockquote><p>默认为asc升序，在列名后加<code>DESC</code>关键字按降序排列，desc关键字只应用到直接位于其前面的列名</p></blockquote></li><li><code>GROUP BY</code>子句，分组允许把数据分为多个逻辑组</li><li><code>HAVING</code>和<code>WHERE</code>的区别：<code>HAVING</code>过滤分组，<code>WHERE</code>过滤行</li><li><code>WHERE</code>是<code>SELECT</code>的子句（在from子句之后给出）用来指定搜索条件</li><li><strong>WHERE子句操作符</strong></li></ul><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">不等于</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在指定的两个值之间</td></tr></tbody></table><ul><li>空值检查(<code>is NULL</code>子句)<code>where...is NULL;</code></li><li><code>WHERE</code>子句给出了<code>AND, OR, IN, NOT</code>逻辑操作符来进行逻辑操作</li></ul><h2 id="三、匹配"><a href="#三、匹配" class="headerlink" title="三、匹配"></a>三、匹配</h2><ul><li>通配符本身实际是SQL的<code>WHERE</code>子句中有特殊含义的字符，在搜索子句中使用通配符，必须使用<code>LIKE</code>操作符，<code>LIKE</code>只是Mysql后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较</li><li>百分号<code>%</code>通配符匹配任意个数的任意字符，下划线<code>_</code>通配符匹配任意单个字符</li><li>使用通配符的技巧<ul><li>不要过度使用通配符</li><li>把通配符置于搜索模式的开始处搜索起来是最慢的</li></ul></li><li><code>WHERE</code>的子句中<code>REGEXP</code>子句使用正则表达式，在<code>REGEXP</code>关键字后加上<code>BINARY</code>来区分匹配表达式的大小写<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Db, User FROM db </span><br><span class="line">WHERE Db REGEXP BINARY &#x27;.ys&#x27;;</span><br></pre></td></tr></table></figure></li><li>匹配正则表达式内具有特殊意义的所有字符都必须以\\的方式转义</li></ul><p><strong>常用字符类</strong></p><table><thead><tr><th align="center">类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">任意字母和数字（同[a-zA-Z0-9])</td></tr><tr><td align="center">[:alpha:]</td><td align="center">任意字符（同[a-zA-Z]）</td></tr><tr><td align="center">[:blank:]</td><td align="center">空格和制表</td></tr><tr><td align="center">[:cntrl:]</td><td align="center">ASCII控制字符</td></tr><tr><td align="center">[:digit:]</td><td align="center">任意数字</td></tr><tr><td align="center">[:graph:]</td><td align="center">与[:print:]相同，但不包括空格</td></tr><tr><td align="center">[:lower:]</td><td align="center">任意小写字母</td></tr><tr><td align="center">[:print:]</td><td align="center">任意可打印字符</td></tr><tr><td align="center">[:space:]</td><td align="center">任意空白字符</td></tr><tr><td align="center">[:upper:]</td><td align="center">任意大写字母</td></tr><tr><td align="center">[:xdigit:]</td><td align="center">任意十六进制数</td></tr></tbody></table><p><strong>重复元字符</strong></p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>0个或多个匹配</td></tr><tr><td>+</td><td>1个或多个匹配（等于{1,}）</td></tr><tr><td>?</td><td>0个或1个匹配（等于{0,1}）</td></tr><tr><td>{n}</td><td>指定数目的匹配</td></tr><tr><td>{n,}</td><td>不少于指定数目的匹配</td></tr><tr><td>{n,m}</td><td>匹配数目的范围</td></tr></tbody></table><p><strong>定位元字符</strong></p><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">文本的开始</td></tr><tr><td align="center">$</td><td align="center">文本的结束</td></tr><tr><td align="center">[[:&lt;:]]</td><td align="center">词的开始</td></tr><tr><td align="center">[[:&gt;:]]</td><td align="center">词的结束</td></tr></tbody></table><ul><li>正则表达式中<code>.</code>表示匹配任意一个字符</li><li><code>LIKE</code>与<code>REGEXP</code>的区别，<code>LIKE</code>匹配整个串，<code>REGEXP</code>匹配子串</li><li>简单的正则表达式测试，例：<code>SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;</code></li><li><code>SELECT</code>语句中，<code>concat()</code>函数用来拼接字段（与列的意思相同），别名用<code>AS</code>关键字赋予，<code>RTrim()</code>函数去掉右边的所有空格<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat(Db, &#x27;(&#x27;, User, &#x27;)&#x27;) AS link</span><br><span class="line">FROM db;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、相关函数"><a href="#四、相关函数" class="headerlink" title="四、相关函数"></a>四、相关函数</h2><ul><li><code>Soundex()</code>函数匹配所有发音类似与Y.Lie的联系名<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE Soundex(cust_contact) = Soundex(&#x27;Y. Lie&#x27;);</span><br></pre></td></tr></table></figure><strong>常用数值处理函数</strong></li></ul><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Abs()</td><td align="center">返回一个数的绝对值</td></tr><tr><td align="center">Cos()</td><td align="center">返回一个角度的余弦</td></tr><tr><td align="center">Exp()</td><td align="center">返回一个数的指数值</td></tr><tr><td align="center">Mod()</td><td align="center">返回余数</td></tr><tr><td align="center">Pi()</td><td align="center">返回圆周率</td></tr><tr><td align="center">Rand()</td><td align="center">返回一个随机数</td></tr><tr><td align="center">Sin()</td><td align="center">返回一个角度的正弦</td></tr><tr><td align="center">Sqrt()</td><td align="center">返回一个角度的平方根</td></tr><tr><td align="center">Tan()</td><td align="center">返回一个角度的正切</td></tr></tbody></table><p><strong>常用时间和日期处理函数</strong></p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">AddDate()</td><td align="center">增加一个日期（天、周等)</td></tr><tr><td align="center">AddTime()</td><td align="center">增加一个时间（时、分等）</td></tr><tr><td align="center">CurDate()</td><td align="center">返回当前日期</td></tr><tr><td align="center">Date()</td><td align="center">返回日期时间的日期部分</td></tr><tr><td align="center">DateDiff()</td><td align="center">计算两个日期之差</td></tr><tr><td align="center">Date_add()</td><td align="center">高度灵活的日期运算函数</td></tr><tr><td align="center">Date_Format()</td><td align="center">返回格式化的日期或时间率</td></tr><tr><td align="center">Day()</td><td align="center">返回一个日期的天数部分</td></tr><tr><td align="center">DayOfWeek()</td><td align="center">对于一个日期，返回对应的星期</td></tr><tr><td align="center">Hour()</td><td align="center">返回一个日期的小时部分</td></tr><tr><td align="center">Minute()</td><td align="center">返回一个日期的分钟部分</td></tr><tr><td align="center">Month()</td><td align="center">返回一个日期的月份</td></tr><tr><td align="center">Now()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">Second()</td><td align="center">返回一个时间的秒部分</td></tr><tr><td align="center">Time()</td><td align="center">返回一个日期时间的时间部分</td></tr><tr><td align="center">Year()</td><td align="center">返回一个日期的年份部分</td></tr></tbody></table><ul><li>子查询，嵌套<code>SELECT</code>语句<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE prod_id = &#x27;TNT2&#x27;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、联结表"><a href="#五、联结表" class="headerlink" title="五、联结表"></a>五、联结表</h2><ul><li><code>WHERE</code>子句在联结表中起配对的作用（用完全限定列名）</li><li>没有联结条件的表关系返回的结果为笛卡尔积（检索出的行的数目将是第一个表中的行数乘以第二个表中的行数）</li><li>应保证所有联结都有<code>WHERE</code>子句</li><li>使用在<code>WHERE</code>子句中使用<code>AND</code>可以联结多个表</li><li>等值连接也称为内部联结</li><li>尽量使用自联结而不用子查询</li><li><strong>联结的方式</strong><br><img src="https://img-blog.csdnimg.cn/20210428125629111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2ODAyNzEz,size_16,color_FFFFFF,t_70#pic_center" alt="联结"></li><li>外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系</li><li>外键的意义：在于解耦合，定义外键的方法<code>FOREIGN KEY (主键）references &lt;表名&gt;(另一个表的主键）</code></li></ul><h2 id="六、组合查询"><a href="#六、组合查询" class="headerlink" title="六、组合查询"></a>六、组合查询</h2><ul><li>组合查询，必须由两条<code>SELECT</code>语句组成，语句之间用<code>UNION</code>关键字分隔</li><li><code>UNION</code>的每个查询必须包含相同的列，表达式或聚集函数</li><li>使用<code>UNION</code>时重复的行会被自动取消（默认行为），若想返回所有的匹配行可以用<code>UNION ALL</code></li><li>在使用<code>UNION</code>组合查询时，只能使用一次<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后</li></ul><h2 id="七、全文本搜索"><a href="#七、全文本搜索" class="headerlink" title="七、全文本搜索"></a>七、全文本搜索</h2><ul><li>全文本搜索会对结果排序，具有较高优先等级（文本中靠前的等级高）的行先返回，搜索默认不区分大小写</li><li>在创建表时跟句子句<code>Fulltext(列名)</code>对它进行索引，函数<code>Match()</code>指定被搜索的列，函数<code>Against()</code>指定要使用的搜索表达式，搭配<code>WHERE</code>子句进行筛选</li><li>使用查询扩展<code>Against(&#39;anvils&#39; WITH QUERY EXPANSION)</code>，找出和搜索相关的其他行</li></ul><h2 id="八、操作数据"><a href="#八、操作数据" class="headerlink" title="八、操作数据"></a>八、操作数据</h2><ul><li><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><ul><li><code>INSERT INTO &lt;表名&gt; (需要插入值的列名) values (给每个列提供一个值)</code></li><li>没有列出的值默认为NULL</li><li><code>INSERT INTO</code>搭配<code>SELECT</code>可以从旧表复制数据到新表</li></ul></li><li><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><ul><li><code>UPDATE &lt;表名&gt; SET 列=值</code></li><li>要更新的表</li><li>列名和他们的新值</li><li>确定要更新行的过滤条件</li></ul></li><li><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li><code>DELETE FROM &lt;表名&gt; WHERE 匹配的列</code></li><li>删除表中所有行<code>TRUNCATE TABLE</code>语句</li></ul></li><li><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul><li><code>CREATE TABLE &lt;表名&gt;(行及相应值)</code></li><li>表的主键可以在创建表时用<code>PRIMARY KEY</code>关键字指定，主键值必须唯一，多个主键使用<code>,</code>分割</li><li>若仅想在一个表不存在时创建它，应该在表名后给出<code>if not exists</code></li><li>指定<code>not null</code>时在插入或更新行时，该列必须有值</li><li><code>AUTO_INCREMENT</code>告诉mysql每当增加一行时自动增量</li><li>每个表只允许一个<code>AUTO_INCREMENT</code>列</li></ul></li><li><h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><ul><li><code>ALTER TABLE &lt;表名&gt; ADD &lt;列&gt; 列的数据类型</code></li></ul></li><li><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><ul><li><code>DROP TABLE &lt;表名&gt;</code></li></ul></li><li><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><ul><li><code>RENAME TABLE &lt;表名&gt; to &lt;重命名的表名&gt;</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lua Note</title>
      <link href="/2021/04/28/Lua%20Note/"/>
      <url>/2021/04/28/Lua%20Note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>初衷还是Unity</p></blockquote><span id="more"></span><h2 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h2><ul><li><code>lua -i</code>，<code>-i</code>参数用于在运行完其他命令行参数后进入交互模式</li><li>不在交互模式下必须把表达式包在函数<code>print</code>的调用中</li><li>如果不想输出结果，可以在行末加上一个<code>;</code></li></ul><h2 id="词法规范"><a href="#词法规范" class="headerlink" title="词法规范"></a>词法规范</h2><ul><li><p>标识符由任意字母、数字和下划线组成的字符串（不能以数字开头）</p></li><li><p><code>_</code>+大写字母（特殊用途）</p></li><li><p><code>_</code>+小写字母（哑变量）</p></li><li><p>注释</p><ul><li>单行注释<code>--</code></li><li>多行注释<br>  <code>--[[   多行注释   ]]</code></li></ul></li><li><p>分隔符<code>;</code></p><ul><li>增加可读性，不是必须的</li></ul></li><li><p>表达式之间的换行不起任何作用</p></li></ul><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul><li>无须声明即可使用</li><li>使用未经初始化的全局变量，得到的结果时<code>nil</code></li><li><code>nil</code>赋值给全局变量时，Lua会回收该全局变量</li></ul><h2 id="类型和值"><a href="#类型和值" class="headerlink" title="类型和值"></a>类型和值</h2><ul><li><p>Lua语言有8种基本类型</p><ul><li><p><code>nil</code>（空）</p><ul><li>nil赋值给全局变量时，则相当于将其删除（Lua会回收）</li></ul></li><li><p><code>boolean</code>（布尔）</p><ul><li>除false和nil之外的所有值都为真（与C++差异）</li><li>not运算符永远返回boolean类型的值<ul><li><code>not nil</code>  – true</li><li><code>not false</code> – true</li></ul></li></ul></li><li><p><code>number</code>（数值）</p></li><li><p><code>string</code>（字符串）</p></li><li><p><code>userdata</code>（用户数据）</p><ul><li>允许把任意的C语言数据保存在Lua语言变量中</li></ul></li><li><p><code>function</code>（函数）</p></li><li><p><code>thread</code>（线程）</p></li><li><p><code>table</code>（表）</p></li></ul></li><li><p><code>type</code>函数</p><ul><li>获取一个值对应的类型</li><li>返回值永远是一个字符串</li></ul></li></ul><h2 id="独立解释器"><a href="#独立解释器" class="headerlink" title="独立解释器"></a>独立解释器</h2><ul><li><p>是一个可以直接使用Lua语言的小程序</p></li><li><p>源代码文件第一行以井号<code>#</code>开头，那么解释器在加载文件时会忽略这一行，主要是为了方便在POSIX系统中将Lua作为一种脚本解释器来使用</p></li><li><p>假设独立解释器位于<code>/usr/local/bin</code>下</p><ul><li><code>#!/usr/local/bin/lua</code> 或<br>  <code>#!/usr/bin/env lua</code><ul><li>不需要显式调用Lua语言解释器也可以直接运行Lua脚本</li></ul></li></ul></li><li><p>编译器在运行代码前会创建一个名为arg的表</p><ul><li>索引0中保存的内容为脚本名<ul><li><code>arg[0]</code></li></ul></li><li>索引1保存的内容为第一个参数<ul><li><code>arg[1]</code></li></ul></li><li>以此类推</li></ul></li><li><p>Lua语言也支持可变长参数(…)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
