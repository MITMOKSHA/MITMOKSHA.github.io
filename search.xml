<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS61B GITLET PROJECT</title>
      <link href="/2022/05/16/CS61B-GITLET-PROJECT/"/>
      <url>/2022/05/16/CS61B-GITLET-PROJECT/</url>
      
        <content type="html"><![CDATA[<h1 id="CS61B-Gitlet"><a href="#CS61B-Gitlet" class="headerlink" title="CS61B Gitlet"></a>CS61B Gitlet</h1><h2 id="Project-2-Getting-Started-Lab6"><a href="#Project-2-Getting-Started-Lab6" class="headerlink" title="Project 2 Getting Started(Lab6)"></a><strong>Project 2 Getting Started(Lab6)</strong></h2><h3 id="Preperation"><a href="#Preperation" class="headerlink" title="Preperation"></a><strong>Preperation</strong></h3><p>首先使用<code>git submodule update --init --recursive</code>命令将21sp的library更新，再一并复制过来。记得再当前操作系统中设置<code>REPO_DIR</code>环境变量为所有projA、HW的根目录。切记要注意看文档, 以及其中给出的设置来实现相应的功能, 最后才发现FAQ也给了非常好的提示，另外比如说在我的机器上使用<code>python</code>而不是<code>python3</code>，<code>make check</code>是跑不通的，需要找到<code>Makefile</code>的第25行, 修改为<code>PYTHON = python</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main story <span class="string">&quot;Once upon a time, there was a beautiful dog.&quot;</span></span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main story <span class="string">&quot;That dog was named Fjerf.&quot;</span></span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main story <span class="string">&quot;Fjerf loved to run and jump.&quot;</span></span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line">Fjerf loved to run and jump.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main dog Mammoth <span class="string">&quot;German Spitz&quot;</span> 10</span></span><br><span class="line">Woof! My name is Mammoth and I am a German Spitz! I am 10 years old! Woof!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main dog Qitmir Saluki 3</span> </span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 3 years old! Woof!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main birthday Qitmir</span></span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 4 years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java capers.Main birthday Qitmir</span></span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 5 years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br></pre></td></tr></table></figure><p>准备开始Gitlet:</p><h2 id="Gitlet"><a href="#Gitlet" class="headerlink" title="Gitlet"></a><strong>Gitlet</strong></h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><ul><li>Git pro book</li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a><strong>Note</strong></h3><ul><li>往年课程的<a href="https://cdn-uploads.piazza.com/attach/k5eevxebzpj25b/jqr7jm9igtc7l5/k97ipfmgmb3n/Gitlet_Slides.pdf">Slide</a>很好地以图片的形式介绍了<code>Gitlet</code>中的各个命令的实现。</li><li><a href="https://paper.dropbox.com/doc/Gitlet-Persistence-zEnTGJhtUMtGr8ILYhoab">Gitlet Persistence</a></li><li><a href="https://chinese.freecodecamp.org/news/git-internals-objects-branches-create-repo/#:~:text=%E5%9C%A8%20git%20%E4%B8%AD%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84,%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E3%80%82">这里</a>有Git比较详细的图解。</li><li>仔细阅读<code>gitlet.Utils</code>中封装好的方法。</li><li>编写设计文档，<a href="https://sp21.datastructur.es/materials/proj/proj2/design.html">规格</a>和<a href="https://sp21.datastructur.es/materials/proj/proj2/capers-example">示例</a></li><li>Git的内部结构<ul><li>blob(Binary Large Object): 文件的保存内容。一个文件可能对应多个blob：每个blob在不同的<code>Commit</code>中被跟踪。</li><li>Tree: 映射文件名称(name)到blob的reference，或者是映射文件名称到其他tree(子目录)的引用。</li><li>commits: 日志消息，其他元数据(提交日期、作者等), 对树的引用和对Parent Commit的引用。<code>repository</code>还维护了分支头到提交引用的映射(以便某些重要的提交具有符号名称)</li></ul></li><li>Gitlet简化的部分<ul><li>将树合并到Commit中而不处理子目录</li><li>只能两个父级合并</li><li>元数据仅包含时间戳和日志消息，因此Commit将由<code>日志消息</code>, <code>时间戳</code>, <code>文件名</code>到<code>Blob</code>引用的映射，<code>父引用</code>, (用于Merge的)<code>第二个父引用</code>来组成。</li></ul></li><li>每个blob和每个commit都有一个唯一的整数id，用作该对象的<strong>引用</strong>。</li><li>当使用SHA-1哈希一个Commit时，会包括所有的数据和引用。</li><li>区分<code>Commit</code>和<code>Blob</code>的哈希值，一种方法是可以在两个类中各自定义一个属性字段来实现。</li><li>不应该在Main中做完所有事情，而是将需要实现的内容封装成一个函数到<code>Repository</code>类中去。</li><li>序列化最好使用<code>TreeMap</code>而不是<code>HashMap</code>。</li><li><code>Gitlet</code>不会出现<code>deteched head</code>(分离头部)的状态。指的是当前<code>HEAD</code>指向的Commit不表示任何一个分支。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul><li>在<code>terminal</code>下出现了<code>Esc</code>无法退出<code>insert mode</code>而且还进入了<code>Itellij</code>的编辑界面。解决方案看<a href="https://www.jianshu.com/p/f1ae155cda6e">此处</a></li><li>暂存区包含两个区域, <code>stage for addition</code>和<code>stage for removal</code>。</li><li><code>gitlet</code>中一条命令对应运行一次程序，因此需要将用到的数据结构序列化为字节流后保存到文件中。</li><li>在实验一开始给的<code>Utils</code>类中， 不需要使用<code>createNewFile()</code>来创建文件, 因为<code>writeObject()</code>中会调用<code>WriteContent()</code>，若文件不存在则会自动创建，或者文件存在则覆盖掉它。</li><li>注意要在当前目录下执行<code>make check</code>，测试文件可能跑通(可能需要操作src/目录中的文件)。</li><li>注意每次更新数据时都需要序列化对象和反序列化文件, 保证更新的数据能够及时存储到文件中。</li><li>也需要将<code>blobs</code>的映射集合序列化存储起来(同样用TreeMap)，<code>checkout</code>命令要使用(用SHA-ID(文件名+文件内容)来作为文件名)。在<code>add</code>命令将blob和文件名映射放入<code>stage for addition</code>的同时，将blob和文件内容的映射放入<code>blobs</code>集合。</li><li><code>blob</code>生成<code>blobId</code>(sha-1 id)的时候，需要通过<code>文件名+文件内容(字节流)</code>生成。若只用文件内容生成<code>blobId</code>，不同名的两个文件内容都为空时，生成的<code>blobId</code>是一致的, 使用<code>文件名+文件对象</code>生成的sha-1哈希也是同样的结果。</li><li><code>mkdirs()</code>方法可以一同创建之前未存在的父目录。</li><li>注意写文件内容时用<code>writeContent()</code>而不是<code>writeObject()</code>。注意到<code>writeObject</code>会在调用<code>writeContent</code>前将第二个参数先序列化, 若将字节数组再序列化，可能会在内容中写入额外的信息。</li><li><code>Untracked file</code>，既没有被当前<code>commit</code>跟踪，也没有被放到<code>stage area</code>里。或者是已经被<code>stage for removal</code>但是又重新创建了。(考虑到我这里rm情况下没有将其从暂存区删除，仅仅是将它从<code>stage for removal</code>删除了而已)。</li><li>保证分支头只有一个, <code>get(0)</code>可以直接取(这里我将分支做所处的位置做成了一个目录，目录中是用分支名来命名的文件, 方便直接取头Commit)。</li><li>暂存区使用<code>blobId</code>映射<code>文件对象</code>不可取(序列化后提取的文件内容还是的却决于当前工作目录下的内容，不符合预期)，试试映射文件内容(字符串readContentsAsString)。经过调试发现必须得映射字节流，因为前面生成blobId中需要<code>文件名+文件内容(字节流)</code>。</li><li>注意<code>Utils</code>中的<code>restrictedDelete()</code>方法，是如果文件存在则删除, 如果文件对象不存在则删除未成功返回false, 给我们实现<code>rm</code>指令来删除当前工作目录中的文件提供了一个很好的帮助。</li><li>需要在每次<code>commit</code>命令执行时都更新分支头目录中的数据以及其对应<code>branches</code>目录中的数据。</li><li>除了<code>init</code>之外剩下的命令在处理之前都需要检测当前<code>.gitlet</code>目录是否存在, 若不存在则输出报错信息。</li><li>在开始项目任何一个功能前一定要有一个<code>Big picture</code>和整体思路，确保在实现过程中能够顺利进行。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h3><ul><li>查看<code>tester.py</code>文档中一些相应的操作来对应测试文件。测试文件可以从<code>AG</code>中获取。</li></ul><h3 id="init"><a href="#init" class="headerlink" title="init"></a><strong>init</strong></h3><ul><li>创建<code>.gitlet</code>目录，并在其中新建一些文件来存储序列化信息。</li><li><code>init</code>会自动创建一个包含initial commit信息的<code>Commit</code>开始</li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a><strong>add</strong></h3><ul><li>暂存已经暂存过的文件，会用新内容来覆盖先前的内容。</li><li>若当前需要暂存的文件与Commit跟踪的文件版本一致(包括其修改之后又还原内容的文件，blobId都是一致的)，则不对它进行处理。</li><li>若当前添加文件在<code>Stage for removal</code>中，则将它从里面删除。</li><li>gitlet一次只能添加一个文件。</li><li>维护一个<code>TreeMap</code>来存放<code>stage for addition</code>文件。</li></ul><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a><strong>commit</strong></h3><ul><li>需要考虑在当前跟踪的文件可能在新的Commit中未被跟踪，与rm指令将文件<code>Stage for removal</code>相关。</li><li>当前Commit跟踪的blob需要加上其父Commit跟踪的blob(前提是父Commit中跟踪的blob未被当前Commit跟踪的文件覆盖过)。</li><li><code>commmit</code>后将<code>stage area</code>清空，也就是<code>stage for add</code>和<code>stage for removal</code>。</li><li>若没有文件被暂存，或没有提交信息则中止。</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><strong>rm</strong></h3><ul><li>若当前文件正在<code>stage for addition</code>，则将它从里面移除。</li><li>若文件在当前<code>Commit</code>中被跟踪，则将其放入<code>stage for removal</code>暂存区中, 同时将本地目录文件删除。</li><li>只考虑被当前Commit跟踪的情况下</li><li>维护一个<code>TreeMap</code>来存放<code>stage for removal</code>文件。</li></ul><h3 id="log"><a href="#log" class="headerlink" title="log"></a><strong>log</strong></h3><ul><li>注意显示的是太平洋标准时间而不是UTC。</li><li>当前操作系统显示时间得调成英文显示，否则打印log会出现中文字样</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a><strong>find</strong></h3><ul><li>通过<code>Utils</code>类中给的方法<code>plainFilenamesIn</code>, 直接遍历<code>commit Id</code>所处的目录，若出现<code>commit</code>对象不同但提交信息一致的打印情况，分行打印各自的<code>commit id</code>。</li></ul><h3 id="status"><a href="#status" class="headerlink" title="status"></a><strong>status</strong></h3><ul><li><code>TreeMap</code>数据结构会按照字典序来排序。</li><li><code>Untrack file</code>，既未跟踪也未暂存。未跟踪将当前目录下的文件名和当前最新Commit中track的文件名做对比。若未包含则说明未跟踪。同样包括已经准备删除但又重新创建的文件(说明其还在<code>stage for removal</code>里，因为<code>stage area</code>只在commit时删除)。思考该该怎么标记? rm之后add的文件?</li><li><code>modified</code>, 同样与Commit中track对比，若文件名相同，但BlobId不同则说明被修改过。</li><li>遍历当前跟踪的文件，使用<code>exist</code>判断文件对象是否存在以及是否存在于<code>stage for removal</code>，就能判断文件是否被<code>delete</code>。</li></ul><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a><strong>checkout</strong></h3><ul><li>有三类<code>checkuout</code>:<ul><li>java gitlet.Main checkout – [file name]</li><li>java gitlet.Main checkout [commit id] – [file name]</li><li>java gitlet.Main checkout [branch name]</li></ul></li><li>若<code>checkout</code>切换分支，且当前目录下文件有文件未被跟踪，则打印提示信息并退出。</li><li>注意切换完成，将新分支放入<code>heads</code>目录的同时，从<code>heads</code>目录中删除先前的分支。</li><li><code>checkout filename</code>将当前文件从<code>head commit</code>中拿到当前工作目录。</li><li>切换到另一个分支要将暂存区清空。要将当前commit中跟踪了但切换到的分支commit中没有跟踪的文件删除(如果有则覆盖)。</li><li>考虑两种情况:<ul><li><code>checkout</code>的目标分支跟踪的文件比当前目录的文件多，直接写就行了</li><li><code>checkout</code>的目标分支跟踪的文件比当前目录的文件少，需要删除本地目录中多余的文件</li><li>这两中情况都需要遍历当前目录中的所有文件名来确定。</li></ul></li><li>一个<strong>错误的策略</strong>是切换之前先将当前当前文件下所有的都删除，然后再将切换到的分支commit跟踪的文件写进CWD当前工作目录, 在后续将跟踪文件写入当前工作目录时，取不到文件对象了。</li><li><code>checkout branchName</code>时需要将暂存区清空。</li><li>后面还有一个<code>checkout shortid</code>的测试，需要包括通过commitid的前8就能切换到不同的分支。和commitId一样序列化到磁盘上的文件就行。</li><li>gitlet<strong>不允许</strong>删除提交。</li></ul><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a><strong>reset</strong></h3><ul><li>神似<code>checkout branchName</code>, 只是最后是将<code>当前branch</code>回退而不是切换分支。</li></ul><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a><strong>branch</strong></h3><ul><li>只新建一个分支(即在branches目录中新建一个序列化的分支Commit文件), 但是并未切换到新建的分支。</li></ul><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a><strong>merge</strong></h3><ul><li>将给定分支名为branchName的文件合并到当前分支中。</li><li>如何找到<code>split point</code>? 考虑到gitlet只支持两个分支合并，因此可以把新建分支的commit作为split point?! hhh笑死ucb学生视频里第一个提问和我想得一模一样。我感觉这种方法在gitlet中可行，但在多分支合并时就不行了。还是得去过一遍图的遍历这一节的slide。</li><li><strong>Latest common ancestor</strong>其实指的也就是<code>split point</code>。</li><li>如果给定分支是<code>split point</code>则不做任何处理。</li><li>无论是否发生冲突，<code>merge</code>结束后新建一个<code>Commit</code>。</li><li>如果当前分支是<code>split point</code>, 则<strong>切换</strong>到给定分支。</li><li>发生冲突且修改的内容不同只写当前分支的冲突文件。</li><li>需要复用<code>add</code>和<code>rm</code>以及<code>commit</code>命令。</li><li>git提交后的分布可以看作是个<code>direct graph</code>。</li><li>可以通过将从<code>init commit</code>到当前分支经过的commit放到一个list中，同时将要给定分支的路径也放到一个set中，再通过按指定顺序遍历(由当前分支开始)当前分支的list，使用<code>contains</code>方法来确定遍历经过的commit是否在分支路径的set中。需要使用BFS来遍历。</li><li>之前的策略是在切换分支(checkout, reset)时才将branches目录中的当前分支信息更新，这在这一步中获取当前分支对象是危险的，因此需要调整策略，在每一次commit更新HEAD目录时和reset时，都更新Branches中当前分支信息。这样就能保证当前分支在Head目录和Branches目录中的信息是同步一致的了。</li><li>注意Java中<code>null</code>在字符串比较时不能用<code>equals()</code>来比较。</li><li>别忘了改写冲突文件时需要生成新的<code>blobId</code>放入暂存区中在新的合并Commit中加入当前目录。</li></ul><h4 id="处理case"><a href="#处理case" class="headerlink" title="处理case"></a><strong>处理case</strong></h4><ul><li><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-5b2470a6def367603e617ea9c709c231.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Image"></li><li>想到了一个比较情况的好方法，将当前分支，给定分支以及split point三个集合中含有的文件名的并集放到集合里。比较时需要各个集合的BlobId和文件名的映射，以及BlobId和content的映射。</li><li>由两个值来区分所有情况分别是<code>isPresent</code>和<code>IsModified</code>。</li><li><code>Modifed</code>只需要通过当前分支分支或给定分支， 与<code>split point blobId</code>比较来区分就行了, 程序里我将不存在的文件的blobId赋值为空串。</li><li>当前分支和给定分支都modifed也就是case3还需要细分发生冲突，还是不发生冲突。直接通过比较当前分支和给定分支<code>commit Id</code>即可。</li><li><code>git pro</code>中的原话, 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。这点与Gitlet还是不同的。</li><li>发生冲突的内容差异会自动写入冲突文件(按合理性来说只需要写入当前分支头即可)如, 需要解决冲突后，需要打印提示信息，合并的提交跟踪冲突文件:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">contents of file in current branch</span><br><span class="line">=======</span><br><span class="line">contents of file in given branch</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li>处理好每个情况后将每个文件对应的result添加到暂存区等待新的Commit。result的内容为当前分支的内容也需要<code>stage for addition</code>, 但不需要放入<code>blobs</code>集合中。</li><li><code>getBytes</code>方法可以将字符串转化为字节数组(byte[])。</li></ul><p><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-de14f3c3a0f560d423afde1fdd05300b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Image"></p>]]></content>
      
      
      <categories>
          
          <category> CS61B </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61C CPU PROJECT</title>
      <link href="/2022/05/16/CS61C-CPU-PROJECT/"/>
      <url>/2022/05/16/CS61C-CPU-PROJECT/</url>
      
        <content type="html"><![CDATA[<h1 id="CS61C-CPU-PROJECT"><a href="#CS61C-CPU-PROJECT" class="headerlink" title="CS61C CPU PROJECT"></a><strong>CS61C CPU PROJECT</strong></h1><h2 id="关于如何Debug"><a href="#关于如何Debug" class="headerlink" title="关于如何Debug"></a><strong>关于如何Debug</strong></h2><p>相信前面的<code>lab5</code>和<code>lab6</code>已经奠定好了使用<code>logisim</code>的基础，前面相关内容同样奠定好了RISC-V ISA的知识基础。接下来Project中的一系列的task可以通过参考:</p><ul><li><code>61C Reference card</code></li><li><code>ROM</code>表</li><li>对应测试文件中的汇编代码和测试电路</li><li>通过<code>change value</code>来对电路中的bit位进行赋值，查看输入输出的值</li></ul><p>需要将所有这些结合起来构建完整的<code>big picture</code>。</p><h2 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a><strong>ALU</strong></h2><p>根据文档中给的功能类别通过门级电路来构造基本的ALU原件，个别功能的实现所用到的元器件还需要查看手册。<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-014bf51c0d29af49c1b904c3cb4a28e2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="ALU"></p><h2 id="RegFile"><a href="#RegFile" class="headerlink" title="RegFile"></a><strong>RegFile</strong></h2><p>需要用到<code>Multiplexer</code>和<code>Demultiplexer</code>，以及一些基本的逻辑，比较废鼠标…<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-2bc53f743fb481fc3a22f8c141f95071.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Regfile"></p><h2 id="Immediate-Generator"><a href="#Immediate-Generator" class="headerlink" title="Immediate Generator"></a><strong>Immediate Generator</strong></h2><p>这一部分跟着61C绿卡里的指令编码表。以下显示的是所有含有imm部分的指令的实现。<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-f46d246882abfdf6f28e13266e41c363.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Imm-gen"></p><h2 id="Control-Store-Implemented-by-ROM"><a href="#Control-Store-Implemented-by-ROM" class="headerlink" title="Control Store(Implemented by ROM)"></a><strong>Control Store(Implemented by ROM)</strong></h2><p>通过分析绿卡上或者是文档里给的指令的功能，来初始化每条指令对应的微指令，需要结合数据通路中每个部分的实现以及PartA中我们已经构建好的ALU。Immsel以及个别控制信号可以自行设计(后面会有介绍修改<code>.csv</code>文件即可, 我这边是修改过后的)，建议PartB部分一开始就完善ROM表。<br>下面给出我的数据:<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-3ffb5bc0653de42a33fba13bf38a868d.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="ROM"></p><p>完善ROM表后，将<code>ROM Output</code>复制到控制逻辑的ROM中。需要在控制逻辑电路中根据指令编码中的<code>opcode</code>, <code>fun3</code>, <code>fun7</code>字段来区分每个类型，甚至每条指令，再通过优先级别编码器来索引控存中的微指令, 产生对应的控制信号。<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-00828871fd39660bf6ddaf8a32ab38fa.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Control"><br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-ee25b2c060400847e6cf55d220704422.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Control"><br>因为优先级别编码器最多只能支持32bit, 但我们的指令有36条, 需拆拆分成两部分输入。剩下四条指令可以通过指令编码格式来各自区分，然后再找到指令编码格式中与前32条指令相异的bit作为控制信号来控制二选一MUX。<img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-4c10eb6557e75cdd3866bd188e5868ff.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Control"></p><h2 id="Branch-and-Jump-Instruction"><a href="#Branch-and-Jump-Instruction" class="headerlink" title="Branch and Jump Instruction"></a><strong>Branch and Jump Instruction</strong></h2><p>通过<code>BrUn</code>信号来实现分支比较器产生对应<code>BrEq</code>和<code>BrLt</code>的控制信号决定分支是否发生跳转。<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-b4917e6611d7a6b8aa66d86f9d1362b5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Branch Comp"></p><p>B类指令和J类指令产生<code>PCsel</code>控制信号来决定是否修改<code>PC</code>, 同样也通过指令编码格式中的bit来区分jump发生还是branch发生<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-941f7fe17956fab75c7e74b1afa5fb17.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Control"></p><h2 id="Loading-and-Storing"><a href="#Loading-and-Storing" class="headerlink" title="Loading and Storing"></a><strong>Loading and Storing</strong></h2><p>这部分需要细心一些，部分load和部分store无论是字节还是半字都要<strong>符号位拓展</strong>成字的大小。部分load相对部分store来说比较简单，因为部分load只需要考虑从存储器中读出来的数据位置不同即可，而部分store不仅需要将从寄存器中读来的数据分割，还需要将分割的数据存到对应存储器中字的偏移位置(这部分是由Mask来确定写入的位置的)。需要通过低两位来判断具体load的是当前字的哪一个部分。</p><h3 id="Partial-Load"><a href="#Partial-Load" class="headerlink" title="Partial Load"></a><strong>Partial Load</strong></h3><p>如果不是取一个字的数据，则要根据当前指令lw来访问存储器的地址字段的低两位来产生控制信号，决定取当前数据字的哪一个部分的数据到寄存器中(通过splitter来划分)。由指令编码中的bit来作为控制信号区分，选择具体是<code>lw</code>还是<code>lh</code>, <code>lb</code>。<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-723ccb2b6671606fe4a6ac5b0cbf58c9.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="Partial-Store"><a href="#Partial-Store" class="headerlink" title="Partial Store"></a><strong>Partial Store</strong></h3><p>同样有指令编码格式来区分三种类型的store指令决定store到存储器中的数据。MemWriteMask有四个二进制bit组成，分别表示store到存储器中数据的位置, 实验中并未提到mask实现的细节。但是需要完成有指令编码和访问存储器的地址来生成mask。生成的mask需要通过指令编码格式中的bit和地址字段的低两位来区分, 额外在利用上优先级别编码器来索引。 生成的mask有<code>lb</code>的0001, 0010, 0100, 1000, 和<code>lh</code>的0011, 1100以及<code>lw</code>的1111, 七种组合。<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-1b3b6bfa9c35647d8b7df3225a1e2a6f.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="Datapath"><a href="#Datapath" class="headerlink" title="Datapath"></a><strong>Datapath</strong></h2><p>下面是流水过后的数据通路, 两级流水线挺好实现的，看了一下不需要考虑<code>Structure Hazards</code>以及<code>Data Hazards</code>，省去了很多数据通路上的麻烦。需要考虑的只有<code>Control Hazards</code>。当Branch或者Jump发生时，紧随其后进入流水线的只有一条指令，实验文档里解决的方案是插入一条NOP指令来防止冲突。什么时候插入NOP指令根据<code>PCsel</code>控制信号来决定即可。同时注意两个不同stage之间的差异(导致后面利用到PC的指令执行结果不正确)，需要通过在两个stage之间加流水线寄存器来存储一个时钟周期之内的信息(包括指令和PC值)。<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-55adeda8be6c453ab203579651619b65.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Datapath"></p><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a><strong>参考书目</strong></h2><ul><li>Introduction to Computing Systems: From Bits &amp; Gates to C &amp; Beyond [3ed.]</li><li>P&amp;H [RISC-V 2ed.]</li><li>CAAQA [6ed.]</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS61C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Lab2: Bomb Lab</title>
      <link href="/2022/05/16/CSAPP-Lab2-Bomb-Lab/"/>
      <url>/2022/05/16/CSAPP-Lab2-Bomb-Lab/</url>
      
        <content type="html"><![CDATA[<h1 id="CSAPP-Lab2-Bomb-Lab"><a href="#CSAPP-Lab2-Bomb-Lab" class="headerlink" title="CSAPP Lab2: Bomb Lab"></a>CSAPP Lab2: Bomb Lab</h1><h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a><strong>Preparation</strong></h2><p>建议在实验大致看一下lab相关的<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f20/www/recitations/f20New/recitation02-bomblab.pdf">pdf</a>。使用<code>man</code>手册来查看库函数，<code>callq … &lt;_exit@plt&gt;</code>类型为C的库函数。注意商用的architecture是以字节为单位编址寻址。</p><p>参考CS61C所了解到的Tool, 做足了准备工作。安装<code>CGDB</code>, 相比较于<code>GDB</code>的<code>tui</code>在调试lab时显示不会出现乱码的情况。从<code>ubuntu</code>中<code>apt-get</code>下载到的版本较低，一些功能不适用。参考<a href="https://cgdb.github.io/">CGDB官网</a>下载最新版本的<code>CGDB</code>, 简单浏览了一下<a href="https://cgdb.github.io/docs/cgdb.pdf">CGDB官方手册</a>, 以及对应<code>CGDB</code>在<code>~/.cgdb/cgdbrc</code>文件中做了如下的配置足以满足调试需求:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set disasm</span><br><span class="line">:set hls</span><br><span class="line">:set syn=style</span><br></pre></td></tr></table></figure><p>另外gdb相关内容再推荐这两本书籍<br><code>Debugs Hacks</code>和<code>Debugging with GDB</code>。</p><p>需要用<code>chmod</code>命令修改一下<code>bomb</code>二进制文件的可执行权限</p><p>接下来可以愉快地开始<code>bomb lab</code>了~</p><p>运行<code>cgdb</code>且在对应phase打上断点后可以用一个放入输入信息的文本文件标准输入重定向到传递给主函数的参数中，这样就可以避免卡死在读取输入的systemcall上。更多关于<a href="https://stackoverflow.com/questions/19467865/how-to-use-redirection-in-c-for-file-input">重定向</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)run &lt; in</span><br></pre></td></tr></table></figure><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a><strong>Phase_1</strong></h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp                   # 开辟栈帧保存返回地址和写在文件中的字符串函数参数<span class="built_in">edi</span></span><br><span class="line">  400ee4:be <span class="number">00</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x402400,%esi</span><br><span class="line">  400ee9:e8 4a <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">401338</span> &lt;strings_not_equal&gt;  # <span class="built_in">edi</span>接着传给strings_not_equal</span><br><span class="line">  400eee:<span class="number">85</span> c0                <span class="keyword">test</span>   %eax,%eax                   # 若字符串相等，即函数返回<span class="number">0</span>，则Defuse炸弹</span><br><span class="line">  400ef0:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     400ef7 &lt;phase_1+<span class="number">0x17</span>&gt;</span><br><span class="line">  400ef2:e8 <span class="number">43</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          <span class="keyword">add</span>    <span class="number">$0</span>x8,%rsp                   # 函数调用结束栈顶指针复原</span><br><span class="line">  400efb:c3                   retq </span><br></pre></td></tr></table></figure><p>分析一下<code>strings_not_equal</code>，判断两个字符串是否相等。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000401338</span> &lt;strings_not_equal&gt;:</span><br><span class="line">  <span class="number">401338</span>:<span class="number">41</span> <span class="number">54</span>                <span class="keyword">push</span>   %r12                             # callee save</span><br><span class="line">  40133a:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp</span><br><span class="line">  40133b:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line">  40133c:<span class="number">48</span> <span class="number">89</span> fb             <span class="keyword">mov</span>    %rdi,%rbx                        # 将两个参数放入local中, 防止后续操作被覆盖</span><br><span class="line">  40133f:<span class="number">48</span> <span class="number">89</span> f5             <span class="keyword">mov</span>    %rsi,%rbp</span><br><span class="line">  <span class="number">401342</span>:e8 d4 ff ff ff       callq  40131b &lt;string_length&gt;           # 第一个参数<span class="built_in">rdi</span>传递给函数返回第一个字符串长度到<span class="built_in">eax</span>中</span><br><span class="line">  <span class="number">401347</span>:<span class="number">41</span> <span class="number">89</span> c4             <span class="keyword">mov</span>    %eax,%r12d</span><br><span class="line">  40134a:<span class="number">48</span> <span class="number">89</span> ef             <span class="keyword">mov</span>    %rbp,%rdi                        # 将当前函数的第二个参数传递给<span class="built_in">rdi</span></span><br><span class="line">  <span class="number">40134d</span>:e8 c9 ff ff ff       callq  40131b &lt;string_length&gt;           # 返回第二个字符串参数的长度</span><br><span class="line">  <span class="number">401352</span>:ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%edx</span><br><span class="line">  <span class="number">401357</span>:<span class="number">41</span> <span class="number">39</span> c4             <span class="keyword">cmp</span>    %eax,%r12d                       # 两个参数的长度比较</span><br><span class="line">  40135a:<span class="number">75</span> 3f                <span class="keyword">jne</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;  # 字符串不相等则到转到restore并返回<span class="built_in">edx</span>中保存的<span class="number">1</span></span><br><span class="line">  40135c:0f b6 <span class="number">03</span>             movzbl (%rbx),%eax                      # 零拓展避免<span class="built_in">eax</span>高位出现杂乱数据, 字符为8bit，将其高位清<span class="number">0</span></span><br><span class="line">  40135f:<span class="number">84</span> c0                <span class="keyword">test</span>   %al,%al                          # 检测第一个参数是否遍历到terminator, 这种形式让<span class="built_in">al</span>与<span class="number">0</span>比较</span><br><span class="line">  <span class="number">401361</span>:<span class="number">74</span> <span class="number">25</span>                <span class="keyword">je</span>     <span class="number">401388</span> &lt;strings_not_equal+<span class="number">0x50</span>&gt;</span><br><span class="line">  <span class="number">401363</span>:3a <span class="number">45</span> <span class="number">00</span>             <span class="keyword">cmp</span>    <span class="number">0x0</span>(%rbp),%al</span><br><span class="line">  <span class="number">401366</span>:<span class="number">74</span> 0a                <span class="keyword">je</span>     <span class="number">401372</span> &lt;strings_not_equal+<span class="number">0x3a</span>&gt;</span><br><span class="line">  <span class="number">401368</span>:eb <span class="number">25</span>                <span class="keyword">jmp</span>    40138f &lt;strings_not_equal+<span class="number">0x57</span>&gt;</span><br><span class="line">  40136a:3a <span class="number">45</span> <span class="number">00</span>             <span class="keyword">cmp</span>    <span class="number">0x0</span>(%rbp),%al</span><br><span class="line">  <span class="number">40136d</span>:0f 1f <span class="number">00</span>             nopl   (%rax)</span><br><span class="line">  <span class="number">401370</span>:<span class="number">75</span> <span class="number">24</span>                <span class="keyword">jne</span>    <span class="number">401396</span> &lt;strings_not_equal+<span class="number">0x5e</span>&gt;</span><br><span class="line">  <span class="number">401372</span>:<span class="number">48</span> <span class="number">83</span> c3 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%rbx                        # 移动读取两个字符串参数中的字符</span><br><span class="line">  <span class="number">401376</span>:<span class="number">48</span> <span class="number">83</span> c5 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%rbp</span><br><span class="line">  40137a:0f b6 <span class="number">03</span>             movzbl (%rbx),%eax</span><br><span class="line">  <span class="number">40137d</span>:<span class="number">84</span> c0                <span class="keyword">test</span>   %al,%al                          # 检测第二个参数是否遍历到terminator</span><br><span class="line">  40137f:<span class="number">75</span> e9                <span class="keyword">jne</span>    40136a &lt;strings_not_equal+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">401381</span>:ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%edx                        # 两参数字符串相等，返回<span class="number">0</span></span><br><span class="line">  <span class="number">401386</span>:eb <span class="number">13</span>                <span class="keyword">jmp</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">401388</span>:ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%edx</span><br><span class="line">  <span class="number">40138d</span>:eb 0c                <span class="keyword">jmp</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  40138f:ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%edx</span><br><span class="line">  <span class="number">401394</span>:eb <span class="number">05</span>                <span class="keyword">jmp</span>    40139b &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">401396</span>:ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%edx</span><br><span class="line">  40139b:<span class="number">89</span> d0                <span class="keyword">mov</span>    %edx,%eax                        # <span class="built_in">eax</span>作为返回值</span><br><span class="line">  <span class="number">40139d</span>:5b                   <span class="keyword">pop</span>    %rbx                             # restore</span><br><span class="line">  40139e:<span class="number">5d</span>                   <span class="keyword">pop</span>    %rbp</span><br><span class="line">  40139f:<span class="number">41</span> 5c                <span class="keyword">pop</span>    %r12</span><br><span class="line">  4013a1:c3                   retq </span><br></pre></td></tr></table></figure><p>观察<code>phase_1</code>函数，需要进入函数<code>string_not_equal</code>，并通过该函数的返回结果来决定是否引爆炸弹。进入该函数后，可以发现在函数中比较的是<code>rdi</code>和<code>rsi</code>两个字符串参数。<code>rdi</code>是标准输入中输入的字符串。<code>string_length</code>的返回值保存在寄存器<code>eax</code>中为两字符串的长度。长度不相等即表示字符串肯定不相等，则返回寄存器<code>edx</code>中的1。初步可以判断<code>phase_1</code>要求比较的两个字符串要相等才能<code>defuse</code>。再仔细观察<code>phase_1</code>函数中<code>test %eax, %eax</code>测试寄存器<code>eax</code><strong>非0</strong>则跳转到<code>bomb</code>。因此要想不爆炸必须得保证存在于<code>($rdi)</code>, <code>($rsi)</code>中的两个字符串相等，即<code>strings_not_equal</code>的返回值为<strong>0</strong>。</p><p>用<code>x/s</code>查看对应<code>memory</code>中地址单元的的字符串内容, 使标准输入参数<code>rdi</code>等于下述字符串即可<code>defuse</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure><p>经分析答案为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a><strong>Phase_2</strong></h2><p><code>x86</code>ISA规定，当参数超过6个的时候就会使用栈来保存参数。<code>print (char*) 0x4025c3</code>打印由地址0x4025c3起始的字符串，显示的结果可以发现字符串为<code>&quot;%d %d %d %d %d %d&quot;</code>格式串。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp                       # callee save</span><br><span class="line">  400efd:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line">  400efe:<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x28,%rsp                 # <span class="built_in">rdi</span>为标准输入字符串的地址</span><br><span class="line">  400f02:<span class="number">48</span> <span class="number">89</span> e6             <span class="keyword">mov</span>    %rsp,%rsi                  # <span class="built_in">rsp</span>作为函数read_six_numbers的第二个参数, caller save</span><br><span class="line">  400f05:e8 <span class="number">52</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40145c &lt;read_six_numbers&gt;  # 函数读取六个数字到栈空间上。</span><br><span class="line">  400f0a:<span class="number">83</span> 3c <span class="number">24</span> <span class="number">01</span>          cmpl   <span class="number">$0</span>x1,(%rsp)                # 取第一个数字</span><br><span class="line">  400f0e:<span class="number">74</span> <span class="number">20</span>                <span class="keyword">je</span>     400f30 &lt;phase_2+<span class="number">0x34</span>&gt;</span><br><span class="line">  400f10:e8 <span class="number">25</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:eb <span class="number">19</span>                <span class="keyword">jmp</span>    400f30 &lt;phase_2+<span class="number">0x34</span>&gt;</span><br><span class="line">  400f17:8b <span class="number">43</span> fc             <span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbx),%eax           # 取接下来的数字</span><br><span class="line">  400f1a:<span class="number">01</span> c0                <span class="keyword">add</span>    %eax,%eax                 # double</span><br><span class="line">  400f1c:<span class="number">39</span> <span class="number">03</span>                <span class="keyword">cmp</span>    %eax,(%rbx)</span><br><span class="line">  400f1e:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     400f25 &lt;phase_2+<span class="number">0x29</span>&gt;     # 下一个参数的值需要为上一个参数值的两倍才能确保不发生爆炸</span><br><span class="line">  400f20:e8 <span class="number">15</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:<span class="number">48</span> <span class="number">83</span> c3 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%rbx</span><br><span class="line">  400f29:<span class="number">48</span> <span class="number">39</span> eb             <span class="keyword">cmp</span>    %rbp,%rbx                 # 若读到第六个数字，则将局部变量所使用的寄存器restore到原来的值, <span class="keyword">pop</span>栈指针复原到调用前的位置, 否则继续<span class="keyword">loop</span></span><br><span class="line">  400f2c:<span class="number">75</span> e9                <span class="keyword">jne</span>    400f17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line">  400f2e:eb 0c                <span class="keyword">jmp</span>    400f3c &lt;phase_2+<span class="number">0x40</span>&gt;</span><br><span class="line">  400f30:<span class="number">48</span> <span class="number">8d</span> 5c <span class="number">24</span> <span class="number">04</span>       <span class="keyword">lea</span>    <span class="number">0x4</span>(%rsp),%rbx</span><br><span class="line">  400f35:<span class="number">48</span> <span class="number">8d</span> 6c <span class="number">24</span> <span class="number">18</span>       <span class="keyword">lea</span>    <span class="number">0x18</span>(%rsp),%rbp           # <span class="built_in">rsp</span>~<span class="built_in">rsp</span>-<span class="number">0x10</span>这部分为函数的返回地址和局部变量以及所用的栈空间</span><br><span class="line">  400f3a:eb <span class="built_in">db</span>                <span class="keyword">jmp</span>    400f17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line">  400f3c:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          <span class="keyword">add</span>    <span class="number">$0</span>x28,%rsp</span><br><span class="line">  400f40:5b                   <span class="keyword">pop</span>    %rbx</span><br><span class="line">  400f41:<span class="number">5d</span>                   <span class="keyword">pop</span>    %rbp</span><br><span class="line">  400f42:c3                   retq   </span><br></pre></td></tr></table></figure><p><code>read_six_numbers</code>中会调用C库函数<code>sscanf</code>，<code>man</code>手册中返回值的描述，返回输入数字匹配的个数。</p><blockquote><p>On success, these functions return the number of input items  success‐<br>fully  matched  and  assigned; this can be fewer than provided for, or<br>even zero, in the event of an early matching failure.</p></blockquote><p>注意<code>x86</code>栈帧由低地址到高地址，先是返回地址，再到局部变量，再到save register。第1个参数在栈帧低地址 立即数为<code>32bit</code>, 按字节变址寻址, 函数参数为<code>caller save</code>。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp                    # 开辟栈帧, <span class="built_in">rdi</span>为第一个参数</span><br><span class="line">  <span class="number">401460</span>:<span class="number">48</span> <span class="number">89</span> f2             <span class="keyword">mov</span>    %rsi,%rdx                     # 第<span class="number">3</span>个参数</span><br><span class="line">  <span class="number">401463</span>:<span class="number">48</span> <span class="number">8d</span> 4e <span class="number">04</span>          <span class="keyword">lea</span>    <span class="number">0x4</span>(%rsi),%rcx                # 第<span class="number">4</span>个参数</span><br><span class="line">  <span class="number">401467</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">46</span> <span class="number">14</span>          <span class="keyword">lea</span>    <span class="number">0x14</span>(%rsi),%rax               # 第<span class="number">8</span>个参数</span><br><span class="line">  40146b:<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>       <span class="keyword">mov</span>    %rax,<span class="number">0x8</span>(%rsp)</span><br><span class="line">  <span class="number">401470</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">46</span> <span class="number">10</span>          <span class="keyword">lea</span>    <span class="number">0x10</span>(%rsi),%rax               # 第<span class="number">7</span>个参数</span><br><span class="line">  <span class="number">401474</span>:<span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>          <span class="keyword">mov</span>    %rax,(%rsp)</span><br><span class="line">  <span class="number">401478</span>:4c <span class="number">8d</span> 4e 0c          <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsi),%r9                 # 第<span class="number">6</span>个参数</span><br><span class="line">  40147c:4c <span class="number">8d</span> <span class="number">46</span> <span class="number">08</span>          <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsi),%r8                 # 第<span class="number">5</span>个参数</span><br><span class="line">  <span class="number">401480</span>:be c3 <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x4025c3,%esi                # 第<span class="number">2</span>个参数，格式串</span><br><span class="line">  <span class="number">401485</span>:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax                     # 初始化返回值</span><br><span class="line">  40148a:e8 <span class="number">61</span> f7 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:<span class="number">83</span> f8 <span class="number">05</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x5,%eax                     # 要求输入数字要大于<span class="number">5</span>个才不会引爆炸弹</span><br><span class="line">  <span class="number">401492</span>:7f <span class="number">05</span>                <span class="keyword">jg</span>     <span class="number">401499</span> &lt;read_six_numbers+<span class="number">0x3d</span>&gt;</span><br><span class="line">  <span class="number">401494</span>:e8 a1 ff ff ff       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401499</span>:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">40149d</span>:c3                   retq  </span><br></pre></td></tr></table></figure><p>查看<code>0x4025c3</code>地址单元中的内容为格式串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4025c3</span><br><span class="line">0x4025c3:       &quot;%d %d %d %d %d %d&quot;</span><br></pre></td></tr></table></figure><p>经分析答案为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure><h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a><strong>Phase_3</strong></h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  400f47:<span class="number">48</span> <span class="number">8d</span> 4c <span class="number">24</span> 0c       <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line">  400f4c:<span class="number">48</span> <span class="number">8d</span> <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line">  400f51:be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x4025cf,%esi         # <span class="string">&quot;%d %d&quot;</span>需要两个无符号十进制数, 少于<span class="number">2</span>个会引爆炸弹</span><br><span class="line">  400f56:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  400f5b:e8 <span class="number">90</span> fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:<span class="number">83</span> f8 <span class="number">01</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">  400f63:7f <span class="number">05</span>                <span class="keyword">jg</span>     400f6a &lt;phase_3+<span class="number">0x27</span>&gt;</span><br><span class="line">  400f65:e8 d0 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:<span class="number">83</span> 7c <span class="number">24</span> <span class="number">08</span> <span class="number">07</span>       cmpl   <span class="number">$0</span>x7,<span class="number">0x8</span>(%rsp)         # 第一个标准输入中的参数大于<span class="number">7</span>则会跳转发生爆炸</span><br><span class="line">  400f6f:<span class="number">77</span> 3c                <span class="keyword">ja</span>     400fad &lt;phase_3+<span class="number">0x6a</span>&gt;</span><br><span class="line">  400f71:8b <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rsp),%eax</span><br><span class="line">  400f75:ff <span class="number">24</span> c5 <span class="number">70</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span> jmpq   *<span class="number">0x402470</span>(,%rax,<span class="number">8</span>)     # indirect jump, 跳转到<span class="number">0x402470</span>+<span class="built_in">rax</span>*<span class="number">8</span>的存储单元中存放的地址即<span class="number">0x400f83</span></span><br><span class="line">  400f7c:b8 cf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>xcf,%eax</span><br><span class="line">  400f81:eb 3b                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f83:b8 c3 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x2c3,%eax</span><br><span class="line">  400f88:eb <span class="number">34</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f8a:b8 <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x100,%eax</span><br><span class="line">  400f8f:eb <span class="number">2d</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f91:b8 <span class="number">85</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x185,%eax</span><br><span class="line">  400f96:eb <span class="number">26</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f98:b8 ce <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>xce,%eax</span><br><span class="line">  400f9d:eb 1f                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400f9f:b8 aa <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x2aa,%eax</span><br><span class="line">  400fa4:eb <span class="number">18</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400fa6:b8 <span class="number">47</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x147,%eax</span><br><span class="line">  400fab:eb <span class="number">11</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400fad:e8 <span class="number">88</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  400fb7:eb <span class="number">05</span>                <span class="keyword">jmp</span>    400fbe &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  400fb9:b8 <span class="number">37</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x137,%eax</span><br><span class="line">  400fbe:3b <span class="number">44</span> <span class="number">24</span> 0c          <span class="keyword">cmp</span>    <span class="number">0xc</span>(%rsp),%eax         # 第二个参数和覆写后的<span class="built_in">eax</span>相等才能跳过bomb</span><br><span class="line">  400fc2:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     400fc9 &lt;phase_3+<span class="number">0x86</span>&gt;</span><br><span class="line">  400fc4:e8 <span class="number">71</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  400fcd:c3                   retq   </span><br></pre></td></tr></table></figure><p><code>jmp *Operand</code>为Indirect Jump, 跳转的target存放在寄存器中或者内存中。查看内存中存放的target:<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-bd761cefa9fec00f19cf892677e0e12d.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Image"><br>再结合上面的汇编代码，可以得出8个答案:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 207</span><br><span class="line">1 311</span><br><span class="line">2 707</span><br><span class="line">3 256</span><br><span class="line">4 389</span><br><span class="line">5 206</span><br><span class="line">6 682</span><br><span class="line">7 327</span><br></pre></td></tr></table></figure><h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a><strong>Phase_4</strong></h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">401010</span>:<span class="number">48</span> <span class="number">8d</span> 4c <span class="number">24</span> 0c       <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsp),%rcx  # callee save</span><br><span class="line">  <span class="number">401015</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsp),%rdx  # callee save</span><br><span class="line">  40101a:be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x4025cf,%esi  # 格式串, 需要两个十进制数, 因此可以断定标准输入为两个数</span><br><span class="line">  40101f:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  <span class="number">401024</span>:e8 c7 fb ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  <span class="number">401029</span>:<span class="number">83</span> f8 <span class="number">02</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x2,%eax             # 需要在标准输入中传递两个参数(sscanf系统调用的返回值)，否则会引爆炸弹</span><br><span class="line">  40102c:<span class="number">75</span> <span class="number">07</span>                <span class="keyword">jne</span>    <span class="number">401035</span> &lt;phase_4+<span class="number">0x29</span>&gt;</span><br><span class="line">  40102e:<span class="number">83</span> 7c <span class="number">24</span> <span class="number">08</span> 0e       cmpl   <span class="number">$0</span>xe,<span class="number">0x8</span>(%rsp)        # 第一个参数若大于<span class="number">14</span>，则bomb</span><br><span class="line">  <span class="number">401033</span>:<span class="number">76</span> <span class="number">05</span>                <span class="keyword">jbe</span>    40103a &lt;phase_4+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">401035</span>:e8 <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:ba 0e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>xe,%edx             # <span class="number">14</span>作为func4的第三个参数</span><br><span class="line">  40103f:be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%esi             # <span class="number">0</span>作为func4的第二个参数</span><br><span class="line">  <span class="number">401044</span>:8b 7c <span class="number">24</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rsp),%edi        # phase_4的第一个参数作为func4的第一个参数</span><br><span class="line">  <span class="number">401048</span>:e8 <span class="number">81</span> ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  <span class="number">40104d</span>:<span class="number">85</span> c0                <span class="keyword">test</span>   %eax,%eax             # 若返回值<span class="built_in">eax</span>不为<span class="number">0</span>则bomb</span><br><span class="line">  40104f:<span class="number">75</span> <span class="number">07</span>                <span class="keyword">jne</span>    <span class="number">401058</span> &lt;phase_4+<span class="number">0x4c</span>&gt;</span><br><span class="line">  <span class="number">401051</span>:<span class="number">83</span> 7c <span class="number">24</span> 0c <span class="number">00</span>       cmpl   <span class="number">$0</span>x0,<span class="number">0xc</span>(%rsp)        # 若第二个标准输入参数不为<span class="number">0</span>则bomb, 因此可以确定第二个标准输入参数必须为<span class="number">0</span></span><br><span class="line">  <span class="number">401056</span>:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     <span class="number">40105d</span> &lt;phase_4+<span class="number">0x51</span>&gt;</span><br><span class="line">  <span class="number">401058</span>:e8 <span class="built_in">dd</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">40105d</span>:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">401061</span>:c3                   retq   </span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp              # stack frame</span><br><span class="line">  400fd2:<span class="number">89</span> d0                <span class="keyword">mov</span>    %edx,%eax</span><br><span class="line">  400fd4:<span class="number">29</span> f0                <span class="keyword">sub</span>    %esi,%eax</span><br><span class="line">  400fd6:<span class="number">89</span> c1                <span class="keyword">mov</span>    %eax,%ecx</span><br><span class="line">  400fd8:c1 e9 1f             <span class="keyword">shr</span>    <span class="number">$0</span>x1f,%ecx             # 取符号位</span><br><span class="line">  400fdb:<span class="number">01</span> c8                <span class="keyword">add</span>    %ecx,%eax</span><br><span class="line">  400fdd:d1 f8                <span class="keyword">sar</span>    %eax                   # <span class="built_in">eax</span>  除以<span class="number">2</span>向下取整, 最后的答案与之相关</span><br><span class="line">  400fdf:<span class="number">8d</span> 0c <span class="number">30</span>             <span class="keyword">lea</span>    (%rax,%rsi,<span class="number">1</span>),%ecx</span><br><span class="line">  400fe2:<span class="number">39</span> f9                <span class="keyword">cmp</span>    %edi,%ecx              # 直到<span class="built_in">ecx</span>小于等于第一个标准输入的参数<span class="built_in">edi</span>, 则跳转到<span class="number">0x400ff2</span></span><br><span class="line">  400fe4:7e 0c                <span class="keyword">jle</span>    400ff2 &lt;func4+<span class="number">0x24</span>&gt;</span><br><span class="line">  400fe6:<span class="number">8d</span> <span class="number">51</span> ff             <span class="keyword">lea</span>    -<span class="number">0x1</span>(%rcx),%edx</span><br><span class="line">  400fe9:e8 e0 ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:<span class="number">01</span> c0                <span class="keyword">add</span>    %eax,%eax</span><br><span class="line">  400ff0:eb <span class="number">15</span>                <span class="keyword">jmp</span>    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;</span><br><span class="line">  400ff2:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax              # 此处很关键，要保证不bomb必须返回<span class="number">0</span></span><br><span class="line">  400ff7:<span class="number">39</span> f9                <span class="keyword">cmp</span>    %edi,%ecx  </span><br><span class="line">  400ff9:<span class="number">7d</span> 0c                <span class="keyword">jge</span>    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;    # 跳转到此处之后，要想此处跳转，条件必须是<span class="built_in">ecx</span>==<span class="built_in">edi</span></span><br><span class="line">  400ffb:<span class="number">8d</span> <span class="number">71</span> <span class="number">01</span>             <span class="keyword">lea</span>    <span class="number">0x1</span>(%rcx),%esi</span><br><span class="line">  400ffe:e8 cb ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  <span class="number">401003</span>:<span class="number">8d</span> <span class="number">44</span> <span class="number">00</span> <span class="number">01</span>          <span class="keyword">lea</span>    <span class="number">0x1</span>(%rax,%rax,<span class="number">1</span>),%eax  # 执行到这一步无论<span class="built_in">rax</span>的值为什么都不可能为<span class="number">0</span></span><br><span class="line">  <span class="number">401007</span>:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          <span class="keyword">add</span>    <span class="number">$0</span>x8,%rsp</span><br><span class="line">  40100b:c3                   retq   </span><br></pre></td></tr></table></figure><p>经过调试分析, 可得出四个答案, 除此之外可能还有其他答案就不另行分析了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7 0</span><br><span class="line">3 0</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a><strong>Phase_5</strong></h2><p>ASCII转化为十六进制时(因为所取数字的下标大于10)需要查看ASCII编码表。关于stack canary的解释可以参考<a href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value/10325915#10325915">文章</a>和<a href="https://qastack.cn/unix/453749/what-sets-fs0x28-stack-canary">文章</a>使用rax寄存器作为间接传递的原因是因为x86中不存在内存到内存的mov指令。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000401062</span> &lt;phase_5&gt;:</span><br><span class="line">  <span class="number">401062</span>:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx                     # callee save</span><br><span class="line">  <span class="number">401063</span>:<span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x20,%rsp</span><br><span class="line">  <span class="number">401067</span>:<span class="number">48</span> <span class="number">89</span> fb             <span class="keyword">mov</span>    %rdi,%rbx                # 标准输入字符串参数</span><br><span class="line">  40106a:<span class="number">64</span> <span class="number">48</span> 8b <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> <span class="keyword">mov</span>    %fs:<span class="number">0x28</span>,%rax            # stack-canary</span><br><span class="line">  <span class="number">401071</span>:<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">401073</span>:<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>       <span class="keyword">mov</span>    %rax,<span class="number">0x18</span>(%rsp)</span><br><span class="line">  <span class="number">401078</span>:<span class="number">31</span> c0                <span class="keyword">xor</span>    %eax,%eax                # 对<span class="built_in">eax</span>清<span class="number">0</span></span><br><span class="line">  40107a:e8 9c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  40131b &lt;string_length&gt;   # <span class="built_in">rdi</span>作为参数, 返回<span class="built_in">rdi</span>字符串的长度</span><br><span class="line">  40107f:<span class="number">83</span> f8 <span class="number">06</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x6,%eax                # 如果标准输入的字符串不为<span class="number">6</span>个字符，则bomb</span><br><span class="line">  <span class="number">401082</span>:<span class="number">74</span> 4e                <span class="keyword">je</span>     4010d2 &lt;phase_5+<span class="number">0x70</span>&gt;</span><br><span class="line">  <span class="number">401084</span>:e8 b1 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401089</span>:eb <span class="number">47</span>                <span class="keyword">jmp</span>    4010d2 &lt;phase_5+<span class="number">0x70</span>&gt;</span><br><span class="line">  40108b:0f b6 0c <span class="number">03</span>          movzbl (%rbx,%rax,<span class="number">1</span>),%ecx       # 取字符</span><br><span class="line">  40108f:<span class="number">88</span> 0c <span class="number">24</span>             <span class="keyword">mov</span>    %cl,(%rsp)               # 取最低字节大小的字符</span><br><span class="line">  <span class="number">401092</span>:<span class="number">48</span> 8b <span class="number">14</span> <span class="number">24</span>          <span class="keyword">mov</span>    (%rsp),%rdx</span><br><span class="line">  <span class="number">401096</span>:<span class="number">83</span> e2 0f             <span class="keyword">and</span>    <span class="number">$0</span>xf,%edx                # 将ASCII转化为对应的十六进制数作为索引</span><br><span class="line">  <span class="number">401099</span>:0f b6 <span class="number">92</span> b0 <span class="number">24</span> <span class="number">40</span> <span class="number">00</span> movzbl <span class="number">0x4024b0</span>(%rdx),%edx      # <span class="number">0x4024b0</span>中存放了一串字符, 通过分析可以发现<span class="built_in">rdx</span>作为取字符串字符的索引</span><br><span class="line">  4010a0:<span class="number">88</span> <span class="number">54</span> <span class="number">04</span> <span class="number">10</span>          <span class="keyword">mov</span>    %dl,<span class="number">0x10</span>(%rsp,%rax,<span class="number">1</span>)    # 将取到的字符存入由<span class="built_in">rsp</span>+<span class="number">0x10</span>处的开始向高地址方向增长</span><br><span class="line">  4010a4:<span class="number">48</span> <span class="number">83</span> c0 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%rax                # 减少迭代次数</span><br><span class="line">  4010a8:<span class="number">48</span> <span class="number">83</span> f8 <span class="number">06</span>          <span class="keyword">cmp</span>    <span class="number">$0</span>x6,%rax                # 迭代<span class="number">6</span>次</span><br><span class="line">  4010ac:<span class="number">75</span> <span class="built_in">dd</span>                <span class="keyword">jne</span>    40108b &lt;phase_5+<span class="number">0x29</span>&gt;</span><br><span class="line">  4010ae:c6 <span class="number">44</span> <span class="number">24</span> <span class="number">16</span> <span class="number">00</span>       movb   <span class="number">$0</span>x0,<span class="number">0x16</span>(%rsp)          # 在字符串后添加termimator, 作为字符串比较结束的标志</span><br><span class="line">  4010b3:be 5e <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x40245e,%esi           # <span class="string">&quot;flyers&quot;</span></span><br><span class="line">  4010b8:<span class="number">48</span> <span class="number">8d</span> 7c <span class="number">24</span> <span class="number">10</span>       <span class="keyword">lea</span>    <span class="number">0x10</span>(%rsp),%rdi</span><br><span class="line">  4010bd:e8 <span class="number">76</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">401338</span> &lt;strings_not_equal&gt;    # 比较存放在<span class="number">0x40245e</span>中的字符串和标准输入转化后的字符串</span><br><span class="line">  4010c2:<span class="number">85</span> c0                <span class="keyword">test</span>   %eax,%eax</span><br><span class="line">  4010c4:<span class="number">74</span> <span class="number">13</span>                <span class="keyword">je</span>     4010d9 &lt;phase_5+<span class="number">0x77</span>&gt;</span><br><span class="line">  4010c6:e8 6f <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:0f 1f <span class="number">44</span> <span class="number">00</span> <span class="number">00</span>       nopl   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line">  4010d0:eb <span class="number">07</span>                <span class="keyword">jmp</span>    4010d9 &lt;phase_5+<span class="number">0x77</span>&gt;</span><br><span class="line">  4010d2:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  4010d7:eb b2                <span class="keyword">jmp</span>    40108b &lt;phase_5+<span class="number">0x29</span>&gt;</span><br><span class="line">  4010d9:<span class="number">48</span> 8b <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>       <span class="keyword">mov</span>    <span class="number">0x18</span>(%rsp),%rax  </span><br><span class="line">  4010de:<span class="number">64</span> <span class="number">48</span> <span class="number">33</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> <span class="keyword">xor</span>    %fs:<span class="number">0x28</span>,%rax                 # 若stack canary未被破坏则跳过__stack_chk_fail</span><br><span class="line">  4010e5:<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  4010e7:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     4010ee &lt;phase_5+<span class="number">0x8c</span>&gt;</span><br><span class="line">  4010e9:e8 <span class="number">42</span> fa ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">20</span>          <span class="keyword">add</span>    <span class="number">$0</span>x20,%rsp                    # restore</span><br><span class="line">  4010f2:5b                   <span class="keyword">pop</span>    %rbx</span><br><span class="line">  4010f3:c3                   retq </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;:  &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:       &quot;flyers&quot;</span><br></pre></td></tr></table></figure><p>输入正确结果后内存中存放的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s $rsp+0x10</span><br><span class="line">0x7fffffffdfc0: &quot;flyers&quot;</span><br></pre></td></tr></table></figure><p>最后的答案为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9?&gt;567</span><br></pre></td></tr></table></figure><h2 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a><strong>Phase_6</strong></h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:<span class="number">41</span> <span class="number">56</span>                <span class="keyword">push</span>   %r14                         # callee save</span><br><span class="line">  4010f6:<span class="number">41</span> <span class="number">55</span>                <span class="keyword">push</span>   %r13</span><br><span class="line">  4010f8:<span class="number">41</span> <span class="number">54</span>                <span class="keyword">push</span>   %r12</span><br><span class="line">  4010fa:<span class="number">55</span>                   <span class="keyword">push</span>   %rbp</span><br><span class="line">  4010fb:<span class="number">53</span>                   <span class="keyword">push</span>   %rbx</span><br><span class="line">  4010fc:<span class="number">48</span> <span class="number">83</span> ec <span class="number">50</span>          <span class="keyword">sub</span>    <span class="number">$0</span>x50,%rsp                   # stack frame</span><br><span class="line">  <span class="number">401100</span>:<span class="number">49</span> <span class="number">89</span> e5             <span class="keyword">mov</span>    %rsp,%r13</span><br><span class="line">  <span class="number">401103</span>:<span class="number">48</span> <span class="number">89</span> e6             <span class="keyword">mov</span>    %rsp,%rsi</span><br><span class="line">  <span class="number">401106</span>:e8 <span class="number">51</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  40110b:<span class="number">49</span> <span class="number">89</span> e6             <span class="keyword">mov</span>    %rsp,%r14</span><br><span class="line">  40110e:<span class="number">41</span> bc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x0,%r12d                   # 迭代器</span><br><span class="line">  <span class="number">401114</span>:4c <span class="number">89</span> ed             <span class="keyword">mov</span>    %r13,%rbp</span><br><span class="line">  <span class="number">401117</span>:<span class="number">41</span> 8b <span class="number">45</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">0x0</span>(%r13),%eax               # <span class="built_in">r13</span>中存放的数字放入<span class="built_in">eax</span>中</span><br><span class="line">  40111b:<span class="number">83</span> e8 <span class="number">01</span>             <span class="keyword">sub</span>    <span class="number">$0</span>x1,%eax                    # <span class="built_in">eax</span>大于<span class="number">5</span>则bomb, 一轮<span class="keyword">loop</span>之后观察可以推出六个数字的范围是<span class="number">1</span>到<span class="number">6</span>, 且相邻数字不能相同</span><br><span class="line">  40111e:<span class="number">83</span> f8 <span class="number">05</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x5,%eax</span><br><span class="line">  <span class="number">401121</span>:<span class="number">76</span> <span class="number">05</span>                <span class="keyword">jbe</span>    <span class="number">401128</span> &lt;phase_6+<span class="number">0x34</span>&gt;        # be无符号比较, 若参数数减去<span class="number">1</span>小于<span class="number">0</span>则会bomb，进而可以推出参数不能小于<span class="number">1</span></span><br><span class="line">  <span class="number">401123</span>:e8 <span class="number">12</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401128</span>:<span class="number">41</span> <span class="number">83</span> c4 <span class="number">01</span>          <span class="keyword">add</span>    <span class="number">$0</span>x1,%r12d </span><br><span class="line">  40112c:<span class="number">41</span> <span class="number">83</span> fc <span class="number">06</span>          <span class="keyword">cmp</span>    <span class="number">$0</span>x6,%r12d</span><br><span class="line">  <span class="number">401130</span>:<span class="number">74</span> <span class="number">21</span>                <span class="keyword">je</span>     <span class="number">401153</span> &lt;phase_6+<span class="number">0x5f</span>&gt;        # 外循环迭代次数到<span class="number">6</span>次则终止<span class="keyword">loop</span></span><br><span class="line">  <span class="number">401132</span>:<span class="number">44</span> <span class="number">89</span> e3             <span class="keyword">mov</span>    %r12d,%ebx</span><br><span class="line">  <span class="number">401135</span>:<span class="number">48</span> <span class="number">63</span> c3             movslq %ebx,%rax</span><br><span class="line">  <span class="number">401138</span>:8b <span class="number">04</span> <span class="number">84</span>             <span class="keyword">mov</span>    (%rsp,%rax,<span class="number">4</span>),%eax           # 取下一个数字放入<span class="built_in">eax</span></span><br><span class="line">  40113b:<span class="number">39</span> <span class="number">45</span> <span class="number">00</span>             <span class="keyword">cmp</span>    %eax,<span class="number">0x0</span>(%rbp)               # 若当前数字与下一个数字相等，则bomb</span><br><span class="line">  40113e:<span class="number">75</span> <span class="number">05</span>                <span class="keyword">jne</span>    <span class="number">401145</span> &lt;phase_6+<span class="number">0x51</span>&gt;</span><br><span class="line">  <span class="number">401140</span>:e8 f5 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;        # 六个数字出现连续相同的数字则发生bomb</span><br><span class="line">  <span class="number">401145</span>:<span class="number">83</span> c3 <span class="number">01</span>             <span class="keyword">add</span>    <span class="number">$0</span>x1,%ebx</span><br><span class="line">  <span class="number">401148</span>:<span class="number">83</span> fb <span class="number">05</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x5,%ebx                    # 若没遍历完六个数字中剩余的数字则<span class="keyword">loop</span></span><br><span class="line">  40114b:7e e8                <span class="keyword">jle</span>    <span class="number">401135</span> &lt;phase_6+<span class="number">0x41</span>&gt;</span><br><span class="line">  <span class="number">40114d</span>:<span class="number">49</span> <span class="number">83</span> c5 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%r13                    # 取下一个数字</span><br><span class="line">  <span class="number">401151</span>:eb c1                <span class="keyword">jmp</span>    <span class="number">401114</span> &lt;phase_6+<span class="number">0x20</span>&gt;</span><br><span class="line">  <span class="number">401153</span>:<span class="number">48</span> <span class="number">8d</span> <span class="number">74</span> <span class="number">24</span> <span class="number">18</span>       <span class="keyword">lea</span>    <span class="number">0x18</span>(%rsp),%rsi              # null terminator, 第六个参数后面的字</span><br><span class="line">  <span class="number">401158</span>:4c <span class="number">89</span> f0             <span class="keyword">mov</span>    %r14,%rax</span><br><span class="line">  40115b:b9 <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x7,%ecx</span><br><span class="line">  <span class="number">401160</span>:<span class="number">89</span> ca                <span class="keyword">mov</span>    %ecx,%edx</span><br><span class="line">  <span class="number">401162</span>:2b <span class="number">10</span>                <span class="keyword">sub</span>    (%rax),%edx                  # 将<span class="number">7</span>减去当前位置的参数数字的结果放回到当前位置, 即将六个数字结果都改为<span class="number">7</span>-当前数字</span><br><span class="line">  <span class="number">401164</span>:<span class="number">89</span> <span class="number">10</span>                <span class="keyword">mov</span>    %edx,(%rax)</span><br><span class="line">  <span class="number">401166</span>:<span class="number">48</span> <span class="number">83</span> c0 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%rax                    # 往下移动一个数字的位置</span><br><span class="line">  40116a:<span class="number">48</span> <span class="number">39</span> f0             <span class="keyword">cmp</span>    %rsi,%rax                    # 若未移动到最后一个数字结束则继续<span class="keyword">loop</span></span><br><span class="line">  <span class="number">40116d</span>:<span class="number">75</span> f1                <span class="keyword">jne</span>    <span class="number">401160</span> &lt;phase_6+<span class="number">0x6c</span>&gt;</span><br><span class="line">  40116f:be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x0,%esi</span><br><span class="line">  <span class="number">401174</span>:eb <span class="number">21</span>                <span class="keyword">jmp</span>    <span class="number">401197</span> &lt;phase_6+<span class="number">0xa3</span>&gt;        </span><br><span class="line">  <span class="number">401176</span>:<span class="number">48</span> 8b <span class="number">52</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rdx),%rdx               # 将当前<span class="built_in">rdx</span>中存放地址的下一个<span class="number">8</span>字节中存放地址的内容存放到<span class="built_in">rdx</span>中, 即遍历链表，取到对应的节点</span><br><span class="line">  40117a:<span class="number">83</span> c0 <span class="number">01</span>             <span class="keyword">add</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">  <span class="number">40117d</span>:<span class="number">39</span> c8                <span class="keyword">cmp</span>    %ecx,%eax                    </span><br><span class="line">  40117f:<span class="number">75</span> f5                <span class="keyword">jne</span>    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;        # 若<span class="built_in">eax</span>与做出变更的数字不相等则继续<span class="keyword">loop</span>, 实际上变更的数字为node号</span><br><span class="line">  <span class="number">401181</span>:eb <span class="number">05</span>                <span class="keyword">jmp</span>    <span class="number">401188</span> &lt;phase_6+<span class="number">0x94</span>&gt;</span><br><span class="line">  <span class="number">401183</span>:ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x6032d0,%edx               # <span class="number">0x6032d0</span>为node1</span><br><span class="line">  <span class="number">401188</span>:<span class="number">48</span> <span class="number">89</span> <span class="number">54</span> <span class="number">74</span> <span class="number">20</span>       <span class="keyword">mov</span>    %rdx,<span class="number">0x20</span>(%rsp,%rsi,<span class="number">2</span>)       # 将当前node的地址存放到$<span class="built_in">rsp</span>+<span class="number">0x20</span>开始，以<span class="number">8</span>字节为间隔的连续地址</span><br><span class="line">  <span class="number">40118d</span>:<span class="number">48</span> <span class="number">83</span> c6 <span class="number">04</span>          <span class="keyword">add</span>    <span class="number">$0</span>x4,%rsi                    # 移动到下一个变更后的参数</span><br><span class="line">  <span class="number">401191</span>:<span class="number">48</span> <span class="number">83</span> fe <span class="number">18</span>          <span class="keyword">cmp</span>    <span class="number">$0</span>x18,%rsi                   </span><br><span class="line">  <span class="number">401195</span>:<span class="number">74</span> <span class="number">14</span>                <span class="keyword">je</span>     4011ab &lt;phase_6+<span class="number">0xb7</span>&gt;        # 遍历完六个参数则跳转到target, 即取对应参数变更后的node号的地址放入内存中</span><br><span class="line">  <span class="number">401197</span>:8b 0c <span class="number">34</span>             <span class="keyword">mov</span>    (%rsp,%rsi,<span class="number">1</span>),%ecx           # 按顺序取做出变更后的参数</span><br><span class="line">  40119a:<span class="number">83</span> f9 <span class="number">01</span>             <span class="keyword">cmp</span>    <span class="number">$0</span>x1,%ecx                    # 若当前数字小于等于<span class="number">1</span>则，直接存放当前节点不需要遍历链表</span><br><span class="line">  <span class="number">40119d</span>:7e e4                <span class="keyword">jle</span>    <span class="number">401183</span> &lt;phase_6+<span class="number">0x8f</span>&gt;</span><br><span class="line">  40119f:b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">  4011a4:ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x6032d0,%edx               # 传递的是地址, gdb调试可以发现存在一个链表, 比如<span class="number">0x6032d8</span>存储单元中存放着的是<span class="number">0x6032e0</span></span><br><span class="line">  4011a9:eb cb                <span class="keyword">jmp</span>    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;</span><br><span class="line">  4011ab:<span class="number">48</span> 8b 5c <span class="number">24</span> <span class="number">20</span>       <span class="keyword">mov</span>    <span class="number">0x20</span>(%rsp),%rbx              # node6的地址</span><br><span class="line">  4011b0:<span class="number">48</span> <span class="number">8d</span> <span class="number">44</span> <span class="number">24</span> <span class="number">28</span>       <span class="keyword">lea</span>    <span class="number">0x28</span>(%rsp),%rax               </span><br><span class="line">  4011b5:<span class="number">48</span> <span class="number">8d</span> <span class="number">74</span> <span class="number">24</span> <span class="number">50</span>       <span class="keyword">lea</span>    <span class="number">0x50</span>(%rsp),%rsi               </span><br><span class="line">  4011ba:<span class="number">48</span> <span class="number">89</span> d9             <span class="keyword">mov</span>    %rbx,%rcx                    </span><br><span class="line">  4011bd:<span class="number">48</span> 8b <span class="number">10</span>             <span class="keyword">mov</span>    (%rax),%rdx                  # node5的地址, 即指针</span><br><span class="line">  4011c0:<span class="number">48</span> <span class="number">89</span> <span class="number">51</span> <span class="number">08</span>          <span class="keyword">mov</span>    %rdx,<span class="number">0x8</span>(%rcx)               # 将node5的指针作为node6的next</span><br><span class="line">  4011c4:<span class="number">48</span> <span class="number">83</span> c0 <span class="number">08</span>          <span class="keyword">add</span>    <span class="number">$0</span>x8,%rax                    # node4指针的地址</span><br><span class="line">  4011c8:<span class="number">48</span> <span class="number">39</span> f0             <span class="keyword">cmp</span>    %rsi,%rax                    # 看一下是否遍历结束</span><br><span class="line">  4011cb:<span class="number">74</span> <span class="number">05</span>                <span class="keyword">je</span>     4011d2 &lt;phase_6+<span class="number">0xde</span>&gt;        </span><br><span class="line">  4011cd:<span class="number">48</span> <span class="number">89</span> d1             <span class="keyword">mov</span>    %rdx,%rcx</span><br><span class="line">  4011d0:eb eb                <span class="keyword">jmp</span>    4011bd &lt;phase_6+<span class="number">0xc9</span>&gt;        # <span class="keyword">loop</span></span><br><span class="line">  4011d2:<span class="number">48</span> c7 <span class="number">42</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="keyword">movq</span>   <span class="number">$0</span>x0,<span class="number">0x8</span>(%rdx)               # 将尾节点node1的next指向空</span><br><span class="line">  4011d9:<span class="number">00</span>                                                        # 应该是涉及pipeline优化的bubble </span><br><span class="line">  4011da:bd <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">$0</span>x5,%ebp                    # 迭代器</span><br><span class="line">  4011df:<span class="number">48</span> 8b <span class="number">43</span> <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rbx),%rax               # 将下一个node的地址赋给<span class="built_in">rax</span></span><br><span class="line">  4011e3:8b <span class="number">00</span>                <span class="keyword">mov</span>    (%rax),%eax                  # 取下一个node的值(即低32bit)赋给<span class="built_in">eax</span></span><br><span class="line">  4011e5:<span class="number">39</span> <span class="number">03</span>                <span class="keyword">cmp</span>    %eax,(%rbx)                  # 当前node的值若小于(&lt;)下一个node的值，则bomb，到这里可以猜测要将链表要按node值来构造递减序列</span><br><span class="line">  4011e7:<span class="number">7d</span> <span class="number">05</span>                <span class="keyword">jge</span>    4011ee &lt;phase_6+<span class="number">0xfa</span>&gt;        # 初步可以判断需要用<span class="number">7</span>-当前参数值来取node号</span><br><span class="line">  4011e9:e8 4c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:<span class="number">48</span> 8b 5b <span class="number">08</span>          <span class="keyword">mov</span>    <span class="number">0x8</span>(%rbx),%rbx               # 将当前node的next赋给<span class="built_in">rbx</span>, 即移动指针遍历到下一个node</span><br><span class="line">  4011f2:<span class="number">83</span> ed <span class="number">01</span>             <span class="keyword">sub</span>    <span class="number">$0</span>x1,%ebp                    # 减少迭代次数</span><br><span class="line">  4011f5:<span class="number">75</span> e8                <span class="keyword">jne</span>    4011df &lt;phase_6+<span class="number">0xeb</span>&gt;</span><br><span class="line">  4011f7:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">50</span>          <span class="keyword">add</span>    <span class="number">$0</span>x50,%rsp</span><br><span class="line">  4011fb:5b                   <span class="keyword">pop</span>    %rbx</span><br><span class="line">  4011fc:<span class="number">5d</span>                   <span class="keyword">pop</span>    %rbp</span><br><span class="line">  4011fd:<span class="number">41</span> 5c                <span class="keyword">pop</span>    %r12</span><br><span class="line">  4011ff:<span class="number">41</span> <span class="number">5d</span>                <span class="keyword">pop</span>    %r13</span><br><span class="line">  <span class="number">401201</span>:<span class="number">41</span> 5e                <span class="keyword">pop</span>    %r14</span><br><span class="line">  <span class="number">401203</span>:c3                   retq   </span><br></pre></td></tr></table></figure><p>查看0x6032d0处地址内容(gdb中的字默认为4字节， 而x86的字默认为2字节), 可以猜测出第一个8字节中高4字节为node号，低4字节为值域，第二个8字节为next指针域，下述示例传递的参数为<code>1 2 3 4 5 6</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/12xg 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x000000010000014c      0x0000000000000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x00000002000000a8      0x00000000006032d0</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x000000030000039c      0x00000000006032e0</span><br><span class="line">0x603300 &lt;node4&gt;:       0x00000004000002b3      0x00000000006032f0</span><br><span class="line">0x603310 &lt;node5&gt;:       0x00000005000001dd      0x0000000000603300</span><br><span class="line">0x603320 &lt;node6&gt;:       0x00000006000001bb      0x0000000000603310</span><br></pre></td></tr></table></figure><p>6个node的值, 再将其由大到小排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node1: 0x14c</span><br><span class="line">node2: 0x0a8</span><br><span class="line">node3: 0x39c</span><br><span class="line">node4: 0x2b3</span><br><span class="line">node5: 0x1dd</span><br><span class="line">node6: 0x1bb</span><br><span class="line">node3 &gt; node4 &gt; node5 &gt; node6 &gt; node1 &gt; node2</span><br></pre></td></tr></table></figure><p>由7-nodeNumber得到答案为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-77b2f6513b85ca11bed6e27cf04ea16d.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Defused"></p>]]></content>
      
      
      <categories>
          
          <category> CMU15-213 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Lab1: Data Lab</title>
      <link href="/2022/05/16/CSAPP-Lab1-Data-Lab/"/>
      <url>/2022/05/16/CSAPP-Lab1-Data-Lab/</url>
      
        <content type="html"><![CDATA[<h1 id="CSAPP-Lab1-Data-Lab"><a href="#CSAPP-Lab1-Data-Lab" class="headerlink" title="CSAPP Lab1: Data Lab"></a>CSAPP Lab1: Data Lab</h1><h2 id="Some-Restriction"><a href="#Some-Restriction" class="headerlink" title="Some Restriction"></a><strong>Some Restriction</strong></h2><h4 id="Integer-Coding-Rules"><a href="#Integer-Coding-Rules" class="headerlink" title="Integer Coding Rules"></a><strong>Integer Coding Rules</strong></h4><ol><li>Expr<ol><li>整型操作数的值被限制在范围[0, 255]。</li><li>不能使用全局变量</li><li>只能使用的一元操作<code>!</code>, <code>~</code></li><li>只能使用的二元操作<code>&amp;</code>, <code>^</code>, <code>|</code>, <code>+</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li><li>一个表达式不会被限制拥有多个操作符</li></ol></li><li>Fobidden<ol><li>使用控制语句如<code>if</code>, <code>do</code>, <code>while</code>, <code>for</code>, <code>switch</code>等等</li><li>定义或使用任何宏</li><li>在当前文件中定义任何额外的函数</li><li>调用任何函数</li><li>使用其他操作</li><li>使用类型转换</li><li>使用除<code>int</code>之外的任何数据类型，使用<code>arrays</code>, <code>structs</code>, <code>unions</code></li></ol></li><li>假设机器的配置<ol><li>使用2的补码，<code>int</code>的表示为32-bit</li><li>执行算术右移</li><li>如果左移的位数小于0或者大于31则会出现未预测的行为。</li></ol></li></ol><h4 id="Floating-Point-Coding-Rules"><a href="#Floating-Point-Coding-Rules" class="headerlink" title="Floating Point Coding Rules"></a><strong>Floating Point Coding Rules</strong></h4><ol><li>Forbidden<ol><li>定义或使用任何宏</li><li>定义任何额外的函数</li><li>调用任何函数</li><li>使用任何形式的类型转换</li><li>使用<code>arrays</code>, <code>structs</code>, <code>unions</code></li></ol></li></ol><h4 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a><strong>Notes</strong></h4><ol><li>使用<code>dlc</code>(data tab checker)编译器来检查解决方案的合理性</li><li>使用<code>btest</code>来检查你的函数的正确性</li><li>使用<code>BDD checker</code>来正式地证实你的函数</li></ol><h4 id="lab-Note"><a href="#lab-Note" class="headerlink" title="lab Note"></a><strong>lab Note</strong></h4><ol><li>64位机器上编译32位程序会出现错误<code>fatal error: bits/libc-header-start.h: 没有那个文件或目录</code>，是因为gcc没有安装<code>multilib</code>库，这个库可以在64位的机器上产生32位的程序<code>sudo apt install gcc-multilib</code></li></ol><h3 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1. bitXor"></a><strong>1. bitXor</strong></h3><p>通过图中所给的与、非和或门构造的异或逻辑电路，再利用德摩根定律将所有的或门转化为与门可得。<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-3e52fb0d69b1220a809e2982919296bf.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="XOR gate"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> ~((~(x&amp;(~y))) &amp; (~((~x)&amp;y)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2. tmin"></a><strong>2. tmin</strong></h3><p>32位整型数<code>2&#39;s complement</code>的范围为<code>[-2^(n-1), 2^(n-1)-1</code>, 很容易得出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3. isTmax"></a><strong>3. isTmax</strong></h3><p>摸索了小一段时间，解法很多，<code>-1</code>可以通过取反<code>+1</code>来构造。假设x为<code>Tmax</code>, 对<code>Tmax</code>取反得到<code>Tmin</code>，再减1则会发生<code>underflow</code>会得到<code>Tmax</code>, 通过逻辑运算的结果与<code>x</code>本身异或，看结果是否为<code>0</code>来判断<code>Tmax</code>。这种情况下<code>-1</code>是需要排除的, 因为对<code>-1</code>的<code>2&#39;s Complement</code>取反得到<code>0</code>，减1之后会得到<code>-1</code>本身，因此异或结果还是<code>0</code>，需要排除(利用好<code>!!</code>,保证与的操作数要么是<code>0</code>或<code>1</code>)。排除直接让<code>x+1</code>判断即可，否则操作数会超出10个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (!(((~x)+(~<span class="number">1</span>+<span class="number">1</span>))^x)) &amp; (!!(x+<span class="number">1</span>));</span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure><h3 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4. allOddBits"></a><strong>4. allOddBits</strong></h3><p>根据题目给定的操作符数的限制，以及操作数值的限定，即可确定需要利用好<code>0xAA</code>。同样也花了一些时间去斟酌，很多细节需要把握住，得到最终的答案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !((((x&amp;<span class="number">0xAA</span>)&amp;((x&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xAA</span>))&amp;(((x&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xAA</span>)&amp;((x&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xAA</span>)))^<span class="number">0xAA</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-negate"><a href="#5-negate" class="headerlink" title="5. negate"></a><strong>5. negate</strong></h3><p>很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6. isAsciiDigit"></a><strong>6. isAsciiDigit</strong></h3><p>可以先将操作数限定在<code>0x3X</code>的范围内，再通过对<code>0x0A</code>取补得到<code>-10</code>，取低4位进行加法运算，得到的结果通过符号位，若符号位为<code>1</code>则为ASCII数字，否则不满足条件。可以通过提取从低位数起第五个bit即<code>0x10</code>来确定符号位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> neg_A = ~<span class="number">0x0A</span>+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((!((x&gt;&gt;<span class="number">4</span>)^<span class="number">0x3</span>)) &amp; (!!(((x&amp;<span class="number">0xF</span>)+neg_A)&amp;(<span class="number">0x10</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7. conditional"></a><strong>7. conditional</strong></h3><p>保证<code>x</code>非<code>0</code>即<code>1</code>，再利用<code>0</code>和<code>1</code>补码的特点, 构造全<code>1</code>和全<code>0</code>, 分别和<code>y</code>, <code>z</code>完成与运算来进行排除，这道题还是非常巧妙的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123; </span><br><span class="line">  <span class="type">int</span> mask = ~(!!(x^<span class="number">0x0</span>))+<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> (y&amp;mask) + (z&amp;(~mask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8. isLessOrEqual"></a><strong>8. isLessOrEqual</strong></h3><p>根据两个参数<code>x</code>, <code>y</code>的符号位先分几种情况</p><ol><li>满足小于等于<ol><li>两数相等</li><li><code>x&lt;0, y&gt;0</code>, 避免符号位相等时的溢出情况</li><li>符号位相等比较。通过第一个操作数加上第二个操作数的取补的形式, 若结果小于0，则<code>x&lt;y</code><ul><li>负负比较, 可能会出现对<code>Tmin</code>取补发生下溢出的特殊情况，因此需要排除第二个操作数为<code>Tmin</code>的情况，恰好该情况要么<strong>相等</strong>(已经判断过了), 要么就是<code>x&gt;y</code>(也判断了)。</li><li>正正比较</li></ul></li></ol></li><li>不满足小于等于,即大于等于(<code>x&gt;0, y&lt;0</code>)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_sign_bit = ((x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x01</span>);</span><br><span class="line">  <span class="type">int</span> y_sign_bit = ((y&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x01</span>);</span><br><span class="line">  <span class="type">int</span> Tmin = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (!((~x_sign_bit)&amp;y_sign_bit)) &amp; ((!(x^y)) | (x_sign_bit&amp;(~y_sign_bit)) | ((((x+(~y+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>)&amp;(!!(y^Tmin))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9. logicalNeg"></a><strong>9. logicalNeg</strong></h3><p>首先要将想一个办法将0和正数，负数区分开来。因为0和正数的符号位都是0，要区分开来恰好利用到了0的补码还是其本身的特性，正数取反加一后符号位由0变1，可以直接区分开来。再利用算数右移的特性，将0构造成全0，负数和正数构造成全1, 最后<code>+1</code>得到返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((x&gt;&gt;<span class="number">31</span>)|((~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10. howManyBits"></a><strong>10. howManyBits</strong></h3><p>坦白说这一题真的是卡了我好久，即便找到了最高bit位要想返回正确的结果几乎是很繁琐的，但肯定会超出操作符的限制。这道题参考了一下各路佬的思想，可以用二分法来实现。还需要注意负数需要按位取反(排除符号位的影响)，正数保持不变即可，可以通过<code>sign_bit</code>减<code>1</code>来构造全<code>0</code>和全<code>1</code>。可以通过右移<code>16</code>、<code>8</code>、<code>4</code>、<code>2</code>、<code>1</code>bit来找到最高的<code>bit 1</code>，这道题还是非常巧妙的。<br>判断右移<code>n bit</code>后是否为0</p><ul><li>如果为0，说明需要的位在高<code>n-bit</code>(左半侧)，数则保持不变，故不记录<code>n</code>，继续进行二分搜索。</li><li>如果不为0，说明需要的位在低<code>n-bit</code>(右半侧), 数向右移动<code>n-bit</code>继续进行搜索，且记录<code>n</code>。<br>最后将所有移位得到的<code>n</code>都累加起来得到最后的结果<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits  - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> sign_bit = (x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">int</span> flag = sign_bit+(~<span class="number">1</span>+<span class="number">1</span>);   <span class="comment">// neg -&gt; all 0,  not_neg -&gt; all 1</span></span><br><span class="line">  x = ((~flag)&amp;(~x))|(flag&amp;x);  <span class="comment">// if neg, reverse.</span></span><br><span class="line">  b16 = (!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  x &gt;&gt;= b16;</span><br><span class="line">  b8 = (!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">  x &gt;&gt;= b8;</span><br><span class="line">  b4 = (!!(x&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">  x &gt;&gt;= b4;</span><br><span class="line">  b2 = (!!(x&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x &gt;&gt;= b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x &gt;&gt;= b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-floatScale2"><a href="#11-floatScale2" class="headerlink" title="11. floatScale2"></a><strong>11. floatScale2</strong></h3><p>描述里没有给<code>Infinity</code>的case，通过测试发现，与<code>Nan</code>返回值一致合并一起判断。需要判断几种情况: <code>NaN</code>, <code>Subnormal</code>, <code>+0</code>, <code>-0</code>, <code>Normalize</code>。<code>Normalize</code>的情况只需要对<code>Exponent</code>的最低位增加一个<code>bit</code>即可。注意<code>Subnormal</code>情况<code>Fraction</code>为全<code>1</code>时左移的结果不需要将<code>Exponent</code>清零，按测试用例应该是将<code>Subnormal</code>转化为<code>Normalize</code>了。强调一下移码的意义为<code>IEEE 754</code> Normalize表示部分2的指数部分。<br>$$Bias = 2^{Exponent-1}-1$$<br>$$Normalize = 1.Fraction \times 2^{Exponent + Bias} (1 \leq Exponent \leq 2^{Exponent} - 2)$$<br>$$Subnormal = 0.Fraction \times 2^{1-Bias}$$<br>$$Biased = Unsigned - Bias$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> exp_mask = <span class="number">0x7F800000</span>;          <span class="comment">// the eight bits of exponent is all 1.</span></span><br><span class="line">  <span class="type">int</span> Neg_zero = <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="type">int</span> sign_mask = Neg_zero;</span><br><span class="line">  <span class="type">int</span> fraction_mask = <span class="number">0x007FFFFF</span>;</span><br><span class="line">  <span class="keyword">if</span> (!((uf &amp; exp_mask)^exp_mask)) &#123;       <span class="comment">// eliminate the case of NaN.</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!uf) &#123;                     <span class="comment">// eliminate the case of +0.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(Neg_zero^uf)) &#123;          <span class="comment">// eliminate the case of -0.</span></span><br><span class="line">    <span class="keyword">return</span> Neg_zero;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(uf &amp; exp_mask)) &#123;              <span class="comment">// elinimate the case of subnormal.</span></span><br><span class="line">    <span class="keyword">return</span> (uf&amp;sign_mask) + (((uf&amp;fraction_mask)&lt;&lt;<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  uf += (<span class="number">0x1</span>&lt;&lt;<span class="number">23</span>);               <span class="comment">// Normalize.</span></span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-floatFloat2Int"><a href="#12-floatFloat2Int" class="headerlink" title="12. floatFloat2Int"></a><strong>12. floatFloat2Int</strong></h3><p>实现到<code>IEEE754</code>单精度浮点数到定点整数的转换。题目中首先要考虑溢出的情况，早在最开始实验就假设机器左移的位数小于0或者大于31都会出现未知的行为，因此需要将这两种情况包含进去。由于<code>Normalize</code>的<code>M</code>部分是$1.Fraction$因此需要将小数点前面的<code>1</code>提前加入<code>fraction</code>部分。实际上<code>fraction</code>右移<code>23位</code>可以和$2^{Biased}$的指数部分进行相减$2^{Biased-23}$，进行对应的移位操作完成$2^n$幂次运算，最后得到对应的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> bias = <span class="number">1</span>-(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">  <span class="type">int</span> exp_mask = <span class="number">0x7F800000</span>;</span><br><span class="line">  <span class="type">int</span> fraction_mask = <span class="number">0x007FFFFF</span>;</span><br><span class="line">  <span class="type">int</span> fraction = (uf &amp; fraction_mask);</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &amp; exp_mask) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">int</span> sign_bit = (uf&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">int</span> biased = <span class="built_in">exp</span> + bias;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">exp</span>^exp_mask) || biased &gt; <span class="number">31</span>) &#123;  <span class="comment">// NaN and infinity</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!uf || !(uf^<span class="number">0x80000000</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (biased &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">  &#125;</span><br><span class="line">  fraction |= (<span class="number">1</span>&lt;&lt;<span class="number">23</span>);  <span class="comment">// 1.F</span></span><br><span class="line">  <span class="keyword">if</span> (biased &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">    fraction &lt;&lt;= (biased<span class="number">-23</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fraction &gt;&gt;= (<span class="number">23</span>-biased);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sign_bit)</span><br><span class="line">    <span class="keyword">return</span> -fraction;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> fraction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-floatPower2"><a href="#13-floatPower2" class="headerlink" title="13. floatPower2"></a><strong>13. floatPower2</strong></h3><p>给定argument为<code>Biased</code>，求出其对应无符号<code>IEEE 754</code>单精度浮点数的表示即可。求出exp的值之后，左移23到IEEE754规格的exponent域中。认真读题后还是蛮简单的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bias = <span class="number">127</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span> = (x + bias)&lt;&lt;<span class="number">23</span>;  <span class="comment">// x = exp - bias</span></span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-127</span>) &#123;              <span class="comment">// too small(exp are all 0s that is Subnormal)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; (<span class="number">255</span><span class="number">-127</span>)) &#123;  <span class="comment">// too large(the floating point number is larger than INF that exp are all 1s)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x7f800000</span>;         <span class="comment">// +INF</span></span><br><span class="line">    &#125;</span><br><span class="line">    f |= <span class="built_in">exp</span>;    <span class="comment">// normalize</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-21774eab522096e708d883dc09a4aa25.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="./btest"><br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-96d0c54113a6951eed5fe3cbfbba5b5a.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="./dlc"></p>]]></content>
      
      
      <categories>
          
          <category> CMU15-213 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.NULL Video Note</title>
      <link href="/2022/05/16/6-NULL-Video-Note/"/>
      <url>/2022/05/16/6-NULL-Video-Note/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="VIDEO-1-The-Shell"><a href="#VIDEO-1-The-Shell" class="headerlink" title="VIDEO 1 The Shell"></a><strong>VIDEO 1</strong> The Shell</h2><ol><li><code>cd -</code>将会在和上一次cd的目录来回切换</li><li><code>rm</code>命令默认非递归的删除，因此删除目录时需要加上-r参数(recursive)，才能完整地将目录下的文件删除;而rmdir只能删除空目录</li><li>解释一下常用命令的含义<code>pwd</code>(print work directory), <code>cd</code>(change directory)</li><li>-表示当前没有允许的权限。d表示目录，注意目录的x位表示当前能够访问该目录的内容，且需要保证当前目录的父目录都含有x位才能访问。</li><li>redirect, &lt; 表示重定向输入, &gt; 表示重定向输出. Some example:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> hello &gt; hello.txt</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ <span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt</span><br><span class="line">missing:~$ <span class="built_in">cat</span> hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><code>&gt;&gt;</code>表示追加(append)</li><li><code>ctrl+L</code>清空终端的命令，返回到顶部。</li><li><code>tail -n</code>将数据中的末尾n行显示出来。</li><li>pipe，将两个不相关联的程序连接起来通过input/output连接起来,管道的左边作为一个input, 管道的右边作为一个output。</li><li><code>$</code>表示当前运行在用户模式下; <code>#</code>表示当前运行在系统模式下,可以通过命令<code>sudo su</code>来打开root下的terminal.</li><li>xdg-open命令可以打开文件对应的格式</li><li>double quotes: backslash, <code>\</code>前面加个<code>!</code>就不会被默认移除</li><li>shebang是由脚本开头的字符数字符号和感叹号<code>#!</code>组成的字符序列。当带有shebang的文本文件被用作类Unix操作系统的”可执行文件”时，程序加载器机制将文件初始行的其余部分解析为”解释器指令”。它告诉内核用什么来运行此脚本(比如说python or shell?)</li></ol><h2 id="VIDEO-2-Shell-Tools-and-Scripting"><a href="#VIDEO-2-Shell-Tools-and-Scripting" class="headerlink" title="VIDEO 2 Shell Tools and Scripting"></a><strong>VIDEO 2</strong> Shell Tools and Scripting</h2><ol><li>different from the single quote<code>(&#39;)</code> and double quote<code>(&quot;)</code>. echo “”中解析出变量放变量(用<code>$</code>符号来表示)。而单引号不会解析变量。</li><li><ul><li><code>$1</code>到<code>$9</code>表示argv中第一个到第九个参数</li><li><code>$0</code>表示脚本的名字</li><li><code>$_</code>(undersocre)表示上一个command的最后一个参数</li><li><code>$?</code>(question mark)获取上一个command的error code(一般值为<code>0</code>表示ok, <code>1</code>表示执行出错)。</li><li><code>$#</code>(hash)表示参数的个数</li><li><code>$$</code>表示当前进程的ID</li><li><code>$@</code>表示所有参数。</li></ul></li><li><code>!!</code>(bang)代替上一次执行过的command，比如说创建一个目录<code>mkdir ..</code>没有权限，这时候只需要<code>sudo !!</code>, 就会默认表示<code>sudo mkdir ..</code>从而减少了一些重复性的工作。</li><li>;(semicolon)分号可以连接任何命令行。<code>false ; echo &quot;haha&quot;</code></li><li>脚本中变量用双引号引起来<code>&quot;$1&quot;</code>.</li><li>执行脚本<code>source ..</code></li><li>globbing, *(asterisk), {}(curly braces)</li><li><code>tldr</code>(too long, don’t read), 精简版带example的man</li><li> <code>test</code>, 查看man手册</li><li><strong>查找文件</strong>: </li></ol><ul><li><code>find</code>查看man手册 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -<span class="built_in">type</span> d</span><br><span class="line"><span class="comment"># 查找所有文件夹路径中包含test的python文件</span></span><br><span class="line">find . -path <span class="string">&#x27;*/test/*.py&#x27;</span> -<span class="built_in">type</span> f</span><br><span class="line"><span class="comment"># 查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="comment"># 查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name <span class="string">&#x27;*.tar.gz&#x27;</span></span><br><span class="line"><span class="comment"># 删除全部扩展名为.tmp 的文件</span></span><br><span class="line">find . -name <span class="string">&#x27;*.tmp&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line"><span class="comment"># 查找全部的 PNG 文件并将其转换为 JPG</span></span><br><span class="line">find . -name <span class="string">&#x27;*.png&#x27;</span> -<span class="built_in">exec</span> convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure></li><li><a href="https://github.com/sharkdp/fd">fd</a>, find的替代物</li><li><code>locate</code>, 只能通过文件名，但速度很快。locate(1)当您只是尝试按名称查找特定文件时会更好，该文件您知道存在，但您只是不记得它的确切位置。find(1)当您有一个重点领域需要检查时，或者当您需要其众多优势中的任何一个时，效果会更好</li></ul><ol start="11"><li><code>shellcheck</code>检查shell脚本的语法。</li><li><strong>查找代码</strong>:<ul><li><code>grep</code></li><li><a href="https://beyondgrep.com/">awk</a></li><li><a href="https://github.com/BurntSushi/ripgrep">rg</a>(ripgrep)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py <span class="string">&#x27;import requests&#x27;</span></span><br><span class="line"><span class="comment"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match <span class="string">&quot;^#!&quot;</span></span><br><span class="line"><span class="comment"># 查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="comment"># 打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>查找shell命令</strong>:</li></ol><ul><li><code>history</code></li><li><code>Ctrl+R</code>, backward search. 搭配<a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a></li></ul><ol start="14"><li><strong>文件夹导航</strong>:<ul><li><code>tree</code></li><li><code>broot</code></li><li><a href="https://github.com/jarun/nnn">nnn</a>, 需要接下来去学习</li></ul></li><li>shell中使用变量需要加<code>&quot;&quot;</code>(double quote), 当变量中含有命令时需要加括号比如<code>&quot;$(pwd)&quot;</code></li><li>进行比较时需要加<code>[[]]</code>双括号，比如说<code>if [[ n -eq 12 ]]; then</code>, <strong>注意</strong>括号左右要有空格否则出错。</li><li><a href="https://linuxhint.com/bash_globbing_tutorial/">globbing</a></li></ol><h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a><strong>Exercise2</strong></h2><ol><li><p>ls</p><ol><li>所有文件（包括隐藏文件<code>ls -a</code></li><li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954) <code>ls -hl</code></li><li>文件以最近访问顺序排序<code>ls -clt</code></li><li>以彩色文本显示输出结果<code>ls --color=always</code></li></ol></li><li><p>设计一个自动化shell。marco函数保存当前工作目录pwd到home目录的一个log文件中，polo函数通过打开log文件中的路径cd跳到之前所保存的目录中。</p><p>方法一:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$HOME</span>/marco_history.log&quot;</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;save pwd <span class="subst">$(pwd)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">   <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(cat $HOME/marco_history.log)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>export</code>可以增加、修改或删除环境变量，仅效力于该次登陆的操作，和第一种方法的时效类似。</p><p>方法二:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">   <span class="built_in">export</span> MARCO=$(<span class="built_in">pwd</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">   <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$MARCO</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>shell表达式计算的格式为两个<code>(())</code>以及一些逻辑表达式的规范见<a href="https://ss64.com/bash/syntax-brackets.html">此处</a>。关于给的test中的语句中<code>&gt;&amp;2</code>以及一些重定向的问题<a href="https://askubuntu.com/questions/959066/what-does-mean-exactly-in-output-redirection">此处</a>给出了答案。<code>&gt;&amp;2</code>表示<code>2</code>是个文件描述符，不是<code>文件名</code>, 因为重定向的对象是文件名; <code>&amp;&gt;</code>则表示同时发送，比如<code>1&amp;&gt;2</code>表示标准输出和标准错误同时输出。</p><p>for循环的格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> u=rwx ./test.sh</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ./test.sh 2&gt; out.log</span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;failed after <span class="variable">$count</span> times&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> out.log</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">   ((count++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>shellcheck建议增加一行<code>mycmd=$?</code>, 用<code>mycmd</code>来代替<code>$?</code></p></li><li><p>利用xargs命令完成一些操作。xargs命令将标准输入的内容作为参数。<a href="https://unix.stackexchange.com/questions/368753/what-does-this-command-with-a-backslash-at-the-end-do">此处</a>有关于<code>find</code>后的<code>/</code>的作用，目的是方便为了遇到换行符<code>\n</code>停止解析?? <code>tar</code>命令，压缩文件<code>tar -czvf</code>, 解压文件<code>tar -xzvf</code>, <code>-c</code>表示创建备份文件，<code>-x</code>表示从备份文件中还原文件。<code>-f</code>表示指定备份文件, <code>-v</code>表示显示verbose, <code>-z</code>表示<code>--gzip</code>或<code>--ungzip</code> 通过<code>gzip</code>指令处理备份文件。<code>xargs</code>的<code>-d</code>参数后面跟字符表示修改xargs的分隔符(默认为空白字符tab、空格、换行符)。</p><p>方法一, <code>xargs -d &#39;\n&#39;</code>指定输入遇到换行符结束:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&#x27;*.html&#x27;</span> -<span class="built_in">type</span> f | xargs -d <span class="string">&#x27;\n&#x27;</span> tar -cxzf html.zip</span><br></pre></td></tr></table></figure><p>方法二, <code>find -print0</code>打印文件名到标准输出后后面自动跟个<code>null</code>; <code>xargs -0</code>输入遇到<code>null</code>则终止代替空格:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&#x27;*.html&#x27;</span> -<span class="built_in">type</span> f -print0 | xargs -0 tar -cxzf html.zip</span><br></pre></td></tr></table></figure></li><li><p>找出当前文件夹下最近使用的文件, 并按照最近使用的时间列出文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="built_in">type</span> -f | xargs <span class="built_in">ls</span> -tl | head-1 </span><br></pre></td></tr></table></figure></li></ol><h2 id="VIDEO-3-Editors-Vim"><a href="#VIDEO-3-Editors-Vim" class="headerlink" title="VIDEO 3 Editors(Vim)"></a><strong>VIDEO 3</strong> Editors(Vim)</h2><ol><li><code>v</code>进入可视化模式; <code>V</code>进入可视化<strong>行模式</strong>; <code>^v</code>(<code>Ctrl + v</code>)进入可视化<strong>块模式</strong></li><li>Vim大量使用<code>Esc键</code>，因此建议将<code>大小写锁定键</code>设置为<code>Esc键</code>, 可以在ubuntu下使用<a href="https://medium.com/@ahmaddynugroho/swap-caps-lock-and-escape-in-ubuntu-19-10-and-use-esc-easily-in-vim-vs-code-1d3d68f18764">gnome-tweaks</a>来配置交换修改大小写和Esc, 这里面同样介绍了VScode下的配置</li><li>Vim 会维护一系列打开的文件，称为“缓存<code>buffer</code>”。一个 Vim 会话包含一系列标签<code>tab</code>页，每个标签页包含 一系列窗口（分隔面板）。每个窗口显示一个缓存。</li><li><code>:qa</code>全部退出, <code>:wq</code>等价于<code>:x</code></li><li><code>:tabnew</code>;</li><li><code>:e &lt;文件名&gt;</code>打开要编辑的文件</li><li><ul><li><code>w</code>移动一个单词</li><li><code>b</code>回退一个单词</li><li><code>e</code>移动到单词末尾, 可以搭配<code>a</code>在光标之后插入文本。</li><li><code>^</code>移动到行首字符</li><li><code>$</code>移动到行尾字符</li><li><code>0</code>移动到行首字符前</li><li><code>^U</code>上翻页</li><li><code>^D</code>下翻页</li><li><code>gg</code>移动到最后一行</li><li>输入<code>number</code>+<code>G</code>则直接跳转到文件中的某一指定行。若不输入<code>number</code>则直接跳到文件第最后一行。</li><li><code>H</code>屏幕首行</li><li><code>M</code>屏幕中间</li><li><code>L</code>屏尾巴行</li></ul></li><li>[<code>f</code>|<code>F</code>|<code>t</code>|<code>T</code>][alpha], find和to功能来找到相应的字母</li><li><code>^g</code>显示当前编辑文件中当前光标所在行位置以及文件状态信息。</li><li><code>u</code>undo, <code>U</code>撤销在一行中做出的所有改动 ;<code>^r</code> redo</li><li><code>d</code>操作会将删除的内容放入vim中的寄存器中, 以便<code>p</code>操作时粘贴。<ul><li><code>de</code>删除从光标处到单词尾</li><li><code>dw</code>删除一个单词</li><li><code>d</code>+上<code>hjkl</code>方向可以删除需要的内容</li></ul></li><li><code>c</code>change，功能类似于<code>d</code>，只是操作<code>c</code>会进入<code>insert</code>模式</li><li>在词尾插入<code>e</code>移动到词尾，随后<code>a</code>在当前词尾插入</li><li><code>x</code>删除当前光标所处的字符, 如果在可视模式下就删除选中部分</li><li><code>r</code>replace, 如<code>ra</code>将当前字符替换为a; <code>R</code>则可以连续替换多个字符。</li><li><code>y</code>yank, <code>p</code>paste, <code>yw</code> copy one word, 都可以搭配可视化<code>v</code>来使用。</li><li><code>~</code>改变字母的大小写</li><li><code>[num[h|j|k|l]</code>, 如<code>4j</code>向下移动四次</li><li>modifier, <code>i</code>指的是<code>inner</code>, <code>a</code>指的是<code>around</code><ul><li><code>ci(</code> 改变当前括号内的内容</li><li><code>ci[</code> 改变当前方括号内的内容</li><li><code>da&#39;</code> 删除一个单引号字符串，包括周围的单引号</li></ul></li><li> <code>%</code>在配对的括号(parenthese)如:<code>), ], &#125;</code>之间来回切换。在程序调试时用来找不配对的括号是很有用的。</li><li> <code>/</code>后紧随一个字符串是在当前所编辑的文档中<code>正向查找</code>改字符串; <code>?</code>则与<code>/</code>相反，是反向查找。<code>:set ic</code>可以忽略大小写(<code>Ignore Case</code>)会在接下来的查找中持续, <code>:set noic</code>则忽略大小写; <code>:set hls</code>搜索时设置高亮显示, 移除匹配项的高亮显示<code>nohlsearch</code>; <code>:set is</code>(incsearch)查找短语时显示部分匹配, <code>:set noic</code>。</li><li> <a href="https://vimways.org/2019/">每日一个vim小技巧</a></li><li> 安装并配置插件</li><li> Windows下映射CapsLock到ESC需要用到<code>autohotkey</code>脚本工具，添加语句<code>Capslock::Esc</code>即可</li><li> <code>^o</code>回退到光标之前的位置，<code>^i</code>跳转到较新的位置。</li><li><code>s</code> is substitution. The first argument is search string, the second is replacement string.<ul><li>输入<code>:s/old/new</code>则只将光标所在行的第一个串<code>old</code>修改为<code>new</code>-</li><li>输入<code>:s/old/new/g</code>则将全行的匹配串<code>old</code>修改为<code>new</code>。</li><li><code>:%s/old/new/g</code>则替换整个文件中的每个匹配串。</li><li><code>:%s/old/new/gc</code>则会在替换时询问。</li><li><code>:#,#s/old/new/g</code>其中<code>#, #</code>代表的是替换操作的若干行中首尾两行的行号</li></ul></li><li>在vim内执行外部命令的方法，输入<code>:!</code>然后紧接着输入外部的<code>shell</code>命令，如:<code>:!ls</code>，回车结束显示。</li><li>可以搭配可视模式将部分内容<code>:w &lt;filename&gt;</code>写到文件名中。</li><li>将磁盘文件内容提取到当前光标行<code>:r &lt;filename&gt;</code>.</li><li><code>:sp</code>分割窗口，<code>^w ^w</code>(double w)在窗口之间来回切换.</li><li><code>F1</code>或者<code>:help</code>打开帮助文档。下面这些参数可以得到该主题的帮助<ul><li><code>:help w</code></li><li><code>:help c_CTRL-D</code></li><li><code>:help insert-index</code></li><li><code>:help user-manual</code>，阅读Vim的用户手册。</li></ul></li><li><code>.</code>(period)会完成重复性的工作。</li><li>vim命令的补全功能，例如输入<code>:e</code>, 然后按下<code>^D</code>键, Vim会显示以e开始的命令的列表, 接着按下<code>&lt;tab&gt;键</code>会自动自动补全命令。</li><li><code>q:</code> | <code>q?</code>查看vim中的历史命令</li><li>从vim8.0版本开始安装插件只需要将插件<code>git clone</code>到<code>~/.vim/pack/vendor/start/</code>文件里就行。</li></ol><h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a><strong>Exercise3</strong></h2><ol><li> <code>vimtutor</code></li><li><ul><li>创建文件<code>~/.vimrc</code>能够获得更多的特性。了解更多信息可以输入<code>:help vimrc-intro</code></li><li>文件中注释使用<code>&quot;</code></li><li><code>set nocompatible</code>从默认的<code>Vi</code>兼容模式切换到激活<code>Vim</code>的功能。如果<code>vimrc</code>文件存在它就会默认设置<code>nocompatible</code>, 包含这一条语句是为了以防以一些别的方式加载配置文件。</li><li><code>syntax on</code>打开语法高亮</li><li><code>set shortmess+=I</code>禁止Vim默认的启动信息<code>:intro</code>，也就是解释vim的版本，以及该如何使用。</li><li><code>set number</code>在vim中显示行数</li><li><code>set relativenumber</code>显示与当前行的行号和与其相对的行号，其实<code>set number</code>也可以不用加了</li><li><code>set laststatus=2</code>在vim底部显示当前状态。<code>2</code>表示不管存在几个窗口总是显示状态栏。</li><li><code>set backspace=indent,eol,start</code>。设置backspace的属性，感觉好像vim兼容了对默认情况，经过测试这一行语句似乎没有什么实质性的作用。</li><li><code>set hidden</code>可以告诉Vim你拥有未显示在屏幕上未保存的工作,  多一条提示信息。</li><li><code>set ignorecase</code>不区分大小写</li><li><code>set smartcase</code>只能在<code>ignorecase</code>，它会使得区分大小写更智能。</li><li><code>incsearch</code>使用<code>/</code>搜索时会实时搜索，而不是等到Enter键按下时才进行搜索。</li><li><code>nmap Q &lt;Nop&gt;</code>对按键Q的解绑操作，按键Q会进入Ex mode, <code>&lt;Nop&gt;</code>意为无操作, 且<code>nmap</code>和<code>nnoremap</code>是等价的。<code>nmap</code>是在Normal模式下使用，详情可见<code>:h map-modes</code>。</li><li><code>set noerrorbells visualbell t_vb=</code>, disable Vim的bell beeping。</li><li><code>set mouse+=a</code>鼠标支持, 方便进入可视化选择。<code>a</code>表示all previous modes。应用在vim中的所有五个模式。</li><li><code>nmap &lt;Left&gt; :echoe &quot;Use h&quot;&lt;CR&gt;</code>来使用户养成在Normal模式下使用h来左移的习惯。</li><li><code>imap &lt;Left&gt; &lt;ESC&gt;:echoe &quot;Use h&quot;&lt;CR&gt;</code>来使用户养成在Insert模式下使用h来左移的习惯，若在Insert模式下使用方向键Left，则回到Normal模式并提示信息”Use h”。因为Vim中的命令行换行是以<code>CR</code>来结尾的(也就是敲完命令需要敲回车换行)才能执行该echo命令回显信息, <code>echoe</code>回显的是错误信息，会加上红色高亮。</li></ul></li></ol><ol start="3"><li>如果创建多级目录的路径不存在则自动创建<code>mkdir -p</code>使用参数<code>p</code>。安装和配置插件内含帮助文档<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md"> ctrlp.vim</a><ul><li><code>^P</code>打开模糊搜索</li><li><code>c-d</code>切换搜索路径和文件的模式</li><li><code>c-t</code>打开该文件作为新的tab; <code>c-v</code>打开该文件分割列; <code>c-x</code>打开该文件分割行; 个人认为这些tmux都可以替代。</li><li><code>c-n</code>和<code>c-p</code>选择next/previous在ctrlp中的搜索记录</li><li>在ctrlp中输入<code>:help ctrlp-mappings</code>查看更多映射的帮助</li><li>查找到文件后加<code>:25</code>即可跳到该文件的25行</li></ul></li><li>使用Chrome上的<code>vimium</code>有关Vim的插件。<ul><li><code>j</code>和<code>k</code>上下移动网页, <code>d</code>和<code>u</code>以翻页的形式上下移动网页, <code>h</code>和<code>l</code>左右移动网页</li><li>同样可以像vim一样前缀加上数字，比如<code>4j</code>等。也可以<code>gg</code>跳至网页头和<code>G</code>跳至网页尾</li><li><code>f</code>通过标签打开当前网页超链接到当前的tab上，<code>F</code>则打开到新的tab上。</li><li>当前tab历史的前进<code>L</code>和回退<code>H</code></li><li>在打开的网页tab之间切换，上一个<code>J</code>, 下一个<code>K</code></li><li>关闭当前标签页<code>x</code>, <code>X</code>恢复关闭的tab</li><li>在历史标签中搜索<code>o</code>，<code>ESC</code>退出</li><li>若标签页太多,可以使用<code>T</code>在已有的标签之中搜索，<code>ESC</code>退出</li><li><code>?</code>打开<code>Vimium</code>的帮助文档。</li><li><code>r</code>(Reload)刷新当前网页</li><li><code>yy</code>将当前的URL复制到剪切板，<code>p</code>将剪切板上的URL在当前tab中打开，<code>P</code>则在新的tab中打开</li><li><code>gi</code>将光标焦距到当前网页的第一个输入栏(即搜索栏)</li><li><code>b</code>搜索书签打开到当前tab，<code>B</code>打开到新的tab中</li><li><code>/</code>在当前网页中使用匹配， 搭配<code>n</code>和<code>N</code></li><li><code>t</code>创建新的tab</li><li><code>alt+p</code>，pin和unpin当前tab</li><li><code>alt+m</code>, 静音和解除静音当前tab</li></ul></li><li>(待做)<code>XML</code>转<code>JSON</code><br>, <code>:wq</code>等价于<code>:x</code><h2 id="VIDEO-4-Data-Wangling-TODO"><a href="#VIDEO-4-Data-Wangling-TODO" class="headerlink" title="VIDEO 4 Data Wangling (TODO)"></a><strong>VIDEO 4</strong> Data Wangling (TODO)</h2></li><li>正则表达式通常以<code>/</code>开始和结束。正则表达式在线调试工具<a href="https://regex101.com/r/qqbZqh/2">regex debugger</a><ul><li><code>.</code>除换行符之外的”任意单个字符”</li><li><code>*</code>匹配前面字符零次或多次</li><li><code>+</code>匹配前面字符一次或多次</li><li><code>[abc]</code>匹配<code>a</code>,<code>b</code>和<code>c</code>中任意一个, 在括号中使用<code>^</code>即为非</li><li><code>(RX1|RX2)</code>任何能够匹配<code>RX1</code>或<code>RX2</code>的结果</li><li><code>^</code>行首</li><li><code>$</code>行尾</li></ul></li><li><code>sed</code>命令<ul><li><code>-E</code>参数支持对正则表达式的拓展</li></ul></li><li><code>uniq</code>命令去除重复行<ul><li><code>-c</code>参数输出过滤后的行数</li></ul></li><li><code>sort</code>命令按照数字顺序对输入进行排序(默认情况下是按照字序列排序)<ul><li><code>-r</code>参数进行倒序排序</li><li><code>-n</code>参数表示仅排序到第<code>n</code>个部分</li></ul></li><li><code>awk</code>编辑器, <code>awk</code>其实是一种编程语言具体可以查看<code>man awk</code>和<code>tldr awk</code></li><li>学习一下<a href="https://regexone.com/lesson/introduction_abcs">交互式正则表达式教程</a></li></ol><h2 id="VIDEO-6-Version-Control-Git"><a href="#VIDEO-6-Version-Control-Git" class="headerlink" title="VIDEO 6 Version Control(Git)"></a><strong>VIDEO 6</strong> Version Control(Git)</h2><ol><li>Git中的对象可以是blob(数据对象)、Tree或Commit</li><li>所有的snapshot都可以用<a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1哈希</a>(40位的十六进制字符)来标记，但显然<code>Reference</code>更方便。</li><li><code>HEAD</code>引用可以通过两种方式查看, <code>cat .git/HEAD</code>; <code>git symbolic-ref HEAD</code>。</li><li><strong>基础</strong><ul><li><code>git help &lt;command&gt;</code>:获取git命令的帮助信息</li><li><code>git init</code>:创建一个新的git仓库，其数据会存放在一个名为<code>.git</code>的目录下</li><li><code>git status</code>:显示当前仓库的状态</li><li><code>git add &lt;filename&gt;</code>:添加文件到暂存区(staging Area)</li><li><code>git commit</code>:创建一个新的提交; 如何编写<a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>, 为什么要<a href="https://cbea.ms/git-commit/">编写良好的提交信息</a></li><li><code>git</code>的提交信息<ol><li>用空行将主体与主体分开</li><li>将主题行限制为50个字符</li><li>将主题行大写</li><li>不要以句点结束主题行</li><li>在主题行中使祈使句语句</li><li>将正文包裹在72个字符处</li><li>用正文来解释<code>what</code> <code>why</code> vs. <code>how</code></li></ol></li><li><code>git log</code>:显示日志历史</li><li><code>git log --all --graph --decorate</code>:可视化历史记录(有向无环图)</li><li><code>git diff &lt;filename&gt;</code>:显示与暂存区文件的差异</li><li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>:显示某个文件两个版本之间的差异</li><li><code>git checkout &lt;revision&gt;</code>:更新HEAD和目前的分支</li></ul></li><li><strong>分支和合并</strong><ul><li><code>git branch</code>:显示分支</li><li><code>git branch &lt;name&gt;</code>:创建分支</li><li><code>git checkout -b &lt;name&gt;</code>:创建分支并切换到该分支, 相当于<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li><li><code>git merge &lt;revision&gt;</code>:合并到当前分支</li><li><code>git mergetool</code>:使用工具来处理合并冲突</li><li><code>git rebase &lt;name&gt;</code>:创建更线性的提交历史</li></ul></li><li><strong>远端操作</strong><ul><li><code>git remote</code>:列出远端</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>:添加一个远端</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>:将对象传送至远端并更新远端引用</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>:创建本地和远端分支关联关系</li><li><code>git fetch</code>:从远端获取对象</li><li><code>git pull</code>:相当于<code>git fetch; git merge</code></li><li><code>git clone &lt;url&gt; &lt;name&gt;</code>:从远端下载仓库并命名为name</li></ul></li><li><strong>撤销</strong><ul><li><code>git commit --amend</code>:编辑提交的内容或信息</li><li><code>git reset HEAD &lt;file&gt;</code>:恢复暂存的文件</li><li>`git checkout – <file>:丢弃修改</li></ul></li><li><strong>Git高级操作</strong><ul><li><code>git config</code>:Git是一个<a href="https://git-scm.com/docs/git-config">高度可定制</a>的工具</li><li><code>git clone --depth=1</code>:浅克隆(shallow clone), 不包括完整的版本历史信息</li><li><code>git add -p</code>:交互式暂存</li><li><code>git blame</code>:查看最后修改某行的人</li><li><code>git stash</code>:暂时移除工作目录下的修改内容</li><li><code>git stash pop</code>:恢复工作目录下的修改内容</li><li><code>git bisect</code>:通过二分查找搜索历史记录</li><li><code>.gitignore</code>:<a href="https://git-scm.com/docs/gitignore">指定</a>故意不追踪的文件</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 6.NULL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile Note</title>
      <link href="/2022/05/16/Makefile-Note/"/>
      <url>/2022/05/16/Makefile-Note/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile-Note"><a href="#Makefile-Note" class="headerlink" title="Makefile Note"></a>Makefile Note</h1><p>参考<a href="https://seisman.github.io/how-to-write-makefile/introduction.html">跟我一起写Makefile</a>做点笔记。</p><ul><li><p>第一个<code>target</code>为<code>make</code>的默认目标</p></li><li><p><code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>command</code>所定义的命令就会被执行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>最开始的实例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure></li><li><p>为了复用可以在<code>Makefile</code>中使用<code>shell</code>的变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></li><li><p><code>make</code>会自动推导命令，只要<code>Make</code>看到一个<code>.o</code>文件，它就会自动地把<code>.c</code>文件加在依赖关系中。并且command <code>cc -c xxx.c</code>也会被自动推导出来</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></li><li><p>更稳健的<code>clean</code>写法: </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean <span class="comment"># `.PHONY`表示`clean`是个伪目标文件</span></span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></li><li><p><code>Makefile</code>中主要包含的五部分:</p><ul><li>显示规则, 显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</li><li>隐晦规则, 由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。</li><li>变量的定义</li><li>文件指示, 即<code>Makefile</code>可以使用<code>include</code>将其他makefile包含进来。<code>filename</code>可以用一个或多个空格隔开。如: <code>include foo.make a.mk b.mk c.mk e.mk f.mk</code>。</li><li>注释，和shell一样使用<code>#</code>。</li></ul></li><li><p><code>make</code>命令开始时，会寻找<code>include</code>所指出的其它<code>Makefile</code>，并把其内容安置在当前的位置。如果还没找到则在当前目录找。如果还是没找到则在以下几个目录找:</p><ul><li>make命令开始时，会找寻 include 所指出的其它Makefile，并把其内容安置在当前的位置</li><li>如果目录 <prefix>/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。</li></ul><p>如果还没找到则会生成警告信息，随后报错。可以在前面加个减号<code>-include &lt;filename&gt;</code>来告诉make无论出现什么错误，都不要报错，继续执行。</p></li><li><p>GNU的make工作时的执行步骤:</p><ol><li>读入所有的Makefile。</li><li>读入被include的其它Makefile。</li><li>初始化文件中的变量。</li><li>推导隐晦规则，并分析所有规则。</li><li>为所有的目标文件创建依赖关系链。</li><li>根据依赖关系，决定哪些目标要重新生成。</li><li>执行生成命令。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim+vscode+tmux+gdb</title>
      <link href="/2022/05/16/vim-vscode-tmux-gdb/"/>
      <url>/2022/05/16/vim-vscode-tmux-gdb/</url>
      
        <content type="html"><![CDATA[<h1 id="vim-vscode-tmux-gdb-git"><a href="#vim-vscode-tmux-gdb-git" class="headerlink" title="vim+vscode+tmux+gdb+git"></a>vim+vscode+tmux+gdb+git</h1><p>个人的一些认为比较常用以及不经常用到的的快捷操作</p><h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a><strong>vscode</strong></h2><ol><li>查找文件ctrl+p， esc退出</li><li>分割屏幕ctrl+\，通过ctrl+1/2/3来切换分割屏幕的焦点</li><li>ctrl+` 打开/关闭终端</li><li>ctrl+tab, 在tab之间切换</li><li>模糊查找当前工作目录下的所有文件ctrl+p, #</li><li>Ctrl + Shift + Tab 导航tab</li><li>alt + &lt;-/-&gt;切换tab</li></ol><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a><strong>vim</strong></h2><ol><li>跳转到指定行号n, ngg</li><li>复制整行 yy, 复制包括当前行接下来n行， nyy</li><li>复制指定行v模式下指定复制内容，然后y键复制。</li><li>粘贴<br>如复制内容不是一整行：p粘贴到当前光标处，P粘贴到当前行首。<br>如复制内容是一整行：p粘贴到当前行的下一行，P粘贴到当前行的上一行</li><li>剪切dd</li><li>在当前文件查找指定内容，/+内容</li><li>ctrl+] 跳转到函数的定义处，ctrl+t返回上一次光标处</li><li>u撤销，ctrl+r恢复</li><li><code>^y</code>向上移动一行, <code>^e</code>向下移动一行</li><li><code>^b</code>向上移动一页，<code>^f</code>向下移动一页</li><li>number + shift + G, 跳到第number行 </li><li>在<code>tab</code>之间切换, <code>Alt</code>+<code>number</code>.</li><li>可视条件下选中后<code>&lt;</code>或<code>&gt;</code>完成缩进。</li><li>要想跳转到函数定义处，需要在项目目录中输入<code>ctags -R</code>命令。<code>ctrl+]</code>跳转, <code>ctrl+o</code>返回。</li><li>可视模式下注释+<code>d</code>。</li><li>替换变量名<code>:%s/foo/bar/g</code>将整个文件中的<code>foo</code>替换为<code>bar</code></li><li>在vim文件内使用shell命令<code>:! command</code></li><li>在当前文件中打开另一个文件<code>:e file</code></li><li>在Vim中编译代码<code>:!gcc %</code>, 编译并运行代码<code>:!gcc % || ./a.out</code></li></ol><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a><strong>tmux</strong></h2><ol><li>任何命令都需要加ctrl+b前缀</li><li>c创建窗口；n, p切换窗口</li><li>%垂直分屏, “水平分屏</li><li>x关闭窗口</li><li>o在窗口之间切换</li><li>PgUp开启tmux终端界面的翻页，q退出。</li></ol><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a><strong>gdb</strong></h2><ol><li>delete 删除所有断点</li><li>layout src/reg/asm 显示c源代码、寄存器和汇编，但未分屏；focus src/reg/asm在src、reg和asm的tui中来回切换</li><li>layout split获得c和asm的分屏。</li><li>info/i frame 查看栈帧, info/i args查看传递给main的参数, i locals显示当前的本地变量。</li><li>通过backtrace查看栈帧，frame n(n为bt结果的栈帧号)，然后i frame查看当前栈帧号的详细内容</li><li>print/p查看argv数据;print/p *argv(默认打印一个参数);可以通过print/p *argv@n 来选择argv数组中的n个元素即参数; p *argv@argc打印所有参数</li><li><code>print</code>是打印值，<code>x</code>是访问主存。</li><li><code>Ctrl + x</code>，再按1：单窗口模式，显示一个窗口</li><li><code>Ctrl + x</code>，再按2：双窗口模式，显示两个窗口</li><li><code>Ctrl + x</code>，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。</li><li><code>^x+a</code>关闭可视化</li><li><code>wa</code>跟踪某个变量(watch point)</li></ol><h2 id="lt-gt-gdb续"><a href="#lt-gt-gdb续" class="headerlink" title="&lt;&gt;(gdb续)"></a><strong>&lt;<Debug Hacks>&gt;(gdb续)</strong></h2><ol><li><code>break/b</code><ul><li><code>break 函数名</code></li><li><code>break 行号</code></li><li><code>break 文件名:行号</code></li><li><code>break 文件名:函数名</code></li><li><code>break +偏移量</code></li><li><code>break -偏移量</code></li><li><code>break *地址</code></li><li><code>break 断点 if 条件</code></li><li>若不指定位置就默认在下一行代码上设置断点</li><li><code>info break</code>显示断点信息</li></ul></li><li><code>run/r</code>, 如果不加参数，执行到断点位置后暂停运行(和start命令一样的效果)</li><li><code>print/p</code><ul><li><code>p $eax</code>，显示寄存器(寄存器名前加$)</li></ul></li><li><code>p/格式 变量</code>, 显示寄存器可用的格式:<ul><li>x, 显示为十六进制数</li><li>d, 显示为十进制数</li><li>u, 显示无符号十进制数</li><li>o, 显示八进制数</li><li>t, 显示二进制数(two)</li><li>a, 显示地址</li><li>c, 显示为字符</li><li>f, 浮点小数</li><li>s, 显示为字符串</li><li>i, 显示为机器语言</li></ul></li><li><code>x/NFU ADDR</code>, 显示内存的内容(eXamining):<ul><li><code>N</code>为重复次数</li><li><code>F</code>为上述的P格式</li><li><code>U</code>代表的单位：<ul><li>b, 字节</li><li>h, 半字</li><li>w, 字(4字节默认)</li><li>g, 双字</li></ul></li></ul></li></ol><h2 id="cgdb"><a href="#cgdb" class="headerlink" title="cgdb"></a><strong>cgdb</strong></h2><ol><li>使用<code>i</code>切换到<code>GDB command</code>，<code>esc</code>切换到<code>source window</code>。</li><li>在<code>source window</code>下，可以像<code>vim</code>一样用<code>\</code>匹配内容， 且移动到指定行按下<code>space</code>可以可视化打断点。</li><li><code>q</code>或者<code>^c+d</code>退出<code>gdb</code></li><li>调整<code>source window</code>的大小, <code>-</code>缩小一行，<code>=</code>增加一行。</li><li>在<code>source window</code>下<code>^w</code>窗口水平竖直分割切换。</li><li><code>F5</code> = <code>run</code>, <code>F6</code> = <code>continue</code>, <code>F7</code> = <code>finish</code>, <code>F8</code> = <code>next</code>, <code>F10</code> = <code>step</code>。</li><li><code>CGDB</code>的配置, 在<code>~/.cgdb/</code>目录下创建<code>cgdbrc</code>文件并编辑。如果<code>cgdbrc</code>文件存在，<code>CGDB</code>就会执行该文件中的每一行。<ul><li><code>:set disasm</code>，以汇编语言的形式显示。</li><li><code>:set hls</code>，高亮显示匹配到的字符串</li><li><code>:set syn=style</code>设置当前文件对应语法风格的高亮。</li></ul></li></ol><h2 id="git"><a href="#git" class="headerlink" title="git"></a><strong>git</strong></h2><ul><li><code>git clone -b branch XXX</code>克隆指定分支的代码</li><li><code>git reset --hard 1a703e</code>回滚到某个历史commit</li><li><code>git branch -m &lt;branchName&gt;</code>将当前分支名更改为branchName</li><li><code>git checkout -b &lt;newbranch&gt;</code>创建新分支并切换到新分支</li><li><code>git diff</code>查看修改的差异</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Cpp Note</title>
      <link href="/2022/05/16/cpp%20Note/"/>
      <url>/2022/05/16/cpp%20Note/</url>
      
        <content type="html"><![CDATA[<h2 id="一、std-function和bind绑定器"><a href="#一、std-function和bind绑定器" class="headerlink" title="一、std::function和bind绑定器"></a>一、std::function和bind绑定器</h2><h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><ul><li>是一个函数指针</li><li>是一个具有<code>operator()</code>成员函数的类对象（仿函数）</li><li>是一个可被转换为函数指针的类对象</li><li>是一个类成员（函数）指针</li></ul><h3 id="可调用对象包装器std-funtion"><a href="#可调用对象包装器std-funtion" class="headerlink" title="可调用对象包装器std::funtion"></a>可调用对象包装器std::funtion</h3><ul><li>头文件<code>&lt;functional&gt;</code></li><li>可以容纳除了类成员（函数）指针之外的所有可调用对象</li><li>可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们</li><li><code>function</code>比普通函数指针更灵活和便利</li></ul><h3 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h3><ul><li>头文件<code>&lt;functional&gt;</code></li><li>接受一个可调用对象，生成一个新的可调用对象</li><li><code>std::bind</code>用来将可调用对象与其参数一起进行绑定，绑定后的结果可以使用<code>std::function</code>进行保存，并延迟调用到任何我们需要的时候</li><li>作用<ul><li>将可调用对象与其参数一起绑定成一个仿函数(functor)</li><li>将多元（参数个数为n）可调用对象转成一元或者（n-1）元可调用对象，却只绑定部分参数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();  <span class="comment">// 输出：1 2</span></span><br><span class="line">std::<span class="built_in">bind</span>(output, std::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);  <span class="comment">// 输出 ：1 2</span></span><br><span class="line">std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_1)(<span class="number">1</span>);  <span class="comment">// 输出 ：2 1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><code>std::bind</code>的返回类型是一个stl内部定义的仿函数类型</li><li><code>std::placeholders::_1</code>是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代</li><li>组合bind函数<ul><li><code>std::bind(std::greater&lt;int&gt;(), std::placeholders::_1, 5);</code><ul><li>判断是否大于5的功能闭包</li></ul></li></ul></li></ul><h3 id="C-11通过提供std-function和std-bind统一了可调用对象的各种操作"><a href="#C-11通过提供std-function和std-bind统一了可调用对象的各种操作" class="headerlink" title="C++11通过提供std::function和std::bind统一了可调用对象的各种操作"></a>C++11通过提供std::function和std::bind统一了可调用对象的各种操作</h3><h2 id="二、lambda表达式"><a href="#二、lambda表达式" class="headerlink" title="二、lambda表达式"></a>二、lambda表达式</h2><h3 id="语法形式"><a href="#语法形式" class="headerlink" title="语法形式"></a>语法形式</h3><ul><li><code>[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</code></li><li>C++11允许省略lambda表达式返回值定义，这样编译器就会根据<code>return</code>语句自动推导出返回类型<ul><li>初始化列表不能用于返回值的自动推导 </li></ul></li><li>lambda表达式在没有参数列表时，参数列表是可以省略的</li></ul><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><ul><li><code>[]</code>不捕获任何变量</li><li><code>[&amp;]</code>捕获外部作用域中所有变量，并作为引用在函数体中使用（引用捕获）</li><li><code>[=]</code>捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）</li><li><code>[=, &amp;foo]</code>按值捕获外部作用域中所有变量，并按引用捕获foo变量</li><li><code>[bar]</code>按值捕获bar变量，同时不捕获其他变量</li><li><code>[this]</code>捕获当前类中的指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了<code>&amp;</code>或者<code>=</code>，就默认添加此选项</li><li>如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为<code>mutable</code>，如：<code>auto f2 = [=]() mutable &#123;return a++; &#125;</code></li></ul><h3 id="可以认为它是个带有operator-的类，即仿函数"><a href="#可以认为它是个带有operator-的类，即仿函数" class="headerlink" title="可以认为它是个带有operator()的类，即仿函数"></a>可以认为它是个带有operator()的类，即仿函数</h3><ul><li>可以使用<code>std::function</code>和<code>std::bind</code>来存储和操作lambda表达式  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f1 = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">void</span>)&gt; f2 = std::<span class="built_in">bind</span>([](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;, <span class="number">123</span>);</span><br></pre></td></tr></table></figure></li><li>对于没有捕获任何变量的lambda表达式，还可以被转换成一个普通的函数指针  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">int</span> (*)(<span class="type">int</span>);</span><br><span class="line"><span class="type">func_t</span> f = [](<span class="type">int</span>  a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></li><li>捕获变量的lambda表达式则不能转化为普通指针，若转换，lambda表达式本身的this指针就丢失掉了</li><li>lambda和<code>std::function</code>的效果是一样的，一般情况下可直接用lambda来代替<code>function</code></li></ul><h2 id="三、tuple元组"><a href="#三、tuple元组" class="headerlink" title="三、tuple元组"></a>三、tuple元组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>可以把它当作一个通用的结构体来用，不需要创建结构体又获取结构体的特征</li><li>在某些情况下可以取代结构体，使程序更简洁、直观</li><li>如果用tuple来替代3个以上字段的结构体时就不太合适了，不直观，易读性降低（建议）</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>创建元组<ul><li><code>tuple&lt;const char*, int&gt; tp = make_tuple(sendPack, nSendSize);</code></li><li><code>auto tp = return std::tie(1, &quot;aa&quot;, 2);</code>  // tp的实际类型是：std::tuple&lt;int&amp;, string&amp;, int&amp;&gt;</li></ul></li><li>获取元组的值  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* data = tp.<span class="built_in">get</span>&lt;<span class="number">0</span>&gt; ();  <span class="comment">// 获取第一个值</span></span><br><span class="line"><span class="type">int</span> len = tp.<span class="built_in">get</span>&lt;<span class="number">1</span>&gt; ();  <span class="comment">// 获取第二个值</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>std::tie</code>解包tuple  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">string a;</span><br><span class="line">std::<span class="built_in">tie</span>(x, a, y) = tp;</span><br></pre></td></tr></table></figure><ul><li>如果只想了解某个位置的值时，可以用<code>std::ignore</code>占位符来表示不解某个位置的值<br><code>std::tie(std::ignore, std::ignore, y) = tp;</code>  // 只解第3个值</li></ul></li></ul></li><li>创建右值引用元组<ul><li><code>forward_as_tuple</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">m.<span class="built_in">emplace</span>(std::forward_as_tuple(<span class="number">10</span>, std::<span class="built_in">string</span>(<span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>)));</span><br></pre></td></tr></table></figure><ul><li>创建了类似于<code>std::tuple&lt;int&amp;&amp;, std::string&amp;&amp;&gt;</code>类型的tuple</li></ul></li></ul></li><li>连接多个tuple<ul><li><code>tuple_cat</code></li></ul></li></ul><h2 id="四、shared-ptr共享的智能指针"><a href="#四、shared-ptr共享的智能指针" class="headerlink" title="四、shared_ptr共享的智能指针"></a>四、shared_ptr共享的智能指针</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>希望多个智能指针管理同一个资源就用shared_ptr</li><li><code>std::shared_ptr</code>使用引用计数，每一个shared_ptr的拷贝都指向相同的内存</li><li>在最后一个shared_ptr析构的时候，内存才会被释放</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>初始化<ul><li>可以通过使用构造函数、<code>std::make_shared&lt;int&gt;</code>辅助函数和<code>reset</code>方法来初始化shared_ptr  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;  <span class="comment">// 使用动态初始化，后加一个括号为值初始化</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr;</span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li>不能将一个原始指针直接赋值给智能指针</li><li>当智能指针中有值的时候，调用reset会使引用计数减1</li></ul></li><li>获取原始指针<ul><li>可以通过<code>get</code>方法来返回原始指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="type">int</span>* p = ptr.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li>指定删除器<ul><li>智能指针初始化可以指定删除器</li><li>当p的<code>引用计数</code>为0时，自动调用删除器DeleteIntPtr来释放对象的内存<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, DeleteIntPtr)</span></span>;</span><br></pre></td></tr></table></figure></li><li>也可以用lambda表达式指定删除器<ul><li><code>std::shared_ptr&lt;int&gt; p(new int, [](int* p) &#123; delete p; &#125;);</code></li></ul></li><li>当我们用<code>shared_ptr</code>管理动态数组时，需要指定删除器，因为<code>std::shared_ptr</code>的默认删除器不支持数组对象</li><li>也可以将<code>std::default_delete</code>作为删除器</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>1）不要用一个原始指针初始化多个shared_ptr</li><li>2）不要在函数实参中创建shared_ptr<ul><li>可能会因为发生异常而泄露内存</li></ul></li><li>3）通过<code>shared_from_this()</code>返回this指针<ul><li>因为this指针本质上是一个<code>裸指针</code>，因此这样可能会导致重复析构</li><li>解决方法<ul><li>让目标类通过派生<code>std::enable_shared_from_this&lt;T&gt;</code>类，然后使用基类的成员函数<code>shared_from_this</code>来返回this的shared_ptr</li></ul></li></ul></li><li>4）要避免循环引用<ul><li>智能指针最大的一个陷阱就是循环引用，循环引用会导致内存泄露</li><li>导致意外延长对象的生命期</li><li>解决方法<ul><li>使用weak_ptr</li></ul></li></ul></li></ul><h2 id="五、unique-ptr独占的智能指针"><a href="#五、unique-ptr独占的智能指针" class="headerlink" title="五、unique_ptr独占的智能指针"></a>五、unique_ptr独占的智能指针</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>希望只有一个智能指针管理资源或者管理数组就用unique_ptr</li><li>unique_ptr是一个独占型的智能指针</li><li>它不允许其他的智能指针共享其内部的指针</li><li>不允许通过赋值将一个unique_ptr赋值给另外一个unique_ptr</li><li>可以通过<code>std::move</code>来转移到其他的unique_ptr  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br><span class="line">unique_ptr&lt;T&gt; myOtherPtr = std:: <span class="built_in">move</span>(myptr);</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>如果是数组，则判断是否是定长数组<ul><li>若为定长数组则编译不通过（不能这样调用<code>make_unique&lt;T[10]&gt;(10) </code>)</li><li>若为非定长数组，则获取数组中的元素类型，再根据参数size创建动态数组的unique_ptr<ul><li><code>unique_ptr&lt;int[]&gt; ptr5 = make_unique&lt;int[]&gt;(10);</code></li></ul></li></ul></li><li>unique_ptr可以指向数组（而shared_ptr这么做不合法）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span> []&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function">ptr[9] </span>= <span class="number">9</span>;         <span class="comment">// 设置最后一个元素值为9</span></span><br></pre></td></tr></table></figure></li><li>unique_ptr指定删除器的时候需要确定删除器的类型<ul><li><code>std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int (1), [](int* p) &#123; delete p; &#125;);</code></li><li>lambda表达式在没有捕获变量的情况下是可以直接转换为函数指针的，一旦捕获了就无法转换了<ul><li><code>std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int (1), [&amp;](int* p) &#123; delete p; &#125;);</code>  // 错误，捕获了变量</li></ul></li><li>如果希望unique_ptr删除器支持lambda可以这么写<ul><li><code>std::unique_ptr&lt;int, std::function&lt;void(int*)&gt;&gt; ptr(new int(1), [&amp;](int* p) &#123; delete p; &#125;</code></li></ul></li></ul></li></ul><h2 id="六、weak-ptr弱引用的智能指针"><a href="#六、weak-ptr弱引用的智能指针" class="headerlink" title="六、weak_ptr弱引用的智能指针"></a>六、weak_ptr弱引用的智能指针</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>weak_ptr是用来监视shared_ptr的，不会使引用计数加1</li><li>它不管理shared_ptr内部的指针，主要是为了监视shared_ptr的生命周期</li><li>它的构造不会增加引用计数，它的析构也不会减少引用计数</li></ul><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>1）通过<code>use_count()</code>方法来获得当前观测资源的引用计数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 结果将输出1</span></span><br></pre></td></tr></table></figure></li><li>2）通过<code>expired()</code>方法来判断所观测的资源是否已经释放（true为无效）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wp.<span class="built_in">expired</span>())</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weak_ptr无效，所监视的智能指针已经被释放&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weak_ptr有效&quot;</span>;</span><br></pre></td></tr></table></figure></li><li>3）通过<code>lock()</code>方法来获取所监视的shared_ptr  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; gw = sp;</span><br><span class="line"><span class="keyword">auto</span> spt = gw.<span class="built_in">lock</span>();  <span class="comment">// 获取所监视的shared_ptr</span></span><br><span class="line">cout &lt;&lt; *spt &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul><h3 id="weak-ptr返回this指针"><a href="#weak-ptr返回this指针" class="headerlink" title="weak_ptr返回this指针"></a>weak_ptr返回this指针</h3><ul><li><code>std::enable_shared_from_this</code>类中有一个weak_ptr，这个weak_ptr用来观测this智能指针</li><li>调用<code>shared_from_this()</code>方法时，会调用内部这个weak_ptr的<code>lock()</code>方法，将所观测的shared_ptr返回</li><li>获取自身智能指针的函数仅在<code>shared_ptr&lt;T&gt;</code>的构造函数被调用之后才能使用，因为<code>enable_shared_from_this</code>内部的weak_ptr只有通过shared_ptr才能构造</li></ul><h3 id="可以通过weak-ptr解决循环引用问题"><a href="#可以通过weak-ptr解决循环引用问题" class="headerlink" title="可以通过weak_ptr解决循环引用问题"></a>可以通过weak_ptr解决循环引用问题</h3>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 403. 青蛙过河</title>
      <link href="/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
      <url>/2021/04/29/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>给定石子位置的列表stones（升序），青蛙可以跳上石子，但不能跳入水中。<br>如果青蛙一步跳跃了k个单位，那么它接下来跳跃的距离只能为k-1、k或k+1个单位。<br>青蛙只能向前方跳跃。<br><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stones = [0,1,3,5,6,8,12,17]</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">青蛙可以成功过河，按照如下方案跳跃：</span><br><span class="line">跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, </span><br><span class="line">然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><p>思路：本题为二维动态规划，使用动态规划的方法，令<code>dp[i][k]</code>为跳跃k个单位能否到达第i个石子，初始化<code>dp[0][0] = true;</code>，得出状态转移方程<code>dp[i][k] = dp[j][k-1] | dp[j][k] | dp[j][k+1];</code>，其中j为上一次所在石子的编号。</p><h3 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;  <span class="comment">// 优化：跳跃距离k必定满足k &lt;= i（可推），此时为青蛙无路可跳</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;  <span class="comment">// 反向枚举</span></span><br><span class="line">                <span class="type">int</span> k = stones[i] - stones[j];  <span class="comment">// 跳跃的距离k，j为上一次所在石子的编号</span></span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;  <span class="comment">// 在第j个石子上至多跳跃j+1的单位</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(n^2^)，n为石子的个数，第i个石子后方只有i-1个石子，因此在任意位置，青蛙的上一次跳跃距离至多只有n种，状态总数为 n^2^ </li><li><strong>空间复杂度</strong>：O(n^2^)，需要二维动态数组的空间，其中n是石子的数量</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP Note</title>
      <link href="/2021/04/28/tcp%20note/"/>
      <url>/2021/04/28/tcp%20note/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP详解"><a href="#TCP-IP详解" class="headerlink" title="TCP/IP详解"></a>TCP/IP详解</h1><h2 id="一、TCP超时与重传"><a href="#一、TCP超时与重传" class="headerlink" title="一、TCP超时与重传"></a>一、TCP超时与重传</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li>计时器超时称为重传超时（RTO）</li><li>若TCP累计确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文段时，快速重传会推断出现丢包</li><li>由下层网络（IP）可能出现丢失重复或失序包，TCP重传其认为已经丢失的包</li></ul><h3 id="简单的超时与重传举例"><a href="#简单的超时与重传举例" class="headerlink" title="简单的超时与重传举例"></a>简单的超时与重传举例</h3><ul><li>二进制指数退避<ul><li>每次重传间隔时间加倍</li></ul></li><li>TCP拥有两个阈值来决定如何重传同一个报文段<ul><li>R1表示TCP在向IP层传递“消极建议”（如重新评估当前路径）前，愿意尝试重传的次数</li><li>R2（大于R1）指示TCP应放弃当前连接的时机</li></ul></li></ul><h3 id="设置重传超时"><a href="#设置重传超时" class="headerlink" title="设置重传超时"></a>设置重传超时</h3><ul><li>TCP超时和重传的基础根据给定连接的RTT（往返时间）设置RTO<ul><li>若TCP先于RTT开始重传，可能会在网络中引入不必要的重复数据</li><li>若延迟远大于RTT的间隔发送重传数据，整体网络利用率（及单个连接吞吐量）会随之下降</li></ul></li><li>RTO设置得当是保证TCP性能的关键</li><li>当分组失序（或丢失）时，RTT会被过高估算。较大的RTT估计值使得RTO也更大</li><li>时间戳选项（TSOPT）使得发送端即使在丢包、延时、失序的情况下也能测量RTT</li></ul><h3 id="基于计时器的重传"><a href="#基于计时器的重传" class="headerlink" title="基于计时器的重传"></a>基于计时器的重传</h3><ul><li>对于TCP来说，计时器需要有效地实现被设置、重新设置或取消的功能</li><li>RTO的设置通常大于RTT（两倍或更大）<ul><li>因此基于计时器的重传会导致网络利用率的下降</li></ul></li><li>快速重传不需要计时器超时来触发且比超时重传更高效</li></ul><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><ul><li>快速重传机制基于接收端的反馈信息来引发重传</li><li>快速重传是根据收到重复ACK来推断出现丢包并启动重传，而不必等待重传计时器超时</li><li>快读重传仅在达到重复阈值后才被触发，而不是一旦收到重复ACK就出发，减少了大量不必要的重传发生</li></ul><h3 id="带选择确认（SACK）的重传"><a href="#带选择确认（SACK）的重传" class="headerlink" title="带选择确认（SACK）的重传"></a>带选择确认（SACK）的重传</h3><ul><li>空缺<ul><li>ACK号与接收端缓存中的其他数据之间的间隔</li></ul></li><li>失序数据<ul><li>序列号高于空缺的数据</li></ul></li><li>在很多情况下，合理采用SACK信息能更快地实现空缺填补，且能减少不必要的重传</li><li>SACK接收端行为<ul><li>SACK选项的空间有限，应尽可能确保向TCP发送端提供最新信息，其余的SACK块包含的内容也按照接收的先后依次排序</li></ul></li><li>SACK发送端行为<ul><li>SACK发送端记录接收到的累计ACK信息，还需要记录接收到的SACK信息</li><li>当SACK发送端执行重传时，通常是由于其收到了SACK或重复SACK（D-SACK）</li></ul></li><li>为提高对ACK丢失的鲁棒性，第一个SACK块中需要包含之前的重复SACK信息</li></ul><h3 id="伪超时与重传"><a href="#伪超时与重传" class="headerlink" title="伪超时与重传"></a>伪超时与重传</h3><ul><li><p>伪重传</p><ul><li>即使没有出现数据丢失也可能引发的重传</li><li>主要原因是伪超时</li></ul></li><li><p>DSACK</p><ul><li>主要目的是判断何时重传是不必要的</li><li>因此发送端至少可以判断是否发生了包失序、ACK丢失、包重复</li></ul></li></ul><h3 id="包失序与重复"><a href="#包失序与重复" class="headerlink" title="包失序与重复"></a>包失序与重复</h3><ul><li>失序<ul><li>IP层不能保证包传输是有序进行的</li><li>如果失序发生在正向链路上，TCP可能无法正确识别失序和丢包</li></ul></li><li>重复<ul><li>采用DSACK避免</li></ul></li></ul><h3 id="重新组包"><a href="#重新组包" class="headerlink" title="重新组包"></a>重新组包</h3><ul><li>定义：发送一个更大的报文段来提高性能（不能超过接收端通告的MSS，也不能大于路径MTU）</li><li>当TCP超时重传，它并不需要完全重传相同的报文段</li><li>解决了重传二义性问题</li></ul><h2 id="二、TCP数据流与窗口管理"><a href="#二、TCP数据流与窗口管理" class="headerlink" title="二、TCP数据流与窗口管理"></a>二、TCP数据流与窗口管理</h2><h3 id="交互式通信"><a href="#交互式通信" class="headerlink" title="交互式通信"></a>交互式通信</h3><ul><li>TCP流量中通常90%或者更多的TCP报文段都包含大批量数据（如Web、文件共享、电子邮件、备份），其余部分则包含交互式数据（如远程登陆、网络游戏），批量数据通常较大，而交互式数据段则会比较小</li><li>对于一个ssh连接，客户端对其传输数据加密，意味着用户输入的信息在通过连接传送前已经进行了加密</li><li>每一个交互按键通常都会生成一个单独的数据包，每个按键是独立传输的（每次一个字符而非每次一行）</li><li>每个输入字符会生成4个TCP数据段：客户端的交互击键输入、服务器对击键的确认、服务器端生成的回显、客户端对该回显的确认<ul><li>通常第二段和第三段可以合并，可将对击键的确认与回显一并传送，这种方法称为（捎带延时确认）</li></ul></li></ul><h3 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h3><ul><li>TCP并不对每个到来的数据包都返回ACK<ul><li>利用TCP的累计ACK字段就能实现该功能</li></ul></li><li>捎带传输：<ul><li>累计确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传输的数据结合发送</li></ul></li><li>TCP不能任意时长地延迟ACK，否则对方会误认以为数据丢失而出现不必要的重传</li><li>RFC指出：TCP实现ACK延迟的时延应小于500ms，实践中时延最大取200ms</li></ul><h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><ul><li>当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据），小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送</li><li>ACK返回越快，数据传输越快</li><li>传输包数目更少而长度更大，但同时传输时延也更长</li><li>Nagle算法结合ACK可能会导致某种程度的死锁（这种死锁不是永久的）</li><li>要求延时尽量小的应用，建议禁用Nagle算法<ul><li>TCP_NODELAY选项可以禁用Nagle算法</li></ul></li></ul><h3 id="流量控制与窗口管理"><a href="#流量控制与窗口管理" class="headerlink" title="流量控制与窗口管理"></a>流量控制与窗口管理</h3><ul><li>每一个TCP报文段（除了建立之初的包交换）都包含一个有效的序列号字段、一个ACK号或确认字段以及一个窗口大小字段（包含窗口通告信息）</li><li>窗口通告：表示发送该窗口信息的通信方为即将到来的新数据预留的存储空间</li><li>窗口大小：表明接收端可用缓存空间的大小</li><li>滑动窗口<ul><li>每个TCP活动连接的两端都维护一个发送窗口结构和接收窗口结构</li><li>TCP以字节（而非包）为单位维护其窗口结构</li><li>窗口左右边界的运动<ul><li>1.关闭<ul><li>即窗口左边界右移。当已发送数据得到ACK确认时，窗口会减小</li></ul></li><li>2.打开<ul><li>即窗口右边界右移。使得可发送数据量增大。当已确认数据得到处理，接收端可用缓存变大，窗口也随之变大</li></ul></li><li>3.收缩<ul><li>即窗口右边界左移</li></ul></li></ul></li></ul></li><li>零窗口与TCP持续计时器<ul><li>零窗口：左右边界相等</li><li>当接收端的通告窗口值为0时，可以有效阻止发送端继续发送，直至窗口大小恢复为非零值</li><li>当接收端重新获得可用空间时，会给发送端传输一个”窗口更新“告知其可以继续发送数据<ul><li>该窗口更新通常不包含数据（纯ACK），不能保证其传输的可靠性，容易丢包，造成死锁的发生（发送方等待收到窗口更新告知其可继续发送，接收方等待接收数据）<ul><li>解决方案：发送端会采用一个持续计时器间歇性地查询接收端，看其窗口是否已增长</li></ul></li></ul></li><li>TCP持续计时器会触发”窗口探测“的传输，强制要求接收端返回ACK（其中包含了窗口大小字段）</li><li>窗口探测包含一个字节的数据，采用TCP可靠传输（丢失重传），因此可以避免由窗口更新丢失导致的死锁<ul><li>该一个字节的数据能否被接收，取决于接收端的可用缓存空间大小</li></ul></li><li>当TCP持续计时器超时，就会触发窗口探测的发送</li><li>窗口探测的响应条件：<ul><li>至少为一个MSS</li><li>超过总接收缓存的四分之一</li></ul></li><li>可以采用指数时间退避来计算持续计时器的超时</li></ul></li><li>糊涂窗口综合征（SWS）<ul><li>基于窗口的流量控制机制，尤其是不使用大小固定的报文段情况（如TCP），可能会出现SWS</li><li>当出现该问题时，交换数据段不是全长的而是一些较小的数据段，由于每个报文段中有用数据相对头部信息的比例较小，因此耗费的资源也更多，相应的传输效率也更低</li><li>避免SWS问题<ul><li>1.对于接收端来说，不应通告小的窗口值</li><li>2.对于发送端来说，不应发送小的报文段</li><li>为了避免SWS问题，至少满足以下条件之一时才能传输报文段（发送窗口更新）<ul><li>（a）全长（发送MSS字节）的报文段可以发送</li><li>（b）数据段长度 &gt;= 接收端通告过的最大窗口的一半的，可以发送</li><li>（c）满足以下任一条件的都可以发送：<ul><li>（i）某一ACK不是目前期盼的（即没有未经确认的在传数据）</li><li>（ii）该连接禁用Nagle算法</li></ul></li></ul></li></ul></li><li>TCP需要避免窗口收缩</li><li>优先级：避免窗口收缩 &gt; 避免SWS</li></ul></li><li>大容量缓存与自动调优<ul><li>使用较小接收缓存的TCP应用的吞吐性能更差</li><li>自动调优<ul><li>高效地自动分配缓存大小</li><li>窗口值随着接收数据的增多而增大</li></ul></li></ul></li><li>紧急机制<ul><li>紧急指针字段被设置后，发送端生成的每个TCP头部都包含该字段</li><li>所有序列号大于紧急指针的数据都经接收端确认</li></ul></li></ul><h2 id="三、TCP拥塞控制"><a href="#三、TCP拥塞控制" class="headerlink" title="三、TCP拥塞控制"></a>三、TCP拥塞控制</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><ul><li>TCP拥塞控制的难点在于怎样准确地判断何时需要减缓且如何减缓TCP传输，以及何时恢复其原有速度</li><li>当网络中大量的发送方和接收方被要求承担超负荷的通信任务时，可以考虑采取(降低发送速率)或者(最终丢弃部分数据)的方法</li><li>拥塞<ul><li>路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象</li></ul></li></ul><h3 id="TCP拥塞检测"><a href="#TCP拥塞检测" class="headerlink" title="TCP拥塞检测"></a>TCP拥塞检测</h3><ul><li>针对丢包情况，TCP采取的首要机制是重传<ul><li>超时重传</li><li>快速重传</li></ul></li><li>丢包被用作判断拥塞发生与否的值标</li><li>在有线网络中，出现在路由器或交换机中的拥塞是造成丢包的主要原因</li><li>在无线网络中，传输和接收错误是导致丢包的重要因素</li></ul><h3 id="减缓TCP发送"><a href="#减缓TCP发送" class="headerlink" title="减缓TCP发送"></a>减缓TCP发送</h3><ul><li>TCP头部设置的通知窗口大小字段，是TCP发送方调节发送速率的依据</li><li>TCP发送端发送速率 = min{接收速率，传输速率}</li><li>拥塞窗口（cwnd）<ul><li>反映网络传输能力的变量</li></ul></li><li>发送端实际可用窗口W = min{cwnd，通知窗口(awnd)}</li><li>在外数据值<ul><li>已经发出但还未经确认的数据量大小</li><li>当TCP不使用选择确认机制时，W的限制作用体现为发送方发送的报文段序列号不能大于ACK号的最大值与W之和</li><li>当TCP使用选择确认机制时，W用来限制在外数据值</li></ul></li><li>带宽延迟积（BDP）也称作最佳窗口大小<ul><li>若在传输数据值远高于BDP时，会引入不必要的延时</li></ul></li></ul><h3 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h3><ul><li>TCP通过与接收端交换一个数据包来获得awnd的值</li><li>获得cwnd最佳值的唯一方法是以越来越快的速率不断发送数据，直到出现数据包丢失（或网络拥塞）为止</li><li>拥塞控制操作是由ACK的接收来驱动或“控制”的</li><li>接收到ACK回复表明发送的数据包已被成功接收，因此可以继续发送操作</li><li>自同步<ul><li>由一个ACK到达（称作ACK时钟）触发一个新数据包传输的关系</li></ul></li><li>在稳定传输状态下，整个系统可“自同步”控制</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ul><li>当一个新的TCP连接建立或检测到由重传超时（RTO）导致的丢包时，需执行慢启动</li><li>TCP发送端长时间处于空闲状态也可能调用慢启动算法<ul><li>在这种情况下cwnd初始值将被设置为重启窗口（RW），RW = min（IW，cwnd）</li></ul></li><li>慢启动的目的<ul><li>使TCP在用拥塞避免探寻更多可用宽带之前得到cwnd值，以帮助TCP建立ACK时钟</li></ul></li><li>慢启动算法防止短时间内大量数据注入导致拥塞</li><li>TCP以发送一定数目的数据段开始慢启动（在SYN交换之后），称为初始窗口（IW）</li><li>SMSS = min（接收方MSS，MTU）</li><li>慢启动算法会以min（N，SMSS）来增加cwnd值，N是指在未经确认的传输数据中能通过这一”新接收的ACK号大于之前收到的ACK号“确认的字节数</li><li>快速ACK模式<ul><li>TCP操作只在慢启动阶段完成后才返回ACK</li></ul></li></ul><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul><li>在慢启动阶段，cwnd会快速增长，帮助确立一个慢启动阈值，一旦达到阈值，就意味着可能有更多可用的传输资源。如果立即全部占用这些资源，将会使共享路由器队列的其他连接出现严重的丢包和重传情况，从而导致整个网络性能不稳定</li><li>一旦确立慢启动阈值，TCP会进入拥塞避免阶段</li><li>拥塞避免阶段窗口随时间线性增长，而慢启动阶段呈指数增长<ul><li>cwnd1 = cwnd0+（1/k）*SMSS</li></ul></li></ul><h3 id="慢启动和拥塞避免的选择"><a href="#慢启动和拥塞避免的选择" class="headerlink" title="慢启动和拥塞避免的选择"></a>慢启动和拥塞避免的选择</h3><ul><li>某个TCP连接总是选择运行慢启动和拥塞避免中的一个，不会出现两者同时运行的情况</li><li>当cwnd&lt;ssthresh，使用慢启动算法</li><li>当cwnd&gt;ssthresh，使用拥塞避免</li><li>当cwnd=ssthresh，任何一种算法都可以使用</li><li>慢启动阈值ssthresh不是固定的，是随时间改变的</li><li>慢启动阈值的主要目的是，在没有丢包发生的情况下，记住上一次”最好的“操作窗口估计值</li><li>ssthresh = max（在外数据值/2，2*SMSS）</li><li>如果出现重传情况，慢启动阈值减小至当前窗口大小的一般（但不小于2*SMSS）</li></ul><h3 id="标准TCP"><a href="#标准TCP" class="headerlink" title="标准TCP"></a>标准TCP</h3><ul><li>当接收到一个好的ACK（表明新的数据传输成功）cwnd会相应更新<ul><li>cwnd += SMSS 慢启动</li><li>cwnd += SMSS*SMSS/cwnd 拥塞避免</li></ul></li><li>当收到三次重复ACK（或其他表明需要快速重传的信号）时，会执行以下行为<ul><li>1.ssthresh更新为大于等式ssthresh = min（在外数据值/2，2*SMSS）的值</li><li>2.启用快速重传算法，将cwnd设为（ssthresh+3*SMSS）</li><li>3.每接收一个重复ACK，cwnd值暂时增加1 SMSS</li><li>4.当接收到一个好的ACK，将cwnd重设为ssthresh</li></ul></li></ul><h3 id="转发确认（FACK）和速率减半"><a href="#转发确认（FACK）和速率减半" class="headerlink" title="转发确认（FACK）和速率减半"></a>转发确认（FACK）和速率减半</h3><ul><li>为避免出现等待空闲而又不违背将拥塞窗口减半的做法，提出了转发确认（FACK）策略</li><li>带界定参数的速率减半（RHBP）<ul><li>基本操作：在一个RTT时间内，每接收两个重复ACK，TCP发送方可发送一个新的数据包</li><li>RHBP中区分了调整间隔（cwnd的修正阶段）和恢复间隔（数据重传阶段）</li></ul></li><li>速率减半是调节发送操作或避免集中发送的方法</li></ul><h3 id="限制传输"><a href="#限制传输" class="headerlink" title="限制传输"></a>限制传输</h3><ul><li>TCP发送方每接收两个连续的重复ACK，就能发送一个新数据包</li><li>TCP因此可以避免长时间等待RTO而导致吞吐性能下降</li><li>速率减半也是限制传输的一种形式<h3 id="拥塞窗口校验（CWV）"><a href="#拥塞窗口校验（CWV）" class="headerlink" title="拥塞窗口校验（CWV）"></a>拥塞窗口校验（CWV）</h3></li><li>在发送长时间暂停的情况下，由ssthresh维护cwnd保存的”记忆”，之后cwnd值会衰减。</li><li>需要区分空闲发送端和应用受限发送端</li><li>CWV算法原理：当需要发送新数据时，首先看距离上次发送操作是否超过一个RTO，如果超过则<ul><li>更新ssthresh值，设为max（ssthresh，（3/4）*cwnd）</li><li>每经一个空闲RTT时间，cwnd值就减半，但不小于1 SMSS</li><li>对应用受限阶段<ul><li>已使用的窗口大小为W_used</li><li>更新ssthresh的值，设为max（ssthresh，（3/4）*cwnd）</li><li>cwnd设置为cwnd和W_used的平均值</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C# Note</title>
      <link href="/2021/04/28/c#%20Note/"/>
      <url>/2021/04/28/c#%20Note/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li>表达式主体方法<ul><li>=&gt;操作符引用构成方法主体的表达式，而且没有return语句。表达式的值自动作为返回值；如果表达式不返回值，则方法自动为void方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResult</span>(<span class="params"><span class="built_in">int</span> answer</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>差值表达式<ul><li>$符号表明这是个差值字符串，{和}之间的任何表达式都需求值并置换，字符串差值比+操作符高效得多  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$&quot;The answer is <span class="subst">&#123;answer&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>只有<code>float</code>和<code>double</code>除以0得到<code>Infinity</code>（不会出错）</li><li><code>int</code>的最大最小值<code>int.MaxValue</code>和<code>int.MinValue</code></li><li>隐式类型变量<code>var</code>,作用类似于C++的<code>auto</code></li></ul><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><ul><li>与C++不一致<br>  -<code>if</code>语句中表达式必须是布尔值, 如：<code>if (1)</code> // 错误</li><li><code>switch</code>语句的控制表达式不能用<code>float</code>和<code>double</code>类型</li><li><code>case</code>标签必须是常量表达式，且必须唯一</li><li>C#语句的直通规则<ul><li>直通，标签之间不能有额外语句（即不加<code>break</code>，不允许拥有语句）</li><li>每个<code>case</code>都加上<code>break</code></li></ul></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>C#所有方法都必须在类的内部声明</li><li>默认参数中如果参数匹配则不会出现歧义</li><li>默认参数（可选参数）必须放在后面</li><li>具名参数<ul><li><code>optMethod(first: 99, third: &quot;Word&quot;);</code>  // 传递具名参数（参数名:传递的值），实参可以按任意顺序传递，second参数使用<code>默认值</code></li></ul></li></ul><h2 id="结构（结构体）"><a href="#结构（结构体）" class="headerlink" title="结构（结构体）"></a>结构（结构体）</h2><ul><li>与C++不一致，结构主体后不加<code>;</code></li><li>值类型<ul><li>对于简单的、比较小的数据值，复制值的效率等同于或基本等同于复制地址的效率，但较复杂的数据就考虑使用类，这样就可选择只复制数据的地址，从而提高代码的执行效率</li></ul></li><li>不能为结构声明默认构造器（无参构造器），否则无法编译，因为编译器始终会自动生成默认构造器（不同于类）</li><li>类的实例字段可在声明时初始化，但结构不允许  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Time</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> hours = <span class="number">0</span>;  <span class="comment">// 编译时错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译器不会自动初始化结构中的字段（与类不一致）</li><li>复制结构变量的前提时<code>=</code>操作符右侧的结构变量已完全初始化，否则编译错误</li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li>与C++不一致，枚举主体后不加<code>;</code></li><li>值类型</li><li>声明枚举时字面值默认是int类型，可以选择枚举的基础类型<ul><li><code>enum Season : short &#123; Spring, Summer &#125;</code></li></ul></li><li>为枚举的字面值显式指定常量整数值<ul><li><code>enum Season &#123; Spring = 1, Summer &#125;</code></li></ul></li><li>编译器自动为它指定比前一个枚举字面值大1的值</li><li>多个枚举字面值可以具有相同的基础值<ul><li><code>enum Season &#123; Spring, Summer, Fall, Autumn = Fall &#125;</code></li></ul></li><li>每个枚举定义的字面值名称都只有这个枚举类型的作用域，因此要加枚举类型限定，否则编译错误，如：Season.Fall</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p>与c++不一致，类主体、结构主体后不加分号</p></li><li><p>每个字段和方法声明都要重复<code>public</code>或<code>private</code>关键字</p></li><li><p>省略控制可访问性，默认为<code>private</code></p></li><li><p>类被拆分到多个文件中之后，要在每个文件中使用<code>partial</code>（分部）关键字定义类的不同部分</p></li><li><p>如果把方法或字段声明为<code>static</code>，就可使用类名调用方法或访问字段，而不用先创建对象</p></li><li><p>静态方法只能访问标记为<code>static</code>的其他方法和字段</p></li><li><p>类外访问类中的<code>static</code>字段要以，类名作为前缀，<code>class.function</code></p></li><li><p>静态方法也称为类方法</p></li><li><p>静态字段称为静态字段或静态变量</p></li><li><p>只有数值类型、字符串类型和枚举类型的字段才能声明为const字段</p></li><li><p>静态类</p><ul><li>只能包含静态成员</li><li><code>public static class Math</code></li></ul></li><li><p>using语句允许将类引入作用域，以便在访问静态成员时省略类名</p><ul><li><code>using static System.Math;</code></li></ul></li><li><p>匿名类</p><ul><li>匿名类就是没有名字的类</li><li>不知道类的名称可以使用隐式类型变量来创建正确类型的对象  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAnonymousObject = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">47</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>值类型</p><ul><li>基元类型</li></ul></li><li><p>引用类型</p><ul><li><code>string</code>在运行时动态分配内存</li><li>声明类变量时，编译器分配一小块内存，其中刚好可以容纳一个地址。以后类实际占用内存块的地址会填充到这里。该地址成为对内存块的引用</li><li>实际占用的内存<ul><li>使用<code>new</code>关键字创建对象时分配的内存</li></ul></li></ul></li><li><p>引用类型的变量包含的是引用，引用本身存储在栈上，但该引用指向堆上的对象</p></li><li><p>类可以提供clone方法来返回自己的新实例，并填充相同数据</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Circle <span class="title">Clone</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Circle clone = <span class="keyword">new</span> Circle();</span><br><span class="line">    clone.radius = <span class="keyword">this</span>.radius;</span><br><span class="line">    <span class="comment">// 返回包含克隆数据的新Circle对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果包含任何引用类型的字段，这种引用类型也需要提供Clone方法，否则只是“浅拷贝”，如果提供了Clone方法，能够复制引用的对象，就成为“深拷贝”</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle(<span class="number">42</span>);</span><br><span class="line">Circle copy = <span class="keyword">new</span> Circle(<span class="number">99</span>);</span><br><span class="line">copy = c;</span><br></pre></td></tr></table></figure></li><li><p>这时候copy原来的引用被回收了（垃圾回收机制）</p></li></ul></li><li><p>空条件操作符（问号加在变量名称之后）</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(c?.Area());</span><br></pre></td></tr></table></figure><ul><li>空条件操作符告诉”运行时“在操作符所应用的变量为null的前提下忽略当前语句</li></ul></li><li><p>可空类型</p><ul><li><code>null</code>本身就是引用，不能把它赋值给值类型</li><li>可将变量声明为可空值类型<ul><li><code>int? i = null;</code></li></ul></li><li>可将恰当值的表达式直接赋给可空变量<ul><li><code>i = j;</code></li></ul></li><li>不可将可空的值赋给普通的值类型变量<ul><li><code>j = i;</code></li></ul></li><li>可空类型的两个属性<ul><li><code>HasValue</code><ul><li>判断可空类型是包含一个值，还是包含null</li></ul></li><li><code>Value</code><ul><li>只读的属性</li><li>读取变量的值，但不能修改</li></ul></li></ul></li></ul></li><li><p>引用传参</p><ul><li><code>ref</code>参数<ul><li>要求实参和形参前都加上<code>ref</code>关键字<ul><li><code>DoWork(ref i)</code>;</li></ul></li><li>要求在传参之前必须初始化</li></ul></li><li><code>out</code>参数<ul><li>要求实参和形参前都加上<code>out</code>关键字</li><li>要求在方法中必须初始化，传参前不要求</li></ul></li></ul></li><li><p><code>object</code>类型</p><ul><li><code>object</code>类型的变量能引用任何引用类型的任何对象</li></ul></li><li><p><code>装箱</code></p><ul><li>将值类型赋给<code>object</code>类型的变量<ul><li><code>object o = 42;</code></li></ul></li><li>数据项从栈自动复制到堆的行为</li><li>与泛型异曲同工</li></ul></li><li><p><code>拆箱</code></p><ul><li>将引用了已装箱的值的object引用强制转换成值类型<ul><li><code>int a = (int)o;</code></li></ul></li><li>必须强制转换</li></ul></li><li><p>装箱和拆箱会产生较大的开销</p><ul><li>它们设计不少检查工作，且需要分配额外的堆内存</li></ul></li><li><p>数据的安全转型</p><ul><li>左操作数为对象，右操作数为类型<ul><li>is操作符<ul><li>if (o is WrappedInt)</li><li>如果is表达式正确，结果为true，反之为false</li></ul></li><li>as操作符<ul><li>WrappedInt temp = o as WrappedInt;</li><li>若转换成功，就返回转换成功的结果，失败则为null</li></ul></li></ul></li></ul></li><li><p>在c#中使用c指针必须将代码标记为<code>unsafe</code></p><ul><li><code>unsafe</code>关键字可标记代码块或整个方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">swap</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>命名规范</p></li><li><p>公共标识符以大写字母开头</p></li><li><p>非公共标识符（包括局部变量）以小写字母开头</p></li><li><p>类名以大写字母开头</p></li><li><p>均采用驼峰命名法</p></li><li><p><code>TODO:</code>注释通常用于标注以后将进行加工的代码</p></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><code>checked</code>语句是<code>checked</code>关键字开头的代码块<ul><li>只有直接在checked块中的整数运算才会检查</li><li>溢出则抛出<code>OverflowException</code></li><li><code>checked</code>和<code>unchecked</code>关键字只适合整型运算</li><li>浮点运算永不抛出异常</li></ul></li><li><code>catch</code>省略名称默认捕获<code>Exception</code><ul><li>异常发生后将运行由”运行时“发现的第一个匹配的异常处理程序<code>catch</code>，其他处理程序会被忽略</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link href="/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/04/28/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>打印出二叉树中节点值的和为输入整数的所有路径（从根节点一直到叶子节点的路径）<br><strong>输入</strong>：<br>给定如下二叉树，以及目标和 target = 22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><p>由根节点出发，首先想到先序遍历的思路</p><h3 id="2-1-回溯"><a href="#2-1-回溯" class="headerlink" title="2.1 回溯"></a>2.1 回溯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">      vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">      <span class="type">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">FindPath</span>(root, target, path, currentSum, ans);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; path, <span class="type">int</span> currentSum, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先序遍历</span></span><br><span class="line">      currentSum += root-&gt;val;  <span class="comment">// 更新当前路径</span></span><br><span class="line">      path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">      <span class="comment">// 如果是叶子节点，并且路径上的节点的和等于输入的值，则打印这条路径</span></span><br><span class="line">      <span class="type">bool</span> isLeaf = root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (currentSum == target &amp;&amp; isLeaf) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若不是叶子节点，则遍历它的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, target, path, currentSum, ans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在返回父节点之前，在路径上删除当前节点</span></span><br><span class="line">      path.<span class="built_in">pop_back</span>();  <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：O(N)，N为二叉树的节点数，需要遍历所有节点</li><li><strong>空间复杂度</strong>：O(N)，最差情况下即树退化成链表，path存储所有树节点，使用O(N)额外空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 684. 冗余连接</title>
      <link href="/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
      <url>/2021/04/28/leetcode%20684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>找出无向图中的冗余连接，即将无向图还原成二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure><h1 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h1><h3 id="2-1-并查集"><a href="#2-1-并查集" class="headerlink" title="2.1 并查集"></a>2.1 并查集</h3><p>思路：通过并查集寻找附加的边，初始时每个节点都属于不同的连通分量，遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量</p><ul><li>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</li><li>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[index]]); </span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      parent[<span class="built_in">Find</span>(parent, x)] = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(klogk)，其中k是图中的节点个数</li><li>空间复杂度：O(n)</li></ul><h3 id="2-2-使用-按秩合并-路径压缩-的并查集"><a href="#2-2-使用-按秩合并-路径压缩-的并查集" class="headerlink" title="2.2 使用==按秩合并+路径压缩==的并查集"></a>2.2 使用==按秩合并+路径压缩==的并查集</h3><p>优化了空间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> index)</span> </span>&#123;  <span class="comment">// 查找根节点</span></span><br><span class="line">      <span class="keyword">if</span> (index != parent[index])  <span class="comment">// 若当前节点不为根节点</span></span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[parent[index]]);  <span class="comment">// 路径压缩，使树的层数更少</span></span><br><span class="line">      <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 合并两个集合</span></span><br><span class="line">      <span class="type">int</span> i = <span class="built_in">Find</span>(parent, x), j = <span class="built_in">Find</span>(parent, y);</span><br><span class="line">      <span class="comment">// 按秩合并</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">// 如果i的秩大于j的秩</span></span><br><span class="line">        parent[j] = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[i] = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> size = edges.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(size + <span class="number">1</span>)</span></span>;  <span class="comment">// 为下列循环防止溢出</span></span><br><span class="line">      <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);  <span class="comment">// 0, 1, 2, 3...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">        <span class="type">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Find</span>(parent, u) != <span class="built_in">Find</span>(parent, v)) &#123;  <span class="comment">// 若两个集合的根节点不同</span></span><br><span class="line">          <span class="built_in">Union</span>(parent, u, v);  <span class="comment">// 则将它们连接起来</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> edge;  <span class="comment">// 返回合并的森林</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(klogk)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql Note</title>
      <link href="/2021/04/28/mysql%20note/"/>
      <url>/2021/04/28/mysql%20note/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul><li>表名是唯一的</li><li>表中的数据是按行存储的</li><li>行（别名 记录）</li><li>主键：一列，其值能够区分表中每个行<ul><li>每个行都必须有一个主键值（不允许为NULL）</li><li>任意两行都不具有相同的主键值</li><li>不更新主键列中的值</li><li>不在主键列中使用可能会更改的值</li></ul></li><li>命令用分号；结束</li><li>连接到mysql需要以下信息<ul><li>主机名：本地服务器为localhost</li><li>端口：默认为3036</li><li>一个合法的用户名</li><li>用户口令（如果需要的话）</li></ul></li><li><code>use&lt;数据库名字&gt;</code>来选择数据库</li><li><code>show databases</code>返回可用数据库的一个列表</li><li><code>show tables</code>返回该数据库内的可用表的一个列表</li><li><code>show columns from &lt;表名&gt;</code> = <code>describe &lt;表名&gt;</code>来显示表中的所有列</li><li>自动增量：Mysql可以自动地为每个行分配下一个可用的编号，需要create语句</li><li><code>show status</code>显示广泛的服务器状态信息</li><li><code>show create databases/table</code>分别用来显示创建特定数据库或表的语句</li><li><code>show grants</code>显示授予用户的安全权限</li><li><code>show errors</code>和<code>show warnings</code>显示服务器错误或警告信息</li></ul><h2 id="二、SELECT语句"><a href="#二、SELECT语句" class="headerlink" title="二、SELECT语句"></a>二、SELECT语句</h2><ul><li><code>SELECT &lt;列名&gt; FROM &lt;表名&gt;</code>在表中检索单个列<blockquote><p>SELECT检索多个列，列名用逗号分隔<br>检索所有列，用<code>*</code>通配符</p></blockquote></li><li>sql语句不区分大小写</li><li>SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写</li><li>处理SQL语句空格会被忽略</li><li><code>SELECT DISTINCT ... FROM</code>返回不重复的行（distinct要放在列名前面）</li><li>使用完全限定的表名<code>SELECT db.host FROM mysql.db</code></li><li><code>FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT</code>是<code>SELECT</code>的子句，其出现次序必须为上述顺序，次序不对将产生错误信息</li><li><code>ORDER BY</code>子句取一个或多个列的名字对输出进行排序<blockquote><p>默认为asc升序，在列名后加<code>DESC</code>关键字按降序排列，desc关键字只应用到直接位于其前面的列名</p></blockquote></li><li><code>GROUP BY</code>子句，分组允许把数据分为多个逻辑组</li><li><code>HAVING</code>和<code>WHERE</code>的区别：<code>HAVING</code>过滤分组，<code>WHERE</code>过滤行</li><li><code>WHERE</code>是<code>SELECT</code>的子句（在from子句之后给出）用来指定搜索条件</li><li><strong>WHERE子句操作符</strong></li></ul><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">不等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在指定的两个值之间</td></tr></tbody></table><ul><li>空值检查(<code>is NULL</code>子句)<code>where...is NULL;</code></li><li><code>WHERE</code>子句给出了<code>AND, OR, IN, NOT</code>逻辑操作符来进行逻辑操作</li></ul><h2 id="三、匹配"><a href="#三、匹配" class="headerlink" title="三、匹配"></a>三、匹配</h2><ul><li>通配符本身实际是SQL的<code>WHERE</code>子句中有特殊含义的字符，在搜索子句中使用通配符，必须使用<code>LIKE</code>操作符，<code>LIKE</code>只是Mysql后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较</li><li>百分号<code>%</code>通配符匹配任意个数的任意字符，下划线<code>_</code>通配符匹配任意单个字符</li><li>使用通配符的技巧<ul><li>不要过度使用通配符</li><li>把通配符置于搜索模式的开始处搜索起来是最慢的</li></ul></li><li><code>WHERE</code>的子句中<code>REGEXP</code>子句使用正则表达式，在<code>REGEXP</code>关键字后加上<code>BINARY</code>来区分匹配表达式的大小写<br>例：      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Db, User FROM db </span><br><span class="line">WHERE Db REGEXP BINARY &#x27;.ys&#x27;;</span><br></pre></td></tr></table></figure></li><li>匹配正则表达式内具有特殊意义的所有字符都必须以\\的方式转义</li></ul><p><strong>常用字符类</strong></p><table><thead><tr><th align="center">类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">任意字母和数字（同[a-zA-Z0-9])</td></tr><tr><td align="center">[:alpha:]</td><td align="center">任意字符（同[a-zA-Z]）</td></tr><tr><td align="center">[:blank:]</td><td align="center">空格和制表</td></tr><tr><td align="center">[:cntrl:]</td><td align="center">ASCII控制字符</td></tr><tr><td align="center">[:digit:]</td><td align="center">任意数字</td></tr><tr><td align="center">[:graph:]</td><td align="center">与[:print:]相同，但不包括空格</td></tr><tr><td align="center">[:lower:]</td><td align="center">任意小写字母</td></tr><tr><td align="center">[:print:]</td><td align="center">任意可打印字符</td></tr><tr><td align="center">[:space:]</td><td align="center">任意空白字符</td></tr><tr><td align="center">[:upper:]</td><td align="center">任意大写字母</td></tr><tr><td align="center">[:xdigit:]</td><td align="center">任意十六进制数</td></tr></tbody></table><p><strong>重复元字符</strong></p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>0个或多个匹配</td></tr><tr><td>+</td><td>1个或多个匹配（等于{1,}）</td></tr><tr><td>?</td><td>0个或1个匹配（等于{0,1}）</td></tr><tr><td>{n}</td><td>指定数目的匹配</td></tr><tr><td>{n,}</td><td>不少于指定数目的匹配</td></tr><tr><td>{n,m}</td><td>匹配数目的范围</td></tr></tbody></table><p><strong>定位元字符</strong></p><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">文本的开始</td></tr><tr><td align="center">$</td><td align="center">文本的结束</td></tr><tr><td align="center">[[:&lt;:]]</td><td align="center">词的开始</td></tr><tr><td align="center">[[:&gt;:]]</td><td align="center">词的结束</td></tr></tbody></table><ul><li>正则表达式中<code>.</code>表示匹配任意一个字符</li><li><code>LIKE</code>与<code>REGEXP</code>的区别，<code>LIKE</code>匹配整个串，<code>REGEXP</code>匹配子串</li><li>简单的正则表达式测试，例：<code>SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;</code></li><li><code>SELECT</code>语句中，<code>concat()</code>函数用来拼接字段（与列的意思相同），别名用<code>AS</code>关键字赋予，<code>RTrim()</code>函数去掉右边的所有空格<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat(Db, &#x27;(&#x27;, User, &#x27;)&#x27;) AS link</span><br><span class="line">FROM db;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、相关函数"><a href="#四、相关函数" class="headerlink" title="四、相关函数"></a>四、相关函数</h2><ul><li><code>Soundex()</code>函数匹配所有发音类似与Y.Lie的联系名<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE Soundex(cust_contact) = Soundex(&#x27;Y. Lie&#x27;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>常用数值处理函数</strong></p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Abs()</td><td align="center">返回一个数的绝对值</td></tr><tr><td align="center">Cos()</td><td align="center">返回一个角度的余弦</td></tr><tr><td align="center">Exp()</td><td align="center">返回一个数的指数值</td></tr><tr><td align="center">Mod()</td><td align="center">返回余数</td></tr><tr><td align="center">Pi()</td><td align="center">返回圆周率</td></tr><tr><td align="center">Rand()</td><td align="center">返回一个随机数</td></tr><tr><td align="center">Sin()</td><td align="center">返回一个角度的正弦</td></tr><tr><td align="center">Sqrt()</td><td align="center">返回一个角度的平方根</td></tr><tr><td align="center">Tan()</td><td align="center">返回一个角度的正切</td></tr></tbody></table><p><strong>常用时间和日期处理函数</strong></p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">AddDate()</td><td align="center">增加一个日期（天、周等)</td></tr><tr><td align="center">AddTime()</td><td align="center">增加一个时间（时、分等）</td></tr><tr><td align="center">CurDate()</td><td align="center">返回当前日期</td></tr><tr><td align="center">Date()</td><td align="center">返回日期时间的日期部分</td></tr><tr><td align="center">DateDiff()</td><td align="center">计算两个日期之差</td></tr><tr><td align="center">Date_add()</td><td align="center">高度灵活的日期运算函数</td></tr><tr><td align="center">Date_Format()</td><td align="center">返回格式化的日期或时间率</td></tr><tr><td align="center">Day()</td><td align="center">返回一个日期的天数部分</td></tr><tr><td align="center">DayOfWeek()</td><td align="center">对于一个日期，返回对应的星期</td></tr><tr><td align="center">Hour()</td><td align="center">返回一个日期的小时部分</td></tr><tr><td align="center">Minute()</td><td align="center">返回一个日期的分钟部分</td></tr><tr><td align="center">Month()</td><td align="center">返回一个日期的月份</td></tr><tr><td align="center">Now()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">Second()</td><td align="center">返回一个时间的秒部分</td></tr><tr><td align="center">Time()</td><td align="center">返回一个日期时间的时间部分</td></tr><tr><td align="center">Year()</td><td align="center">返回一个日期的年份部分</td></tr></tbody></table><ul><li>子查询，嵌套<code>SELECT</code>语句<br>例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE prod_id = &#x27;TNT2&#x27;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、联结表"><a href="#五、联结表" class="headerlink" title="五、联结表"></a>五、联结表</h2><ul><li><code>WHERE</code>子句在联结表中起配对的作用（用完全限定列名）</li><li>没有联结条件的表关系返回的结果为笛卡尔积（检索出的行的数目将是第一个表中的行数乘以第二个表中的行数）</li><li>应保证所有联结都有<code>WHERE</code>子句</li><li>使用在<code>WHERE</code>子句中使用<code>AND</code>可以联结多个表</li><li>等值连接也称为内部联结</li><li>尽量使用自联结而不用子查询</li><li><strong>联结的方式</strong><br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20210428125629111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2ODAyNzEz,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="联结"></li><li>外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系</li><li>外键的意义：在于解耦合，定义外键的方法<code>FOREIGN KEY (主键）references &lt;表名&gt;(另一个表的主键）</code></li></ul><h2 id="六、组合查询"><a href="#六、组合查询" class="headerlink" title="六、组合查询"></a>六、组合查询</h2><ul><li>组合查询，必须由两条<code>SELECT</code>语句组成，语句之间用<code>UNION</code>关键字分隔</li><li><code>UNION</code>的每个查询必须包含相同的列，表达式或聚集函数</li><li>使用<code>UNION</code>时重复的行会被自动取消（默认行为），若想返回所有的匹配行可以用<code>UNION ALL</code></li><li>在使用<code>UNION</code>组合查询时，只能使用一次<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后</li></ul><h2 id="七、全文本搜索"><a href="#七、全文本搜索" class="headerlink" title="七、全文本搜索"></a>七、全文本搜索</h2><ul><li>全文本搜索会对结果排序，具有较高优先等级（文本中靠前的等级高）的行先返回，搜索默认不区分大小写</li><li>在创建表时跟句子句<code>Fulltext(列名)</code>对它进行索引，函数<code>Match()</code>指定被搜索的列，函数<code>Against()</code>指定要使用的搜索表达式，搭配<code>WHERE</code>子句进行筛选</li><li>使用查询扩展<code>Against(&#39;anvils&#39; WITH QUERY EXPANSION)</code>，找出和搜索相关的其他行</li></ul><h2 id="八、操作数据"><a href="#八、操作数据" class="headerlink" title="八、操作数据"></a>八、操作数据</h2><ul><li><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><ul><li><code>INSERT INTO &lt;表名&gt; (需要插入值的列名) values (给每个列提供一个值)</code></li><li>没有列出的值默认为NULL</li><li><code>INSERT INTO</code>搭配<code>SELECT</code>可以从旧表复制数据到新表</li></ul></li><li><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><ul><li><code>UPDATE &lt;表名&gt; SET 列=值</code></li><li>要更新的表</li><li>列名和他们的新值</li><li>确定要更新行的过滤条件</li></ul></li><li><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li><code>DELETE FROM &lt;表名&gt; WHERE 匹配的列</code></li><li>删除表中所有行<code>TRUNCATE TABLE</code>语句</li></ul></li><li><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul><li><code>CREATE TABLE &lt;表名&gt;(行及相应值)</code></li><li>表的主键可以在创建表时用<code>PRIMARY KEY</code>关键字指定，主键值必须唯一，多个主键使用<code>,</code>分割</li><li>若仅想在一个表不存在时创建它，应该在表名后给出<code>if not exists</code></li><li>指定<code>not null</code>时在插入或更新行时，该列必须有值</li><li><code>AUTO_INCREMENT</code>告诉mysql每当增加一行时自动增量</li><li>每个表只允许一个<code>AUTO_INCREMENT</code>列</li></ul></li><li><h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><ul><li><code>ALTER TABLE &lt;表名&gt; ADD &lt;列&gt; 列的数据类型</code></li></ul></li><li><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><ul><li><code>DROP TABLE &lt;表名&gt;</code></li></ul></li><li><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><ul><li><code>RENAME TABLE &lt;表名&gt; to &lt;重命名的表名&gt;</code> </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lua Note</title>
      <link href="/2021/04/28/Lua%20Note/"/>
      <url>/2021/04/28/Lua%20Note/</url>
      
        <content type="html"><![CDATA[<h2 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h2><ul><li><code>lua -i</code>，<code>-i</code>参数用于在运行完其他命令行参数后进入交互模式</li><li>不在交互模式下必须把表达式包在函数<code>print</code>的调用中</li><li>如果不想输出结果，可以在行末加上一个<code>;</code></li></ul><h2 id="词法规范"><a href="#词法规范" class="headerlink" title="词法规范"></a>词法规范</h2><ul><li><p>标识符由任意字母、数字和下划线组成的字符串（不能以数字开头）</p></li><li><p><code>_</code>+大写字母（特殊用途）</p></li><li><p><code>_</code>+小写字母（哑变量）</p></li><li><p>注释</p><ul><li>单行注释<code>--</code></li><li>多行注释<br>  <code>--[[   多行注释 ]]</code></li></ul></li><li><p>分隔符<code>;</code></p><ul><li>增加可读性，不是必须的</li></ul></li><li><p>表达式之间的换行不起任何作用</p></li></ul><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul><li>无须声明即可使用</li><li>使用未经初始化的全局变量，得到的结果时<code>nil</code></li><li><code>nil</code>赋值给全局变量时，Lua会回收该全局变量</li></ul><h2 id="类型和值"><a href="#类型和值" class="headerlink" title="类型和值"></a>类型和值</h2><ul><li><p>Lua语言有8种基本类型</p><ul><li><p><code>nil</code>（空）</p><ul><li>nil赋值给全局变量时，则相当于将其删除（Lua会回收）</li></ul></li><li><p><code>boolean</code>（布尔）</p><ul><li>除false和nil之外的所有值都为真（与C++差异）</li><li>not运算符永远返回boolean类型的值<ul><li><code>not nil</code>  – true</li><li><code>not false</code> – true</li></ul></li></ul></li><li><p><code>number</code>（数值）</p></li><li><p><code>string</code>（字符串）</p></li><li><p><code>userdata</code>（用户数据）</p><ul><li>允许把任意的C语言数据保存在Lua语言变量中</li></ul></li><li><p><code>function</code>（函数）</p></li><li><p><code>thread</code>（线程）</p></li><li><p><code>table</code>（表）</p></li></ul></li><li><p><code>type</code>函数</p><ul><li>获取一个值对应的类型</li><li>返回值永远是一个字符串</li></ul></li></ul><h2 id="独立解释器"><a href="#独立解释器" class="headerlink" title="独立解释器"></a>独立解释器</h2><ul><li><p>是一个可以直接使用Lua语言的小程序</p></li><li><p>源代码文件第一行以井号<code>#</code>开头，那么解释器在加载文件时会忽略这一行，主要是为了方便在POSIX系统中将Lua作为一种脚本解释器来使用</p></li><li><p>假设独立解释器位于<code>/usr/local/bin</code>下</p><ul><li><code>#!/usr/local/bin/lua</code> 或<br><code>#!/usr/bin/env lua</code><ul><li>不需要显式调用Lua语言解释器也可以直接运行Lua脚本</li></ul></li></ul></li><li><p>编译器在运行代码前会创建一个名为arg的表</p><ul><li>索引0中保存的内容为脚本名<ul><li><code>arg[0]</code></li></ul></li><li>索引1保存的内容为第一个参数<ul><li><code>arg[1]</code></li></ul></li><li>以此类推</li></ul></li><li><p>Lua语言也支持可变长参数(…)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PL </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
