<!DOCTYPE html>
<html>
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>MIT 6.S081 Lab3: Page tables | Moksha&#39;s Blog</title>

  
    
<link rel="stylesheet" href="/js/aos/aos.css">

  

  <link rel="icon" type="image/png" href="/puzzle_favicon.png">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    
<link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Moksha's Blog" type="application/atom+xml">
</head>

  <script src="/js/jquery3.5.1.js"></script>
  <script src="/js/vue2.6.11.js"></script>
  <link href="/js/danmu/barrager.css" rel="stylesheet">
<script src="/js/danmu/jquery.barrager.js"></script>
  <body>
    <!-- 判断是否为黑夜模式 -->
    <script>
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

      if (isDark) {
        $(document.body).addClass('darkModel');
      }
    </script>

    <header class="header bg-color" 
  style="position: fixed; 
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <i class="fa fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo" src="/medias/logo.jpg" alt="logo">
      <h3 class="drawer-box-head_title">Moksha&#39;s Blog</h3>
      <h5 class="drawer-box-head_desc">Opportunities are ready for it, the more to beat action.</h5>
    </div>
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
          <li class="drawer-box-content_item">
            <a href="/" class="menu-item-link">
              
                <i class="fa fa-home" aria-hidden="true"></i>
              
              <span>Home</span>
            </a>
          </li>
        
          <li class="drawer-box-content_item">
            <a href="/archives" class="menu-item-link">
              
                <i class="fa fa-home" aria-hidden="true"></i>
              
              <span>Archives</span>
            </a>
          </li>
        
          <li class="drawer-box-content_item">
            <a href="/categories" class="menu-item-link">
              
                <i class="fa fa-bookmark" aria-hidden="true"></i>
              
              <span>Categories</span>
            </a>
          </li>
        
          <li class="drawer-box-content_item">
            <a href="/friends" class="menu-item-link">
              
                <i class="fa fa-link" aria-hidden="true"></i>
              
              <span>link</span>
            </a>
          </li>
        
        <li class="drawer-box-content_item">
          <a target="_blank" rel="noopener" href="https://github.com/MITMOKSHA">
            <i class="fa fa-github" aria-hidden="true"></i>
            <span>Github</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%; position: fixed; top: -' + this.top  + 'px; left: 0; overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>
    </div>
    <div class="blog-title" id="author-avatar">
      <div class="avatar">
        <img src="/medias/logo.jpg" alt="logo">
      </div>
      <a href="/" class="logo">Moksha&#39;s Blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
          <li class="menu-item">
            <a href="/" class="menu-item-link">
              
                <i class="fa fa-home" aria-hidden="true"></i>
              
              <span>Home</span>
            </a>
          </li>
        
          <li class="menu-item">
            <a href="/archives" class="menu-item-link">
              
                <i class="fa fa-archive" aria-hidden="true"></i>
              
              <span>Archives</span>
            </a>
          </li>
        
          <li class="menu-item">
            <a href="/categories" class="menu-item-link">
              
                <i class="fa fa-bookmark" aria-hidden="true"></i>
              
              <span>Categories</span>
            </a>
          </li>
        
          <li class="menu-item">
            <a href="/friends" class="menu-item-link">
              
                <i class="fa fa-link" aria-hidden="true"></i>
              
              <span>link</span>
            </a>
          </li>
        
      </ul>
      
        <div class="dark">
  <div class="dark-content">
    <i class="fa fa-moon-o" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fa fa-lightbulb-o" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fa fa-moon-o" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fa fa-lightbulb-o" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
        
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fa fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <!-- <div class="close" style="overflow: hidden;">
          <i class="fa fa-close" aria-hidden="true" style="float:right;" @click.self="cancelDialogVisible()"></i>
        </div> -->
        <h2>
          <i class="fa fa-search" aria-hidden="true"></i>
          <span class="title">Search</span>
          <i class="fa fa-close close" style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="Please enter keywords"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
  <a target="_blank" rel="noopener" href="https://github.com/MITMOKSHA" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
</header>
    <main class="main" style="margin-top: 60px;">
      
 <!-- prismjs 代码高亮 -->
 

<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;" :style="{'background-color': bgColor ? bgColor : 'transparent'}">
    <transition-group tag="ul" :name="names">
        <li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
            <img :src="image" class="bg-swiper-img">
        </li>
    </transition-group>
</div>
<script>
    var vm = new Vue({
        el: '#appBgSwiper',
        data: {
            names: '' || 'fade' || 'fade', // translate-fade fade
            mark: 0,
            img: [],
            bgColor: '',
            time: null
        },
        methods: {   //添加方法
            change(i, m) {
                if (i > m) {
                    // this.names = 'fade';
                } else if (i < m) {
                    // this.names = 'fade';
                } else {
                    return;
                }
                this.mark = i;
            },
            prev() {
                // this.names = 'fade';
                this.mark--;
                if (this.mark === -1) {
                    this.mark = 3;
                    return
                }
            },
            next() {
                // this.names = 'fade';
                this.mark++;
                if (this.mark === this.img.length) {
                    this.mark = 0;
                    return
                }
            },
            autoPlay() {
                // this.names = 'fade';
                this.mark++;
                if (this.mark === this.img.length) {
                    this.mark = 0;
                    return
                }
            },
            play() {
                let bgImgDelay = '' || '180000'
                let delay = parseInt(bgImgDelay) || 180000;
                this.time = setInterval(this.autoPlay, delay);
            },
            enter() {
                clearInterval(this.time);
            },
            leave() {
                this.play();
            }
        },
        created() {
            this.play()
        },
        beforeDestroy() {
            clearInterval(this.time);
        },
        mounted() {
            let prop = ''|| '';
            let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://') 
            if (isImg) {
                let img = prop.split(',');
                let configRoot = '/'
                let arrImg = [];
                img.forEach(el => {
                    var Expression=/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
			        var objExp = new RegExp(Expression);

                    if(objExp.test(el)) {
                        // http or https
                        arrImg.push(el);
                    } else {
                        // 非http or https开头
                        // 本地文件
                        let firstStr = el.charAt(0);
                        if (firstStr == '/') {
                            el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
                        }
                        el = configRoot + el;
                        arrImg.push(el);
                    }
                })
                this.img = arrImg;
            } else {
                this.bgColor = prop;
            }
        }
    })
</script>

<style>
    .bg-swiper-box {
        position: absolute;
        display: block;
        width: 100%;
        height: 100%;
    }
    .bg-swiper-img {
        object-fit: cover;
        width: 100%;
        height: 100%;
    }
</style>




<div class="post-detail-header lazyload" id="thumbnail_canvas" data-original="/medias/17.jpg" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0"></canvas>
  
    <div class="title-box">
      
          <span class="title">
            MIT 6.S081 Lab3: Page tables
          </span>
        
    </div>
  
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>


<div class="row justify-position">
  <div class="main-content">
    <article class="post post-detail">
      
      
      <div class="post-meta">
        <i class="fa fa-clock-o" aria-hidden="true"></i>
        <span class="post-time">2022-05-16</span>
      </div>
      
      <div class="post-tags-categories">
        
        
        <div class="categories">
          <i class="iconfont iconbookmark1"></i>
          
            <a href="/categories/MIT-6-S081/" class="">
              MIT 6.S081
            </a>
          
        </div>
        
      </div>
      <div class="post-content">
        <h1 id="MIT-6-S081-Lab3-Page-tables"><a href="#MIT-6-S081-Lab3-Page-tables" class="headerlink" title="MIT 6.S081 Lab3: Page tables"></a>MIT 6.S081 Lab3: Page tables</h1><h2 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a><strong>1. Print a page table</strong></h2><h3 id="1-1-Description"><a href="#1-1-Description" class="headerlink" title="1.1 Description"></a><strong>1.1 Description</strong></h3><blockquote>
<p>Define a function called vmprint(). It should take a pagetable_t argument, and print that pagetable in the format described below. Insert if(p-&gt;pid==1) vmprint(p-&gt;pagetable) in exec.c just before the return argc, to print the first process’s page table. You receive full credit for this assignment if you pass the pte printout test of make grade.</p>
</blockquote>
<h3 id="1-2-Implementation"><a href="#1-2-Implementation" class="headerlink" title="1.2 Implementation"></a><strong>1.2 Implementation</strong></h3><ul>
<li>将<code>vmprint</code>函数添加到<code>kernel/vm.c</code>文件中并在<code>kernel/defs.h</code>文件中添加该函数的声明。使用格式符<code>%p</code>打印16进制数，使用<code>kernel/riscv.h</code>文件中定义的宏, 参考<code>freewalk</code>函数以递归的形式完成。实现该函数方便接下来的调试, 可以在gdb中测试其正确性。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">3</span>)  <span class="comment">// terminate condition.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      uint64 pa = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; depth; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, pa);</span><br><span class="line">      vmprint((<span class="type">pagetable_t</span>)pa, ++depth);  <span class="comment">// recursive.</span></span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2. A kernel page table per process"></a><strong>2. A kernel page table per process</strong></h2><h3 id="2-1-Description"><a href="#2-1-Description" class="headerlink" title="2.1 Description"></a><strong>2.1 Description</strong></h3><blockquote>
<p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify struct proc to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if usertests runs correctly.</p>
</blockquote>
<ul>
<li><p>Add a field to struct proc for the process’s kernel page table.</p>
</li>
<li><p>A reasonable way to produce a kernel page table for a new process is to implement a modified version of kvminit that makes a new page table instead of modifying kernel_pagetable. You’ll want to call this function from allocproc.</p>
</li>
<li><p>Make sure that each process’s kernel page table has a mapping for that process’s kernel stack. In unmodified xv6, all the kernel stacks are set up in procinit. You will need to move some or all of this functionality to allocproc.</p>
</li>
<li><p>Modify scheduler() to load the process’s kernel page table into the core’s satp register (see kvminithart for inspiration). Don’t forget to call sfence_vma() after calling w_satp().</p>
</li>
<li><p>scheduler() should use kernel_pagetable when no process is running.</p>
</li>
<li><p>Free a process’s kernel page table in freeproc.</p>
</li>
<li><p>You’ll need a way to free a page table without also freeing the leaf physical memory pages.</p>
</li>
<li><p>vmprint may come in handy to debug page tables.</p>
</li>
<li><p>It’s OK to modify xv6 functions or add new functions; you’ll probably need to do this in at least kernel/vm.c and kernel/proc.c. (But, don’t modify kernel/vmcopyin.c, kernel/stats.c, user/usertests.c, and user/stats.c.)</p>
</li>
<li><p>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes sepc=0x00000000XXXXXXXX. You can find out where the fault occurred by searching for XXXXXXXX in kernel/kernel.asm.</p>
<h3 id="2-2-Implementation"><a href="#2-2-Implementation" class="headerlink" title="2.2 Implementation"></a><strong>2.2 Implementation</strong></h3></li>
<li><p>在<code>proc.h</code>进程的结构体中加入内核页表的属性<code>pkpagetable</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="type">pagetable_t</span> pkpagetable;     <span class="comment">// process&#x27;s kernel page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>实现<code>kvminit</code>函数的另一个版本来初始化进程的内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create processes&#x27;s kernel table</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">ukvmcreate</span><span class="params">()</span>  </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  uvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  uvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> kpagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以及专门将映射加入进程的内核页表的函数<code>uvmmap</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to processes&#x27;s kernel</span></span><br><span class="line"><span class="comment">// page table</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>确保每个进程的内核页表中包含该进程所使用到的内核栈的映射。可以将原来在<code>boot time</code>进程初始化<code>procinit</code>函数中全局内核页表映射内核栈的代码<strong>注释</strong>掉。应题目要求在<code>allocproc</code>函数中实现映射当前进程所对应的内核栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="type">char</span> *pa = kalloc();   <span class="comment">// allocate physical memory per page.</span></span><br><span class="line"><span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="type">int</span>) (p - proc));  <span class="comment">// virtual address.</span></span><br><span class="line"><span class="comment">// make sure each process&#x27;s kernel page table has a mapping</span></span><br><span class="line"><span class="comment">// for that process&#x27;s kernel stack.</span></span><br><span class="line">uvmmap(p-&gt;pkpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>scheduler</code>函数内实现，模仿<code>kvminithart</code>函数在调度时切换页表，即将进程的内核页表的地址放入<code>satp</code>寄存器，相应地刷新<code>TLB</code>，当进程没有在运行时，调度器切换回全局内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  load the process&#x27;s kernel page table into the core&#x27;s satp register.</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;pkpagetable));</span><br><span class="line">        sfence_vma();   <span class="comment">// flush the TLB.</span></span><br><span class="line">        </span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">        <span class="comment">// use kernel_pagetable when no process is running</span></span><br><span class="line">        kvminithart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;   <span class="comment">// wait for interrupt.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>freeproc</code>函数中完成释放进程的内核页表操作, 同时实现函数<code>freeukpagetable</code>, 在释放页表时不释放掉<code>leaf</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;pkpagetable) &#123;</span><br><span class="line">  freeukpagetable(p-&gt;pkpagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freeukpagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;  <span class="comment">// not leaf.</span></span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        freeukpagetable((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Simplify"><a href="#3-Simplify" class="headerlink" title="3. Simplify"></a><strong>3. Simplify</strong></h2><h3 id="3-1-Description"><a href="#3-1-Description" class="headerlink" title="3.1 Description"></a><strong>3.1 Description</strong></h3><blockquote>
<p>Your job in this part of the lab is to add user mappings to each process’s kernel page table (created in the previous section) that allow copyin (and the related string function copyinstr) to directly dereference user pointers. Replace the body of copyin in kernel/vm.c with a call to copyin_new (defined in kernel/vmcopyin.c); do the same for copyinstr and copyinstr_new. Add mappings for user addresses to each process’s kernel page table so that copyin_new and copyinstr_new work. You pass this assignment if usertests runs correctly and all the make grade tests pass.</p>
</blockquote>
</li>
<li><p>Replace copyin() with a call to copyin_new first, and make it work, before moving on to copyinstr.</p>
</li>
<li><p>At each point where the kernel changes a process’s user mappings, change the process’s kernel page table in the same way. Such points include fork(), exec(), and sbrk().</p>
</li>
<li><p>Don’t forget that to include the first process’s user page table in its kernel page table in userinit.</p>
</li>
<li><p>What permissions do the PTEs for user addresses need in a process’s kernel page table? (A page with PTE_U set cannot be accessed in kernel mode.)<br>Don’t forget about the above-mentioned PLIC limit.</p>
<h3 id="3-2-Implementation"><a href="#3-2-Implementation" class="headerlink" title="3.2 Implementation"></a><strong>3.2 Implementation</strong></h3></li>
<li><p>用<code>copy_new</code>函数替代<code>copyin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>copyinstr_new</code>函数替代<code>copyinstr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>fork()</code>中针对用户页表映射修改，相应进程的内核页表做出的改动。并实现将用户页表copy到内核页表并清空相应<code>PTE_U</code>标志的函数<code>copyupttokpt</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line"><span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line"><span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(np);</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">copyupttokpt(np-&gt;pkpagetable, np-&gt;pagetable, <span class="number">0</span>, np-&gt;sz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy saved user registers.</span></span><br><span class="line">*(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">copyupttokpt</span><span class="params">(<span class="type">pagetable_t</span> ker, <span class="type">pagetable_t</span> user, uint64 old_size, uint64 new_size)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte_from, *pte_to;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  old_size = PGROUNDUP(old_size);</span><br><span class="line">  <span class="keyword">for</span>(i = old_size; i &lt; new_size; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte_from = walk(user, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;copyupttokpt: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((pte_to = walk(ker, i, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;copyupttokpt: walk&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte_from);</span><br><span class="line">    <span class="comment">// clear PTE_U bit because of kernel page table.</span></span><br><span class="line">    flags = PTE_FLAGS(*pte_from) &amp; (~PTE_U);</span><br><span class="line">    *pte_to = PA2PTE(pa) | flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数<code>exec()</code>中，替换当前进程的用户页表时，内核页表也随之释放，并<code>copy</code>新用户页表的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line"><span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">  <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    last = s+<span class="number">1</span>;</span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br><span class="line">p-&gt;sz = sz;</span><br><span class="line"></span><br><span class="line">uvmunmap(p-&gt;pkpagetable, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line"></span><br><span class="line">p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure></li>
<li><p>函数<code>sbrk()</code>，相应的增加和减少内存时变更用户页表，需要同时更新进程的内核页表。需要判断用户分配地址空间的限制。如果增加的内存大于<code>PLIC</code>则返回<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((sz + n) &gt;= PLIC) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// test overflow.</span></span><br><span class="line">    <span class="comment">// mapping the n bytes in process&#x27;s kernel table.</span></span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, sz-n, sz);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// ummaping the n bytes in process&#x27;s kernel table.</span></span><br><span class="line">    uvmunmap(p-&gt;pkpagetable, PGROUNDUP(sz), (PGROUNDUP(p-&gt;sz) - PGROUNDUP(sz))/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>userinit</code>，初始化第一个<code>process</code>时也需要更新进程的内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>简单的写一下lab 3的总结吧，做之前最好把概念理清楚，确实蛮有难度的。</p>
<p>打印三级也页表页表项的虚拟地址以及物理地址，利用递归就可以完成，leaf pte的判断的判断条件即递归结束条件，可以参考vm.c中部分函数的源代码。leaf pte可以通过pte中的flag进行判断，事实上，也就只有leaf pte才含有PTE_W，PTE_X，PTE_R。</p>
<p>由于历史原因部分os将内核和用户进程独立分为两个page table，本lab的初衷是为了利用好进程之间的isolation，为每个用户进程分配一个内核页表(初始时的映射和全局内核页表相同, <strong>其中此内核页表中含有用户页表的映射</strong>)，释放进程的同时也要将进程的内核页表释放，注意不将叶子pte的物理内存释放，初始化时也是同样的。注意到procinit函数里已经为每个用户进程通过全局内核页表分配好了内核栈，hint中要求把该部分迁移到分配用户进程是时分配栈，另外kvmpa函数中也有个坑，需要将全局内核页表替换为当前用户进程的内核页表。</p>
<p>将用户进程页表载入到用户的内核页表后，系统调用传参时所用到的copyin或者copyinstr就不需要再间接的将该参数的虚拟地址通过用户页表转换为物理地址之后再处理了，简化了一步walk的操作，直接dereference即可。copy页表映射时可以参考vmcopy函数，fork中有相关页表复制的内容，但不是全部参考，可能会出现remap的情况，因此考虑不使用mappages函数即可。注意sbrk时相关函数growproc的overflow检测，以及虚拟地址空间减少时要从用户内核页表中unmap掉相关内容，增加时正常复制即可。exec函数中copy前需要将用户内核页表的映射清空。其他都按hint去做就行了，The devil is in the details.</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><p>强调一下<code>walk</code>函数的实现，在xv6中即为遍历三级页表, 很清晰地刻画了真实的页表实现。<code>PTE2PA</code>宏将当前PTE的地址(物理地址)右移10位将10个有效位置0，左移12位加上偏移量(因为页大小为<code>4kb</code>, $2^{12}=4096=4k$, 所以偏移量为12, <code>byte</code>为寻址能力大小), 最后转化为物理地址。<br>记住页目录存在于物理地址空间中。虚拟地址空间中的<code>L2</code>, <code>L1</code>, <code>L0</code>字段确定每一级页目录中的<code>Entry</code>。<strong>非叶子节点</strong>的<code>PPN</code>(Physical page number)连结上全0的Offset为下一级页目录的<strong>物理地址</strong>。<br><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-78092855fd01e077d1d69fda55a6f1b2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Page table"></p>
<ul>
<li><strong>walk</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];  <span class="comment">// 根据虚拟地址的L字段获取页目录中的Entry</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// 解引用获取当前Entry的地址, 将PPN(物理页号)和Offset(全0)连接后更下一级页目录的物理地址</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];  <span class="comment">// 叶子节点处PPN+虚拟地址的Offset为最终转换的物理地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>宏</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure></li>
</ul>

      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>author:  </strong>Pishun Huang</a>
    </li>
    <li class="post-copyright-link">
    <strong>link:  </strong>
    <a href="/2022/05/16/s081-lab3/" target="_blank" title="MIT 6.S081 Lab3: Page tables">https://mitmoksha.github.io/2022/05/16/s081-lab3/</a>
    </li>
    <li class="post-copyright-license">
      <strong>Copyright notice:   </strong>
      All articles on this website, unless otherwise stated, adopt <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      reprint polocy. If reproduced, please indicate source!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      
<div class="post-nav">



  
  <div class="post-nav-prev post-nav-item">
    <div class="post-nav-img lazyload" data-original="/medias/2.jpg" style="background-size: cover; 
      background-position: center center;">
    </div>
    <a href="/2022/05/16/s081-lab4/" class="post-nav-link">
      <div class="title">
        <i class="fa fa-angle-left"></i> Prev:
        <div>MIT 6.S081 Lab4: Traps</div>
      </div>
      
      <!-- <div class="content">
        MIT 6.S081 Lab4: Traps
跟着视频走一遍系统调用gdb的流程。tmux分割两个窗口，一个窗口作为服务
      </div> -->
    </a>
  </div>



  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img lazyload" data-original="/medias/40.jpg" style="background-size: cover; 
      background-position: center center;">
    </div>
    <a href="/2022/05/16/s081-lab2/" class="post-nav-link">
      <div class="title">
        Next: <i class="fa fa-angle-right"></i>
        <div>MIT 6.S081 Lab2: System Calls</div>
      </div>
      <!-- <div class="content">
        MIT 6.S081 Lab2: System Calls1. System call tracing1.1 描述
In
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->

<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
      
        <div id="myComment">
          
        </div>
      
  </div>

  
    <div class="toc-aside">
      <div class="toc-main">
        <div class="toc-aside-title">
          <i class="fa fa-list-ul" aria-hidden="true"></i><span>catalog</span>
          <div class="toc-open-close">catalog</div>
        </div>
        <div class="toc-content">
          <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script>
<div class="toc"></div>

<script>
  if ($('.toc').length > 0) {
    var headerEl = 'h2, h3, h4',  //headers 
      content = '.post-detail',//文章容器
      idArr = {};  //标题数组以确定是否增加索引id
      //add #id

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    tocbot.init({
      // Where to render the table of contents.
      tocSelector: '.toc',
      // Where to grab the headings to build the table of contents.
      contentSelector: content,
      // Which headings to grab inside of the contentSelector element.
      headingSelector: headerEl,
      scrollSmooth: true,
      scrollSmoothOffset: -80,
      headingsOffset: 130,
      positionFixedSelector: '.toc-main',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  }

</script>

<style>
.is-position-fixed {
  position:fixed !important;
  top: 64px;
}
.toc-main ul {
  counter-reset: show-list;
}
.toc-main ul li::before {
  content: counter(item)".";
  display: block;
  position: absolute;
  left: 12px;
  top:0;
}
.toc > .toc-list {
  padding-left: 35px;
}
.toc>.toc-list li {
  list-style: decimal;
}
.toc-list {
  padding-left: 25px;
}
</style>
        </div>
      </div>
    </div>

    

    <script>
      let openOrCloseBtn = $('.toc-aside .toc-aside-title .toc-open-close');
      let open = eval('' || 'true');
      openOrCloseBtn.click(function() {
        if (open === true) {
          $(".toc-aside").css({'width': 0, 'padding': 0});
          $(".toc-content").css({'width': 0});
          $(".toc-aside-title span, .toc-aside-title i").css({'display': 'none'});
          $(".main-content").css({'width': '75%', 'margin': '10px auto'});
          open = false;
        } else {
          $(".toc-aside").css({'width': '300px', 'padding': '0 10px'});
          $(".toc-content").css({'width': '300px'});
          $(".toc-aside-title span, .toc-aside-title i").css({'display': 'inline-block'});
          $(".main-content").css({'width': '65%', 'margin-right': '10px', 'margin-left': 'calc(35% - 350px)'});
          open = true;
        }
      });
    </script>
  
</div>


    </main>
    <div class="footer bg-color">
  <div class="footer-main">
    <div class="link">
      <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo">
        <i class="fa fa-github" aria-hidden="true"></i>
      </a>
      <a href="mailto:1730241541@qq.com">
        <i class="fa fa-envelope-o" aria-hidden="true"></i>
      </a>
      <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1730241541">
        <i class="fa fa-qq" aria-hidden="true"></i>
      </a>
      <a href="/atom.xml" target="_blank">
        <i class="fa fa-rss" aria-hidden="true"></i>
      </a>
    </div>
    <div class="footer-copyright">
      Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> 
    </div>
    
      
  <!-- 不蒜子统计 -->
  <span id="busuanzi_container_site_pv">
        <i class="fa fa-book" aria-hidden="true"></i>Total reading：<span id="busuanzi_value_page_pv"></span> times
  </span>
  <span id="busuanzi_container_site_pv">
        <i class="fa fa-eye" aria-hidden="true"></i>Total visits：<span id="busuanzi_value_site_pv"></span> times
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv" style='display:none'>
        <i class="fa fa-users" aria-hidden="true"></i>Number of visitors：<span id="busuanzi_value_site_uv"></span> people
  </span>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    
  </div>
</div>


    
      <div class="goTop top-btn-color border-color">
  <i class="fa fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>
    

    

    <!-- 图片放大 -->
    
      <script src="/js/fancybox/jquery.fancybox.min.js"></script>
    

    <script src="/js/wrapImage.js"></script>
    
    <!-- 爱心点击 -->
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    
      <script src="/js/aos/aos.js"></script>
      <script>
        // https://github.com/michalsnik/aos
        const themeOffset = parseInt('120') || 120;
        const themeDelay = parseInt('0')|| 0;
        const themeDuration = parseInt('400') || 400;
        const themeEasing = 'ease' || 'ease';
        const themeOnce = eval('true') || false;
        const themeMirror = eval('false') || false;
        const themeAnchorPlacement = 'top-bottom' || 'top-bottom';
        AOS.init({
          // Global settings:
          disable: false, // accepts following values: 'phone', 'tablet', 'mobile', boolean, expression or function
          startEvent: 'DOMContentLoaded', // name of the event dispatched on the document, that AOS should initialize on
          initClassName: 'aos-init', // class applied after initialization
          animatedClassName: 'aos-animate', // class applied on animation
          useClassNames: false, // if true, will add content of `data-aos` as classes on scroll
          disableMutationObserver: false, // disables automatic mutations' detections (advanced)
          debounceDelay: 50, // the delay on debounce used while resizing window (advanced)
          throttleDelay: 99, // the delay on throttle used while scrolling the page (advanced)

          // Settings that can be overridden on per-element basis, by `data-aos-*` attributes:
          offset: themeOffset, // offset (in px) from the original trigger point
          delay: themeDelay, // values from 0 to 3000, with step 50ms
          duration: themeDuration, // values from 0 to 3000, with step 50ms
          easing: themeEasing, // default easing for AOS animations
          once: themeOnce, // whether animation should happen only once - while scrolling down
          mirror: themeMirror, // whether elements should animate out while scrolling past them
          anchorPlacement: themeAnchorPlacement, // defines which position of the element regarding to window should trigger the animation

        });
      </script>
    

    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/v-plugs-ayu/lib/ayu.css">
<script src="https://cdn.jsdelivr.net/npm/v-plugs-ayu/lib/ayu.umd.min.js"></script>
<div id="appCopy">
</div>
<script>
  var vm = new Vue({
    el: '#appCopy',
    data: {
    },
    computed: {
    },
    mounted() {
      const that = this;
      //  监听 ctrl + c事件  
      $(document).unbind('keypress').bind('keypress', function (e) {
        if (e.ctrlKey && e.keyCode == 67) {
          doSomething();
          // 返回false, 防止重复触发copy事件  
          return false;
        }
      })

      // 鼠标右键的复制事件  
      $(document).unbind('copy').bind('copy', function (e) {
        doSomething();
        // console.log('右键复制 监听成功');
      });

      function doSomething() {
        that.$notify({
          title: "成功",
          content: "代码已复制，请遵守相关授权协议。",
          type: 'success'
        })
        // console.log('ctrl + c 监听成功');  
      }
    },
    methods: {
    },
    created() { }
  })
</script>
    

    <!-- 输入框打字特效 -->
    
      <script src="/js/activate-power-mode.js"></script>
      <script>
          POWERMODE.colorful = true;  // 打开随机颜色特效
          POWERMODE.shake = false;    // 关闭输入框抖动
          document.body.addEventListener('input', POWERMODE);//监听打字事件
      </script>
    

    <!-- markdown代码一键复制功能 -->
    <script src="/js/clipboard/clipboard.min.js"></script>
    <script>
      !function (e, t, a) {
        var copy = 'copy';
        /* code */
        var initCopyCode = function(){
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fa fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
              target: function(trigger) {
                  return trigger.nextElementSibling;
              }
          });
        }
        initCopyCode();
      }(window, document);
    </script>

    <script src="/js/lazyload/lazyload@1.9.1.js"></script>
    <script>
      $(function() {
        $("div.lazyload, img.lazyload, a.lazyload").lazyload(
            {
                effect: "fadeIn",
                placeholder: "https://img10.360buyimg.com/ddimg/jfs/t1/159345/8/2271/222193/5ff7b36fEe49f5663/a95287c20385127f.gif"    //图片未加载出来时显示的占位图
            }
        );
    });
    </script>
    
    <script src="/js/app.js"></script>
  </body>
</html>