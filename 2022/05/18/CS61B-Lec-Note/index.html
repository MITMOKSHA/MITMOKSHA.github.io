<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mitmoksha.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Data Structure in Java">
<meta property="og:type" content="article">
<meta property="og:title" content="CS61B Lec Note">
<meta property="og:url" content="https://mitmoksha.github.io/2022/05/18/CS61B-Lec-Note/index.html">
<meta property="og:site_name" content="Moksha&#39;s Blog">
<meta property="og:description" content="Data Structure in Java">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-a8b3d43d066476b5c6eafbcdc5071c5a.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-6d77a6127e21f7f37c62dd23bf1df0b9.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-e925732ad6e4f45795982fe471a6eed9.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ecdf853a69118f5400c7fa20e1986555.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-8010a66ab4fb46d6c67ecb5f5f433b84.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-7cd7df921c5da3080ef5c0d352e71b84.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-12a66211e25a00cd7ba604f07378324e.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-f23000dfd8f9db7487f066e4558fc55d.png">
<meta property="article:published_time" content="2022-05-18T02:52:23.000Z">
<meta property="article:modified_time" content="2022-05-18T09:57:19.750Z">
<meta property="article:author" content="Pishun Huang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic4.zhimg.com/80/v2-a8b3d43d066476b5c6eafbcdc5071c5a.png">


<link rel="canonical" href="https://mitmoksha.github.io/2022/05/18/CS61B-Lec-Note/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://mitmoksha.github.io/2022/05/18/CS61B-Lec-Note/","path":"2022/05/18/CS61B-Lec-Note/","title":"CS61B Lec Note"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CS61B Lec Note | Moksha's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Moksha's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Moksha's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CS61B-Data-Structure-Notes"><span class="nav-number">1.</span> <span class="nav-text">CS61B Data Structure Notes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-Syntax"><span class="nav-number">2.</span> <span class="nav-text">Java Syntax</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IDEA-Skill"><span class="nav-number">3.</span> <span class="nav-text">IDEA Skill</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Algorithm"><span class="nav-number">4.</span> <span class="nav-text">Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Big-Theta-Theta-%E6%9D%A5%E4%BB%A3%E6%9B%BForder-of-growth-%E5%A2%9E%E9%95%BF%E7%BA%A7"><span class="nav-number">4.1.</span> <span class="nav-text">1.(Big-Theta$\Theta$来代替order of growth(增长级))</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">4.2.</span> <span class="nav-text">2.并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">属性和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">4.2.2.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B8%90%E8%BF%91%E7%BA%BF%E5%88%86%E6%9E%90"><span class="nav-number">4.3.</span> <span class="nav-text">3.渐近线分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort"><span class="nav-number">4.4.</span> <span class="nav-text">4.归并排序(Merge Sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%9D%87%E6%91%8A-Amortized-%E5%88%86%E6%9E%90"><span class="nav-number">4.5.</span> <span class="nav-text">5.均摊(Amortized)分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST-Binary-Search-Trees"><span class="nav-number">4.6.</span> <span class="nav-text">6.二叉搜索树(BST Binary Search Trees)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5put"><span class="nav-number">4.6.1.</span> <span class="nav-text">插入put</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">4.6.2.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">4.6.3.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">4.6.4.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BST%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.6.5.</span> <span class="nav-text">BST存在的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-B%E6%A0%91-B-Trees"><span class="nav-number">4.7.</span> <span class="nav-text">7.B树(B-Trees)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E6%A0%91%E4%B8%8D%E5%8F%98%E9%87%8F-Invariant"><span class="nav-number">4.7.1.</span> <span class="nav-text">B树不变量(Invariant)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-number">4.7.2.</span> <span class="nav-text">B树的插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2B%E6%A0%91%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90"><span class="nav-number">4.7.3.</span> <span class="nav-text">搜索B树运行时最坏情况分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">4.7.4.</span> <span class="nav-text">B树的删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93"><span class="nav-number">4.7.5.</span> <span class="nav-text">B树的特性总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%BA%A2%E9%BB%91%E6%A0%91-Red-Black-Trees"><span class="nav-number">4.8.</span> <span class="nav-text">8. 红黑树(Red-Black Trees)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7-1"><span class="nav-number">4.8.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%84%E5%88%99"><span class="nav-number">4.8.2.</span> <span class="nav-text">规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93"><span class="nav-number">4.8.3.</span> <span class="nav-text">红黑树总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%93%88%E5%B8%8C"><span class="nav-number">4.9.</span> <span class="nav-text">9. 哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A2%9E%E9%95%BF%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">4.9.1.</span> <span class="nav-text">动态增长哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E9%AA%8C%E6%B3%95%E5%88%99"><span class="nav-number">4.9.2.</span> <span class="nav-text">经验法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="nav-number">4.9.3.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.9.4.</span> <span class="nav-text">避免冲突的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">4.10.</span> <span class="nav-text">10. 堆和优先队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="nav-number">4.10.1.</span> <span class="nav-text">最小堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementation-of-PQ"><span class="nav-number">4.10.2.</span> <span class="nav-text">Implementation of PQ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">4.11.</span> <span class="nav-text">树和图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.11.1.</span> <span class="nav-text">简单图的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.11.2.</span> <span class="nav-text">图的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.11.3.</span> <span class="nav-text">图的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Depth-First-Traversal"><span class="nav-number">4.11.4.</span> <span class="nav-text">Depth-First Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graph-Traversal"><span class="nav-number">4.11.5.</span> <span class="nav-text">Graph Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graph-API"><span class="nav-number">4.11.6.</span> <span class="nav-text">Graph API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.11.7.</span> <span class="nav-text">图的实现</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pishun Huang</p>
  <div class="site-description" itemprop="description">Opportunities are ready for it, the more to beat action.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/18/CS61B-Lec-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CS61B Lec Note | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS61B Lec Note
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-05-18 10:52:23 / Modified: 17:57:19" itemprop="dateCreated datePublished" datetime="2022-05-18T10:52:23+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS61B/" itemprop="url" rel="index"><span itemprop="name">CS61B</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>Data Structure in Java</p>
</blockquote>
<span id="more"></span>
<h1 id="CS61B-Data-Structure-Notes"><a href="#CS61B-Data-Structure-Notes" class="headerlink" title="CS61B Data Structure Notes"></a>CS61B Data Structure Notes</h1><h1 id="Java-Syntax"><a href="#Java-Syntax" class="headerlink" title="Java Syntax"></a><strong>Java Syntax</strong></h1><ul>
<li>Java除了8种基本类型(按值传递)<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>boolean</code>, <code>char</code>之外，其他一切，包括<code>数组</code>，不是原始类型，而是<code>Reference Type</code>(引用类型)，说白了就是指针。</li>
<li>声明任何引用类型(Reference Type)的变量，java会分配一个64-bit的box，这64-bit种不包含数据(如对象的属性等)，而是包含该数据的在内存中的地址。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;             </span><br><span class="line">b = a;                <span class="comment">// 将a在内存中的地址赋给b，使a和b指向同一内容。</span></span><br></pre></td></tr></table></figure></li>
<li>嵌套类(Nested Class)。经验法则：如果不使用外部类的任何实例成员，则将嵌套类定义为<code>static</code>。因为被声明为static的嵌套类不能访问外部类的实例成员, 同时也节约了内存。</li>
<li>文件名必须和类名相同，每个文件必须只包含一个外部类。</li>
<li>泛型(Generic Type)仅适用于引用类型，尖括号内不能放入原始类型比如:int, double, 但是可以放入原始类型的引用版本，如: <code>Integer</code>, <code>Double</code>, <code>Character</code>, <code>Boolean</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code>, <code>Float</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;genericTypeName&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> genericTypeName item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(IntNode _prev, genericTypeName _item, IntNode _next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = _prev;</span><br><span class="line">            <span class="built_in">this</span>.item = _item;</span><br><span class="line">            <span class="built_in">this</span>.next = _next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLList</span><span class="params">(genericTypeName x)</span> &#123;</span><br><span class="line">        prev = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="literal">null</span>, x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        DDList&lt;String&gt; d1 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        DDList&lt;Integer&gt; d2 = <span class="keyword">new</span> <span class="title class_">DDList</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 上一行代码和这行是相等的实例化尖括号声明类型可以省略</span></span><br><span class="line">        DDList&lt;Integer&gt; d2 = <span class="keyword">new</span> <span class="title class_">DDList</span>&lt;Integer&gt;(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建数组的三种方法:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">y = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] z = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;   <span class="comment">// 类似第二种方法，但只能和声明结合时使用</span></span><br></pre></td></tr></table></figure></li>
<li>java数组仅在运行时执行边界检查。System.arraycopy()方法非常方便使用。</li>
<li><code>[]</code>允许我们在运行时指定想要的索引，而类中指定字段就不行。</li>
<li>创建泛型对象数组的方法(虽然java不允许，而且编译器会报错)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glorp[] items = (Glorp []) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure></li>
<li>判断两个字符串是否相等使用<code>equals</code>而不是<code>==</code>的原因是，<code>==</code>比较的是地址，而<code>equals</code>比较的是存储单元中的值。</li>
<li>java不允许使用<code>&gt;</code>运算符在字符串之间比较，而是用<code>str1.compareTo(str2)</code>来进行比较，如果相等则返回0，str1 &gt; str2则返回一个正数。</li>
<li><code>org.junit</code>库提供了很多方法来简化测试的编写, <a target="_blank" rel="noopener" href="https://junit.org/junit4/javadoc/4.12/org/junit/Assert.html">Junit官方文档</a>; <code>import static org.junit.Assert.*</code> <code>import org.junit.Test</code>之后，就可以省略掉<code>org.junit.Assert</code>前缀，进而直接使用<code>assertEquals</code>方法; 需要在每个方法前加上<code>@org.junit.Test</code>来替代<code>@Test</code>, IDEA中Junit可视化测试是根据<code>@Test</code>标签在运行时自动检测的。</li>
<li>获取String的第i个字符的方法<code>str.charAt(i)</code>。</li>
<li>Java中字符使用单引号，字符串则使用双引号。</li>
<li><code>public class AList&lt;Item&gt; implements List61B&lt;Item&gt;&#123;...&#125;</code>, implements, 接口继承，子类可以使用父类的方法，也可以覆盖父类的方法; <code>AList</code>将保证拥有并定义<code>List61B</code>接口中指定的所有属性和方法; <code>AList</code> is a <code>List61B</code>, 他们之间是<code>is a</code>关系; 在<code>AList</code>中实现<code>List61B</code>的方法时，<code>@Override</code>是必要的, 这是为了提醒编译器通知你可能发生的错误。</li>
<li><code>List61B&lt;Item&gt; lst = new AList&lt;&gt;();</code>完成多态。</li>
<li><code>StdRandom</code>库生成随机数<a target="_blank" rel="noopener" href="https://introcs.cs.princeton.edu/java/stdlib/javadoc/StdRandom.html">文档</a>。</li>
<li><code>assertEquals(message, expected, actual)</code>, JUnit测试失败时输出有用信息, 将预期值和实际值作为<code>message</code>。</li>
<li>Difference between <code>implement</code> and <code>extends</code>。</li>
<li>实现继承<code>extends</code>(is a关系, 继承…)关键字，子类继承父类的所有成员包括(构造函数不被继承)：<ul>
<li>所有实例和静态变量</li>
<li>所有方法</li>
<li>所有嵌套类</li>
</ul>
</li>
<li>在子类的构造函数中需要调用父类的构造函数，在子类的构造函数中使用<code>super()</code>关键字。原因: 比如<code>TA extends Human</code>(TA is a Human), 先需要创建一个人，接着创建TA才有意义; 当然如果我们不这样做，Java会<strong>自动</strong>调用super类的<code>无参构造函数</code>。</li>
<li>Java中的每个类都是<code>Object Class</code>或者是它的后代(descendant), 类没有<strong>显示地</strong>extends仍然会<strong>隐式地</strong>extends <code>Object Class</code>。</li>
<li>Java可以用<code>interface</code>(接口)类型来充当函数指针。</li>
<li>通过接口继承来定义一个比较接口<code>CompareTo</code>，解决<code>Object</code>对象之间不能比较的问题。</li>
<li>抽象数据类型(Abstract Data Type), 简称ADT, 指的是一种数据类型，只带有行为，没有任何具体的方式来实现展示这些行为(抽象的); <code>java.util</code>库中包含三个最重要的ADT: <ul>
<li><img src="https://pic4.zhimg.com/80/v2-a8b3d43d066476b5c6eafbcdc5071c5a.png" alt="白色框是接口, 蓝色框是具体的类"></li>
<li><code>List</code>, 比较流行的实现是(ArrayList)<code>List&lt;String&gt; lst = new ArrayList&lt;String&gt;();</code></li>
<li><code>Set</code>, 比较流行的实现是(HashSet)<code>Set&lt;String&gt; ss = new HashSet&lt;&gt;();</code></li>
<li><code>Map</code>。比较流行的实现是(HashMap)<code>Map&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;();</code></li>
</ul>
</li>
<li>接口(interface)的特性:<ul>
<li>所有方法都必须是<code>public</code></li>
<li>所有变量都必须是<code>public static final</code>，<code>final</code>类似于cpp的<code>const</code></li>
<li>无法实例化</li>
<li><strong>默认情况</strong>下，所有方法都是<code>abstract</code>的，除非指定为<code>defualt</code></li>
<li>每个类可以<code>Implements</code>多个<code>Interface</code>。</li>
</ul>
</li>
<li>抽象类(Abstract类似cpp), 介于<code>interface</code>和<code>concrete class</code>之间。<ul>
<li>方法可以是<code>public</code>也可以是<code>private</code>，或者<code>protected</code></li>
<li>可以有任何类型的变量</li>
<li>无法实例化</li>
<li><strong>默认情况</strong>下，方法是<code>concrete</code>的，除非指定为<code>abstract</code></li>
<li>每个类只能<code>Implements</code>一个<code>Abstract</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GraphicObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meveTo</span><span class="params">(<span class="type">int</span> newX, <span class="type">int</span> newY)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>wrapper class(包装类)，如int的包装类是Integer。Java可以在原始类型和包装类型(也成为引用类型)之间进行<strong>隐式转换</strong>。两个方向的转换成为装箱(box)(int-&gt;Integer), 拆箱(unbox)(Integer-&gt;int); 注意:<ul>
<li>数组永远不会自动装箱或自动拆箱</li>
<li>自动装箱和拆箱会对性能产生影响</li>
<li>包装类型比原始类型使用更多的内存, 关于内存使用信息的拓展<a target="_blank" rel="noopener" href="http://www.javamex.com/tutorials/memory/object_memory_usage.shtml">此链接</a>或<a target="_blank" rel="noopener" href="http://blog.kiyanpro.com/2016/10/07/system_design/memory-usage-estimation-in-java/">链接</a></li>
</ul>
</li>
<li>Java同如CPP这样的语言，会自动隐式向上类型转换，若占用字节较大的类型转换为较小的类型则需要手动去转换。</li>
<li>不可变数据类型，如String或加上<code>final</code>关键字修饰的基本类型。<ul>
<li>优点：防止错误并使调试更容易</li>
<li>缺点：需要创建一个新对象才能更改属性。</li>
</ul>
</li>
<li>在Java中异常是对象，抛出异常的格式<code>throw new IllegalArgumentException(&quot;can&#39;t add null&quot;);</code></li>
<li>在Java中可以定义一个迭代器接口, 如ADT需使用则<code>extend</code>或者Implement这个接口，需要有next, hasNext方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Java中创建<code>Package</code>(类似于cpp的namespace), 存储package的文件夹名称应该和包一致<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ug.joshh.animal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>JAR</code>文件就像zip文件一样，完全可以将文件解压缩并转换回.java文件。</li>
<li>public、protected、package-private、private的访问控制权限:<img src="https://pic4.zhimg.com/80/v2-6d77a6127e21f7f37c62dd23bf1df0b9.png" alt="Image"></li>
<li>Java中操作文件，查看<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html">File javadocs</a>和使用<code>Utils.java</code>类，该类具有许多有用的文件操作辅助函数。</li>
<li>序列化(seralize), 将java<strong>对象</strong>序列化为文件(持久性)，通过implements<code>Serializable</code>接口</li>
<li>使用<code>Utils</code>类(proj Gitlet提供的子集)中的辅助函数来序列化和反序列化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Model m;</span><br><span class="line"><span class="type">File</span> <span class="variable">outFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializing the Model object</span></span><br><span class="line">writeObject(outFile, m);</span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line">Model m;</span><br><span class="line"><span class="type">File</span> <span class="variable">inFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deserializing the Model object</span></span><br><span class="line">m = readObject(inFile, Model.class);</span><br></pre></td></tr></table></figure></li>
<li>可变参数形式<code>static void writeContents(File file, Object... contents)</code></li>
<li>常用ADT的操作<ul>
<li>Stacks<ul>
<li><code>push(int x)</code>: 将x放在栈顶</li>
<li><code>int pop()</code>: 获取栈顶元素</li>
</ul>
</li>
<li>Lists<ul>
<li><code>add(int i)</code>: 添加一个元素</li>
<li><code>int get(int i)</code>: 获取索引i处的元素</li>
</ul>
</li>
<li>Sets<ul>
<li><code>add(int i)</code>: 添加一个元素</li>
<li><code>contains(int i)</code>: 返回集合是否包含值得布尔值</li>
</ul>
</li>
<li>Maps<ul>
<li><code>put(K key, V value)</code>: 将键值放入哈希表中</li>
<li><code>V get(K key)</code>: 获取key对应得值</li>
</ul>
</li>
</ul>
</li>
<li>Java泛型<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/bounded.html">bounded type parameter</a></li>
<li><code>Collection</code>可以由许多不同的数据结构实例化</li>
</ul>
<h1 id="IDEA-Skill"><a href="#IDEA-Skill" class="headerlink" title="IDEA Skill"></a><strong>IDEA Skill</strong></h1><ul>
<li>左键点击行号的右侧打断点</li>
<li>条件断点，在断点的基础上右键增加条件。进入Debug模式后，拖动console到右侧可以同时显示console和Debugger。</li>
<li>比较好用的Plugin: <code>Java visualizer</code>, <code>IdeaVim</code>, IDEA自带的<code>Sheck Style</code>。</li>
<li><code>Step into</code> vs. <code>Step over</code>, Step into进入函数，而Step over则不进入函数直接向下执行。<code>Step out</code>跳出函数。</li>
<li><code>Resuming</code>类似于continue，跳到条件断点的下一个条件，在step over的左下侧向右的绿色箭头</li>
<li><code>Destructive</code> vs. <code>Non-Destructive</code>, 非破坏性调用函数没有修改传入的数据结构，相反破坏性则修改了传入的数据结构。</li>
<li>创建JAR文件<ul>
<li>File -&gt; Project Structure -&gt; Artifacts -&gt; JAR -&gt; “From modules with dependencies</li>
</ul>
</li>
<li>IDEA将生成的<code>.class</code>文件存储在<code>out</code>或<code>target</code>文件夹中。</li>
</ul>
<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a><strong>Algorithm</strong></h1><h2 id="1-Big-Theta-Theta-来代替order-of-growth-增长级"><a href="#1-Big-Theta-Theta-来代替order-of-growth-增长级" class="headerlink" title="1.(Big-Theta$\Theta$来代替order of growth(增长级))"></a><strong>1.(Big-Theta$\Theta$来代替order of growth(增长级))</strong></h2><pre><code>- Only consider the worst case.
- Pick a representative operation (aka: cost model)
- Ignore lower order terms
- Ignore multiplicative constants.
</code></pre>
<h2 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2.并查集"></a><strong>2.并查集</strong></h2><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><pre><code>- Connect()
- isConnect()
- find()
- parent[]
</code></pre>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li>路径压缩<br> $$lg^<em>n :&#x3D; \begin{cases}0, &amp; \text {if n $\leq$ 1}\ 1+lg^</em>(lgn), &amp; \text{if n $&gt;$ 1} \end{cases}$$  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">        id[p] = id[id[p]]; <span class="comment">// 路径压缩，使得下次查找更快</span></span><br><span class="line">        p = id[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>按秩合并</li>
</ol>
<ul>
<li>规则：将<code>height</code>较小的Set连接到<code>height</code>较大的Set<h2 id="3-渐近线分析"><a href="#3-渐近线分析" class="headerlink" title="3.渐近线分析"></a><strong>3.渐近线分析</strong></h2>并不是所有两层for循环的复杂度都为$\Theta(N^2)$, 比如下面这个for loop的复杂度为$C(N) &#x3D; 1 + 2 + 4 + … + N &#x3D; 2N-1$(如何N为2的幂)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printParty</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j += <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);   </span><br><span class="line">            <span class="type">int</span> <span class="variable">ZUG</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
递归, 复杂度为$C(N) &#x3D; 1 + 2 + 4 + 8 + … + 2^{N-1} &#x3D; 2(2^{N-1})-1 &#x3D; 2^N-1 &#x3D; \Theta(N)$<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> f3(n-<span class="number">1</span>) + f3(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
$O$(<code>Big O</code>)是$\Theta$(<code>Big Theta</code>)在不考虑最好情况和最坏情况下的表示, 在不同的输入，运行时间不同的情况下，它允许我们做出没有实例(case)限定的简单语句</li>
<li>$\Theta$形式表示增长级(Order of growth)为$F(N)$</li>
<li>$\Omega$表示增长级小于等于$F(N)$</li>
<li>$\Omicron$表示增长级大于等于$F(N)$<h2 id="4-归并排序-Merge-Sort"><a href="#4-归并排序-Merge-Sort" class="headerlink" title="4.归并排序(Merge Sort)"></a><strong>4.归并排序(Merge Sort)</strong></h2>结合选择排序来理解，在选择排序上进行优化$\Theta(nlogn)$, 额外开辟一个存储结果的空间，利用双指针获得最后的排序数组。</li>
</ul>
<h2 id="5-均摊-Amortized-分析"><a href="#5-均摊-Amortized-分析" class="headerlink" title="5.均摊(Amortized)分析"></a><strong>5.均摊(Amortized)分析</strong></h2><p>$\Phi_i &#x3D; \Phi_{i-1} + a_i - c_i$, 其中$c_i$是操作的真实开销，$a_i$是随机摊销操作的开销，在所有$i$中必须一致。假设$\Phi_0 &#x3D; 0$。</p>
<h2 id="6-二叉搜索树-BST-Binary-Search-Trees"><a href="#6-二叉搜索树-BST-Binary-Search-Trees" class="headerlink" title="6.二叉搜索树(BST Binary Search Trees)"></a><strong>6.二叉搜索树(BST Binary Search Trees)</strong></h2><p>除了含有二叉树的属性外，对于树中的每个节点X，要求左子树中的每个键都小于X的键，右子树中的每个键都大于X的键。需要成员为<code>root</code>, 具备的私有内嵌类有<code>BSTNode</code>，其中的成员为<code>key</code>, <code>value</code>, <code>left</code>, <code>right</code>, <code>node count</code>。</p>
<h3 id="插入put"><a href="#插入put" class="headerlink" title="插入put"></a>插入<code>put</code></h3><ul>
<li>总是在叶节点插入, 递归找到<code>null</code>节点后创建一个node count为1的<code>Node</code>。<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3></li>
<li>被删除节点没有子节点, 直接删除它的父指针</li>
<li>被删除节点有1个子节点，将父节点的子指针分配给被删除节点的子节点</li>
<li>被删除节点有2个子节点，由新的节点来替换，必须要大于左子树，且小于右子树, 即取右子树的<code>min</code>或者左子树的<code>max</code>两种解决方案。<strong>Hibbard deletion</strong>，维护好删除节点后后BST的平衡性, 要实现的方法有<code>ceiling</code>, <code>floor</code>, <code>deleteMin</code>, <code>deleteMax</code>。<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3></li>
<li><code>get</code>递归返回值，而<code>put</code>递归返回一个子树。<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3></li>
<li><code>depth</code>, <code>height</code>, <code>average depth</code>:<br>  <img src="https://pic4.zhimg.com/80/v2-e925732ad6e4f45795982fe471a6eed9.png" alt="BST"><br>  $$Average Depth &#x3D; \frac{\sum^D_{i&#x3D;0}d_in_i}{N}$$<br>  其中$d_i$为depth, $n_i$为当前层节点的数目<br>  <img src="https://pic4.zhimg.com/80/v2-ecdf853a69118f5400c7fa20e1986555.png" alt="BST"><h3 id="BST存在的问题"><a href="#BST存在的问题" class="headerlink" title="BST存在的问题"></a>BST存在的问题</h3>我们总是在叶子节点处插入，这是导致高度增加的原因。插入顺序不同会导致高度不同。</li>
<li>树的<strong>高度</strong>决定了最坏情况的运行时间，</li>
<li>树的<strong>平均深度</strong>决定了平均情况的运行时间。<br><img src="https://pic4.zhimg.com/80/v2-8010a66ab4fb46d6c67ecb5f5f433b84.png" alt="BST"><h2 id="7-B树-B-Trees"><a href="#7-B树-B-Trees" class="headerlink" title="7.B树(B-Trees)"></a><strong>7.B树(B-Trees)</strong></h2></li>
<li>B树很好地避免了BST存在的问题, 最糟糕搜索情况为$O(N)$——以链表的形式展开</li>
<li>BigO $\not &#x3D;$ Worst Case</li>
<li>L非常大的情况，在数据库和文件系统中会出现。</li>
<li><code>2-3树</code>, 通常指明<code>L</code>(每个节点中项(item)的最大数量)为2，而<code>2-3</code>指的是可以拥有的孩子节点的数量为2或3。</li>
<li><code>max-degree</code>指的是所能拥有最多孩子节点的个数, <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B树可视化模拟</a>。<h3 id="B树不变量-Invariant"><a href="#B树不变量-Invariant" class="headerlink" title="B树不变量(Invariant)"></a>B树不变量(Invariant)</h3>保证了B树的<code>bushy</code>。</li>
<li>所有叶子节点到根节点有着<strong>相同</strong>的距离</li>
<li>含有<code>k</code>项的节点一定含有<code>k+1</code>个子节点。<h3 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h3></li>
<li>向叶子节点中插入，沿着树向下遍历以及根据当前节点项的大小左右遍历</li>
<li>将节点添加到叶子节点后，如果项数&gt;L, 则弹出<strong>中左</strong>(middle left)项，加入到父节点中重新排列。</li>
<li>如果父节点的项数也大于L，则再次弹出<strong>中左</strong>项目</li>
<li>重复完成此过程，直到父节点可以容纳或到达根节点。<h3 id="搜索B树运行时最坏情况分析"><a href="#搜索B树运行时最坏情况分析" class="headerlink" title="搜索B树运行时最坏情况分析"></a>搜索B树运行时最坏情况分析</h3></li>
<li>总运行时间$O(LlogN)$, 搜索在树中最大的数，遍历到底部需要$O(logN)$, 向右遍历得到最大数需要$O(L)$, 因为当前节点有有L个项。<h3 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h3>分以下几种情况, 打算做到15445的proj2 B+Tree的时候再review B树删除操作的<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g508ece10b0_1_1305">slide</a></li>
<li>Case 1: Multi-Key Sibling</li>
<li>Case 2: Multi-Key Parent</li>
<li>Case 3: Single-Key Parent and Sibling<h3 id="B树的特性总结"><a href="#B树的特性总结" class="headerlink" title="B树的特性总结"></a>B树的特性总结</h3></li>
<li>Nodes may contain between<code>1</code>and<code>L</code>items.</li>
<li>contains works almost exactly like a normal BST.</li>
<li>add works by adding items to existing leaf nodes.</li>
<li>If nodes are too full, they split.</li>
<li>Resulting tree has perfect balance. Runtime for operations is $O(logN)$.</li>
<li>B-trees are more complex, but they can efficiently handle ANY insertion order.</li>
<li>B树实现起来比较复杂，相对来说比较慢<h2 id="8-红黑树-Red-Black-Trees"><a href="#8-红黑树-Red-Black-Trees" class="headerlink" title="8. 红黑树(Red-Black Trees)"></a><strong>8. 红黑树(Red-Black Trees)</strong></h2></li>
<li>left-Leaning Red Black Binary Search Tree (LLRB)<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3></li>
<li>不存在节点含有两个<code>red links</code>(意味着4个item一个节点，在2-3树中是不存在的)。</li>
<li>叶子节点到root的<code>black links</code>数一致。<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3></li>
<li>在2-3树，插入时总是使用<code>red links</code>。</li>
<li>通过旋转使得<code>red links</code>在左侧。右侧的<code>Red links</code>是不允许的, 除了<code>temporary 4 node</code>即含有两个red links的子节点</li>
<li>如果出现2个连续的左侧连接，则通过右旋转来调整为<code>temporary 4 node</code></li>
<li>含有<code>temporary 4 node</code>, 即含有两个red links的子节点, 则<code>color clip</code>来模拟BST的<code>split</code>. <code>Color Flip</code>指将当前节点的两个<code>red links</code>变黑，并将父节点的<code>black links</code>变红。如果当前节点为根节点则，则不存在将父节点变红这一步。<h3 id="红黑树总结"><a href="#红黑树总结" class="headerlink" title="红黑树总结"></a>红黑树总结</h3></li>
<li>61B的<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1jgOgvx8tyu_LQ5Y21k4wYLffwp84putW8iD7_EerQmI/edit#slide=id.g463de7561_042">demo</a>通过insert来理解红黑树的特性。</li>
<li>红黑树和B树的复杂度一致</li>
<li>将BST转化为红黑树的代码实现<img src="https://pic4.zhimg.com/80/v2-7cd7df921c5da3080ef5c0d352e71b84.png" alt="Image"></li>
</ul>
<h2 id="9-哈希"><a href="#9-哈希" class="headerlink" title="9. 哈希"></a><strong>9. 哈希</strong></h2><ul>
<li>Properties of HashCode(哈希值)<ul>
<li>必须是整数</li>
<li><code>.hashCode()</code>在同一对象上运行两次，应该返回相同的数字</li>
<li>被考虑的两个对象<code>.equal()</code>必须具有相同的哈希码</li>
</ul>
</li>
<li>实际上哈希表key-value对，在Java中key在哈希表中的索引是由<code>hashCode()</code>成员函数生成的。</li>
<li>溢出会引起冲突(出现在哈希值过大的情况下)，比如最大的整型数加1会变成最小的整型数</li>
<li>避免冲突的方式，取模而不是无限地增大空间。</li>
<li>尝试用链表数组(ArrayList), 即数组元素为链表，来作为哈希的空间，处理碰撞的复杂度$\Theta(Q)$, 因为<code>add</code>和<code>contains</code>需要检查当前链表数组元素(即链表)的第<code>Q</code>项是否为存在。最坏的情况下为所有项目的hashCode都是相同的，因此需要$\Theta(N)$。</li>
<li>利用<strong>模运算</strong>来减少bucket的数量了。<h3 id="动态增长哈希表"><a href="#动态增长哈希表" class="headerlink" title="动态增长哈希表"></a>动态增长哈希表</h3></li>
<li>假设含有<code>M</code>个Bucket和<code>N</code>个items。Bucket相当于一个链表数组的一个元素。<img src="https://pic4.zhimg.com/80/v2-12a66211e25a00cd7ba604f07378324e.png" alt="Image"></li>
<li>每隔一段时间就<strong>Double</strong> M创建一个新的哈希表，来确保时间复杂度为$\Theta(N&#x2F;M)$即$\Theta(1)$。</li>
<li>遍历旧的哈希表，将元素一个个地添加到新的哈希表中。因为哈希表大小的改变，元素对哈希表大小的模数也会发生变化。</li>
<li><code>Load Factor</code>(即N&#x2F;M)等于上述最好情况(Best case)的运行时间。如果<code>N</code>在增加，Load Factor也将会持续增加</li>
<li><code>Load Factor Threshold</code>，当Load factor大于load factor threshold时就<code>resize</code>。 resize需要$\Theta(N)$的时间，因为需要将N个items添加到哈希表中，每个添加需要$\Theta(1)$的时间。</li>
<li>注意: 当resize时，不需要检查项目是否已经存在于Linkedlist中(因为知道没有重复项)，所以<code>Add</code>只需要$\Theta(1)$的时间<h3 id="经验法则"><a href="#经验法则" class="headerlink" title="经验法则"></a>经验法则</h3></li>
<li>使用<code>base</code>策略，即模数。</li>
<li>使用一个小的质数作为<code>base</code>。素数非偶特性有助于避免溢出问题，以及更容易计算等等。<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3></li>
<li>当一个目标变量改变，它的哈希值也改变。因此不要再哈希表中存储能够改变的Objects<h3 id="避免冲突的方法"><a href="#避免冲突的方法" class="headerlink" title="避免冲突的方法"></a>避免冲突的方法</h3></li>
<li>开放定址法(open addressing), 如果目标bucket已经存在，则选择不同的bucket<ul>
<li>linear Probing(线性探测法)，如果当前bucket已被占用，使用下一个bucket，一个接着一个扫描</li>
</ul>
</li>
</ul>
<h2 id="10-堆和优先队列"><a href="#10-堆和优先队列" class="headerlink" title="10. 堆和优先队列"></a><strong>10. 堆和优先队列</strong></h2><ul>
<li>涉及到搜索树的优先级?</li>
<li>堆的数据结构是<strong>二叉搜索树</strong></li>
</ul>
<h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><ul>
<li>属性<ul>
<li>每个节点都小于等于它的两个子节点。</li>
</ul>
</li>
<li>操作<ul>
<li>add: 临时添加到堆尾，<code>swimming</code>到合适的位置。</li>
<li>getSmallest: 返回堆的根。</li>
<li>removeSmallest: 将堆中的最后一项交换到根中，将层次结构下沉到适当的位置。<h3 id="Implementation-of-PQ"><a href="#Implementation-of-PQ" class="headerlink" title="Implementation of PQ"></a>Implementation of PQ</h3></li>
</ul>
</li>
<li>leftchild(k) &#x3D; k * 2;</li>
<li>rightchild(k) &#x3D; k * 2 - 1;</li>
<li>parent(k) &#x3D; k &#x2F; 2;</li>
<li>实现基于的数据结构: <code>数组</code>, <code>BST</code>, <code>哈希表</code>，<code>堆</code></li>
<li><img src="https://pic4.zhimg.com/80/v2-f23000dfd8f9db7487f066e4558fc55d.png" alt="Image"></li>
</ul>
<h2 id="树和图的遍历"><a href="#树和图的遍历" class="headerlink" title="树和图的遍历"></a><strong>树和图的遍历</strong></h2><ul>
<li>树也是图的一种实现方式, 无环。</li>
<li>先序遍历(preorder traversal)适合打印目录结构。</li>
<li>后序遍历(postorder traversal)同样适用计算出当前目录下的文件总大小。</li>
</ul>
<h3 id="简单图的定义"><a href="#简单图的定义" class="headerlink" title="简单图的定义"></a><strong>简单图的定义</strong></h3><ul>
<li>不存在一个顶点的边回到自身。</li>
<li>不存在两条边连着同样的顶点。</li>
</ul>
<h3 id="图的类型"><a href="#图的类型" class="headerlink" title="图的类型"></a><strong>图的类型</strong></h3><ul>
<li>Acyclic(非循环) vs. cyclic(循环), 循环指的是第一个顶点和最后一个顶点是同一个。</li>
<li>Directed(有向) vs. Indirected(无向)</li>
<li>With edge label(a.k.a. weight)(边权重).</li>
</ul>
<h3 id="图的问题"><a href="#图的问题" class="headerlink" title="图的问题"></a><strong>图的问题</strong></h3><ul>
<li>s-t Path? 由顶点s到t是否存在路径?</li>
<li>Connectivity? 每个顶点到其它顶点是否存在路径?</li>
<li>Biconnectivity? 如果将某两个顶点的边移除，图就不是连通的了。</li>
<li>Shortest s-t Path?</li>
<li>Cycle Detection?</li>
<li>Euler(欧拉) Tour? 是否存在一个cycle使得所有边只使用一次。</li>
<li>Hamilton Tour? 是否存在一个cycle使得所有顶点只使用一次。</li>
<li>Planarity(平面化)? 能否画一张图不出现交叉的边。</li>
<li>Isomorphism? 两个图是否为同构?</li>
</ul>
<h3 id="Depth-First-Traversal"><a href="#Depth-First-Traversal" class="headerlink" title="Depth-First Traversal"></a><strong>Depth-First Traversal</strong></h3><ul>
<li>marks, 可以避免connected(v, t)–(寻找neighborhood)的无限循环。</li>
<li>marked(), 判断是否被标记</li>
<li>edgeTo[w] &#x3D; v, 添加边</li>
</ul>
<h3 id="Graph-Traversal"><a href="#Graph-Traversal" class="headerlink" title="Graph Traversal"></a><strong>Graph Traversal</strong></h3><ul>
<li>Dfs postorder, 若当前顶点的邻居都被标记时才返回当前顶点的值。</li>
<li>Dfs preorder, 若遍历到当前顶点即打印值。</li>
<li>BFS</li>
</ul>
<h3 id="Graph-API"><a href="#Graph-API" class="headerlink" title="Graph API"></a><strong>Graph API</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span>:               Create empty graph with v vertices</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span>: add an edge v-w</span><br><span class="line">  Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>:      vertices adjacent to v</span><br><span class="line">  <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>:                           number of vertices</span><br><span class="line">  <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>:                           number of edges</span><br></pre></td></tr></table></figure>

<h3 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a><strong>图的实现</strong></h3><ul>
<li>邻接矩阵(无向图)</li>
<li>邻接链表(有向图)</li>
<li>边集合, 如<code>&#123;&#123;0, 2&#125;, &#123;0, 1&#125;&#125;</code>表示顶点0分别指向1和2。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/18/CS61C-C-Note/" rel="prev" title="CS61C C Note">
                  <i class="fa fa-chevron-left"></i> CS61C C Note
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/18/Letex-Note/" rel="next" title="Letex Note">
                  Letex Note <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pishun Huang</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>-->

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","//mhchem.github.io/MathJax-mhchem/ mhchem":false,"js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
