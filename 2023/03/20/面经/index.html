<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mitmoksha.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="面试总要总结吧">
<meta property="og:type" content="article">
<meta property="og:title" content="面经">
<meta property="og:url" content="https://mitmoksha.github.io/2023/03/20/%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="Moksha&#39;s Blog">
<meta property="og:description" content="面试总要总结吧">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-03-20T09:32:17.000Z">
<meta property="article:modified_time" content="2023-04-11T14:48:17.807Z">
<meta property="article:author" content="Pishun Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mitmoksha.github.io/2023/03/20/%E9%9D%A2%E7%BB%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://mitmoksha.github.io/2023/03/20/%E9%9D%A2%E7%BB%8F/","path":"2023/03/20/面经/","title":"面经"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面经 | Moksha's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Moksha's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Moksha's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">1.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">计网&#x2F;网络编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%BB%84os"><span class="nav-number">1.2.</span> <span class="nav-text">计组&#x2F;OS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cc"><span class="nav-number">1.3.</span> <span class="nav-text">C&#x2F;C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#other"><span class="nav-number">1.4.</span> <span class="nav-text">Other</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E9%97%AE%E7%8E%AF%E8%8A%82"><span class="nav-number">1.5.</span> <span class="nav-text">反问环节</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pishun Huang</p>
  <div class="site-description" itemprop="description">Opportunities are ready for it, the more to beat action.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2023/03/20/%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="面经 | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-20 17:32:17" itemprop="dateCreated datePublished" datetime="2023-03-20T17:32:17+08:00">2023-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-04-11 22:48:17" itemprop="dateModified" datetime="2023-04-11T22:48:17+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <!-- # 面经 -->
<blockquote>
<p>面试总要总结吧 <span id="more"></span></p>
</blockquote>
<ul>
<li>自我介绍
<ul>
<li>面试官您好，我是，毕业于XXX大学计算机科学与技术专业。</li>
<li>在校期间，我独立完成了项目..., 在做项目期间遇到问题能谷歌/stackoverflow，查看相关手册，独立思考，并热衷于利用互联网与校外同学或网友交流讨论。</li>
<li>我对计算机系统方向如操作系统、计算机组成原理、计算机系统结构等相关课程感兴趣。</li>
<li>我不局限于学校所学内容，喜欢阅读原版技术书籍，文学类书籍。希望贵公司可以给我一个机会。</li>
</ul></li>
<li>进程间通信方式？
<ul>
<li>信号</li>
<li>管道。 半双工通信方式(通常指无名管道PIPE)</li>
<li>消息队列。用一个链表来存储操作系统内核中的消息，并且使用“消息队列标识符”来标识消息队列。</li>
<li>共享内存。共享内存使用mmap，不同进程的虚拟地址映射到同一处物理地址进行通信</li>
<li>套接字</li>
<li>信号量。信号值为0下调用sem_wait()则会<strong>阻塞</strong>直到信号值大于0或者是信号中断处理的调用</li>
</ul></li>
<li>说一下多态？
<ul>
<li>C++支持两种多态性：编译时多态(通过函数重载，泛型编程实现)，运行时多态(通过虚函数实现。常见通过派生类对象指针或引用, 赋给基类对象指针或引用)。</li>
<li>静态多态是指在编译期间就可以确定函数的地址，而动态多态需要等到运行时才能知道函数的地址</li>
</ul></li>
<li>了解线程池吗？
<ul>
<li>一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。<strong>这避免了在处理短时间任务时创建与销毁线程的代价</strong></li>
<li>半同步半异步模式(采用Reactor模式作为事件处理模式)：分为同步层(用于处理客户逻辑)、队列层、异步层(用于处理I/O事件)三层。同步层的<strong>主线程(异步线程，不会出现阻塞)</strong>处理工作任务并<strong>存入</strong>请求队列，<strong>工作线程(同步线程)</strong>从工作队列<strong>取出</strong>任务执行，取不到任务的工作线程进入挂起状态
<ul>
<li>缺点
<ul>
<li>主线程往请求队列中添加<strong>任务</strong>，或者工作线程从请求队列中取任务都需要对请求队列加锁保护，从而白白耗费cpu时间</li>
<li>如果客户数量较多，工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢，如果通过添加工作线程来解决这一问题，工作线程的切换也将耗费大量CPU时间</li>
</ul></li>
</ul></li>
<li>领导者/追随者模式：程序仅有一个<strong>领导者</strong>线程(负责监听I/O事件)，其他线程则都是<strong>追随者</strong>。当前领导者如果检测到I/O事件，首先要从线程池中选出新的领导者线程，然后处理I/O事件。此时新的领导者等待新的I/O事件，而原来的领导者处理I/O事件，二者实现了并发
<ul>
<li>优点：不需要在线程之间传递任何额外的数据，也无需像半同步半异步模式那样在线程之间同步请求队列的访问。</li>
<li>缺点：仅支持一个事件源集合</li>
</ul></li>
</ul></li>
<li>epoll，select，poll的区别？
<ul>
<li>select
<ul>
<li>每次调用select，都需要把fd集合从用户空间拷贝到内核空间(不论这些文件描述符是否就绪)，fd很多时开销就很大</li>
<li>每次调用select都需在内核遍历传递进来的所有fd, 线性扫描，即轮询是否有就绪的文件描述符, 效率低, 查询时间为O(n)</li>
<li>select支持的文件描述符数量太少(默认最大支持1024个)</li>
<li>fds集合不能重用</li>
</ul></li>
<li>poll
<ul>
<li>相对于select
<ul>
<li>无最大连接数限制，基于链表存储</li>
</ul></li>
<li>水平触发，报告fd后没有被处理，则下次poll时会再次报告该fd</li>
<li>解决了select第三第四个缺点</li>
</ul></li>
<li>epoll
<ul>
<li>水平触发(LT)和边缘触发(ET)
<ul>
<li>边缘触发若存在就绪的文件描述符只提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。所以ET模式下，read一个fd时，一定要把它的buffer读完，即直到read返回值小于请求值或遇到EAGAIN错误。</li>
<li>采用回调机制(使用<code>epoll_ctl</code>往内核事件表中注册)，即调用read/write处理I/O就绪事件，有信号发生则执行相应的处理函数，激活fd。</li>
<li>若用LT，若系统中有大量无需读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会降低效率</li>
</ul></li>
<li>对比select和poll省略了把fd集合从用户空间拷贝到内核空间(而是通过直接在内核空间中创建)，而且从内核空间拷贝到用户空间的fd集合是就绪fd集合(拷贝开销较小)</li>
</ul></li>
<li>三者对比：
<ul>
<li>表面上看epoll性能远优于poll和select，但在连接数少且都十分活跃的情况下，select/poll性能可能比epoll好。</li>
</ul></li>
</ul></li>
<li>红黑树说一下？
<ul>
<li>特化的平衡二叉树</li>
<li>查找、插入、删除的时间复杂度都是O(logn)</li>
<li>性质
<ul>
<li>节点是红色或者黑色的</li>
<li>根节点是黑色</li>
<li>所有叶子都是黑色</li>
<li>每个红色结点的两个子结点都是黑色</li>
<li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点</li>
</ul></li>
</ul></li>
<li>TCP，UDP的区别
<ul>
<li>TCP是面向连接的、可靠的(确认应答、超时重传、冗余ACK)、有序的(序列号)；UDP是无连接的、不可靠的、无序的</li>
<li>TCP开销比UDP大，TCP头部需要20个字节，UDP头部只需要8个字节</li>
<li>TCP有拥塞控制，UDP没有拥塞控制</li>
<li>TCP通过字节流传输，UDP中每一个包都是单独的</li>
<li>TCP<strong>提供可靠的服务</strong>，适用于可靠性要求高的场景；UDP<strong>传输效率高</strong>，适用于高速传输和实时性要求的场景</li>
<li>TCP仅支持一对一连接</li>
</ul></li>
<li>TCP是如何保证可靠的？
<ul>
<li>确认应答机制</li>
<li>重传机制(超时重传、冗余ACK)</li>
<li>序号(一个字节对应一个序号)</li>
</ul></li>
<li>UDP什么不可靠？
<ul>
<li>不保证消息交付：不确认、无超时重传</li>
<li>不保证交付顺序：不设置序列号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不需要拥塞控制：不设置客户端或网路反馈机制</li>
</ul></li>
<li>线程池中线程是什么状态
<ul>
<li>RUNNING。能够接收新任务，以及对已添加的任务进行处理</li>
<li>SHUTDOWN。不能接收新任务，但能处理已添加的任务</li>
<li>STOP。不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</li>
<li>TIDYING。当线程池中执行的任务为空时(即线程池中的当前活动线程降为0时)，STOP和SHUTDOWN状态会转换为TIDYING状态</li>
<li>TERMINATED。TYDYING执行terminated()，线程池彻底终止，变为TERMINATED状态</li>
</ul></li>
<li>UDP什么时候会出现丢包的现象
<ul>
<li>UDP报文错误。系统会将错误报文直接丢弃</li>
<li>UDP接收缓冲区不足。接收报文速率过快，UDP报文超过缓冲区或MTU的大小，</li>
<li>防火墙</li>
</ul></li>
<li>线程切换用到的硬件有什么？
<ul>
<li>寄存器组</li>
<li>程序计数器(PC)</li>
</ul></li>
<li>常见的系统调用有哪些？
<ul>
<li>文件操作
<ul>
<li>creat, read, write, open, close, link, unlink, chmod等</li>
</ul></li>
<li>过程控制
<ul>
<li>fork, wait, exit, exec</li>
</ul></li>
</ul></li>
<li>什么是内联函数？
<ul>
<li>内联函数编译时展开，省去了函数调用的开销(如将实参、局部变量、返回地址等压入栈中, 返回时还要弹栈)</li>
</ul></li>
</ul>
<h1 id="补充">补充</h1>
<h2 id="计网网络编程">计网/网络编程</h2>
<ul>
<li>https加密过程？
<ul>
<li>对称加密："和日常中的钥匙差不多"</li>
<li>非对称加密：简单来说就是有两把钥匙，一把公钥，一把私钥。使用私钥加密的内容用公钥才能解开，同理，使用公钥加密的内容使用私钥才能解开</li>
<li>https采用非对称加密和对称加密
<ol type="1">
<li>某网站拥有用于非对称加密的公钥A和私钥A'</li>
<li>浏览器首先向网站服务器发送请求，服务器发回公钥A给浏览器</li>
<li>浏览器随机生成一个对称加密的密钥X，用公钥A加密后发给服务器</li>
<li>服务器用私钥A'解密并得到密钥X</li>
<li>这样双方都有密钥X了，且其他人都不知道，之后双方所有数据都通过密钥X加密解密即可</li>
</ol></li>
<li>中间人攻击解决方案
<ul>
<li>数字证书，证明浏览器收到的公钥一定是该网站的公钥，浏览器进行验证</li>
</ul></li>
</ul></li>
<li>HTTP常见请求方法和区别？
<ul>
<li>GET
<ul>
<li>本质上用来请求服务器上的资源，资源通过一组HTTP头部和呈现数据返回给客户端。GET请求中，永远不会包含<strong>呈现数据</strong>。即GET请求只用来向服务器获取资源，而GET请求本身并不应该携带任何呈现数据</li>
<li>应用场景：
<ol type="1">
<li>登录时GET获取服务器数据库用户名和密码进行验证</li>
<li>下载文本、图片、音频时等获取服务器资源</li>
</ol></li>
</ul></li>
<li>POST
<ul>
<li>用于将实体提交到指定的资源。数据被包含在POST请求体中。POST 请求可能会导致新的资源的建立或已有资源的修改。</li>
<li>应用场景
<ol type="1">
<li>提交用户注册信息</li>
<li>提交修改的用户信息</li>
</ol></li>
</ul></li>
<li>HEAD。
<ul>
<li>和GET方法一样，只是不返回报文的主体部分(返回的响应没有具体内容)。用于确定URI的有效性及资源更新的日期时间等</li>
<li>应用场景：
<ol type="1">
<li>向服务器获取某些易过期或丢失的大型文件时，可以用HEAD方法查询是否存在</li>
</ol></li>
</ul></li>
<li>GET和POST的区别<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28586791">见</a>
<ul>
<li>GET用来从服务器中的指定资源请求数据，POST将实体提交到服务器中的指定资源中</li>
<li>GET是幂等的(没有副作用)；POST是不幂等的(不能随意多次执行)</li>
<li>浏览器可以对GET请求的数据缓存；POST请求不能被浏览器缓存(能缓存意味者比如提交一份订单不会向服务器发送请求)</li>
<li>GET可收藏为书签; POST不可收藏为书签(因为是不幂等的，比如点一个书签就下一个单是很恐怖的事)</li>
<li>POST更安全(POST用HTTP请求body携带数据，GET用url携带数据)</li>
</ul></li>
</ul></li>
<li>TCP粘包了解吗？解决方法？UDP为什么不存在粘包？
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/644658">文章</a></li>
<li>通俗的来讲"我客户端调用了两次send，怎么服务器端一个recv就都读出来了？！"</li>
<li>TCP采用Nagle算法，合并相连的小的数据包，再一次性发送，来达到提升网络传输效率的目的。但是接收方并不知道发送包合并数据包，所以就导致接收方不能还原原始的数据包</li>
<li>解决方法：
<ol type="1">
<li>禁用nagle算法，只能解决发送方的问题，粘包还可能因为接收方，而且TCP传输效率降低了</li>
<li>自定协议，将数据报分为封包(为发送的数据增加包头，包头也可以包含校验信息)和解包</li>
</ol></li>
<li>UDP不是面向流的，发送的每个数据包都是独立的</li>
</ul></li>
<li>TCP三次握手？
<ul>
<li>主要是为了确认双方接收能力和发送能力是否正常</li>
<li>第一次握手SYN=1, seq=x(客户端由CLOSED状态变为SYN_SEND), 第二次握手SYN=1, ACK=1, seq=y, ack=x+1(服务器端由LISTEN变为SYN_RCVD)，第三次握手ACK=1, seq=x+1, ack=y+1(客户端和服务器端都变为ESTABLISHED)</li>
</ul></li>
<li>为什么TCP握手不是两次？
<ul>
<li>第一次握手确定客户端的发送能力和服务器端的接收能力，第二次握手确认服务器端的发送能力，如果没有第三次握手，不能确定客户端的接收能力是否正常</li>
</ul></li>
<li>TCP四次挥手？
<ul>
<li>第一次挥手发送FIN=1，seq=u(客户端由ESTABLISHED变为FIN_WAIT1)，第二次挥手发送ACK=1，seq=v，ack=u+1（服务器端由ESTABLISHED变为CLOSE_WAIT），第三次挥手发送FIN=1，seq=w，ack=u+1(服务器端由CLOSED_WAIT变为LAST_ACK)，第四次挥手发送ACK=1，seq=u+1，ack=w+1</li>
</ul></li>
<li>为什么TCP挥手不是三次？
<ul>
<li>服务器端在收到第一次挥手时可以将ACK和FIN一并发送出去，但是服务器并不会立刻关闭socket，只有等到服务器把所有的报文发送完了(TCP的半关闭特性，这样服务器还能发送，客户端还能接收)，才能发送FIN报文，因此是四次挥手</li>
</ul></li>
<li>time_wait为什么需要2MSL？
<ol type="1">
<li>确保被动关闭TCP链接的一端能收到第四次挥手的ACK</li>
<li>避免上一次TCP连接的数据包影响到下一次的TCP连接(若服务端没有收到ACK，会重发第三次挥手的FIN包，此时客户端新建了一个到服务端的TCP连接，并且客户端使用的还是之前的端口号，那么网络延迟到达的FIN包就会被这个新的TCP连接接收到，这不是客户端希望接收到的数据)</li>
</ol></li>
<li>给定一个网址，访问过程是怎么样的？
<ol type="1">
<li>浏览器向DNS服务器请求解析该URL中的域名所定义的IP地址</li>
<li>解析出IP地址后，根据该IP地址和默认端口号80，和服务器建立TCP连接</li>
<li>浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li>
<li>服务器对浏览器请求作出响应，并把对应的HTML文本发送给浏览器</li>
<li>释放TCP连接</li>
<li>浏览器解析该HTML文本并显示内容</li>
</ol></li>
<li>网络层有哪些协议？
<ul>
<li>IP、ARP、ICMP、IGMP</li>
</ul></li>
<li>TCP第二次握手丢包处理？第三次？
<ul>
<li>客户端第一次握手发送的SYN包、以及服务器端第二次握手的发送的SYN、ACK包会发生重传。有重传最大次数的限制</li>
<li>第三次握手丢包，第二次握手SYN、ACK包会重传，如果达到最大次数限制还未收到ACK，那么就是一个半连接的状态</li>
<li>每一次重传RTO(重传超时时间)就会重新计算</li>
</ul></li>
<li>网络I/O五层模型？
<ul>
<li>阻塞I/O。执行I/O线程会被阻塞(比如socket缓冲区无数据但调用read去读)</li>
<li>非阻塞I/O。上述情况执行I/O线程不会被阻塞，返回EAGAIN或EWOULDBLOCK</li>
<li>I/O复用。在单进程/单线程中一次可以检测多个客户端的事件</li>
<li>信号驱动I/O(在多线程中不好处理)。
<ol type="1">
<li>使用linux相关的API(sigaction)，将信号处理程序的注册到服务器上，当读/写事件就绪时调用处理程序(将信号写入管道中)，然后在事件循环中解析该信号</li>
</ol></li>
<li>异步I/O</li>
</ul></li>
<li>close文件描述符后，epoll会不会把它自动从监听集合中删除呢？
<ul>
<li>如果fd的引用计数是1，close之后会自动删除</li>
</ul></li>
<li>广播和多播的区别？
<ul>
<li>广播(客户端绑定本地IP和端口，需要设置一下socket属性)只能用于局域网；多播即可用于局域网也可用于广域网</li>
<li>多播中客户端需要加入多播组才能接收到多播</li>
</ul></li>
<li>I/O多路复用是同步I/O还是异步的？
<ul>
<li>同步</li>
</ul></li>
<li>TCP的队头阻塞？</li>
<li>UDP具体使用过程？</li>
</ul>
<h2 id="计组os">计组/OS</h2>
<ul>
<li>堆栈有什么区别?
<ul>
<li>申请方式：栈由系统自动分配释放(如函数调用时存放函数的参数值，局部变量的值等)；堆需要程序员自己申请，并指明大小</li>
<li>申请效率：栈由系统自动分配，申请效率高；堆一般速度较慢，容易产生内存碎片。</li>
<li>增长方向：栈由高地址向低地址方向增长；堆由低地址向高地址方向增长</li>
<li>(堆), 空闲链表来管理，动态分配内存时空闲内存的管理：首次适配(不需要排序)、最佳适配(空闲分区按<strong>容量</strong>递增次序排序)、下次适配(在首次适配的基础上，每次分配内存时，从上次查找结束的位置开始查找)、最差适配(空闲分区按<strong>容量</strong>递减次序排序)</li>
</ul></li>
<li>静态库与动态库(共享库)？
<ul>
<li>静态库在程序的链接阶段被链接到了程序当中；而动态库是由程序运行时动态加载到进程的虚拟地址空间里的</li>
<li>库的好处：代码保密、方便部署和分发</li>
<li>静态库浪费空间和资源，包括对程序更新、部署和发布都需要重新编译(因此衍生出了动态库)</li>
<li>动态库并不会链接到目标代码中，而是在程序<strong>运行时</strong>才被载入。不同的应用程序如果调用相同的库，那么共享内存(可实现进程间资源的共享)中只需要有一份实例</li>
</ul></li>
<li>死锁？
<ul>
<li>死锁是指<strong>两个或两个以上</strong>的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种<strong>阻塞</strong>的现象</li>
</ul></li>
<li>自旋锁和互斥锁？
<ul>
<li>加锁失败的处理
<ul>
<li>互斥锁加锁失败后会进行线程切换</li>
<li>自旋锁(通过CPU提供的CAS(compare and swap), TAS原子操作)加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁</li>
<li>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁(因为线程互斥锁线程上下文切换的开销)</li>
</ul></li>
</ul></li>
<li>悲观锁和乐观锁（加场景）？
<ul>
<li>悲观锁，认为多线程同时修改共享资源的概率比较高，因此访问共享资源前总会加锁</li>
<li>乐观锁(无锁编程，并没有加锁)，反之，会先修改完共享资源后再验证这段时间内是否发生冲突，如果没有则操作完成，有则放弃本次操作。</li>
<li>乐观锁重试的成本非常高，因此只有在锁成本高且冲突概率低的场景时，才考虑使用乐观锁，如：多人在线文档</li>
</ul></li>
<li>进程和线程？区别？
<ul>
<li>进程是正在执行的程序实实例，执行程序时，内核会将程序代码载入虚拟内存中，并为程序变量分配空间，建立进程数据结构(记录如进程ID、用户ID、组ID以及终止状态等)。进程虚拟地址空间逻辑上划分为，栈区、堆区、数据区(初始化的全局和静态变量、未初始化的全局和静态变量(BSS))、文本区</li>
<li>线程共享同一数据区和堆，每个线程都有属于自己的栈，可以通过共享的全局变量进行通信，线程也能利用IPC的方式进行通信，多线程应用能从多处理器硬件的并行处理中得到性能的提升</li>
<li>区别：
<ul>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程</li>
<li>进程在执行过程中拥有独立的内存空间，而多个线程共享进程的内存空间</li>
<li>进程上下文切换的开销大，线程切换的开销小</li>
<li>进程间不会相互影响，而线程为了保证同步需要加锁</li>
</ul></li>
</ul></li>
<li>线程间的同步方式？
<ul>
<li>互斥锁、自旋锁、读写锁、条件变量</li>
</ul></li>
<li>僵尸进程和孤儿进程？
<ul>
<li>孤儿进程是指，父进程已经退出了，子进程还在运行，那么这些子进程将被init进程所收养，并由init进程对它们完成状态收集工作</li>
<li>僵尸进程是指，子进程退出了，但父进程并未调用waitpid/wait收集子进程状态信息，那么子进程的进程描述符仍然在系统中(如果有大量的僵尸进程，因为系统所能使用的进程号是有限的，就可能因为没有进程号而导致创建不了新的进程)</li>
</ul></li>
<li>死锁及避免？
<ul>
<li>死锁预防，破坏四个必要条件之一：
<ul>
<li>请求并保持，互斥条件，不可剥夺，循环等待</li>
<li>破坏
<ul>
<li>请求并保持：一次性申请在整个运行过程中需要的全部资源</li>
<li>互斥条件：无锁编程</li>
<li>循环等待：按顺序申请资源</li>
<li>不可剥夺：如果某一个进程进一步的请求资源被拒绝，则释放该进程的资源</li>
</ul></li>
</ul></li>
<li>死锁避免，银行家算法</li>
</ul></li>
<li>如何检验死锁？
<ul>
<li>死锁的检测算法通过检测有向图是否存在环来实现，从一个结点出发进行DFS，如果存在环，则出现死锁</li>
</ul></li>
<li>什么是mmap？
<ul>
<li>是一种内存映射文件的方法，将一个文件映射到虚拟地址空间，实现这样的映射关系后，进程就可以采用指针的方式读写这一段内存，对文件的操作不再需要用read、write等系统调用。</li>
<li>mmap由操作系统负责管理</li>
</ul></li>
<li>条件变量和信号量的区别？
<ul>
<li><strong>条件变量可以一次唤醒所有等待者</strong>(通过pthread_cond_broadcast唤醒所有阻塞的线程, pthread_cond_signal保证至少唤醒一条，效率较高)；而信号量不行</li>
<li>信号量可以指明有效资源的数量(是有值的)，而条件变量没有</li>
</ul></li>
<li>CAS?
<ul>
<li><code>compare and swap</code>(传入三个参数)，通过检查内存位置中的值是否等于旧值，若未发生变化，则将新值更新到内存位置中。需要搭配Volatile使用(使编译器不再优化对该变量的ld和st)</li>
</ul></li>
<li>内存管理的方式？
<ul>
<li>页式管理</li>
<li>段式管理</li>
<li>段页式管理</li>
</ul></li>
<li>字节对齐的好处？
<ul>
<li>字节对齐能够更好地对指令进行译码，同时使得访问存储器的次数更少(比如获取一个8bit数据，主存宽度为8，如果字节不对齐，取数据需要访问两次存储器)</li>
</ul></li>
<li>为什么<code>pthread_create</code>第三个传入的参数为成员函数必须得是静态的？
<ul>
<li>普通成员函数的参数会隐式存在一个默认的底层const的this参数，这就和pthread_create的第四个参数(参数列表)不匹配，编译器会报错。因为传入的是静态成员函数，若想使用成员变量，传入一个this指针即可(因为静态成员函数没有this指针)</li>
</ul></li>
<li>进程挂起态和阻塞态的区别？
<ul>
<li>挂起是主动的；阻塞是被动的</li>
<li>挂起会因为主存资源不够将进程换出到磁盘交换区；</li>
<li>挂起会占用CPU资源(收到CPU的监督，等待激活)；阻塞可以通过上下文切换，不会占用CPU</li>
</ul></li>
<li>中断和异常的区别？
<ul>
<li>中断一般由外部引起(如外部设备的中断)；异常一般由内部引起一般会重新执行处于异常的指令(如缺页异常)</li>
<li>中断会进行中断优先级的比较；异常没有</li>
</ul></li>
<li>虚拟内存的优势？
<ul>
<li>程序的保护(每个进程有自己的虚拟地址空间)和共享(进程间通过共享内存通信)</li>
<li>内存管理的便利，如malloc可以分配不连续的物理地址空间，减少内存碎片</li>
<li>使得一个进程所占用的物理空间能够超过主存储器的空间(有一部分在磁盘的交换区)</li>
<li>可以管理每个页的访问权限(进程虚拟地址空间内核数据的部分是和物理地址空间一一映射的，不需要进行VA到PA的转换)</li>
</ul></li>
<li>为什么要引入Cache？
<ul>
<li>充分利用局部性原理(时间局部性和空间局部性)</li>
<li>CPU和主存的速度相差三个数量级，指令和数据都需要到主存中去取(太慢)</li>
</ul></li>
<li>B+树和B树的区别？
<ul>
<li>B+树范围查找更方便</li>
<li>B+树只有叶子节点存储数据指针；B树叶子节点和内部节点都存储数据指针</li>
<li>节点数量相同，B+的高度比B树更低</li>
</ul></li>
</ul>
<h2 id="cc">C/C++</h2>
<ul>
<li>malloc和new的区别？
<ul>
<li>new是运算符(其中调用malloc)，malloc是库函数</li>
<li>new申请的堆大小由系统自动判断，malloc需要传递申请大小的参数</li>
<li>new返回相应类型的指针，malloc返回void*，需要强制转换</li>
<li>若new申请不到内存则会抛出异常，malloc返回NULL</li>
<li>new会调用构造函数，而malloc不会</li>
</ul></li>
<li>C++为什么构造函数不能是虚函数？
<ul>
<li>因为虚函数的地址是通过虚函数表来查找的，虚函数表由实例化对象中的vptr指向，实例化对象需要构造函数完成初始化，但此时vptr还未初始化</li>
</ul></li>
<li>虚函数表在哪？虚函数指针vptr在哪？
<ul>
<li>虚函数表在只读数据区；vptr一般在对象内存分布的第一个位置，对象的地址就是虚函数指针vptr的地址</li>
</ul></li>
<li>C++纯虚函数？
<ul>
<li>没有函数体，只有声明</li>
<li>函数声明的结尾加上=0，告诉编译器这是纯虚函数</li>
<li>含纯虚函数的类称为抽象类，之所以抽象，因为它无法实例化。</li>
</ul></li>
<li>const限定的变量可以修改吗？怎么修改？
<ul>
<li>mutable只能用来修饰类的数据成员，该成员可以在const成员函数内进行修改</li>
<li>如果是顶层const修饰的变量则不能修改</li>
<li>如果是指针变量，且用底层const修饰，那么该指针指向的值不能修改，但是指针值可以修改</li>
<li><code>const int* const p;  // 靠右的是顶层const，靠左的是底层const</code></li>
</ul></li>
<li>如何用C语言实现面向对象？
<ul>
<li>面向对象三大特性封装、继承、多态，见<a target="_blank" rel="noopener" href="https://schaepher.github.io/2020/03/12/c-oop/">文章</a></li>
<li>封装。可以将结构体的定义在<code>.c</code>文件中，<code>.h</code>中仅作结构体的声明, 这样其他文件就没办法直接访问结构体的具体内容。若想访问成员变量需要提供访问这些变量的方法,如 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">animalGetName</span><span class="params">(Animal this)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>继承。了解过C++内存模型之后很容易能知道，只需要定义"父类"作为"派生类"结构体成员(必须在第一个位置)，这样转换为父类指针时，子类结构体前面部分就是父类结构体了</li>
<li>多态。定义一个结构体作为虚函数表，在基类中增加虚表指针。虚表在构造函数中初始化，在析构函数中销毁。</li>
</ul></li>
<li>用过函数指针吗？
<ul>
<li>本质上是一个指针，指向函数。通常用于函数回调的应用场景</li>
</ul></li>
<li>C++深拷贝和浅拷贝?
<ul>
<li>若没有定义拷贝构造函数，编译器执行的是默认拷贝构造函数(浅拷贝)。如果类成员中有指针成员变量，对指针拷贝后会出现两个指针变量指向同一个内存单元，会出现两次析构，造成内存泄露，此时要采用深拷贝(即自己定义拷贝构造函数, 使拷贝后的对象指针成员有自己的内存空间)</li>
</ul></li>
<li>为什么在继承情况下析构函数要为虚函数？
<ul>
<li>如果不是虚函数则会造成内存泄露，比如多态，delete父类指针后，仅调用父类的析构函数，子类析构函数并未被调用。但如果析构函数是虚函数，则会先调用子类析构函数再调用父类虚构函数(析构函数调用的顺序)</li>
</ul></li>
<li>C语言sizeof和strlen的区别？
<ul>
<li>sizeof是运算符，用来求指定变量或变量类型所占内存空间的大小(单位为字节)，其值在编译时期就计算好了，因此只能算出静态的大小</li>
<li>strlen是库函数，用来求字符串的长度，它回去找字符串结尾的'\0'<strong>结束符</strong>(返回值不包括\0)；如果找不到，返回值会是一个不确定的值</li>
</ul></li>
<li>构造函数的顺序和析构函数的顺序原因？
<ul>
<li>个人感觉是因为对象模型</li>
</ul></li>
<li>空类有哪些函数？空类的大小？
<ul>
<li>有六个:
<ol type="1">
<li>默认构造函数</li>
<li>默认拷贝构造函数</li>
<li>默认拷贝赋值运算符</li>
<li>默认析构函数</li>
<li>取地址运算符</li>
<li>取地址运算符const</li>
</ol></li>
<li>编译器默认分配1 byte空间，编译器是支持空类实例化对象的，因此对象必须要被分配内存空间才有意义</li>
</ul></li>
<li>RAII机制？
<ul>
<li>资源获取即初始化，利用C++构造的对象最终会被析构函数销毁的原则，进行资源的释放，避免内存泄露的风险</li>
</ul></li>
<li>四种类型转换
<ul>
<li>const_cast, 消除底层const</li>
<li>static_cast, 只要不含底层const都可以使用，</li>
<li>dynamic_cast, 运行时进行类型转换的安全检查，用于基类和派生类之间的转换</li>
<li>reinterpreter_cast, 进行位模式上的强制转换</li>
</ul></li>
<li>vector在push_back的时候容量满了怎么办？
<ul>
<li>capacity会变为原来的两倍。申请一块新内存，拷贝数据，释放原内存</li>
</ul></li>
<li>vector中resize和reserve的区别？
<ul>
<li>resize是改变容器大小，且创建对象，如果改变之后的大小小于当前容器大小，则erase，否则insert</li>
<li>reserve指定容器预留的空间(改变可用空间的大小)，并未构造对象</li>
</ul></li>
<li>map和unordered_map的区别？
<ul>
<li>map的底层是红黑树，存储的键是有序的。缺点:空间的开销</li>
<li>unordered_map底层是哈希表，存储的键是无序的。缺点：哈希表的建立费时</li>
</ul></li>
<li>C++常用<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/cpp">设计模式</a>？
<ul>
<li>TODO</li>
<li>工厂模式。抽象工厂定了用于创建不同产品的接口，但实际的创建工作留给了具体的工厂类</li>
<li>单例模式
<ol type="1">
<li>保证一个类只有一个实例(控制某些共享资源的访问权限，如数据库、文件)，因此将其构造和虚构函数用private修饰</li>
<li>为该实例提供一个全局访问的节点(使用一个静态成员变量存储指向该实例的指针，再用静态成员函数获取该静态成员变量)</li>
</ol></li>
<li>代理模式</li>
<li>策略模式</li>
<li>原型模式</li>
<li>模板模式</li>
</ul></li>
<li>对象的什么函数不能被声明为虚函数？
<ul>
<li>非成员函数</li>
<li>静态成员函数。该类的所有对象都共享这份代码，<strong>不能被继承</strong>，没有动态绑定的必要性</li>
<li>内联成员函数。内联函数在编译期展开，virtual函数体现的是运行时机制</li>
<li>构造函数(上面有说过)</li>
<li>友元函数。本质上是因为C++不支持友元的继承</li>
</ul></li>
<li>指针和引用的区别？
<ul>
<li>指针是存储变量地址的变量，引用是变量的别名</li>
<li>引用定义时必须初始化，而指针可以不必初始化</li>
<li>指针可以改变指向的存储单元，而引用初始化之后就<strong>不能改变了</strong></li>
<li><strong>sizeof</strong>指针变量可以得到一个字长的大小(32/64位机器)，而引用得到所指变量的大小</li>
<li>指针的自增标识指向下一个地址单元，而引用的自增表示引用变量值的增减</li>
</ul></li>
<li>哪几种情况必须用到初始化列表？
<ul>
<li>const成员变量，不能赋值</li>
<li>引用成员变量，不能赋值</li>
<li>类成员没有默认构造函数的类类型</li>
<li>如果类存在继承关系，派生类必须在其初始化列表中调用直接基类的构造函数</li>
</ul></li>
<li>struct和class的区别？
<ul>
<li>struct类成员默认是public，class是private(作用域限定)</li>
<li>struct默认是public继承，而class是private</li>
</ul></li>
<li>常见C++四大内存分区
<ul>
<li>代码区</li>
<li>静态/全局数据区。包括常量区、静态区、全局区</li>
<li>栈区</li>
<li>堆区</li>
<li>其中const修饰的全局变量保存在代码区，const修饰的局部变量保存在栈区</li>
</ul></li>
<li>迭代器失效的情况？解决方案？
<ul>
<li>在迭代时调用erase()、insert()、容器扩容(原来容器的迭代器失效)等</li>
<li>数组型数据容器(如vector、deque等，因为是连续分配的内存，所有元素的迭代器都会失效, 都向前/后移动了一个位置)</li>
<li>链表型数据容器(如list，因为是链式存储，插入和删除不会对其他迭代器造成影响)</li>
<li>树型数据容器(如map、set，删除、插入元素不会对其他元素造成影响，因此只是当前被删除的迭代器失效)</li>
<li>解决方法：
<ul>
<li><strong>erase会返回当前删除的迭代器的下一个迭代器</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里想把大于2的元素都删除</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=q.<span class="built_in">begin</span>();it!=q.<span class="built_in">end</span>();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      it=q.<span class="built_in">erase</span>(it); <span class="comment">// 这里会返回指向下一个元素的迭代器，因此不需要再自加了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>++i和i++是原子操作吗？线程安全？
<ul>
<li>不是，++i先自加再赋值，i++先赋值再自加</li>
<li>如果i是局部变量，那就是线程安全的(每个线程有自己的栈)</li>
</ul></li>
<li>宏和inline的区别
<ul>
<li>宏
<ul>
<li>没有类型检测，不安全，如： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sums(a,b) a+b  <span class="comment">// 这时候调用2*sums(a,b)会被解析为 2*a+b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sums(a,b) (a+b)  <span class="comment">// 这时候调用会被解析为2*(a+b)</span></span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>inline时将函数展开，减少函数调用的开销，编译器会进行安全检查</li>
</ul></li>
<li>C++重写和重载的区别？
<ul>
<li>重写
<ul>
<li>被重写的函数必须是virtual的(C++对象模型虚函数表)</li>
<li>函数名称、参数列表、参数个数、返回值类型都一致</li>
<li>访问修饰符(private等)可以不同</li>
</ul></li>
<li>重载
<ul>
<li><strong>在一个类中</strong>(相同作用域)</li>
<li>函数名称相同</li>
<li>参数个数、参数类型、不同</li>
</ul></li>
</ul></li>
<li>emplace_back vs. push_back？
<ul>
<li>push_back会先创建一个元素然后再将这个元素拷贝/移动到容器的尾部(push_back会优先调用移动构造，如果没有才调用拷贝构造)；而emplace_back直接在容器尾部直接构造，省去了拷贝/移动的过程。</li>
</ul></li>
<li>预处理阶段做的事情
<ul>
<li>使用<code>gcc -E</code>，生成<code>.i</code>文件，将注释删去，将将头文件和宏进行展开和替换</li>
</ul></li>
<li>include防范？
<ul>
<li>为了避免重复声明</li>
</ul></li>
<li>静态成员变量/函数的意义？
<ul>
<li>使用静态成员变量实现<strong>多个对象之间的数据共享</strong>不会破坏隐藏的原则，保证了安全性还可以节省内存</li>
<li>编译器会在编译一个普通成员函数时，隐式地加上一个this指针。静态成员函数中没有this指针，因此只能访问静态成员变量</li>
<li>静态成员变量/函数声明时要加<code>static</code>，定义时不需要，编译器会去找声明</li>
<li><strong>静态成员不能在类内初始化，只能在类外初始化</strong>，<code>类型 类名::变量名 = 值</code></li>
</ul></li>
<li>虚函数和纯虚函数的区别？
<ul>
<li>纯虚函数当前抽象基类的子类必须对该纯虚函数进行覆写；虚函数可以不需要</li>
<li>纯虚函数没有函数体；虚函数有函数体</li>
<li>纯虚函数在声明结尾加上=0 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚函数声明</span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 纯虚函数声明</span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>构造函数和析构函数有返回值吗？
<ul>
<li>它们都没有返回值</li>
</ul></li>
<li>命名空间的作用？
<ul>
<li>处理常见的同名冲突，实际上是由程序设计者命名的内存区域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开</li>
</ul></li>
<li>C++中this指针什么情况下必须要用？
<ul>
<li>重载赋值运算符通常返回<code>*this</code></li>
<li>把自己作为函数实参。</li>
</ul></li>
<li>#define INT 5是什么类型？
<ul>
<li>预处理阶段不会进行类型检查(编译器做的事)，因此它没有类型</li>
</ul></li>
<li>NULL和nullptr的区别 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0  <span class="comment">// C++定义的NULL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)  <span class="comment">// C定义的NULL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在C++中使用<code>nullptr(std::nullptr_t)</code>能隐式转换为其他类型的指针，但C++中不能将<code>void*</code>指针隐式转换为其他类型(反过来是可以的)</li>
<li>避免出现重载时的二义性，比如一个函数的参数为<code>void*</code>，另一个函数的参数为<code>int</code>，这时候编译器就会报错</li>
<li>模板的类型推导会将<code>NULL</code>推导为<code>long int</code></li>
</ul></li>
<li>C++模板类和普通类的区别？
<ul>
<li>普通类都是在头文件中声明，在源文件中是实现；而模板类必须都放在头文件中</li>
<li>模板类和普通类都可以在类体中定义，但模板类在类体外定义要用函数模板</li>
</ul></li>
<li>函数默认参数？
<ul>
<li>在声明时指定，定义时不指定</li>
</ul></li>
</ul>
<h2 id="other">Other</h2>
<ul>
<li>团队遇到分歧怎么办？
<ul>
<li>在分歧中寻找共识，通过共识化解分歧</li>
<li>想想各自的出发点</li>
<li>承认冲突并找到解决方案</li>
</ul></li>
</ul>
<h2 id="反问环节">反问环节</h2>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/03/20/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="prev" title="网络系统编程笔记">
                  <i class="fa fa-chevron-left"></i> 网络系统编程笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/23/IC-note/" rel="next" title="IC note">
                  IC note <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pishun Huang</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>-->

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","//mhchem.github.io/MathJax-mhchem/ mhchem":false,"js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"MITMOKSHA","repo":"MITMOKSHA.github.io","client_id":"1bc801cf709af0ddca6a","client_secret":"10ac0f160a26730afadf94d39d045789894a180a","admin_user":"MITMOKSHA","distraction_free_mode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"b89b4a040229b38fdcca71ed7777849c"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
