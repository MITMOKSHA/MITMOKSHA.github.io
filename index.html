<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mitmoksha.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Opportunities are ready for it, the more to beat action.">
<meta property="og:type" content="website">
<meta property="og:title" content="Moksha&#39;s Blog">
<meta property="og:url" content="https://mitmoksha.github.io/index.html">
<meta property="og:site_name" content="Moksha&#39;s Blog">
<meta property="og:description" content="Opportunities are ready for it, the more to beat action.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Pishun Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mitmoksha.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Moksha's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Moksha's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Moksha's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pishun Huang</p>
  <div class="site-description" itemprop="description">Opportunities are ready for it, the more to beat action.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/17/csappCh1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/17/csappCh1/" class="post-title-link" itemprop="url">CSAPP Ch.1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-17 23:14:00" itemprop="dateCreated datePublished" datetime="2022-05-17T23:14:00+08:00">2022-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:24:09" itemprop="dateModified" datetime="2022-05-18T09:24:09+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP-Reading/" itemprop="url" rel="index"><span itemprop="name">CSAPP Reading</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a><strong>计算机系统漫游</strong></h1><ul>
<li>计算机系统是由<strong>硬件</strong>和<strong>系统软件</strong>组成的</li>
<li>源程序中由<code>ASCII</code>字符构成的文件称为<strong>文本文件</strong>, 所有其他文都称为<strong>二进制文件</strong><br><img src="/../images/img-2022-05-17-23-21-05.png"></li>
<li>预处理阶段预处理器根据以字符<code>#</code>开头的命令，修改原始C程序，读取系统头文件的内容，并把它直接插入程序文本中，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">--</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li>
<li><code>字(word)</code>: 总线传送定长字节块的大小</li>
<li>磁盘驱动器(HDD)简单说其实就是磁盘</li>
<li>适配器: 插在主板插槽的卡(比如图形适配器，显示屏); 控制器：I&#x2F;O设备本身或系统主板上的芯片组<br><img src="/../images/img-2022-05-17-23-29-59.png"></li>
<li>在键盘上读取<code>hello</code>命令。通过将数据读取到<code>KBDR</code>中(中间涉及到ASCII到Binary的转换)，再将<code>KBDR</code>中的数据存入主存中。整个过程需要CPU参与，引出了概念<code>可编程I/O</code><br><img src="/../images/img-2022-05-17-23-34-32.png"></li>
<li>因此也延伸出了优化的方案(使用<code>DMA</code>)<br><img src="/../images/img-2022-05-17-23-35-01.png"></li>
<li>将字符串显示到显示器上。通过将数据写入到<code>DDR</code>中(要将Binary转换为ASCII)，再将<code>DDR</code>中的数据显示到图形适配器上</li>
<li><code>Cache</code>产生的原因：随着时间的推移<code>DRAM</code>的性能和<code>Disk</code>相差三个数量级; Cache充分利用了<strong>局部性原理</strong>。</li>
<li><code>Posix标准</code>：标准化<code>Unix</code>的开发</li>
<li><code>上下文切换</code>涉及到<code>PC</code>和<code>寄存器组</code>的Save和Restore<br><img src="/../images/img-2022-05-17-23-40-48.png" alt="存储器层次结构"><br><img src="/../images/img-2022-05-17-23-44-21.png" alt="进程虚拟地址空间"></li>
<li>进程虚拟内存中的内容存储在磁盘上，而主存作为磁盘的缓存, 造成<code>容量又大速度又快</code>的假象。</li>
<li>Unix I&#x2F;O的读写系统调用为<code>逻辑读写</code></li>
<li>通过<code>网络适配器</code>可以在不同主机之间在交换主存中的数据</li>
<li><code>Amdahl&#39;s law</code>: $S&#x3D;\frac{1}{(1-\alpha)+\alpha&#x2F;k}$, 其中$S$为加速比, $\alpha$为所需执行时间占总时间的比例, $k$为该部分性能提升的比例</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/16/NJU-OS-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/NJU-OS-Note/" class="post-title-link" itemprop="url">NJU OS Note</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-16 18:14:19" itemprop="dateCreated datePublished" datetime="2022-05-16T18:14:19+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:16:11" itemprop="dateModified" datetime="2022-05-18T09:16:11+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Science-Notes/" itemprop="url" rel="index"><span itemprop="name">Computer Science Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="NJU-OS-Note"><a href="#NJU-OS-Note" class="headerlink" title="NJU OS Note"></a>NJU OS Note</h1><ul>
<li><code>ld</code>, GNU Linker</li>
<li><code>gcc</code>支持对汇编代码的预编译(还会定义__ASSEMBLER__宏)。</li>
<li><code>wget url</code>下载URL的文件内容。</li>
<li><code>gcc -E foo.c</code>在预处理阶段后停止。</li>
<li><code>volatile</code>声明的变量不能优化。</li>
<li><code>asm</code>是<code>GNU</code>的拓展。可以从汇编程序中读取和写入C变量。</li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html"><code>Extended asm</code></a>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asm asm-qualifiers ( AssemblerTemplate  </span><br><span class="line">               :OutputOperands  </span><br><span class="line">               [:InputOperands[: Clobbers]]) </span><br></pre></td></tr></table></figure>
<ul>
<li>Qualifier: volatile, inline, goto。</li>
<li>AssemblerTemplate: 包含汇编程序指令的文字字符串。</li>
<li>OutputOperands(允许使用空列表): <code>[[asmSymbolicName]] constraint(c_variablename)</code>，输出约束必须以<code>=</code>作为开头, 常见的约束<code>r</code> for register, <code>m</code> for memory。约束后还需要有个C的变量名，括号是语法的必须部分。</li>
<li>InputOperands(允许使用空列表)。</li>
<li>eample  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> src = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dst;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;mov %1, %0\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;add $1, %0&quot;</span></span><br><span class="line">    : <span class="string">&quot;=r&quot;</span> (dst) </span><br><span class="line">    : <span class="string">&quot;r&quot;</span> (src));</span><br></pre></td></tr></table></figure></li>
<li>Clobbers: <code>memory</code>( Further, the compiler does not assume that any values read from memory before an asm remain unchanged after that asm;), <code>Compiler barrier</code>.</li>
</ul>
</li>
<li><code>strace</code>追踪当前程序或者进程执行过的系统调用。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/16/ICS-Lab-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/ICS-Lab-Note/" class="post-title-link" itemprop="url">ICS Lab Note</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-16 18:08:09" itemprop="dateCreated datePublished" datetime="2022-05-16T18:08:09+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:15:52" itemprop="dateModified" datetime="2022-05-18T09:15:52+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Science-Notes/" itemprop="url" rel="index"><span itemprop="name">Computer Science Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="ICS-Lab-Note"><a href="#ICS-Lab-Note" class="headerlink" title="ICS Lab Note"></a>ICS Lab Note</h1><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a><strong>lab1</strong></h2><ol>
<li>实际上通过编写发现，为了编写方便，我将ASCII模板0和存放文件起始地址的位置调换(即0x3013和0x3012)，并将文件的内容连续(consecutively)放在从0x3013处的开始；随之变动的也有将LDR R3, x3013改为LEA R3, x3013，最开始没有注意到这个问题debug发现其实x3013里我设的值为’H’即x0048，按照原来的执行，它会提取x0048处的内容，因此单步执行到这行机器代码直接halt掉了，且估计是因为ACV异常导致的结果。</li>
<li>编写bin文件转化为obj之后调试发现，bin文件第一行的内容并没有被显示在主存中。因此可以推断第一行为程序执行的起始地址(可能是因为我没有仔细看实验手册吧:)。</li>
<li>fgets执行成功文件指针自动后移; 格式化写入文件fprintf;</li>
<li>a+: 以追加、可读写的方式打开文件，允许读写。若进行读操作，则从头开始读；若进行写操作，则将内容添加在末尾。若文件不存在，则创建文件。打开成功后返回文件指针，位置指针指向文件头部。</li>
</ol>
<ul>
<li>完成时间3h</li>
</ul>
<h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a><strong>lab2</strong></h2><ol>
<li>Bug: Loop的次数不是所期望的3，因此需要改变影响loop次数的BR，将BRzp改为BRp，即可达到所期望的3次，结果为30.</li>
<li>Bug: 应该把LDR改为LEA这样就可以提取存储单元的内容，而不是提取存储单元内容的内容(相当于间接寻址)，修改过后就为正确的了。</li>
<li>Bug: x300C和x300B行应该调换位置。因为实际上R3寄存器的设置是作为loop的次数，同时LDR同样也可以生成条件码，这会导致意想不到的错误(比如对应文件地址里存储的是负数或者0就会终止循环得到意想不到的结果)</li>
<li>Bug: 如果x3400地址单元内存的值为0，那么就会出现死循环的问题，单步调试之后发现在x3003处的BR指令并没有判断取数为0的情况，因此我做出了这样的调整。在x3003处将BRn改为BRnz</li>
</ol>
<ul>
<li>完成时间2h</li>
</ul>
<h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a><strong>lab3</strong></h2><ol>
<li>将输入的 大写&#x2F;小写字母 转化为 小写&#x2F;大写字母 输出到显示屏上，如果是别的字符则输出error.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">       .ORIG  x3000           ; program start at x3000</span><br><span class="line">       LD     R2, TERM        ; Load negative of ASCII 7</span><br><span class="line">AGAIN  TRAP   x23             ; input syscall</span><br><span class="line">; judge the range of R0</span><br><span class="line">       LD     R5, UPMIN       </span><br><span class="line">       ADD    R5, R5, R0     </span><br><span class="line">       BRn    OTH             ; if input &lt; A, jump to OTH</span><br><span class="line">       LD     R5, UPMAX      </span><br><span class="line">       ADD    R5, R5, R0      </span><br><span class="line">       BRnz   U2L             ; if input &lt;= Z, jump to U2L</span><br><span class="line">       LD     R5, LOWMIN      </span><br><span class="line">       ADD    R5, R5, R0      </span><br><span class="line">       BRn    OTH             ; if input &lt; a, jump to OTH</span><br><span class="line">       LD     R5, LOWMAX      </span><br><span class="line">       ADD    R5, R5, R0</span><br><span class="line">       BRnz   L2U             ; if input &lt;= z, jump to L2U</span><br><span class="line">       BR     OTH             ; the rest range of input.</span><br><span class="line">U2L    LD     R3, ASCII       ; load difference value</span><br><span class="line">       BR     OUTPUT</span><br><span class="line">L2U    LD     R3, ASCII2</span><br><span class="line">;</span><br><span class="line">; handle alpha</span><br><span class="line">;</span><br><span class="line">OUTPUT ADD    R1, R2, R0      ; if input 7, jump to halt.</span><br><span class="line">       BRz    EXIT            ; exit</span><br><span class="line">       ADD    R0, R0, R3      ; trasforming u2l/l2u</span><br><span class="line">       TRAP   x21             ; output syscall</span><br><span class="line">       BR     AGAIN           ; unconditional loop</span><br><span class="line">;</span><br><span class="line">; if the character not an alpha, handle from there</span><br><span class="line">;</span><br><span class="line">OTH    ADD    R1, R2, R0</span><br><span class="line">       BRz    EXIT</span><br><span class="line">       LEA    R3, ERROR       ; load prompt pointer</span><br><span class="line">LOOP   LDR    R0, R3, #0      ; load character</span><br><span class="line">       BRz    AGAIN</span><br><span class="line">       TRAP   x21             ; it may change the value in R1</span><br><span class="line">       ADD    R3, R3, #1      ; load next character</span><br><span class="line">       BR     LOOP</span><br><span class="line">TERM   .FILL  xFFC9           ; xFFC9 is negative of ASCII 7(x0037)</span><br><span class="line">ASCII  .FILL  x0020           ; The difference value between upper case and lower case</span><br><span class="line">ASCII2 .FILL  xFFE0           ; xFFE0 is negative of -20</span><br><span class="line">UPMIN  .FILL  xFFBF           ; xFFBF is negative of ASCII A</span><br><span class="line">UPMAX  .FILL  xFFA6           ; xFFA6 is negative of ASCII Z</span><br><span class="line">LOWMIN .FILL  xFF9F           ; xFF9F is negative of ASCII a</span><br><span class="line">LOWMAX .FILL  xFF86           ; xFF86 is negative of ASCII z</span><br><span class="line">EXIT   TRAP   x25             ; halt</span><br><span class="line">ERROR  .STRINGZ &quot;Input character error!&quot;</span><br><span class="line">       .END</span><br></pre></td></tr></table></figure></li>
<li>gets函不包含换行符(<code>\n</code>)</li>
</ol>
<ul>
<li>完成时间2h</li>
</ul>
<h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a><strong>lab4</strong></h2><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>1.编写完程序之后发现有报错log, 于是配合上vscode+vim插件可以直接在代码中定位错误信息，将报错log(主要时label名字输入错误)全部修改正确。</p>
<p>2.汇编成功后，debug发现书上有两个小错误，最开始以为x-0A是0x0A但后面发现并不是，而是0x0A的取补数来判定值, 还有x-03和x-09也是一样的。后来ADD后面只能跟5个Bit的值，遂用#-10表示,因此改为:</p>
<p><img src="https://pic4.zhimg.com/80/v2-812c175efddbad0e4dc2b76e381e3064.png" alt="Image"></p>
<p>3.debug发现这一段条件码判断的有问题，应该是照着敲的时候敲错了太粗心了…!第一步和负的ASCII的0比较应该是判断BRn才为NOT A integer, 事实上我写成了BRp才造成了这样的错误，而且还漏写了大于9的边界判断，下面是Debug错误图:</p>
<p><img src="https://pic4.zhimg.com/80/v2-90401b2396aac9499e8c7c5c69eebe6a.png" alt="Image"><img src="https://pic4.zhimg.com/80/v2-790558c0ce2a716b2a8942c46c83b599.png" alt="Image"></p>
<p><strong>正确</strong>应该改为:</p>
<p><img src="https://pic4.zhimg.com/80/v2-3cd596729cfb00576d353da469fe8e5b.png" alt="Image"></p>
<p>4.输入+测试会crash，随后我设置断点缩小了BUG的范围，找到了对应的位置，最后确定是因为这一段代码输入错，可以能是因为重复恢复R5寄存器，也可能是以为忘记恢复R7寄存器的值。crash的图片:</p>
<p><img src="https://pic4.zhimg.com/80/v2-bae4d8bc8edf58837b97b96dcdd5430a.png" alt="Image"></p>
<p>错误代码的图片:</p>
<p><img src="https://pic4.zhimg.com/80/v2-dce739185fc63a23b13334f0a3f8b0b7.png" alt="Image"></p>
<p>改正了这部分代码, 恢复正常:</p>
<p><img src="https://pic4.zhimg.com/80/v2-e9bccf6f55cf7287a06b29ea514e85da.png" alt="Image"></p>
<p>5.debug排错技巧，先在某个特定的函数位置打好断点再看源代码是否有误，并屏感觉有不合理的地方对照课本，最后走一遍单步调试.</p>
<p>6.仔细查看这行代码并没有实际的意义，于是对照可课本发现确实是敲错了:</p>
<p><img src="https://pic4.zhimg.com/80/v2-24cbd8d35456387479b36ffc0ab9c213.png" alt="Image"></p>
<p>7.查看了Display的源代码发现显示的其实是栈顶元素(一个符号位三个数字)，也就是刚输入的ASCIIBUFF。衍生出了一个问题，如果上上次输入的是一个3位数字，且上次输入的是一个2位数字，那么ASCIIBUF的2位数字会和3位数字的百位一起显示吗？因为实际上在ASCIItoBinary函数中会覆盖掉之前的内容。</p>
<p>8.测试了一下栈内一共可以存10个元素，于是看了一下地址分布，又确认了一下确实是这样(1 stackbase location + 9 stackmax locations):</p>
<p><img src="https://pic4.zhimg.com/80/v2-c16ad818c2c0113c2c065f26ec96a56c.png" alt="Image"></p>
<p>9.实际上POP和PUSH操作在发生underflow&#x2F;overflow时是不会移动栈顶指针的，而是直接打印信息改变寄存器R5的值然后返回:</p>
<p><img src="https://pic4.zhimg.com/80/v2-e64de1d0088a29d4552ccaac0bf33758.png" alt="Image"></p>
<p>10.每一次ADD操作弹栈取两个操作后求和，会检查值是否超出范围([-999, 999]).</p>
<p>11.MULT操作专门有一个寄存器存放sign bit, 方便两个操作数进行累加来完成乘法。还有如果其中有一个操作数为0则直接将这个值压入栈中，退出乘法操作。而且乘法只需要将作为累加次数的乘数的值变为正数即可，最后根据符号位取结果的时候，可以发现四种结果都是正确的。</p>
<p>12.发现有个BUG，在console中输入一个数字之后又backtrace将它清除再输入一个数回车就会出现Not a integer的报错，看了一下它的VALUE_LOOP的实现发现确实是有这么一个缺陷。</p>
<p>13.PUSH和POP默认操作的都是R0寄存器</p>
<p>14.查看clear函数源码，发现仅仅是将栈顶指针初始化为空(即初始化为stackbase再-1)</p>
<p>15.又发现一个BUG：输入百位数Display显示乱码，进而导致相加的结果出错。有两个原因：1.push值到栈中出错(PUSH_VALUE)A2B。2.或者B2A的过程中出错。经过定位之后发现输入到ASCIIBUFF中的三个数字是完整的存在里面的，难道是转换出错？开始往Display函数上打断点，可以发现在单步执行通过Binary2ASCII前后ASCIIBUF的值发生了变化，经过之前:</p>
<p><img src="https://pic4.zhimg.com/80/v2-f8f064c63aee48c35230e6c2f40972f1.png" alt="Image"><br><img src="https://pic4.zhimg.com/80/v2-fc118d61d731129e1ba81f336f17015a.png" alt="Image"></p>
<p>经过之后，可以看出ASCIIBUFF中的值已经发生了变化：</p>
<p><img src="https://pic4.zhimg.com/80/v2-943b0e7832ae7bd4226d27f845a828d6.png" alt="Image"><br><img src="https://pic4.zhimg.com/80/v2-ac2006c2c1cf9c2b19d0dfb80e4e07ca.png" alt="Image"></p>
<p>接下来又试了一下两位数，经过这个函数后显示的结果是正确的，难道是课本代码出错？？？Not！又进一步精确了错误的位置，发现如果是两位数，在发现在栈中的值就是所输入的两位数的值，而三位数的时候就变成了随机的值，因此可以推断问题不是出在B2A而是处在A2B往栈中存的值不正确导致最后Display从栈中取二进制数时打印出错!(刚好就只剩A2B的源代码没看哈哈哈)。以下是输入123，栈中值错误：</p>
<p><img src="https://pic4.zhimg.com/80/v2-17b94c6024eebac989a7adaf9ec1b6e4.png" alt="Image"></p>
<p>仔细阅读了A2B的源代码定位到了错误(从十六进制转化为十进制时使用MASK的对象应该是R4,也就是刚LD过来的内容):</p>
<p><img src="https://pic4.zhimg.com/80/v2-c69df62813b011e7fb9b5c15daff2404.png" alt="Image"></p>
<p>修改过后，成功了！:</p>
<p><img src="https://pic4.zhimg.com/80/v2-634e98e287e5de31e3de86f7f7de08a7.png" alt="Image"></p>
<p>16.最后说一下A2B的设计，我本以为是数位的ASCII码来和’0’做减，没想到是和x000F的MASK取模也行，太妙了！</p>
<ul>
<li>完成时间5h</li>
</ul>
<h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>1.难受了windows下是carriage return + linefeed, 我提取的字符是一位….我很难受。遂换一个策略</p>
<p>2.scanf后面接个getchar吸收换行符</p>
<ul>
<li>完成时间5h</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/16/CS186-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/CS186-Note/" class="post-title-link" itemprop="url">CS186 Note</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-16 18:07:44" itemprop="dateCreated datePublished" datetime="2022-05-16T18:07:44+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:15:40" itemprop="dateModified" datetime="2022-05-18T09:15:40+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Science-Notes/" itemprop="url" rel="index"><span itemprop="name">Computer Science Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="CS186-Note"><a href="#CS186-Note" class="headerlink" title="CS186 Note"></a><strong>CS186 Note</strong></h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a><strong>SQL</strong></h2><ul>
<li><code>SELECT</code>后加<code>DISTINCT</code>可以将重复的tuple去掉。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tbl<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="NULL-value"><a href="#NULL-value" class="headerlink" title="NULL value"></a>NULL value</h3><ul>
<li>任何以<code>NULL</code>值作为操作数的算数运算操作结果都为<code>NULL</code>，所以通常需要<code>IS NULL</code>或<code>IS NOT NULL</code>来提前判断。</li>
<li><code>NULL</code> is <strong>falsey</strong>.</li>
</ul>
<h3 id="Aggregate-funtion"><a href="#Aggregate-funtion" class="headerlink" title="Aggregate funtion"></a>Aggregate funtion</h3><ul>
<li>SUM, AVG, MAX, MIN, COUNT。</li>
<li>输入是一个列，输出是一个值。</li>
<li>每个aggregate都忽略掉<code>NULL</code>, 除了<code>COUNT(*)</code>之外。注意<code>COUNT&lt;column&gt;</code>返回具体列非空值的数量。</li>
<li>注意分组后COUNT(*)计算的是当前组的行数。<br><img src="https://pic4.zhimg.com/80/v2-e51e235585811be04b61e04c12a2d1e0.png" alt="Image"></li>
</ul>
<h3 id="Groups-of-Data"><a href="#Groups-of-Data" class="headerlink" title="Groups of Data"></a>Groups of Data</h3><ul>
<li>GROUP BY</li>
<li>将当前列中属性值相同的行放入一个组中, 该组中的所有行要合并为一行。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tbl<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span> −− <span class="keyword">Filter</span> <span class="keyword">out</span> <span class="keyword">rows</span> (before <span class="keyword">grouping</span>) .</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>; −− <span class="keyword">Filter</span> <span class="keyword">out</span> <span class="keyword">groups</span> (after <span class="keyword">grouping</span>) .</span><br></pre></td></tr></table></figure></li>
<li>WHERE用于过滤行，而HAVING用来过滤组。</li>
</ul>
<h3 id="有问题的查询语句"><a href="#有问题的查询语句" class="headerlink" title="有问题的查询语句"></a>有问题的查询语句</h3><ul>
<li>投影的属性<code>AVG(num dogs)</code>是只有一个值，但是<code>age</code>属性中有很多值。因此形成的表中必须有同样数量的行，error。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, <span class="built_in">AVG</span>(num_dogs)</span><br><span class="line"><span class="keyword">FROM</span> Person;</span><br></pre></td></tr></table></figure></li>
<li>将age分为一个组之后，无法合并为一行(因为age在当前组中含单个数字，但num_dogs含多个数字)，error。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, num_dogs</span><br><span class="line"><span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Order-By"><a href="#Order-By" class="headerlink" title="Order By"></a>Order By</h3><ul>
<li>默认是升序排列的，要想降序排列需要具体列名(属性名)后加关键字DESC。下面语句列num_dogs按升序排列，但name按降序排列。我们先对num_dogs排序再对num_dogs中相同的行进行name降序排序。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, num_dogs</span><br><span class="line"><span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num_dogs ,name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><ul>
<li>限定返回的行数</li>
</ul>
<h3 id="语句编写顺序"><a href="#语句编写顺序" class="headerlink" title="语句编写顺序"></a>语句编写顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>tbl<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>columns<span class="operator">&gt;</span></span><br><span class="line">LIMIT <span class="operator">&lt;</span>num<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><ul>
<li>cross join(笛卡尔积), filter在笛卡尔积过后的表中寻找对应的行。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>inner join，和上述语句输出是一样的结果。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line">    <span class="keyword">ON</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 除了加上共有的属性值行...</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 加上左侧表中特有的属性值行，当前右侧表中对应的不存在的属性用<span class="keyword">NULL</span>代替。</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 加上右侧表中特有的属性值行。</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span>, 加上两侧表中特有的属性值行。</span><br><span class="line"><span class="operator">-</span> <span class="keyword">natural</span> <span class="keyword">join</span>, <span class="operator">*</span><span class="operator">*</span>隐式地<span class="operator">*</span><span class="operator">*</span>将属性值一致的列<span class="keyword">inner</span> <span class="keyword">join</span>, 比如在当前例子中，将会自动包含<span class="keyword">join</span> <span class="keyword">condition</span>: courses.num <span class="operator">=</span> enrollment.num。</span><br><span class="line">    ``` <span class="keyword">sql</span></span><br><span class="line">    <span class="keyword">SELECT</span> ∗</span><br><span class="line">    <span class="keyword">FROM</span> courses <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> enrollment;</span><br></pre></td></tr></table></figure></li>
<li>ON后跟的是连接的predicate。</li>
</ul>
<h3 id="Name-conflict"><a href="#Name-conflict" class="headerlink" title="Name conflict"></a>Name conflict</h3><ul>
<li>通过<code>列名.属性</code>来避免命名冲突。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ∗</span><br><span class="line"><span class="keyword">FROM</span> courses <span class="keyword">INNER</span> <span class="keyword">JOIN</span> enrollment</span><br><span class="line"><span class="keyword">ON</span> courses.num <span class="operator">=</span> enrollment.num;</span><br></pre></td></tr></table></figure></li>
<li>通过AS来指定别名。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> courses <span class="keyword">AS</span> a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> enrollment <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> A.num <span class="operator">=</span> B.num;</span><br></pre></td></tr></table></figure>
<h3 id="Subqueries"><a href="#Subqueries" class="headerlink" title="Subqueries"></a>Subqueries</h3></li>
<li>Notes中举得例子是，需要找到课程的学生人数大于所有课程的平均学生人数的课程。如果单纯进行AVG处理，那么想要获取的行将会被过滤掉了，这时候就需要用到子查询了。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> num</span><br><span class="line"><span class="keyword">FROM</span> enrollment</span><br><span class="line"><span class="keyword">WHERE</span> students <span class="operator">&gt;=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(students)</span><br><span class="line">    <span class="keyword">FROM</span> enrollment;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Set-Operators"><a href="#Set-Operators" class="headerlink" title="Set Operators"></a>Set Operators</h3></li>
<li>ANY, ALL, UNION, INTERSECT, DIFFERENCE, IN.</li>
</ul>
<h3 id="Correlated-Subqueries"><a href="#Correlated-Subqueries" class="headerlink" title="Correlated Subqueries"></a>Correlated Subqueries</h3><ul>
<li>子查询可以嵌套在WHERE中，也可以嵌套在FROM中。</li>
</ul>
<h3 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h3><ul>
<li><code>%</code>可以匹配任何子串。</li>
<li><code>_</code>可以匹配任何单个字符。</li>
</ul>
<h3 id="Regular-expression"><a href="#Regular-expression" class="headerlink" title="Regular expression"></a>Regular expression</h3><ul>
<li>使用前需要加~。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> artist_name, first_yr_active</span><br><span class="line"><span class="keyword">FROM</span> Artists</span><br><span class="line"><span class="keyword">WHERE</span> artist_name <span class="operator">~</span><span class="string">&#x27;^B.*&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Relation-Algerbra"><a href="#Relation-Algerbra" class="headerlink" title="Relation Algerbra"></a><strong>Relation Algerbra</strong></h2><p>关系代数中返回结果不包含重复的tuple。</p>
<h3 id="Projection-pi"><a href="#Projection-pi" class="headerlink" title="Projection($\pi$)"></a>Projection($\pi$)</h3><ul>
<li>$\pi_{name}(dog)$选择对应的列，类似于SELECT name FROM dogs;</li>
<li>在关系代数中不存在操作符等价于FROM。</li>
</ul>
<h3 id="Selection-sigma"><a href="#Selection-sigma" class="headerlink" title="Selection($\sigma$)"></a>Selection($\sigma$)</h3><ul>
<li>根据给定的条件过滤出具体的行。如:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> dogs <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
  对应关系代数的版本<br>  $\pi_{name, age}(\sigma_{age &#x3D; 12}(dogs))$<br>  或者$\sigma_{age &#x3D; 12}(\pi_{name, age}(dogs))$</li>
<li>Selection操作符同样支持<code>compound predicate</code>，比如<code>AND</code>可以用$\wedge$来表示<code>OR</code>可以用$\vee$来表示, 如:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age </span><br><span class="line"><span class="keyword">FROM</span> dogs </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;Timmy&#x27;</span>;</span><br></pre></td></tr></table></figure>
  对应的关系代数版本<br>  $\sigma_{age&#x3D;12 \wedge name&#x3D;’Timmy’}(\pi_{name, age}(dogs))$</li>
</ul>
<h3 id="Union-cup"><a href="#Union-cup" class="headerlink" title="Union($\cup$)"></a>Union($\cup$)</h3><ul>
<li>Compatible: 要求union的两个操作数必须拥同样数量的attribute, 并且对应的attribute必须拥有同样的类型。</li>
</ul>
<h3 id="Set-Difference"><a href="#Set-Difference" class="headerlink" title="Set Difference($-$)"></a>Set Difference($-$)</h3><ul>
<li>和union一样要求Compatible</li>
<li>等价于SQL的EXCEPT语句, 比如$\pi_{name}(dogs) - \pi_{name}(cats)$只显示dogs表的行而不显示cats表的行。</li>
</ul>
<h3 id="Intersection-cap"><a href="#Intersection-cap" class="headerlink" title="Intersection($\cap$)"></a>Intersection($\cap$)</h3><ul>
<li>和union一样要求Compatible。</li>
<li>等价于SQL的INTERSECT语句。</li>
</ul>
<h3 id="CrossProduct-times"><a href="#CrossProduct-times" class="headerlink" title="CrossProduct($\times$)"></a>CrossProduct($\times$)</h3><ul>
<li>就像在SQL中执行笛卡尔积，输出两个表中行的所有组合。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ∗</span><br><span class="line"><span class="keyword">FROM</span> dogs, parks;</span><br></pre></td></tr></table></figure>
  等价于$dogs \times parks$。</li>
<li>不必要求属性数量一致。</li>
</ul>
<h3 id="Join-Join"><a href="#Join-Join" class="headerlink" title="Join($\Join$)"></a>Join($\Join$)</h3><ul>
<li><code>inner join</code>: $dogs\Join_{dogs.name&#x3D;cats.name}cats$，subscript中表示join的条件，也称作Theta join, “$\Join(\theta)$”。</li>
<li><code>Natual join</code>: $dogs\Join cats$，上面SQL中提到过，自然连接将会把两个表中所有同样的列自动合并。</li>
<li>和selection操作符一样可以使用compound predicate。</li>
<li>join都可以由cross和selection生成。</li>
<li>$cats \Join_{\theta} dogs$和$\sigma_{\theta}(cats \times dogs)$是等价的。</li>
<li>$cats \Join dogs$和$\sigma_{cats.col1&#x3D;dogs.col1\wedge cats.col2&#x3D;dogs.col2\wedge…\wedge cats.colN&#x3D;dogs.colN}(cats \times dogs)$是等价的。</li>
</ul>
<h3 id="Rename-rho"><a href="#Rename-rho" class="headerlink" title="Rename($\rho$)"></a>Rename($\rho$)</h3><ul>
<li>等价于SQL中的Alias。</li>
<li>$cats\Join_{name&#x3D;dname} \rho_{name-&gt;dname}(dogs)$，将dog中的name属性重命名为dname, 避免冲突。</li>
</ul>
<h3 id="Group-By-x2F-Aggregation-gamma"><a href="#Group-By-x2F-Aggregation-gamma" class="headerlink" title="Group By&#x2F; Aggregation($\gamma$)"></a>Group By&#x2F; Aggregation($\gamma$)</h3><ul>
<li>exp1  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age</span><br><span class="line"><span class="keyword">FROM</span> dogs</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
  等价于$\gamma_{age, COUNT(*)&gt;5}(dogs)$</li>
<li>exp2  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, <span class="built_in">SUM</span>(weight)</span><br><span class="line"><span class="keyword">FROM</span> dogs</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">8</span>) <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
  等价于$\gamma_{age, SUM(weight), COUNT(*)&gt;5(dogs)}$</li>
</ul>
<h3 id="SQL-gt-Relation-Algebra"><a href="#SQL-gt-Relation-Algebra" class="headerlink" title="SQL -&gt; Relation Algebra"></a>SQL -&gt; Relation Algebra</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> teamid <span class="keyword">AS</span> tid</span><br><span class="line"><span class="keyword">FROM</span> players</span><br><span class="line"><span class="keyword">WHERE</span> players.teamid <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> teamid <span class="keyword">FROM</span> teams)</span><br><span class="line"><span class="keyword">AND</span> position<span class="operator">=</span><span class="string">&#x27;shootingGuard&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>等价于<br>$$\rho_{teamid-&gt;tid}(\pi_{teamid}(\sigma_{position&#x3D;’shootingGuard’}(players))-\pi_{players.teamid}(players\Join_{players.teamid&#x3D;teams.teamid}teams))$$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/16/cmu15445-project1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/cmu15445-project1/" class="post-title-link" itemprop="url">CMU 15-445 Project1: BUFFER POOL MANAGER</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-16 18:02:20" itemprop="dateCreated datePublished" datetime="2022-05-16T18:02:20+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:15:19" itemprop="dateModified" datetime="2022-05-18T09:15:19+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CMU15-445/" itemprop="url" rel="index"><span itemprop="name">CMU15-445</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="CMU-15-445-Project1-BUFFER-POOL-MANAGER"><a href="#CMU-15-445-Project1-BUFFER-POOL-MANAGER" class="headerlink" title="CMU 15-445 Project1: BUFFER POOL MANAGER"></a>CMU 15-445 Project1: BUFFER POOL MANAGER</h1><h2 id="TASK-1-LRU-REPLACEMENT-POLICY"><a href="#TASK-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="TASK #1 - LRU REPLACEMENT POLICY"></a><strong>TASK #1 - LRU REPLACEMENT POLICY</strong></h2><h3 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a><strong>1.1 问题描述</strong></h3><p>需要完成的函数</p>
<ul>
<li>Victim(frame_id_t*) : Remove the object that was accessed least recently compared to all the other elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False.</li>
<li>Pin(frame_id_t) : This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer.</li>
<li>Unpin(frame_id_t) : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer.</li>
<li>Size() : This method returns the number of frames that are currently in the LRUReplacer</li>
</ul>
<p>想到lc上有类似的实现可以参考一下，双链表+哈希表实现<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">LRU</a>，大致思路和本题是一样的。pin时表示该页正在被使用，因此需要将该页从lru_replacer中移除，unpin反之。需要注意的是，不能多次unpin，这点与lc上有差别。</p>
<h3 id="1-2-部分实现"><a href="#1-2-部分实现" class="headerlink" title="1.2 部分实现"></a><strong>1.2 部分实现</strong></h3><p><strong>lru_replacer.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// TODO(student): implement me!</span></span><br><span class="line"> std::unordered_map&lt;<span class="type">frame_id_t</span>, ListNode*&gt; cache_;</span><br><span class="line"> std::mutex lru_latch_;</span><br><span class="line"> ListNode* head_;  <span class="comment">// dummy.</span></span><br><span class="line"> ListNode* tail_;</span><br><span class="line"> <span class="type">size_t</span> curr_size_;</span><br><span class="line"> <span class="type">size_t</span> capacity_;</span><br></pre></td></tr></table></figure>
<p><strong>lru_replacer.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;  <span class="comment">// evict the old frame.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(lru_latch_)</span></span>;  <span class="comment">// lock</span></span><br><span class="line">  <span class="keyword">if</span> (curr_size_ == <span class="number">0</span>) &#123;  <span class="comment">// lruReplacer empty.</span></span><br><span class="line">    frame_id = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode* delframe = tail_-&gt;prev;</span><br><span class="line">  <span class="type">frame_id_t</span> delframe_id= delframe-&gt;frame_id;</span><br><span class="line">  *frame_id = delframe_id;</span><br><span class="line">  cache_.<span class="built_in">erase</span>(delframe_id);  <span class="comment">// remove from frame.</span></span><br><span class="line">  curr_size_--;</span><br><span class="line">  <span class="comment">// Evict frame.</span></span><br><span class="line">  <span class="built_in">RemoveFrame</span>(delframe);</span><br><span class="line">  <span class="keyword">delete</span> delframe;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(lru_latch_)</span></span>;  <span class="comment">// lock</span></span><br><span class="line">  <span class="keyword">if</span> (cache_.<span class="built_in">find</span>(frame_id) != cache_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// decrease the attribute size.</span></span><br><span class="line">    curr_size_--;</span><br><span class="line">    ListNode* delframe = cache_[frame_id];</span><br><span class="line">    cache_.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">    <span class="built_in">RemoveFrame</span>(delframe);</span><br><span class="line">    <span class="comment">// release the source.</span></span><br><span class="line">    <span class="keyword">delete</span> delframe;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(lru_latch_)</span></span>;  <span class="comment">// lock</span></span><br><span class="line">  <span class="keyword">if</span> (cache_.<span class="built_in">find</span>(frame_id) == cache_.<span class="built_in">end</span>()) &#123;  <span class="comment">// didn&#x27;t find Unpin frame.</span></span><br><span class="line">    ListNode* frame = <span class="keyword">new</span> <span class="built_in">ListNode</span>(frame_id);</span><br><span class="line">    ++curr_size_;</span><br><span class="line">    <span class="keyword">if</span> (curr_size_ &gt; capacity_) &#123;</span><br><span class="line">      <span class="type">frame_id_t</span> fid;</span><br><span class="line">      <span class="built_in">Victim</span>(&amp;fid);</span><br><span class="line">      cache_[frame_id] = frame;</span><br><span class="line">      curr_size_--;</span><br><span class="line">      <span class="built_in">AddToHead</span>(frame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cache_[frame_id] = frame;</span><br><span class="line">      <span class="built_in">AddToHead</span>(frame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// couldn&#x27;t Unpin many times but once.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">LRUReplacer::Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> curr_size_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::AddToHead</span><span class="params">(ListNode* frame)</span> </span>&#123;</span><br><span class="line">  frame-&gt;next = head_-&gt;next;</span><br><span class="line">  head_-&gt;next-&gt;prev = frame;</span><br><span class="line">  head_-&gt;next = frame;</span><br><span class="line">  frame-&gt;prev = head_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::RemoveFrame</span><span class="params">(ListNode* frame)</span> </span>&#123;</span><br><span class="line">  frame-&gt;prev-&gt;next = frame-&gt;next;</span><br><span class="line">  frame-&gt;next-&gt;prev = frame-&gt;prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TASK-2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#TASK-2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="TASK #2 - BUFFER POOL MANAGER INSTANCE"></a><strong>TASK #2 - BUFFER POOL MANAGER INSTANCE</strong></h2><h3 id="2-1-问题描述"><a href="#2-1-问题描述" class="headerlink" title="2.1 问题描述"></a><strong>2.1 问题描述</strong></h3><p>可以联系课程给的slide了解对应的关系，需要理解的概念以及注意的点：</p>
<ol>
<li>free_list、lru_replacer、buffer_pool是独立存在的。</li>
<li>free_list中存放的是未被使用的frame，页表中不存在其frame的映射，即page_id为INVALID_PAGE_ID。</li>
<li>unpin_page，存放在lru_replacer中，页表中存在其frame的映射，但其在buffer pool中未被使用。</li>
<li>pin_page，存在于buffer pool中且正在被使用。</li>
<li>刷盘的时机，只需要在victim、deletePage时刷盘即可，不需要在每次unpinpage时刷盘，在unpinpage时保存其传入的dirty状就行。因此每次fetch或者new一个页，从free_list中返回的页都不是脏页，同时victim时刷盘也保证获取的页不是脏页。</li>
<li>从fetch、new获取lru_replace中的页时，需要在页表中删除原page与frame的映射。</li>
<li>避免加锁函数的嵌套，可能会出现死锁的情况。</li>
</ol>
<h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a><strong>2.2 代码实现</strong></h3><p>可以进一步细化锁粒度，这里只给了未优化的实现。</p>
<p><strong>NewPgImp</strong></p>
<p>fetchpage和newpgImp都需要增加pin_count值，实现是差不多的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call AllocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span></span><br><span class="line">  <span class="comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span></span><br><span class="line">  <span class="comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span></span><br><span class="line">  <span class="comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// step 1</span></span><br><span class="line">  <span class="type">bool</span> all_pinned = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pages_[i].pin_count_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      all_pinned = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (all_pinned)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// allocate a page on disk.</span></span><br><span class="line">  *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line">  </span><br><span class="line">  Page* p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// pick a victim page P.</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid;</span><br><span class="line">  <span class="keyword">if</span> (free_list_.<span class="built_in">empty</span>()) &#123;  <span class="comment">// pick from free list first.</span></span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Victim</span>(&amp;fid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p = &amp;pages_[fid];</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;is_dirty_) &#123;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(p-&gt;page_id_, p-&gt;data_);</span><br><span class="line">        p-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_.<span class="built_in">erase</span>(p-&gt;page_id_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fid = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    p = &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// add P to the page table.</span></span><br><span class="line">  page_table_[*page_id] = fid;</span><br><span class="line">  <span class="comment">// updata P&#x27;s metadata.</span></span><br><span class="line">  p-&gt;page_id_ = *page_id;</span><br><span class="line">  p-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(fid);</span><br><span class="line">  <span class="comment">// zeroes out the data that is held within the page</span></span><br><span class="line">  p-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  <span class="comment">// step 4</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>FetchPgImp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManagerInstance::FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.     Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.1    If P exists, pin it and return it immediately.</span></span><br><span class="line">  <span class="comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span></span><br><span class="line">  <span class="comment">//        Note that pages are always found from the free list first.</span></span><br><span class="line">  <span class="comment">// 2.     If R is dirty, write it back to the disk.</span></span><br><span class="line">  <span class="comment">// 3.     Delete R from the page table and insert P.</span></span><br><span class="line">  <span class="comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// step 1</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid;</span><br><span class="line">  Page* p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">find</span>(page_id) != page_table_.<span class="built_in">end</span>()) &#123;  <span class="comment">// find.</span></span><br><span class="line">    fid = page_table_[page_id];</span><br><span class="line">    pages_[fid].pin_count_++;</span><br><span class="line">    <span class="comment">// pin it.</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(fid);</span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (free_list_.<span class="built_in">empty</span>()) &#123;  <span class="comment">// pick from free list first.</span></span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Victim</span>(&amp;fid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// the page placed in the lrureplacer need to be flushed.</span></span><br><span class="line">      p = &amp;pages_[fid];</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;is_dirty_) &#123;</span><br><span class="line">        disk_manager_-&gt;<span class="built_in">WritePage</span>(p-&gt;page_id_, p-&gt;data_);</span><br><span class="line">        p-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_.<span class="built_in">erase</span>(p-&gt;page_id_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fid = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    p = &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// step 3</span></span><br><span class="line">  <span class="comment">// insert p.</span></span><br><span class="line">  page_table_[page_id] = fid;</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(fid);</span><br><span class="line">  <span class="comment">// update P&#x27;s metadata.</span></span><br><span class="line">  p-&gt;page_id_ = page_id;</span><br><span class="line">  p-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// read in the page content from disk.</span></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, p-&gt;data_);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DeletePgImp</strong></p>
<p>删除buffer pool中的页后需要将page的元数据还原到初始值，再放入free_list中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DeallocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.   If P does not exist, return true.</span></span><br><span class="line">  <span class="comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span></span><br><span class="line">  <span class="comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">// P does not exist.</span></span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">find</span>(page_id) == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// P does exist.</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid = page_table_[page_id];</span><br><span class="line">  Page* deletepage = &amp;pages_[fid];</span><br><span class="line">  <span class="keyword">if</span> (deletepage-&gt;pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// flush the page before deallocate it.</span></span><br><span class="line">  <span class="keyword">if</span> (deletepage-&gt;is_dirty_) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, deletepage-&gt;data_);</span><br><span class="line">    deletepage-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="comment">// remove P from the page table.</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page_id);</span><br><span class="line">  <span class="comment">// reset its metadata.</span></span><br><span class="line">  <span class="comment">// the page returned to freelist does not stores any page.</span></span><br><span class="line">  deletepage-&gt;page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  deletepage-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  deletepage-&gt;pin_count_ = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// return it to free_list_.</span></span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(fid);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UnpinPgImp</strong></p>
<p>保留传入的dirty状态，在Victim时刷盘。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="type">frame_id_t</span> fid = page_table_[page_id];</span><br><span class="line">  Page* p = &amp;pages_[fid];</span><br><span class="line">  p-&gt;is_dirty_ = is_dirty;  <span class="comment">// hold the state until victim.</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pin_count_ &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  --p-&gt;pin_count_;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Unpin</span>(fid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>FlushPgImp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManagerInstance::FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure you call DiskManager::WritePage!</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">find</span>(page_id) == page_table_.<span class="built_in">end</span>() || page_id == INVALID_PAGE_ID)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[page_table_[page_id]].data_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TASK-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#TASK-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="TASK #3 - PARALLEL BUFFER POOL MANAGER"></a><strong>TASK #3 - PARALLEL BUFFER POOL MANAGER</strong></h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a><strong>3.1 问题描述</strong></h3><p>问题是从task2进一步延出来的，单个缓冲池管理器可能会照成大量的锁争用，因为在这种情况下每个线程和缓冲池交互都争着用单个锁存器，因此需要实现一个并行管理器来管理多个缓冲池管理器，进而实现每个缓冲池都有自己的latch。在这里只需要复用上一个task所实现的缓冲器实例即可，再实现一些基本的逻辑即可通过。</p>
<h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a><strong>3.2 代码实现</strong></h3><p><strong>parallel_buffer_pool_manager.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ParallelBufferPoolManager::<span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager,</span><br><span class="line">                                                     LogManager *log_manager) &#123;</span><br><span class="line">  <span class="comment">// Allocate and create individual BufferPoolManagerInstances</span></span><br><span class="line">  num_instances_ = num_instances;</span><br><span class="line">  pool_size_ = pool_size;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances; ++i) &#123;</span><br><span class="line">    parallel_.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">BufferPoolManagerInstance</span>(pool_size, num_instances, i, disk_manager, log_manager));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update constructor to destruct all BufferPoolManagerInstances and deallocate any associated memory</span></span><br><span class="line">ParallelBufferPoolManager::~<span class="built_in">ParallelBufferPoolManager</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> bpm : parallel_) &#123;</span><br><span class="line">    <span class="keyword">delete</span> bpm;</span><br><span class="line">  &#125;</span><br><span class="line">  parallel_.<span class="built_in">clear</span>();</span><br><span class="line">  std::<span class="built_in">vector</span>&lt;BufferPoolManager*&gt;().<span class="built_in">swap</span>(parallel_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>parallel_buffer_pool_manager.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;BufferPoolManager*&gt; parallel_;</span><br><span class="line">  <span class="type">uint32_t</span> num_instances_;</span><br><span class="line">  <span class="type">size_t</span> pool_size_;</span><br><span class="line">  <span class="type">int</span> start_ = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>通过完成lab1，让我站在DBMS的角度去理解了操作系统的工作原理，以及对页表，缓存，刷盘时机，页面调度算法LRU有了更深刻的理解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/16/cs61c-lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/cs61c-lab2/" class="post-title-link" itemprop="url">CS61C Lab2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-16 17:59:00" itemprop="dateCreated datePublished" datetime="2022-05-16T17:59:00+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:15:33" itemprop="dateModified" datetime="2022-05-18T09:15:33+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS61C/" itemprop="url" rel="index"><span itemprop="name">CS61C</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="CS61C-Lab2"><a href="#CS61C-Lab2" class="headerlink" title="CS61C Lab2"></a>CS61C Lab2</h1><h2 id="Exercise-0-Makefiles"><a href="#Exercise-0-Makefiles" class="headerlink" title="Exercise 0: Makefiles"></a><strong>Exercise 0: Makefiles</strong></h2><ol>
<li>Which target is part of a rule that deletes all the compiled programs?</li>
<li>Which target is part of a rule that makes all the compiled programs?</li>
<li>Which compiler is currently being used?</li>
<li>What C standard are we currently using?</li>
<li>How would we reference a variable FOO in a makefile?</li>
<li>What operating system does the term “Darwin” represent?</li>
<li>What line creates the lfsr program from its object files? (Give its line number.)</li>
</ol>
<p>我的答案:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.clean</span><br><span class="line">2.all</span><br><span class="line">3.gcc</span><br><span class="line">4.c99</span><br><span class="line">5.$(Foo)</span><br><span class="line">6.macos</span><br><span class="line">7.31</span><br></pre></td></tr></table></figure>
<h2 id="Exercise-1-Bit-Operations"><a href="#Exercise-1-Bit-Operations" class="headerlink" title="Exercise 1: Bit Operations"></a><strong>Exercise 1: Bit Operations</strong></h2><p><code>get_bit</code>很简单，<code>set_bit</code>中需要将<code>v</code>的<code>0</code>和<code>1</code>减去1构造一下变成全0和全1来判断条件, 做过csapp的datalab之后一下就有思路了。若<code>v</code>为<code>1</code>则只需要移动<code>n</code>个bit到对应的bit或一下就行了，置为0则需要考虑一下除了移动到的bit之外的bit都置为1，可以在移位前做加上一个<code>1</code>的处理，随后移动到相应位置之后再取反，与一下即可。<code>flip_bit</code>只需要稍加处理在应用<code>set_bit</code>的模式即可，先取到即将要翻转的bit，随后与<code>1</code>做异或运算，使得0变为1，1变为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bit_ops.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the nth bit of x.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">get_bit</span><span class="params">(<span class="type">unsigned</span> x,</span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">    <span class="comment">// Returning -1 is a placeholder (it makes</span></span><br><span class="line">    <span class="comment">// no sense, because get_bit only returns</span></span><br><span class="line">    <span class="comment">// 0 or 1)</span></span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; n) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set the nth bit of the value of x to v.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(<span class="type">unsigned</span> * x,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> n,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">	<span class="type">int</span> flag = v<span class="number">-1</span>;</span><br><span class="line">	(*x) = (((*x) | (v &lt;&lt; n)) &amp; (~flag)) | ((*x) &amp; (~((v+<span class="number">1</span>) &lt;&lt; n)) &amp; flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Flip the nth bit of the value of x.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flip_bit</span><span class="params">(<span class="type">unsigned</span> * x,</span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">	<span class="type">int</span> v = ((*x) &gt;&gt; n) &amp; <span class="number">0x1</span>;</span><br><span class="line">	v ^= <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> flag = v<span class="number">-1</span>;</span><br><span class="line">	(*x) = (((*x) | (v &lt;&lt; n)) &amp; (~flag)) | ((*x) &amp; (~((v+<span class="number">1</span>) &lt;&lt; n)) &amp; flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Exercise-2-Linear-Feedback-Shift-Register"><a href="#Exercise-2-Linear-Feedback-Shift-Register" class="headerlink" title="Exercise 2: Linear Feedback Shift Register"></a><strong>Exercise 2: Linear Feedback Shift Register</strong></h2><p><img src="https://pic4.zhimg.com/80/v2-704f48aad6446d5640cac655e77e7a19.gif" alt="Linear Feedback Shift Register"></p>
<p>根据图中信息构造门级电路即可，<code>test</code>中循环已经写好不需要再构建循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lfsr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lfsr_calculate</span><span class="params">(<span class="type">uint16_t</span> *reg)</span> &#123;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">	<span class="type">uint16_t</span> regs =	*reg; </span><br><span class="line">	<span class="type">uint16_t</span> msb = ((regs&amp;<span class="number">0x1</span>)^((regs&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x1</span>)^((regs&gt;&gt;<span class="number">3</span>)&amp;<span class="number">0x1</span>)^((regs&gt;&gt;<span class="number">5</span>)&amp;<span class="number">0x1</span>))&lt;&lt;<span class="number">15</span>;</span><br><span class="line">	(*reg) &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	(*reg) |= msb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exercise-3-Linked-Lists"><a href="#Exercise-3-Linked-Lists" class="headerlink" title="Exercise 3: Linked Lists"></a><strong>Exercise 3: Linked Lists</strong></h2><p>面试常考的翻转链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a node to the end of the linked list. Assume head_ptr is non-null. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">append_node</span> <span class="params">(node** head_ptr, <span class="type">int</span> new_data)</span> &#123;</span><br><span class="line">	<span class="comment">/* First lets allocate memory for the new node and initialize its attributes */</span></span><br><span class="line">	<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">	node* new_node = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">	new_node-&gt;val = new_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the list is empty, set the new node to be the head and return */</span></span><br><span class="line">	<span class="keyword">if</span> (*head_ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">		*head_ptr = new_node;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	node* curr = *head_ptr;</span><br><span class="line">	<span class="keyword">while</span> (curr-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		curr = curr-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Insert node at the end of the list */</span></span><br><span class="line">	<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">	curr-&gt;next = new_node;</span><br><span class="line">	new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reverse a linked list in place (in other words, without creating a new list).</span></span><br><span class="line"><span class="comment">   Assume that head_ptr is non-null. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_list</span> <span class="params">(node** head_ptr)</span> &#123;</span><br><span class="line">	node* prev = <span class="literal">NULL</span>;</span><br><span class="line">	node* curr = *head_ptr;</span><br><span class="line">	node* next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* INSERT CODE HERE */</span></span><br><span class="line">		next = curr-&gt;next;</span><br><span class="line">		curr-&gt;next = prev;</span><br><span class="line">		prev = curr;</span><br><span class="line">		curr = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Set the new head to be what originally was the last node in the list */</span></span><br><span class="line">	*head_ptr = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exercise-4-Memory-Management"><a href="#Exercise-4-Memory-Management" class="headerlink" title="Exercise 4: Memory Management"></a><strong>Exercise 4: Memory Management</strong></h2><p>为<code>vector</code>在<code>Makefile</code>中指定目标, 将下列语句添加到<code>Makefile</code>中。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(VECTOR_PROG)</span>: <span class="variable">$(VECTOR_OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -g -o <span class="variable">$(VECTOR_PROG)</span> <span class="variable">$(VECTOR_OBJS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure>

<p>分析一下: <code>bad_vector_new</code>。声明的指针变量v未被使用，且没有为结构体<code>vector_t</code>动态开辟堆空间，而是使用野指针，这样很危险; <code>also_bad_vector_new</code>。声明栈上的结构体数据，最后返回之后拷贝的开销非常大，因此也不够合理, 且如果未及时对返回值进行保存，栈帧会有被覆盖的可能，会丢失返回的数据。</p>
<blockquote>
<p>$ valgrind –tool&#x3D;memcheck –leak-check&#x3D;full –track-origins&#x3D;yes [OS SPECIFIC ARGS] <code>./&lt;executable&gt;</code></p>
</blockquote>
<ul>
<li><code>Valgrind</code>默认使用<code>memcheck</code>工具。还有其它工具包括: <code>Callgrind</code>, <code>Cachegrind</code>, <code>Helgrind</code>, <code>Massif</code>。</li>
<li><code>--leak-check=full</code>: 详细地显示每个单独的内存泄露。</li>
<li><code>--track-origins=yes</code>: 这会跟踪初始化值的来源。着重于有用的输出而不是速度。</li>
</ul>
<p>注意在函数<code>vector_set</code>的题意，超出访问的loc超出堆内存的范围需要重新再申请空间<code>realloc</code>，而不是简单地提示错误信息，若重新申请为空则提示错误信息<code>allocation_failed</code>。用<code>cgdb</code>慢慢调就行了。在<code>make vector_test</code>通过后，使用工具<code>Valgrind</code>检测到内存泄露，查看了一下<code>vector_test</code>函数，发现存在使用未初始化元素的行为，随后便可以将问题可以定位到<code>vector_set</code>函数中，在其中加入for循环初始化即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new vector with a size (length) of 1</span></span><br><span class="line"><span class="comment">   and set its single component to zero... the</span></span><br><span class="line"><span class="comment">   RIGHT WAY */</span></span><br><span class="line"><span class="type">vector_t</span> *<span class="title function_">vector_new</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* Declare what this function will return */</span></span><br><span class="line">    <span class="type">vector_t</span> *retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First, we need to allocate memory on the heap for the struct */</span></span><br><span class="line">    retval = (<span class="type">vector_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">vector_t</span>));<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check our return value to make sure we got memory */</span></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="literal">NULL</span><span class="comment">/* YOUR CODE HERE */</span>) &#123;</span><br><span class="line">        allocation_failed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we need to initialize our data.</span></span><br><span class="line"><span class="comment">       Since retval-&gt;data should be able to dynamically grow,</span></span><br><span class="line"><span class="comment">       what do you need to do? */</span></span><br><span class="line">    retval-&gt;size = <span class="number">1</span>;<span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line">    retval-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*retval-&gt;size);<span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the data attribute of our vector to make sure we got memory */</span></span><br><span class="line">    <span class="keyword">if</span> (retval-&gt;data == <span class="literal">NULL</span><span class="comment">/* YOUR CODE HERE */</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(retval);				<span class="comment">//Why is this line necessary? Because it allocate the memory of vector but not allocate the data that will cause memory leak.</span></span><br><span class="line">        allocation_failed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Complete the initialization by setting the single component to zero */</span></span><br><span class="line">    <span class="comment">/* YOUR CODE HERE */</span> </span><br><span class="line">	*(retval-&gt;data) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* and return... */</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at the specified location/component &quot;loc&quot; of the vector */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vector_get</span><span class="params">(<span class="type">vector_t</span> *v, <span class="type">size_t</span> loc)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are passed a NULL pointer for our vector, complain about it and exit. */</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;vector_get: passed a NULL vector.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the requested location is higher than we have allocated, return 0.</span></span><br><span class="line"><span class="comment">     * Otherwise, return what is in the passed location.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (loc &lt; v-&gt;size<span class="comment">/* YOUR CODE HERE */</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> v-&gt;data[loc];<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free up the memory allocated for the passed vector.</span></span><br><span class="line"><span class="comment">   Remember, you need to free up ALL the memory that was allocated. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_delete</span><span class="params">(<span class="type">vector_t</span> *v)</span> &#123;</span><br><span class="line">    <span class="comment">/* YOUR SOLUTION HERE */</span></span><br><span class="line">	<span class="built_in">free</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set a value in the vector. If the extra memory allocation fails, call</span></span><br><span class="line"><span class="comment">   allocation_failed(). */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vector_set</span><span class="params">(<span class="type">vector_t</span> *v, <span class="type">size_t</span> loc, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">/* What do you need to do if the location is greater than the size we have</span></span><br><span class="line"><span class="comment">     * allocated?  Remember that unset locations should contain a value of 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* YOUR SOLUTION HERE */</span></span><br><span class="line">	<span class="keyword">if</span> (loc &gt;= v-&gt;size) &#123;</span><br><span class="line">		v-&gt;data = (<span class="type">int</span>*)<span class="built_in">realloc</span>(v-&gt;data, <span class="keyword">sizeof</span>(<span class="type">int</span>)*(loc+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            allocation_failed();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = v-&gt;size; i &lt; loc+<span class="number">1</span>; ++i)</span><br><span class="line">			v-&gt;data[i] = <span class="number">0</span>;</span><br><span class="line">		v-&gt;size = loc+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	v-&gt;data[loc] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/16/cs144-lab0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/cs144-lab0/" class="post-title-link" itemprop="url">Stanford CS144 Lab0: Networking Warmup</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-16 17:58:51" itemprop="dateCreated datePublished" datetime="2022-05-16T17:58:51+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:15:37" itemprop="dateModified" datetime="2022-05-18T09:15:37+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS144/" itemprop="url" rel="index"><span itemprop="name">CS144</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="Stanford-CS144-Lab0-Networking-Warmup"><a href="#Stanford-CS144-Lab0-Networking-Warmup" class="headerlink" title="Stanford CS144 Lab0: Networking Warmup"></a>Stanford CS144 Lab0: Networking Warmup</h1><h2 id="1-Fetch-a-Web-page"><a href="#1-Fetch-a-Web-page" class="headerlink" title="1. Fetch a Web page"></a><strong>1. Fetch a Web page</strong></h2><p>使用<code>telnet</code>通过<code>http</code>协议访问远端服务器<br><img src="https://pic4.zhimg.com/80/v2-0f3f73376b27537497d7778b962aa839.png" alt="Image"></p>
<h2 id="2-Writing-webget"><a href="#2-Writing-webget" class="headerlink" title="2. Writing webget"></a><strong>2. Writing webget</strong></h2><h3 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a><strong>2.1 描述</strong></h3><p>实现<code>webget</code>来通过Internet获取网页，使用TCP协议和套接字抽象。实现简单的Web客户端，使用上述<code>HTTP</code>的形式。读数据时遇到<code>EOF</code>则结束，使用轮询的方式读取数据。</p>
<blockquote>
<p>Please note that in HTTP, each line must be ended with “\r\n” (it’s not sufficient<br>to use just “\n” or endl).<br>• Don’t forget to include the “Connection: close” line in your client’s request. This<br>tells the server that it shouldn’t wait around for your client to send any more<br>requests after this one. Instead, the server will send one reply and then will<br>immediately end its outgoing bytestream (the one from the server’s socket to your<br>socket). You’ll discover that your incoming byte stream has ended because your<br>socket will reach “EOF” (end of file) when you have read the entire byte stream<br>coming from the server. That’s how your client will know that the server has<br>finished its reply.<br>• Make sure to read and print all the output from the server until the socket reaches<br>“EOF” (end of file)—a single call to read is not enough.<br>• We expect you’ll need to write about ten lines of code.</p>
</blockquote>
<h3 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a><strong>2.2 实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\n&quot;;</span></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;</span></span><br><span class="line">    TCPSocket client;</span><br><span class="line">    client.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    string message = <span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span> + </span><br><span class="line">                    host + <span class="string">&quot; \r\nConnection: close\r\n\r\n&quot;</span>;</span><br><span class="line">    client.<span class="built_in">write</span>(message);</span><br><span class="line">    client.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!client.<span class="built_in">eof</span>()) &#123;  <span class="comment">// polling</span></span><br><span class="line">        cout &lt;&lt; client.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    client.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-An-in-memory-reliable-byte-stream"><a href="#3-An-in-memory-reliable-byte-stream" class="headerlink" title="3. An in-memory reliable byte stream"></a><strong>3. An in-memory reliable byte stream</strong></h2><h3 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a><strong>3.1 描述</strong></h3><ol>
<li><code>ByteStream</code>字节流是有限的, 容量为<code>capacity</code>，允许在内存中存在的最大数量的字节，确保写字节数不超过<code>capacity</code>。</li>
<li>需要实现一个缓冲区<code>buffer</code>来模拟当前字节流相应的功能。考虑到读端(Output End)队头和写端(Input End)队尾，因此使用<code>stl</code>中的双端队列<code>deque</code>来实现。</li>
<li><code>eof()</code>返回<code>true</code>, 读端无数据可读有两种情况, 一次读到<code>eof</code>、或者buffer为空。</li>
<li>从写端取数据分为两种操作, <code>peek</code>和<code>pop</code></li>
</ol>
<h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a><strong>3.2 实现</strong></h3><p>byte_stream.cc</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : <span class="built_in">buffer_</span>(std::<span class="built_in">move</span>(<span class="built_in">deque</span>&lt;<span class="type">char</span>&gt;(<span class="number">0</span>))), <span class="built_in">capacity_</span>(capacity), <span class="built_in">end_write_</span>(<span class="literal">false</span>),</span><br><span class="line">                    <span class="built_in">read_num_</span>(<span class="number">0</span>), <span class="built_in">write_num_</span>(<span class="number">0</span>) &#123; <span class="built_in">DUMMY_CODE</span>(capacity); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(data);</span><br><span class="line">    <span class="type">size_t</span> can_write = <span class="built_in">min</span>(data.<span class="built_in">size</span>(), <span class="built_in">remaining_capacity</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; can_write; ++i) &#123;</span><br><span class="line">        buffer_.<span class="built_in">push_back</span>(data[i]);    <span class="comment">// push from the input side.</span></span><br><span class="line">    &#125;</span><br><span class="line">    write_num_ += can_write;</span><br><span class="line">    <span class="keyword">return</span> can_write;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(len);</span><br><span class="line">    <span class="type">size_t</span> can_peek = <span class="built_in">min</span>(len, buffer_.<span class="built_in">size</span>());</span><br><span class="line">    string peek_data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; can_peek; ++i) &#123;</span><br><span class="line">        peek_data += buffer_[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> peek_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; buffer_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">set_error</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        buffer_.<span class="built_in">pop_front</span>();           <span class="comment">// removed from the output side.</span></span><br><span class="line">    &#125;</span><br><span class="line">    read_num_ += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DUMMY_CODE</span>(len);</span><br><span class="line">    string message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> can_read = <span class="built_in">min</span>(len, buffer_.<span class="built_in">size</span>());  <span class="comment">// next &quot;len&quot; bytes.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; can_read; ++i) &#123;</span><br><span class="line">        message += buffer_.<span class="built_in">front</span>();</span><br><span class="line">        buffer_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    read_num_ += can_read;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; end_write_ = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end_write_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">buffer_empty</span>() &amp;&amp; end_write_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> write_num_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> read_num_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> capacity_ - buffer_.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>byte_stream.hh</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that&#x27;s a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; buffer_;</span><br><span class="line">    <span class="type">size_t</span> capacity_;     <span class="comment">// capacity in memory.</span></span><br><span class="line">    <span class="type">bool</span> end_write_;</span><br><span class="line">    <span class="type">size_t</span> read_num_;</span><br><span class="line">    <span class="type">size_t</span> write_num_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> _error&#123;&#125;;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/16/s081-lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/s081-lab5/" class="post-title-link" itemprop="url">MIT 6.S081 Lab5: xv6 lazy page allocation</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-16 17:55:02" itemprop="dateCreated datePublished" datetime="2022-05-16T17:55:02+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:16:28" itemprop="dateModified" datetime="2022-05-18T09:16:28+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MIT-6-S081/" itemprop="url" rel="index"><span itemprop="name">MIT 6.S081</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="MIT-6-S081-Lab5-xv6-lazy-page-allocation"><a href="#MIT-6-S081-Lab5-xv6-lazy-page-allocation" class="headerlink" title="MIT 6.S081 Lab5: xv6 lazy page allocation"></a>MIT 6.S081 Lab5: xv6 lazy page allocation</h1><p>很多方法都用到了Lazy allocation, 比如:</p>
<ul>
<li>paging from disk</li>
<li>COW fork</li>
<li>automatically extending stack</li>
<li>memory-mapped files</li>
</ul>
<p>xv6使用<code>sbrk()</code>申请<strong>物理地址空间</strong>并将其映射到进程的虚拟地址空间(向内核请求堆内存)。这个lab视频上也给了很多提示，重要的是理解并掌握原理。</p>
<p>实际上复杂的内核会在分配栈空间时做这样的处理, <code>sbrk</code>没有分配物理地址空间，只是记住分配了哪些用户地址，并在用户地址将这些地址标记为无效(invalid)。当进程尝试第一次使用任何给定Lazy Allocation的页面时，CPU会产生Page Fault的异常，该异常错误的类型会存放到<code>scause</code>寄存器，而<code>stval</code>寄存器中从存放着不能被translate的虚拟地址。<br><img src="https://pic4.zhimg.com/80/v2-998ad453d6ec0eed41edd98ca61aa644.png" alt="scause"></p>
<p>Page Fault的类型:</p>
<ul>
<li>load page faults, load指令不能translate地址</li>
<li>store page faults，store指令不能translate地址</li>
<li>instruction page faults，指令地址未能被tanslate<h2 id="1-Eliminate-allocation-from-sbrk"><a href="#1-Eliminate-allocation-from-sbrk" class="headerlink" title="1. Eliminate allocation from sbrk()"></a><strong>1. Eliminate allocation from sbrk()</strong></h2><h3 id="1-1-Description"><a href="#1-1-Description" class="headerlink" title="1.1 Description"></a><strong>1.1 Description</strong></h3>将<code>growproc</code>函数注释掉，不分配物理地址空间，只增加进程内存的大小。<h3 id="1-2-Implementation"><a href="#1-2-Implementation" class="headerlink" title="1.2 Implementation"></a><strong>1.2 Implementation</strong></h3><code>kernel/sysproc.c</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line"></span><br><span class="line">  myproc()-&gt;sz += n;</span><br><span class="line">  <span class="comment">// if(growproc(n) &lt; 0)  // Not need to allocate pysical memory.</span></span><br><span class="line">  <span class="comment">//   return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;  <span class="comment">// return the old size of process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Lazy-allocation"><a href="#2-Lazy-allocation" class="headerlink" title="2. Lazy allocation"></a><strong>2. Lazy allocation</strong></h2><h3 id="2-1-Description"><a href="#2-1-Description" class="headerlink" title="2.1 Description"></a><strong>2.1 Description</strong></h3>比如说要实现<code>Lazy allocation</code>, 在<code>sbrk()</code>系统调用时<code>page fault</code>异常发生，<code>sepc</code>寄存器保证在修补完页表之后到跳转回异常发生时执行指令的位置重新执行指令(原本的疑虑是在<code>usertrapret()</code>中sepc会+4即跳转到当前指令的下一条指令，实际上在lab3中才有自增4这条语句&#x3D; &#x3D;)。若没有空闲的物理内存，则返回错误，并且kill进程。如果<code>sbrk()</code>缩减堆内存，<code>page fault</code>就不会发生。</li>
</ul>
<p><code>uvmunmap</code>产生panic的原因是因为<code>sbrk()</code>已经分配物理内存但该物理内存未被使用。</p>
<p>在<code>printf</code>之前修改代码，使得<code>echo hi</code>正确执行。<br>Some hint:</p>
<ul>
<li>You can check whether a fault is a page fault by seeing if r_scause() is 13 or 15 in usertrap().</li>
<li>r_stval() returns the RISC-V stval register, which contains the virtual address that caused the page fault.</li>
<li>Steal code from uvmalloc() in vm.c, which is what sbrk() calls (via growproc()). You’ll need to call kalloc() and mappages().</li>
<li>Use PGROUNDDOWN(va) to round the faulting virtual address down to a page boundary.</li>
<li>uvmunmap() will panic; modify it to not panic if some pages aren’t mapped.</li>
<li>If the kernel crashes, look up sepc in kernel&#x2F;kernel.asm</li>
<li>Use your vmprint function from pgtbl lab to print the content of a page table.</li>
<li>If you see the error “incomplete type proc”, include “spinlock.h” then “proc.h”.<h3 id="2-2-Implementation"><a href="#2-2-Implementation" class="headerlink" title="2.2 Implementation"></a><strong>2.2 Implementation</strong></h3><code>kernel/trap:usertrap</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    <span class="comment">// check whether a fault is a page fault</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page fault: %p\n&quot;</span>, va);</span><br><span class="line">    <span class="comment">// lazy allocation before printf information.</span></span><br><span class="line">    <span class="type">char</span>* mem = kalloc();  <span class="comment">// allocate one page of physical memory. </span></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);  <span class="comment">// set all zeros.</span></span><br><span class="line">      <span class="keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<code>kernel/vm.c:uvmunmap</code>, 如果这一部分不用<strong>continue</strong>来处理，在接下来的code，刚分配的物理内存就会被释放掉。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">        panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Lazytests-and-Usertests"><a href="#3-Lazytests-and-Usertests" class="headerlink" title="3. Lazytests and Usertests"></a><strong>3. Lazytests and Usertests</strong></h2><h3 id="3-1-Description"><a href="#3-1-Description" class="headerlink" title="3.1 Description"></a><strong>3.1 Description</strong></h3>如果<code>sbrk()</code>缩减堆空间大小而不是扩大，注意<code>proc.sz</code>为无符号整型数，和一个int型数相加，有符号数会向无符号数发生隐式地转换。还需要注意<code>uvmunmap</code>的<code>walk panic</code>，已经改变sz但未分配物理地址，在释放就会出现<code>panic</code>，只需要执行<code>continue</code>即可。<code>out of memory</code>测试。同时xv6book中第三章有说<code>guard page</code>的<code>PTE_V</code>未设置，注意参考第三章给出的用户地址空间的布局。xv6中为用户栈分配了一个页</li>
</ul>
<p>Some hints:</p>
<ul>
<li>Handle negative sbrk() arguments.</li>
<li>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</li>
<li>Handle the parent-to-child memory copy in fork() correctly.</li>
<li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li>
<li>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</li>
<li>Handle faults on the invalid page below the user stack.<h3 id="3-2-Implementation"><a href="#3-2-Implementation" class="headerlink" title="3.2 Implementation"></a><strong>3.2 Implementation</strong></h3></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/16/s081-lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/s081-lab4/" class="post-title-link" itemprop="url">MIT 6.S081 Lab4: Traps</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-16 17:54:57" itemprop="dateCreated datePublished" datetime="2022-05-16T17:54:57+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:16:26" itemprop="dateModified" datetime="2022-05-18T09:16:26+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MIT-6-S081/" itemprop="url" rel="index"><span itemprop="name">MIT 6.S081</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="MIT-6-S081-Lab4-Traps"><a href="#MIT-6-S081-Lab4-Traps" class="headerlink" title="MIT 6.S081 Lab4: Traps"></a>MIT 6.S081 Lab4: Traps</h1><ul>
<li>跟着视频走一遍系统调用<code>gdb</code>的流程。<code>tmux</code>分割两个窗口，一个窗口作为服务器<code>make CPUS=1 qemu-gdb</code>，另一个窗口作为<code>gdb</code>调试窗口<code>gdb-multiarch</code>。将断点打在<code>ecall指令处</code>, <code>continue</code>执行，随后再将第二个断点打到<code>print/x $stvec</code>处也就是，<code>TRAPFRAME</code>的起始地址。<code>ecall</code>指令完成三件事，将用户模式切换到管理员模式、将PC保存到sepc寄存器中、将stvec寄存器的值赋给PC跳转到stvec保存的地址处执行。</li>
<li>进入<code>trampoline.s</code>后，<code>csrrw a0, sscratch, a0</code>首先将非体系结构寄存器<code>sscratch</code>与<code>a0</code>的值交换，<code>sscratch</code>寄存器中保存的时<code>TRAPFRAME</code>的起始地址。</li>
<li>然后将当前的现场(即寄存器)保存到<code>TRAPFRAME</code>中，再将<code>TRAPFRAME</code>中保存的内核栈指针，<code>hartid</code>，<code>usertrap()</code>的地址，以及内核页表所在的<code>stap</code>寄存器的值加载到当前通用寄存器中。</li>
<li>随后将寄存器<code>t1</code>保存的内核页目录的地址写入当前<code>satp</code>寄存器中，再刷新<code>TLB</code>，将用户页表切换为内核页表  <figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csrw satp, <span class="built_in">t1</span></span><br><span class="line">sfence.vma <span class="built_in">zero</span>, <span class="built_in">zero</span></span><br></pre></td></tr></table></figure></li>
<li>将用户模式完全切换为内核模式之后，最后跳到<code>t0</code>中保存的<code>usertrap()</code>的入口地址，<code>jr t0</code>跳入<code>usertrap</code>函数。</li>
<li>进入函数后，首先判断<code>sstatus</code>寄存器的<code>SSP</code>位是否为<code>0</code>(即是否为用户模式下发生的trap)。将<code>stvec</code>赋值为<code>kernelvec</code>的入口地址，即在当前<code>usertrap</code>发生的中断或异常则跳转到<code>stvec</code>处执行。再保存中断返回的地址到<code>sepc</code>。</li>
<li>中断将会改变<code>sstatus</code>寄存器，因此在修改结束之后才将中断打开<code>intr_on()</code>。</li>
<li>之后进入系统调用<code>syscall()</code>，根据<code>p-&gt;trapframe-&gt;a7</code>中保存的系统调用号来决定调用哪个系统调用(专门通过一个静态数组查找<code>syscalls[num]</code>), 随后将系统调用的返回值保存到<code>p-&gt;trapframe-&gt;a0</code>中。</li>
<li>完成系统调用之后，随后计算<code>uservec</code>的虚拟地址并赋值给<code>stvec</code>，以便发生异常或中断的时候处理。接下来将相应的内容restore到<code>trapframe</code>中方便进行下一次<code>trap</code>。随后更新<code>sstatus</code>状态寄存器的值，清空<code>SSP</code>、设置<code>SPIE</code>位。</li>
<li>更新<code>sepc</code>的值以及将<code>satp</code>的值设为内核页表的地址，将在<code>userret</code>中切换页表。计算<code>userret</code>在<code>trampoline.s</code>中的虚拟地址，跳转到<code>userret</code>，跳转之前传参有个小细节，即将<code>TRAMPOLINE</code>作为第一个参数，这样在<code>a0</code>与<code>sscratch</code>交换后，<code>sscratch</code>就得到<code>TRAMPOLINE</code>的起始地址了。</li>
<li>进入到收尾阶段，将恢复到<code>trap</code>之前的状态。将<code>TRAMPOLINE</code>中的内容load到通用寄存器中，先将<code>a0</code>寄存器的值写入<code>sscratch</code>寄存器中，这样最后<code>csrrw a0, sscratch, a0</code>即可将这两个寄存器复位为各自的值。最后<code>sret</code>将<code>sepc</code>赋给<code>pc</code>完成系统调用恢复正常执行。</li>
</ul>
<h4 id="比较重要的非体系结构寄存器"><a href="#比较重要的非体系结构寄存器" class="headerlink" title="比较重要的非体系结构寄存器"></a><strong>比较重要的非体系结构寄存器</strong></h4><ul>
<li>stvec, 存放系统调用处理程序的地址</li>
<li>sepc, 当系统调用发生时PC存放到此处，以便系统调用返回时能从下一条指令开始执行<code>sret</code>: sepc -&gt; pc。</li>
<li>scause, ISA通过它来分析系统调用的种类</li>
<li>sscratch, 内核将一个值放到这里，方便系统调用的开始(通用寄存器和sscratch寄存器通过csrrw来交换值<code>csrrw a0, sscratch, a0</code>)。</li>
<li>sstatus, 状态寄存器，类似LC-3来决定是否发生中断，或者决定是用户模式还是系统模式，若存在条件码则存放条件码。</li>
</ul>
<h4 id="Debug相关"><a href="#Debug相关" class="headerlink" title="Debug相关"></a><strong>Debug相关</strong></h4><ul>
<li><code>add-symbol-file</code>或<code>file</code>命令从文件<code>filename</code>中读取附加的符号表信息存放在<code>ELF</code>文件(可重定向目标文件)中的<code>.symtab</code> Entry中。当文件名（通过其他方式）动态加载到正在运行的程序中时，将使用此命令。</li>
<li>解决调试alarmtest时<code>usertrap</code> C源代码不显示的, 函数和变量信息不够全，需要<code>add-symbol-file kernel/kernel</code>即可。</li>
</ul>
<h2 id="1-RISC-V-assembly"><a href="#1-RISC-V-assembly" class="headerlink" title="1. RISC-V assembly"></a><strong>1. RISC-V assembly</strong></h2><h3 id="1-1-Description"><a href="#1-1-Description" class="headerlink" title="1.1 Description"></a><strong>1.1 Description</strong></h3><blockquote>
<p>It will be important to understand a bit of RISC-V assembly, which you were exposed to in 6.004. There is a file user&#x2F;call.c in your xv6 repo. make fs.img compiles it and also produces a readable assembly version of the program in user&#x2F;call.asm.</p>
</blockquote>
<p>可以在<code>gdb</code>中使用<code>file</code>来对<code>call.o</code>文件调试，并将断点打到<code>main</code>函数上。解释调试时<code>RISCV</code>汇编出现的一些指令, <code>x</code>表示寄存器, <code>M</code>表示存储器:</p>
<ul>
<li><code>auipc</code>, Add Upper Immediate to PC. 将指令编码格式中的<code>Imm[31:12]</code>左移12位后的结果<code>sign-extened</code>后再加上PC。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auipc rd, Imm  <span class="comment">; x[rd] = PC + sext(Imm[31:12] &lt;&lt; 12)</span></span><br></pre></td></tr></table></figure></li>
<li><code>li</code>(pseudoinstruction), Load Immediate.<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li rd, Imm  <span class="comment">; x[rd] = Imm</span></span><br></pre></td></tr></table></figure></li>
<li><code>mv</code>(pseudoinstruction), Move. 注意与<code>x86 ISA</code>的<code>mov</code>传递方向不同。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv rd, rs1  <span class="comment">; x[rd] = x[rs1]</span></span><br></pre></td></tr></table></figure></li>
<li><code>jalr</code>, Jump And Link Register. <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40453719/risc-v-why-set-least-significant-bit-to-zero-in-jalr">为什么要将最低有效位置为0?</a>字节对齐。将当前pc+4赋给ra作为返回地址并跳转到offset(rs1), 随后返回到当前指令的下一条指令继续执行。注意如果rd省略了，那么rd就默认为x1(即<code>ra</code>保存返回地址的寄存器)。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jalr </span>rd, offset(rs1)  <span class="comment">; t=pc+4; pc=(x[rs1]+sext(offset)) &amp; ~1; x[rd] = t;</span></span><br></pre></td></tr></table></figure></li>
<li><code>lbu</code>, Load Byte Unsigned. 取完一个字节后，紧接着零拓展, <code>lb</code>为符号位拓展。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lbu </span>rd, offset(rs1)  <span class="comment">; x[rd] M[x[rs1] + sext(offset)] [7:0]</span></span><br></pre></td></tr></table></figure></li>
<li><code>seqz</code>(pseudoinstruction), Set if Equal to Zero.<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seqz rd, rs1  <span class="comment">; x[rd] = (x[rs1] == 0)</span></span><br></pre></td></tr></table></figure></li>
<li><code>csrrw</code>, Control and Status Register Read and Write. 状态寄存器和通用寄存器之间的读写操作。将状态寄存器中的内容放入rd寄存器，将rs1的内容放入状态寄存器。<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrrw rd, csr, rs1  <span class="comment">; t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t</span></span><br></pre></td></tr></table></figure></li>
<li><code>csrw</code><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrw csr, rs1</span><br></pre></td></tr></table></figure></li>
<li><code>csrr</code><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrr rd, csr</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Implementation"><a href="#1-2-Implementation" class="headerlink" title="1.2 Implementation"></a><strong>1.2 Implementation</strong></h3></li>
<li>不了解RISCV指令集的建议可以把<a target="_blank" rel="noopener" href="https://inst.eecs.berkeley.edu/~cs61c/su20/">CS61C</a>的Week2专门讲RISCV的slide或者视频看完，直到把调试过程中遇到的每条指令弄明白再来做这一个task。</li>
</ul>
<p>分析<code>user/call.asm</code></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  <span class="number">1</span>c:	<span class="number">1141</span>                	<span class="keyword">addi	</span><span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">16</span></span><br><span class="line">  <span class="number">1</span>e:	e406                	sd	<span class="built_in">ra</span>,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="symbol">  20:</span>	e022                	sd	<span class="built_in">s0</span>,<span class="number">0</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="symbol">  22:</span>	<span class="number">0800</span>                	<span class="keyword">addi	</span><span class="built_in">s0</span>,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">  printf(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line"><span class="symbol">  24:</span>	<span class="number">4635</span>                	li	<span class="built_in">a2</span>,<span class="number">13</span></span><br><span class="line"><span class="symbol">  26:</span>	<span class="number">45</span>b1                	li	<span class="built_in">a1</span>,<span class="number">12</span></span><br><span class="line"><span class="symbol">  28:</span>	<span class="number">00000517</span>          	auipc	<span class="built_in">a0</span>,<span class="number">0x0</span></span><br><span class="line">  <span class="number">2</span>c:	<span class="number">7</span>c050513          	<span class="keyword">addi	</span><span class="built_in">a0</span>,<span class="built_in">a0</span>,<span class="number">1984</span> <span class="comment"># 7e8 &lt;malloc+0xea&gt;</span></span><br><span class="line"><span class="symbol">  30:</span>	<span class="number">00000097</span>          	auipc	<span class="built_in">ra</span>,<span class="number">0x0</span></span><br><span class="line"><span class="symbol">  34:</span>	<span class="number">610080</span>e7          	<span class="keyword">jalr	</span><span class="number">1552</span>(<span class="built_in">ra</span>) <span class="comment"># 640 &lt;printf&gt;</span></span><br><span class="line">  exit(<span class="number">0</span>);</span><br><span class="line"><span class="symbol">  38:</span>	<span class="number">4501</span>                	li	<span class="built_in">a0</span>,<span class="number">0</span></span><br><span class="line">  <span class="number">3</span>a:	<span class="number">00000097</span>          	auipc	<span class="built_in">ra</span>,<span class="number">0x0</span></span><br><span class="line">  <span class="number">3</span>e:	<span class="number">27</span>e080e7          	<span class="keyword">jalr	</span><span class="number">638</span>(<span class="built_in">ra</span>) <span class="comment"># 2b8 &lt;exit&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2</span><br></pre></td></tr></table></figure></li>
<li>Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline funtions.)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译器优化: g被inline到了f中，f又进一步被内联到了main中 </span><br></pre></td></tr></table></figure></li>
<li>At what address is the function printf located?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auipc ra, 0x0指令将0x30赋给ra中, 而jalr 1552(ra)跳转到的地址为0x640</span><br></pre></td></tr></table></figure></li>
<li>What value is in the register ra just after the jalr to printf in main?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果jalr没有第一个操作数，那么返回地址默认存放到ra寄存器中。ra=pc+4即0x38</span><br></pre></td></tr></table></figure></li>
<li>Run the following code.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line"> ```     </span><br><span class="line"> What is the output? </span><br></pre></td></tr></table></figure>
57616&#x3D;0xe110, RISCV是little-endian, 因此i在内存中存储的形式为0x726c6400对应的ASCII值为0x72 &#x3D; ‘r’, 0x6c &#x3D; ‘l’, 0x64 &#x3D; ‘d’, 0x00 &#x3D; ‘\0’。因此最后printf输出的结果为”He110, World\0”。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If the RISC-V were instead big-endian what would you set i to in order to yield the same output?</span><br></pre></td></tr></table></figure>
如果是大端字节序，为保持相同的输出结果，将i的值反过来即可i &#x3D; 0x726c6400<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- In the following code, what is going to be printed after &#x27;y=&#x27;? (note: the answer is not a specific value.) Why does this happen?</span><br><span class="line">  ``` c</span><br><span class="line">	printf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阅读call.asm, 将3存放到a1寄存器后，在调用printf之前并未对a2寄存器进行修改(本应该有第二个参数的), 第二个参数传入的值是a2寄存器中原有的随机值。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-Backtrace"><a href="#2-Backtrace" class="headerlink" title="2. Backtrace"></a><strong>2. Backtrace</strong></h2><h3 id="2-1-Description"><a href="#2-1-Description" class="headerlink" title="2.1 Description"></a><strong>2.1 Description</strong></h3><p>在<code>kernel/printf.c</code>中实现<code>backtrace()</code>函数。阅读源码时会有<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">内联汇编</a>的相关知识。实现backtrace函数还需要了解<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/lec/l-riscv-slides.pdf">RISCV栈帧</a>布局。当前的<code>stack frame</code>含有对前一个<code>stack frame</code>的指针。高地址往低地址以此为<code>Return Address</code>, <code>To Prev. Frame Pointer</code>, <code>Saved Registers</code>, <code>Local Variables</code>…其中frame pointer指向栈帧第一个entry的顶部。<br>Some hints</p>
<ul>
<li>Add the prototype for backtrace to kernel&#x2F;defs.h so that you can invoke backtrace in sys_sleep.</li>
<li>The GCC compiler stores the frame pointer of the currently executing function in the register s0. Add the following function to kernel&#x2F;riscv.h:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
and call this function in backtrace to read the current frame pointer. This function uses in-line assembly to read s0.</li>
<li>These lecture notes have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</li>
<li>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using PGROUNDDOWN(fp) and PGROUNDUP(fp) (see kernel&#x2F;riscv.h. These number are helpful for backtrace to terminate its loop.<h3 id="2-2-Implementation"><a href="#2-2-Implementation" class="headerlink" title="2.2 Implementation"></a><strong>2.2 Implementation</strong></h3>要利用好当前栈帧所在页的边界，来通过每个栈帧的prev(类似于链表)，来遍历并打印当前栈帧的返回地址。要注意栈是由高地址向低地址方向增长的，因此需要获取页的Top作为边界, 要理解<strong>回溯</strong>这个词。注意更新fp的时候上一个栈帧的fp是存放在地址单元为当前栈帧的fp-8中的, 因此需要解引用(*)取地址。在xv6中，内核为进程分配一个页大小的栈。<br><code>kernel/printf.c</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 fp = r_fp();  <span class="comment">// r_fp() return the fp of current execute function</span></span><br><span class="line">  uint64 ftop = PGROUNDUP(fp);  <span class="comment">// get the top addr of stack frame page.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (fp &lt; ftop) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(fp<span class="number">-8</span>));  <span class="comment">// print return address stored in (fp-8).</span></span><br><span class="line">    fp = *(uint64*)(fp<span class="number">-16</span>);   <span class="comment">//  update fp to previous frame fp.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-Alarm"><a href="#3-Alarm" class="headerlink" title="3. Alarm"></a><strong>3. Alarm</strong></h2><h3 id="3-1-Description"><a href="#3-1-Description" class="headerlink" title="3.1 Description"></a><strong>3.1 Description</strong></h3><blockquote>
<p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example</p>
</blockquote>
<p>sigalarm(n, fn)表示，在每个n ticks之后将会调用应用程序函数fn, 当fn函数调用结束之后，应用程序将会在它调用fn的地址处恢复执行。</p>
<h3 id="3-2-1-test0-invoke-handler"><a href="#3-2-1-test0-invoke-handler" class="headerlink" title="3.2.1 test0: invoke handler"></a><strong>3.2.1 test0: invoke handler</strong></h3><p>Some hints:</p>
<ul>
<li>You’ll need to modify the Makefile to cause alarmtest.c to be compiled as an xv6 user program.</li>
<li>The right declarations to put in user&#x2F;user.h are:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>Update user&#x2F;usys.pl (which generates user&#x2F;usys.S), kernel&#x2F;syscall.h, and kernel&#x2F;syscall.c to allow alarmtest to invoke the sigalarm and sigreturn system calls.</li>
<li>For now, your sys_sigreturn should just return zero.</li>
<li>Your sys_sigalarm() should store the alarm interval and the pointer to the handler function in new fields in the proc structure (in kernel&#x2F;proc.h).</li>
<li>You’ll need to keep track of how many ticks have passed since the last call (or are left until the next call) to a process’s alarm handler; you’ll need a new field in struct proc for this too. You can initialize proc fields in allocproc() in proc.c.</li>
<li>Every tick, the hardware clock forces an interrupt, which is handled in usertrap() in kernel&#x2F;trap.c.</li>
<li>You only want to manipulate a process’s alarm ticks if there’s a timer interrupt; you want something like  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) ...</span><br></pre></td></tr></table></figure></li>
<li>Only invoke the alarm function if the process has a timer outstanding. Note that the address of the user’s alarm function might be 0 (e.g., in user&#x2F;alarmtest.asm, periodic is at address 0).</li>
<li>You’ll need to modify usertrap() so that when a process’s alarm interval expires, the user process executes the handler function. When a trap on the RISC-V returns to user space, what determines the instruction address at which user-space code resumes execution?</li>
<li>It will be easier to look at traps with gdb if you tell qemu to use only one CPU, which you can do by running  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure></li>
<li>You’ve succeeded if alarmtest prints “alarm!”.<h3 id="3-2-2-test0-implementation"><a href="#3-2-2-test0-implementation" class="headerlink" title="3.2.2 test0 implementation"></a><strong>3.2.2 test0 implementation</strong></h3></li>
<li><code>kernel/proc.h</code>，在proc结构体中加入结构体成员<code>tick</code>, <code>handler</code>, <code>intervel</code>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint64 tick;</span><br><span class="line">uint64 handler;</span><br><span class="line">uint64 intervel;</span><br></pre></td></tr></table></figure></li>
<li><code>kernel/proc.c</code>，在<code>allocproc</code>函数中初始化<code>tick</code>成员为0。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;tick = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>kernel/trap.c</code>, 当trap返回时，sret指令将sepc寄存器中的地址赋给pc执行，也就是说在下述代码中，trap返回时将执行alarm的中断处理程序。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;intervel == p-&gt;tick) &#123;  <span class="comment">// expire</span></span><br><span class="line">    p-&gt;tick = <span class="number">0</span>;  <span class="comment">// reset tick</span></span><br><span class="line">    <span class="comment">// save all the needed registers</span></span><br><span class="line">    <span class="comment">// epc store the user program counter(PC).</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;handler;  <span class="comment">// when returned, jump to execute handler.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p-&gt;tick++;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>kernel/sysproc.c</code>, <code>argint</code>和<code>argaddr</code>获取系统调用的第n个参数值, 然后初始化进程中对应的属性。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">int</span> interval;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="comment">// fetch syscall nth argument.</span></span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;interval) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// initialize p&#x27;s attribute.</span></span><br><span class="line">  p-&gt;intervel = interval;</span><br><span class="line">  p-&gt;handler = handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-test1-x2F-test2-resume-interrupted-code"><a href="#3-3-1-test1-x2F-test2-resume-interrupted-code" class="headerlink" title="3.3.1 test1&#x2F;test2: resume interrupted code"></a><strong>3.3.1 test1&#x2F;test2: resume interrupted code</strong></h3>需要添加一些操作，确保在alarm处理程序完成后，控制权返回到用户程序最初被时钟中断的指令。必须得确保寄存器内容恢复到中断前的值，以及中断前的位置，所以需要在alarm的handler覆盖掉sepc之前保存好存放返回地址的sepc寄存器。<br>Some hints:</li>
<li>Your solution will require you to save and restore registers—what registers do you need to save and restore to resume the interrupted code correctly? (Hint: it will be many).</li>
<li>Have usertrap save enough state in struct proc when the timer goes off that sigreturn can correctly return to the interrupted user code.</li>
<li>Prevent re-entrant calls to the handler—-if a handler hasn’t returned yet, the kernel shouldn’t call it again. test2 tests this.</li>
</ul>
<h3 id="3-3-2-test1-x2F-test2-Implementation"><a href="#3-3-2-test1-x2F-test2-Implementation" class="headerlink" title="3.3.2 test1&#x2F;test2 Implementation"></a><strong>3.3.2 test1&#x2F;test2 Implementation</strong></h3><p>考虑一下第一个提示，是不是可以选择性地<code>save</code>寄存器? 看一下alarmtest.asm中的handler的汇编程序找一找。</p>
<ul>
<li>在<code>kernel/proc.h</code>中加入<code>is_alarm_working</code>属性，防止当前还在执行handler而导致的重入。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> is_alarm_working = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>kernel/trap.c</code>, 因为为用户级别的中断，因此不涉及到trapframe中保存的有关内核寄存器的修改。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!p-&gt;is_alarm_working &amp;&amp; p-&gt;intervel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;intervel == p-&gt;tick) &#123;  <span class="comment">// expire</span></span><br><span class="line">      p-&gt;tick = <span class="number">0</span>;  <span class="comment">// reset tick</span></span><br><span class="line">      p-&gt;is_alarm_working = <span class="number">1</span>;  <span class="comment">// reprensent executed handler is not terminate.</span></span><br><span class="line">      <span class="comment">// save all the needed registers.</span></span><br><span class="line">      p-&gt;saved_epc = p-&gt;trapframe-&gt;epc; <span class="comment">// save return address.</span></span><br><span class="line">      p-&gt;saved_ra = p-&gt;trapframe-&gt;ra;</span><br><span class="line">      p-&gt;saved_sp = p-&gt;trapframe-&gt;sp;</span><br><span class="line">      p-&gt;saved_gp = p-&gt;trapframe-&gt;gp;</span><br><span class="line">      p-&gt;saved_tp = p-&gt;trapframe-&gt;tp;</span><br><span class="line">      p-&gt;saved_t0 = p-&gt;trapframe-&gt;t0;</span><br><span class="line">      p-&gt;saved_t1 = p-&gt;trapframe-&gt;t1;</span><br><span class="line">      p-&gt;saved_t2 = p-&gt;trapframe-&gt;t2;</span><br><span class="line">      p-&gt;saved_t3 = p-&gt;trapframe-&gt;t3;</span><br><span class="line">      p-&gt;saved_t4 = p-&gt;trapframe-&gt;t4;</span><br><span class="line">      p-&gt;saved_t5 = p-&gt;trapframe-&gt;t5;</span><br><span class="line">      p-&gt;saved_t6 = p-&gt;trapframe-&gt;t6;</span><br><span class="line">      p-&gt;saved_a0 = p-&gt;trapframe-&gt;a0;</span><br><span class="line">      p-&gt;saved_a1 = p-&gt;trapframe-&gt;a1;</span><br><span class="line">      p-&gt;saved_a2 = p-&gt;trapframe-&gt;a2;</span><br><span class="line">      p-&gt;saved_a3 = p-&gt;trapframe-&gt;a3;</span><br><span class="line">      p-&gt;saved_a4 = p-&gt;trapframe-&gt;a4;</span><br><span class="line">      p-&gt;saved_a5 = p-&gt;trapframe-&gt;a5;</span><br><span class="line">      p-&gt;saved_a6 = p-&gt;trapframe-&gt;a6;</span><br><span class="line">      p-&gt;saved_a7 = p-&gt;trapframe-&gt;a7;</span><br><span class="line">      p-&gt;saved_s0 = p-&gt;trapframe-&gt;s0;</span><br><span class="line">      p-&gt;saved_s1 = p-&gt;trapframe-&gt;s1;</span><br><span class="line">      p-&gt;saved_s2 = p-&gt;trapframe-&gt;s2;</span><br><span class="line">      p-&gt;saved_s3 = p-&gt;trapframe-&gt;s3;</span><br><span class="line">      p-&gt;saved_s4 = p-&gt;trapframe-&gt;s4;</span><br><span class="line">      p-&gt;saved_s5 = p-&gt;trapframe-&gt;s5;</span><br><span class="line">      p-&gt;saved_s6 = p-&gt;trapframe-&gt;s6;</span><br><span class="line">      p-&gt;saved_s7 = p-&gt;trapframe-&gt;s7;</span><br><span class="line">      p-&gt;saved_s8 = p-&gt;trapframe-&gt;s8;</span><br><span class="line">      p-&gt;saved_s9 = p-&gt;trapframe-&gt;s9;</span><br><span class="line">      p-&gt;saved_s10 = p-&gt;trapframe-&gt;s10;</span><br><span class="line">      p-&gt;saved_s11 = p-&gt;trapframe-&gt;s11;</span><br><span class="line">      <span class="comment">// epc register store the user program counter(PC).</span></span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;handler;  <span class="comment">// when returned, jump to execute handler.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p-&gt;tick++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>kernel/sysproc.c</code>, <code>sigreturn</code>系统调用在alarm的handler结束之后完成<code>sigalarm</code>发生前现场的保护，即对寄存器的<code>restore</code>和防止重入变量的<code>reset</code>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;trapframe-&gt;epc = p-&gt;saved_epc; </span><br><span class="line">  p-&gt;trapframe-&gt;ra = p-&gt;saved_ra; </span><br><span class="line">  p-&gt;trapframe-&gt;sp = p-&gt;saved_sp; </span><br><span class="line">  p-&gt;trapframe-&gt;gp = p-&gt;saved_gp; </span><br><span class="line">  p-&gt;trapframe-&gt;tp = p-&gt;saved_tp; </span><br><span class="line">  p-&gt;trapframe-&gt;a0 = p-&gt;saved_a0; </span><br><span class="line">  p-&gt;trapframe-&gt;a1 = p-&gt;saved_a1; </span><br><span class="line">  p-&gt;trapframe-&gt;a2 = p-&gt;saved_a2; </span><br><span class="line">  p-&gt;trapframe-&gt;a3 = p-&gt;saved_a3; </span><br><span class="line">  p-&gt;trapframe-&gt;a4 = p-&gt;saved_a4; </span><br><span class="line">  p-&gt;trapframe-&gt;a5 = p-&gt;saved_a5; </span><br><span class="line">  p-&gt;trapframe-&gt;a6 = p-&gt;saved_a6; </span><br><span class="line">  p-&gt;trapframe-&gt;a7 = p-&gt;saved_a7; </span><br><span class="line">  p-&gt;trapframe-&gt;t0 = p-&gt;saved_t0; </span><br><span class="line">  p-&gt;trapframe-&gt;t1 = p-&gt;saved_t1; </span><br><span class="line">  p-&gt;trapframe-&gt;t2 = p-&gt;saved_t2; </span><br><span class="line">  p-&gt;trapframe-&gt;t3 = p-&gt;saved_t3; </span><br><span class="line">  p-&gt;trapframe-&gt;t4 = p-&gt;saved_t4; </span><br><span class="line">  p-&gt;trapframe-&gt;t5 = p-&gt;saved_t5; </span><br><span class="line">  p-&gt;trapframe-&gt;t6 = p-&gt;saved_t6;</span><br><span class="line">  p-&gt;trapframe-&gt;s0 = p-&gt;saved_s0;</span><br><span class="line">  p-&gt;trapframe-&gt;s1 = p-&gt;saved_s1;</span><br><span class="line">  p-&gt;trapframe-&gt;s2 = p-&gt;saved_s2;</span><br><span class="line">  p-&gt;trapframe-&gt;s3 = p-&gt;saved_s3;</span><br><span class="line">  p-&gt;trapframe-&gt;s4 = p-&gt;saved_s4;</span><br><span class="line">  p-&gt;trapframe-&gt;s5 = p-&gt;saved_s5;</span><br><span class="line">  p-&gt;trapframe-&gt;s6 = p-&gt;saved_s6;</span><br><span class="line">  p-&gt;trapframe-&gt;s7 = p-&gt;saved_s7;</span><br><span class="line">  p-&gt;trapframe-&gt;s8 = p-&gt;saved_s8;</span><br><span class="line">  p-&gt;trapframe-&gt;s9 = p-&gt;saved_s9;</span><br><span class="line">  p-&gt;trapframe-&gt;s10 = p-&gt;saved_s10;</span><br><span class="line">  p-&gt;trapframe-&gt;s11 = p-&gt;saved_s11;</span><br><span class="line">  p-&gt;is_alarm_working = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最后的疑问"><a href="#最后的疑问" class="headerlink" title="最后的疑问"></a><strong>最后的疑问</strong></h3><p>用户级别的时钟中断是在系统调用<code>sigalarm</code>时对硬件进行操作使得其周期性地发生中断?</p>
<h3 id="All-Test-Passed"><a href="#All-Test-Passed" class="headerlink" title="All Test Passed"></a><strong>All Test Passed</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-a5ba7b96aa580477641e72690d8b2044.png" alt="Test"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>终于结束lab4了，呼~, gdb调的真舒服，基本的syscall逻辑大致都搞明白了。Backtrace按照hint写入一些函数，实际上就是要理解上一节video讲的frame point的一些概念，当前stack frame的第1个entry会指向前一个frame同时也给出了stack frame的分布图，间接地实现了gdb的查看栈帧的backtrace命令; 系统调用alarm会在进程使用CPU时间定期发出警报，手把手实现一个<strong>用户级别</strong>的中断。通过trap中根据devintr()的返回值判断中断的类型，1为设备中断，2为时钟中断，0为未识别。进而tick控制在指定intervel内调用中断处理程序handler。同时还需要在proc.h中加入字段，防止中断发生时的重入。涉及到部分寄存器的store&#x2F;restore。另外<code>ecall</code>指令完成三件事：1.将用户模式切换到管理员模式; 2.将PC保存到sepc寄存器中; 3.将跳转到stvec寄存器中存储的地址处执行，即将stvec赋给PC。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mitmoksha.github.io/2022/05/16/s081-lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pishun Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moksha's Blog">
      <meta itemprop="description" content="Opportunities are ready for it, the more to beat action.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moksha's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/s081-lab3/" class="post-title-link" itemprop="url">MIT 6.S081 Lab3: Page tables</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-16 17:54:53" itemprop="dateCreated datePublished" datetime="2022-05-16T17:54:53+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-18 09:16:23" itemprop="dateModified" datetime="2022-05-18T09:16:23+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MIT-6-S081/" itemprop="url" rel="index"><span itemprop="name">MIT 6.S081</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h1 id="MIT-6-S081-Lab3-Page-tables"><a href="#MIT-6-S081-Lab3-Page-tables" class="headerlink" title="MIT 6.S081 Lab3: Page tables"></a>MIT 6.S081 Lab3: Page tables</h1><h2 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a><strong>1. Print a page table</strong></h2><h3 id="1-1-Description"><a href="#1-1-Description" class="headerlink" title="1.1 Description"></a><strong>1.1 Description</strong></h3><blockquote>
<p>Define a function called vmprint(). It should take a pagetable_t argument, and print that pagetable in the format described below. Insert if(p-&gt;pid&#x3D;&#x3D;1) vmprint(p-&gt;pagetable) in exec.c just before the return argc, to print the first process’s page table. You receive full credit for this assignment if you pass the pte printout test of make grade.</p>
</blockquote>
<h3 id="1-2-Implementation"><a href="#1-2-Implementation" class="headerlink" title="1.2 Implementation"></a><strong>1.2 Implementation</strong></h3><ul>
<li>将<code>vmprint</code>函数添加到<code>kernel/vm.c</code>文件中并在<code>kernel/defs.h</code>文件中添加该函数的声明。使用格式符<code>%p</code>打印16进制数，使用<code>kernel/riscv.h</code>文件中定义的宏, 参考<code>freewalk</code>函数以递归的形式完成。实现该函数方便接下来的调试, 可以在gdb中测试其正确性。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">3</span>)  <span class="comment">// terminate condition.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      uint64 pa = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; depth; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, pa);</span><br><span class="line">      vmprint((<span class="type">pagetable_t</span>)pa, ++depth);  <span class="comment">// recursive.</span></span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2. A kernel page table per process"></a><strong>2. A kernel page table per process</strong></h2><h3 id="2-1-Description"><a href="#2-1-Description" class="headerlink" title="2.1 Description"></a><strong>2.1 Description</strong></h3><blockquote>
<p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify struct proc to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if usertests runs correctly.</p>
</blockquote>
<ul>
<li><p>Add a field to struct proc for the process’s kernel page table.</p>
</li>
<li><p>A reasonable way to produce a kernel page table for a new process is to implement a modified version of kvminit that makes a new page table instead of modifying kernel_pagetable. You’ll want to call this function from allocproc.</p>
</li>
<li><p>Make sure that each process’s kernel page table has a mapping for that process’s kernel stack. In unmodified xv6, all the kernel stacks are set up in procinit. You will need to move some or all of this functionality to allocproc.</p>
</li>
<li><p>Modify scheduler() to load the process’s kernel page table into the core’s satp register (see kvminithart for inspiration). Don’t forget to call sfence_vma() after calling w_satp().</p>
</li>
<li><p>scheduler() should use kernel_pagetable when no process is running.</p>
</li>
<li><p>Free a process’s kernel page table in freeproc.</p>
</li>
<li><p>You’ll need a way to free a page table without also freeing the leaf physical memory pages.</p>
</li>
<li><p>vmprint may come in handy to debug page tables.</p>
</li>
<li><p>It’s OK to modify xv6 functions or add new functions; you’ll probably need to do this in at least kernel&#x2F;vm.c and kernel&#x2F;proc.c. (But, don’t modify kernel&#x2F;vmcopyin.c, kernel&#x2F;stats.c, user&#x2F;usertests.c, and user&#x2F;stats.c.)</p>
</li>
<li><p>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes sepc&#x3D;0x00000000XXXXXXXX. You can find out where the fault occurred by searching for XXXXXXXX in kernel&#x2F;kernel.asm.</p>
<h3 id="2-2-Implementation"><a href="#2-2-Implementation" class="headerlink" title="2.2 Implementation"></a><strong>2.2 Implementation</strong></h3></li>
<li><p>在<code>proc.h</code>进程的结构体中加入内核页表的属性<code>pkpagetable</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="type">pagetable_t</span> pkpagetable;     <span class="comment">// process&#x27;s kernel page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>实现<code>kvminit</code>函数的另一个版本来初始化进程的内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create processes&#x27;s kernel table</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">ukvmcreate</span><span class="params">()</span>  </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  uvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  uvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> kpagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以及专门将映射加入进程的内核页表的函数<code>uvmmap</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to processes&#x27;s kernel</span></span><br><span class="line"><span class="comment">// page table</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保每个进程的内核页表中包含该进程所使用到的内核栈的映射。可以将原来在<code>boot time</code>进程初始化<code>procinit</code>函数中全局内核页表映射内核栈的代码<strong>注释</strong>掉。应题目要求在<code>allocproc</code>函数中实现映射当前进程所对应的内核栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="type">char</span> *pa = kalloc();   <span class="comment">// allocate physical memory per page.</span></span><br><span class="line"><span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="type">int</span>) (p - proc));  <span class="comment">// virtual address.</span></span><br><span class="line"><span class="comment">// make sure each process&#x27;s kernel page table has a mapping</span></span><br><span class="line"><span class="comment">// for that process&#x27;s kernel stack.</span></span><br><span class="line">uvmmap(p-&gt;pkpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>scheduler</code>函数内实现，模仿<code>kvminithart</code>函数在调度时切换页表，即将进程的内核页表的地址放入<code>satp</code>寄存器，相应地刷新<code>TLB</code>，当进程没有在运行时，调度器切换回全局内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  load the process&#x27;s kernel page table into the core&#x27;s satp register.</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;pkpagetable));</span><br><span class="line">        sfence_vma();   <span class="comment">// flush the TLB.</span></span><br><span class="line">        </span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">        <span class="comment">// use kernel_pagetable when no process is running</span></span><br><span class="line">        kvminithart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;   <span class="comment">// wait for interrupt.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>freeproc</code>函数中完成释放进程的内核页表操作, 同时实现函数<code>freeukpagetable</code>, 在释放页表时不释放掉<code>leaf</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;pkpagetable) &#123;</span><br><span class="line">  freeukpagetable(p-&gt;pkpagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freeukpagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;  <span class="comment">// not leaf.</span></span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        freeukpagetable((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Simplify"><a href="#3-Simplify" class="headerlink" title="3. Simplify"></a><strong>3. Simplify</strong></h2><h3 id="3-1-Description"><a href="#3-1-Description" class="headerlink" title="3.1 Description"></a><strong>3.1 Description</strong></h3><blockquote>
<p>Your job in this part of the lab is to add user mappings to each process’s kernel page table (created in the previous section) that allow copyin (and the related string function copyinstr) to directly dereference user pointers. Replace the body of copyin in kernel&#x2F;vm.c with a call to copyin_new (defined in kernel&#x2F;vmcopyin.c); do the same for copyinstr and copyinstr_new. Add mappings for user addresses to each process’s kernel page table so that copyin_new and copyinstr_new work. You pass this assignment if usertests runs correctly and all the make grade tests pass.</p>
</blockquote>
</li>
<li><p>Replace copyin() with a call to copyin_new first, and make it work, before moving on to copyinstr.</p>
</li>
<li><p>At each point where the kernel changes a process’s user mappings, change the process’s kernel page table in the same way. Such points include fork(), exec(), and sbrk().</p>
</li>
<li><p>Don’t forget that to include the first process’s user page table in its kernel page table in userinit.</p>
</li>
<li><p>What permissions do the PTEs for user addresses need in a process’s kernel page table? (A page with PTE_U set cannot be accessed in kernel mode.)<br>Don’t forget about the above-mentioned PLIC limit.</p>
<h3 id="3-2-Implementation"><a href="#3-2-Implementation" class="headerlink" title="3.2 Implementation"></a><strong>3.2 Implementation</strong></h3></li>
<li><p>用<code>copy_new</code>函数替代<code>copyin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>copyinstr_new</code>函数替代<code>copyinstr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>fork()</code>中针对用户页表映射修改，相应进程的内核页表做出的改动。并实现将用户页表copy到内核页表并清空相应<code>PTE_U</code>标志的函数<code>copyupttokpt</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line"><span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line"><span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(np);</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">copyupttokpt(np-&gt;pkpagetable, np-&gt;pagetable, <span class="number">0</span>, np-&gt;sz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy saved user registers.</span></span><br><span class="line">*(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">copyupttokpt</span><span class="params">(<span class="type">pagetable_t</span> ker, <span class="type">pagetable_t</span> user, uint64 old_size, uint64 new_size)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte_from, *pte_to;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  old_size = PGROUNDUP(old_size);</span><br><span class="line">  <span class="keyword">for</span>(i = old_size; i &lt; new_size; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte_from = walk(user, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;copyupttokpt: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((pte_to = walk(ker, i, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;copyupttokpt: walk&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte_from);</span><br><span class="line">    <span class="comment">// clear PTE_U bit because of kernel page table.</span></span><br><span class="line">    flags = PTE_FLAGS(*pte_from) &amp; (~PTE_U);</span><br><span class="line">    *pte_to = PA2PTE(pa) | flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数<code>exec()</code>中，替换当前进程的用户页表时，内核页表也随之释放，并<code>copy</code>新用户页表的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line"><span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">  <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    last = s+<span class="number">1</span>;</span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br><span class="line">p-&gt;sz = sz;</span><br><span class="line"></span><br><span class="line">uvmunmap(p-&gt;pkpagetable, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line"></span><br><span class="line">p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure></li>
<li><p>函数<code>sbrk()</code>，相应的增加和减少内存时变更用户页表，需要同时更新进程的内核页表。需要判断用户分配地址空间的限制。如果增加的内存大于<code>PLIC</code>则返回<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((sz + n) &gt;= PLIC) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// test overflow.</span></span><br><span class="line">    <span class="comment">// mapping the n bytes in process&#x27;s kernel table.</span></span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, sz-n, sz);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// ummaping the n bytes in process&#x27;s kernel table.</span></span><br><span class="line">    uvmunmap(p-&gt;pkpagetable, PGROUNDUP(sz), (PGROUNDUP(p-&gt;sz) - PGROUNDUP(sz))/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>userinit</code>，初始化第一个<code>process</code>时也需要更新进程的内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  copyupttokpt(p-&gt;pkpagetable, p-&gt;pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>简单的写一下lab 3的总结吧，做之前最好把概念理清楚，确实蛮有难度的。</p>
<p>打印三级也页表页表项的虚拟地址以及物理地址，利用递归就可以完成，leaf pte的判断的判断条件即递归结束条件，可以参考vm.c中部分函数的源代码。leaf pte可以通过pte中的flag进行判断，事实上，也就只有leaf pte才含有PTE_W，PTE_X，PTE_R。</p>
<p>由于历史原因部分os将内核和用户进程独立分为两个page table，本lab的初衷是为了利用好进程之间的isolation，为每个用户进程分配一个内核页表(初始时的映射和全局内核页表相同, <strong>其中此内核页表中含有用户页表的映射</strong>)，释放进程的同时也要将进程的内核页表释放，注意不将叶子pte的物理内存释放，初始化时也是同样的。注意到procinit函数里已经为每个用户进程通过全局内核页表分配好了内核栈，hint中要求把该部分迁移到分配用户进程是时分配栈，另外kvmpa函数中也有个坑，需要将全局内核页表替换为当前用户进程的内核页表。</p>
<p>将用户进程页表载入到用户的内核页表后，系统调用传参时所用到的copyin或者copyinstr就不需要再间接的将该参数的虚拟地址通过用户页表转换为物理地址之后再处理了，简化了一步walk的操作，直接dereference即可。copy页表映射时可以参考vmcopy函数，fork中有相关页表复制的内容，但不是全部参考，可能会出现remap的情况，因此考虑不使用mappages函数即可。注意sbrk时相关函数growproc的overflow检测，以及虚拟地址空间减少时要从用户内核页表中unmap掉相关内容，增加时正常复制即可。exec函数中copy前需要将用户内核页表的映射清空。其他都按hint去做就行了，The devil is in the details.</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><p>强调一下<code>walk</code>函数的实现，在xv6中即为遍历三级页表, 很清晰地刻画了真实的页表实现。<code>PTE2PA</code>宏将当前PTE的地址(物理地址)右移10位将10个有效位置0，左移12位加上偏移量(因为页大小为<code>4kb</code>, $2^{12}&#x3D;4096&#x3D;4k$, 所以偏移量为12, <code>byte</code>为寻址能力大小), 最后转化为物理地址。<br>记住页目录存在于物理地址空间中。虚拟地址空间中的<code>L2</code>, <code>L1</code>, <code>L0</code>字段确定每一级页目录中的<code>Entry</code>。<strong>非叶子节点</strong>的<code>PPN</code>(Physical page number)连结上全0的Offset为下一级页目录的<strong>物理地址</strong>。<br><img src="https://pic4.zhimg.com/80/v2-78092855fd01e077d1d69fda55a6f1b2.png" alt="Page table"></p>
<ul>
<li><strong>walk</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];  <span class="comment">// 根据虚拟地址的L字段获取页目录中的Entry</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// 解引用获取当前Entry的地址, 将PPN(物理页号)和Offset(全0)连接后更下一级页目录的物理地址</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];  <span class="comment">// 叶子节点处PPN+虚拟地址的Offset为最终转换的物理地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>宏</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pishun Huang</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>-->

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","//mhchem.github.io/MathJax-mhchem/ mhchem":false,"js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
